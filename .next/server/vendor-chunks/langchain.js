"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/langchain";
exports.ids = ["vendor-chunks/langchain"];
exports.modules = {

/***/ "(rsc)/./node_modules/langchain/dist/document_loaders/base.js":
/*!**************************************************************!*\
  !*** ./node_modules/langchain/dist/document_loaders/base.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseDocumentLoader: () => (/* binding */ BaseDocumentLoader)\n/* harmony export */ });\n/* harmony import */ var _text_splitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../text_splitter.js */ \"(rsc)/./node_modules/langchain/dist/text_splitter.js\");\n\n/**\n * Abstract class that provides a default implementation for the\n * loadAndSplit() method from the DocumentLoader interface. The load()\n * method is left abstract and needs to be implemented by subclasses.\n */ class BaseDocumentLoader {\n    /**\n     * Loads the documents and splits them using a specified text splitter.\n     * @param textSplitter The TextSplitter instance to use for splitting the loaded documents. Defaults to a RecursiveCharacterTextSplitter instance.\n     * @returns A Promise that resolves with an array of Document instances, each split according to the provided TextSplitter.\n     */ async loadAndSplit(splitter = new _text_splitter_js__WEBPACK_IMPORTED_MODULE_0__.RecursiveCharacterTextSplitter()) {\n        const docs = await this.load();\n        return splitter.splitDocuments(docs);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvZG9jdW1lbnRfbG9hZGVycy9iYXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXNFO0FBQ3RFOzs7O0NBSUMsR0FDTSxNQUFNQztJQUNUOzs7O0tBSUMsR0FDRCxNQUFNQyxhQUFhQyxXQUFXLElBQUlILDZFQUE4QkEsRUFBRSxFQUFFO1FBQ2hFLE1BQU1JLE9BQU8sTUFBTSxJQUFJLENBQUNDLElBQUk7UUFDNUIsT0FBT0YsU0FBU0csY0FBYyxDQUFDRjtJQUNuQztBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3luY2NoYXQvLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvZG9jdW1lbnRfbG9hZGVycy9iYXNlLmpzPzI0YTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVjdXJzaXZlQ2hhcmFjdGVyVGV4dFNwbGl0dGVyLCB9IGZyb20gXCIuLi90ZXh0X3NwbGl0dGVyLmpzXCI7XG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHRoYXQgcHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciB0aGVcbiAqIGxvYWRBbmRTcGxpdCgpIG1ldGhvZCBmcm9tIHRoZSBEb2N1bWVudExvYWRlciBpbnRlcmZhY2UuIFRoZSBsb2FkKClcbiAqIG1ldGhvZCBpcyBsZWZ0IGFic3RyYWN0IGFuZCBuZWVkcyB0byBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZURvY3VtZW50TG9hZGVyIHtcbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgZG9jdW1lbnRzIGFuZCBzcGxpdHMgdGhlbSB1c2luZyBhIHNwZWNpZmllZCB0ZXh0IHNwbGl0dGVyLlxuICAgICAqIEBwYXJhbSB0ZXh0U3BsaXR0ZXIgVGhlIFRleHRTcGxpdHRlciBpbnN0YW5jZSB0byB1c2UgZm9yIHNwbGl0dGluZyB0aGUgbG9hZGVkIGRvY3VtZW50cy4gRGVmYXVsdHMgdG8gYSBSZWN1cnNpdmVDaGFyYWN0ZXJUZXh0U3BsaXR0ZXIgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZiBEb2N1bWVudCBpbnN0YW5jZXMsIGVhY2ggc3BsaXQgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCBUZXh0U3BsaXR0ZXIuXG4gICAgICovXG4gICAgYXN5bmMgbG9hZEFuZFNwbGl0KHNwbGl0dGVyID0gbmV3IFJlY3Vyc2l2ZUNoYXJhY3RlclRleHRTcGxpdHRlcigpKSB7XG4gICAgICAgIGNvbnN0IGRvY3MgPSBhd2FpdCB0aGlzLmxvYWQoKTtcbiAgICAgICAgcmV0dXJuIHNwbGl0dGVyLnNwbGl0RG9jdW1lbnRzKGRvY3MpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJSZWN1cnNpdmVDaGFyYWN0ZXJUZXh0U3BsaXR0ZXIiLCJCYXNlRG9jdW1lbnRMb2FkZXIiLCJsb2FkQW5kU3BsaXQiLCJzcGxpdHRlciIsImRvY3MiLCJsb2FkIiwic3BsaXREb2N1bWVudHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langchain/dist/document_loaders/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langchain/dist/document_loaders/fs/buffer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/langchain/dist/document_loaders/fs/buffer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BufferLoader: () => (/* binding */ BufferLoader)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_utils_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/utils/env */ \"(rsc)/./node_modules/@langchain/core/utils/env.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base.js */ \"(rsc)/./node_modules/langchain/dist/document_loaders/base.js\");\n\n\n/**\n * Abstract class that extends the `BaseDocumentLoader` class. It\n * represents a document loader that loads documents from a buffer. The\n * `load()` method is implemented to read the buffer contents and metadata\n * based on the type of `filePathOrBlob`, and then calls the `parse()`\n * method to parse the buffer and return the documents.\n */ class BufferLoader extends _base_js__WEBPACK_IMPORTED_MODULE_1__.BaseDocumentLoader {\n    constructor(filePathOrBlob){\n        super();\n        Object.defineProperty(this, \"filePathOrBlob\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: filePathOrBlob\n        });\n    }\n    /**\n     * Method that reads the buffer contents and metadata based on the type of\n     * `filePathOrBlob`, and then calls the `parse()` method to parse the\n     * buffer and return the documents.\n     * @returns Promise that resolves with an array of `Document` objects.\n     */ async load() {\n        let buffer;\n        let metadata;\n        if (typeof this.filePathOrBlob === \"string\") {\n            const { readFile } = await BufferLoader.imports();\n            buffer = await readFile(this.filePathOrBlob);\n            metadata = {\n                source: this.filePathOrBlob\n            };\n        } else {\n            buffer = await this.filePathOrBlob.arrayBuffer().then((ab)=>Buffer.from(ab));\n            metadata = {\n                source: \"blob\",\n                blobType: this.filePathOrBlob.type\n            };\n        }\n        return this.parse(buffer, metadata);\n    }\n    /**\n     * Static method that imports the `readFile` function from the\n     * `fs/promises` module in Node.js. It is used to dynamically import the\n     * function when needed. If the import fails, it throws an error\n     * indicating that the `fs/promises` module is not available in the\n     * current environment.\n     * @returns Promise that resolves with an object containing the `readFile` function.\n     */ static async imports() {\n        try {\n            const { readFile } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! node:fs/promises */ \"node:fs/promises\", 19));\n            return {\n                readFile\n            };\n        } catch (e) {\n            console.error(e);\n            throw new Error(`Failed to load fs/promises. TextLoader available only on environment 'node'. It appears you are running environment '${(0,_langchain_core_utils_env__WEBPACK_IMPORTED_MODULE_0__.getEnv)()}'. See https://<link to docs> for alternatives.`);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvZG9jdW1lbnRfbG9hZGVycy9mcy9idWZmZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1EO0FBQ0g7QUFDaEQ7Ozs7OztDQU1DLEdBQ00sTUFBTUUscUJBQXFCRCx3REFBa0JBO0lBQ2hERSxZQUFZQyxjQUFjLENBQUU7UUFDeEIsS0FBSztRQUNMQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGtCQUFrQjtZQUMxQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBT047UUFDWDtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRCxNQUFNTyxPQUFPO1FBQ1QsSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUksT0FBTyxJQUFJLENBQUNULGNBQWMsS0FBSyxVQUFVO1lBQ3pDLE1BQU0sRUFBRVUsUUFBUSxFQUFFLEdBQUcsTUFBTVosYUFBYWEsT0FBTztZQUMvQ0gsU0FBUyxNQUFNRSxTQUFTLElBQUksQ0FBQ1YsY0FBYztZQUMzQ1MsV0FBVztnQkFBRUcsUUFBUSxJQUFJLENBQUNaLGNBQWM7WUFBQztRQUM3QyxPQUNLO1lBQ0RRLFNBQVMsTUFBTSxJQUFJLENBQUNSLGNBQWMsQ0FDN0JhLFdBQVcsR0FDWEMsSUFBSSxDQUFDLENBQUNDLEtBQU9DLE9BQU9DLElBQUksQ0FBQ0Y7WUFDOUJOLFdBQVc7Z0JBQUVHLFFBQVE7Z0JBQVFNLFVBQVUsSUFBSSxDQUFDbEIsY0FBYyxDQUFDbUIsSUFBSTtZQUFDO1FBQ3BFO1FBQ0EsT0FBTyxJQUFJLENBQUNDLEtBQUssQ0FBQ1osUUFBUUM7SUFDOUI7SUFDQTs7Ozs7OztLQU9DLEdBQ0QsYUFBYUUsVUFBVTtRQUNuQixJQUFJO1lBQ0EsTUFBTSxFQUFFRCxRQUFRLEVBQUUsR0FBRyxNQUFNLHNJQUEwQjtZQUNyRCxPQUFPO2dCQUFFQTtZQUFTO1FBQ3RCLEVBQ0EsT0FBT1csR0FBRztZQUNOQyxRQUFRQyxLQUFLLENBQUNGO1lBQ2QsTUFBTSxJQUFJRyxNQUFNLENBQUMscUhBQXFILEVBQUU1QixpRUFBTUEsR0FBRywrQ0FBK0MsQ0FBQztRQUNyTTtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zeW5jY2hhdC8uL25vZGVfbW9kdWxlcy9sYW5nY2hhaW4vZGlzdC9kb2N1bWVudF9sb2FkZXJzL2ZzL2J1ZmZlci5qcz84YTQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEVudiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvdXRpbHMvZW52XCI7XG5pbXBvcnQgeyBCYXNlRG9jdW1lbnRMb2FkZXIgfSBmcm9tIFwiLi4vYmFzZS5qc1wiO1xuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IGV4dGVuZHMgdGhlIGBCYXNlRG9jdW1lbnRMb2FkZXJgIGNsYXNzLiBJdFxuICogcmVwcmVzZW50cyBhIGRvY3VtZW50IGxvYWRlciB0aGF0IGxvYWRzIGRvY3VtZW50cyBmcm9tIGEgYnVmZmVyLiBUaGVcbiAqIGBsb2FkKClgIG1ldGhvZCBpcyBpbXBsZW1lbnRlZCB0byByZWFkIHRoZSBidWZmZXIgY29udGVudHMgYW5kIG1ldGFkYXRhXG4gKiBiYXNlZCBvbiB0aGUgdHlwZSBvZiBgZmlsZVBhdGhPckJsb2JgLCBhbmQgdGhlbiBjYWxscyB0aGUgYHBhcnNlKClgXG4gKiBtZXRob2QgdG8gcGFyc2UgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuIHRoZSBkb2N1bWVudHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCdWZmZXJMb2FkZXIgZXh0ZW5kcyBCYXNlRG9jdW1lbnRMb2FkZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpbGVQYXRoT3JCbG9iKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpbGVQYXRoT3JCbG9iXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmaWxlUGF0aE9yQmxvYlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgcmVhZHMgdGhlIGJ1ZmZlciBjb250ZW50cyBhbmQgbWV0YWRhdGEgYmFzZWQgb24gdGhlIHR5cGUgb2ZcbiAgICAgKiBgZmlsZVBhdGhPckJsb2JgLCBhbmQgdGhlbiBjYWxscyB0aGUgYHBhcnNlKClgIG1ldGhvZCB0byBwYXJzZSB0aGVcbiAgICAgKiBidWZmZXIgYW5kIHJldHVybiB0aGUgZG9jdW1lbnRzLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIGFycmF5IG9mIGBEb2N1bWVudGAgb2JqZWN0cy5cbiAgICAgKi9cbiAgICBhc3luYyBsb2FkKCkge1xuICAgICAgICBsZXQgYnVmZmVyO1xuICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5maWxlUGF0aE9yQmxvYiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgeyByZWFkRmlsZSB9ID0gYXdhaXQgQnVmZmVyTG9hZGVyLmltcG9ydHMoKTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGF3YWl0IHJlYWRGaWxlKHRoaXMuZmlsZVBhdGhPckJsb2IpO1xuICAgICAgICAgICAgbWV0YWRhdGEgPSB7IHNvdXJjZTogdGhpcy5maWxlUGF0aE9yQmxvYiB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyID0gYXdhaXQgdGhpcy5maWxlUGF0aE9yQmxvYlxuICAgICAgICAgICAgICAgIC5hcnJheUJ1ZmZlcigpXG4gICAgICAgICAgICAgICAgLnRoZW4oKGFiKSA9PiBCdWZmZXIuZnJvbShhYikpO1xuICAgICAgICAgICAgbWV0YWRhdGEgPSB7IHNvdXJjZTogXCJibG9iXCIsIGJsb2JUeXBlOiB0aGlzLmZpbGVQYXRoT3JCbG9iLnR5cGUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShidWZmZXIsIG1ldGFkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIG1ldGhvZCB0aGF0IGltcG9ydHMgdGhlIGByZWFkRmlsZWAgZnVuY3Rpb24gZnJvbSB0aGVcbiAgICAgKiBgZnMvcHJvbWlzZXNgIG1vZHVsZSBpbiBOb2RlLmpzLiBJdCBpcyB1c2VkIHRvIGR5bmFtaWNhbGx5IGltcG9ydCB0aGVcbiAgICAgKiBmdW5jdGlvbiB3aGVuIG5lZWRlZC4gSWYgdGhlIGltcG9ydCBmYWlscywgaXQgdGhyb3dzIGFuIGVycm9yXG4gICAgICogaW5kaWNhdGluZyB0aGF0IHRoZSBgZnMvcHJvbWlzZXNgIG1vZHVsZSBpcyBub3QgYXZhaWxhYmxlIGluIHRoZVxuICAgICAqIGN1cnJlbnQgZW52aXJvbm1lbnQuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGByZWFkRmlsZWAgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGltcG9ydHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlYWRGaWxlIH0gPSBhd2FpdCBpbXBvcnQoXCJub2RlOmZzL3Byb21pc2VzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVhZEZpbGUgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgZnMvcHJvbWlzZXMuIFRleHRMb2FkZXIgYXZhaWxhYmxlIG9ubHkgb24gZW52aXJvbm1lbnQgJ25vZGUnLiBJdCBhcHBlYXJzIHlvdSBhcmUgcnVubmluZyBlbnZpcm9ubWVudCAnJHtnZXRFbnYoKX0nLiBTZWUgaHR0cHM6Ly88bGluayB0byBkb2NzPiBmb3IgYWx0ZXJuYXRpdmVzLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbImdldEVudiIsIkJhc2VEb2N1bWVudExvYWRlciIsIkJ1ZmZlckxvYWRlciIsImNvbnN0cnVjdG9yIiwiZmlsZVBhdGhPckJsb2IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwibG9hZCIsImJ1ZmZlciIsIm1ldGFkYXRhIiwicmVhZEZpbGUiLCJpbXBvcnRzIiwic291cmNlIiwiYXJyYXlCdWZmZXIiLCJ0aGVuIiwiYWIiLCJCdWZmZXIiLCJmcm9tIiwiYmxvYlR5cGUiLCJ0eXBlIiwicGFyc2UiLCJlIiwiY29uc29sZSIsImVycm9yIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langchain/dist/document_loaders/fs/buffer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langchain/dist/document_loaders/fs/pdf.js":
/*!****************************************************************!*\
  !*** ./node_modules/langchain/dist/document_loaders/fs/pdf.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PDFLoader: () => (/* binding */ PDFLoader)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_documents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/documents */ \"(rsc)/./node_modules/@langchain/core/documents.js\");\n/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ \"(rsc)/./node_modules/langchain/dist/document_loaders/fs/buffer.js\");\n/* harmony import */ var _util_document_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/document.js */ \"(rsc)/./node_modules/langchain/dist/util/document.js\");\n\n\n\n/**\n * A class that extends the `BufferLoader` class. It represents a document\n * loader that loads documents from PDF files.\n * @example\n * ```typescript\n * const loader = new PDFLoader(\"path/to/bitcoin.pdf\");\n * const docs = await loader.load();\n * console.log({ docs });\n * ```\n */ class PDFLoader extends _buffer_js__WEBPACK_IMPORTED_MODULE_1__.BufferLoader {\n    constructor(filePathOrBlob, { splitPages = true, pdfjs = PDFLoaderImports, parsedItemSeparator = \"\" } = {}){\n        super(filePathOrBlob);\n        Object.defineProperty(this, \"splitPages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"pdfjs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parsedItemSeparator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.splitPages = splitPages;\n        this.pdfjs = pdfjs;\n        this.parsedItemSeparator = parsedItemSeparator;\n    }\n    /**\n     * A method that takes a `raw` buffer and `metadata` as parameters and\n     * returns a promise that resolves to an array of `Document` instances. It\n     * uses the `getDocument` function from the PDF.js library to load the PDF\n     * from the buffer. It then iterates over each page of the PDF, retrieves\n     * the text content using the `getTextContent` method, and joins the text\n     * items to form the page content. It creates a new `Document` instance\n     * for each page with the extracted text content and metadata, and adds it\n     * to the `documents` array. If `splitPages` is `true`, it returns the\n     * array of `Document` instances. Otherwise, if there are no documents, it\n     * returns an empty array. Otherwise, it concatenates the page content of\n     * all documents and creates a single `Document` instance with the\n     * concatenated content.\n     * @param raw The buffer to be parsed.\n     * @param metadata The metadata of the document.\n     * @returns A promise that resolves to an array of `Document` instances.\n     */ async parse(raw, metadata) {\n        const { getDocument, version } = await this.pdfjs();\n        const pdf = await getDocument({\n            data: new Uint8Array(raw.buffer),\n            useWorkerFetch: false,\n            isEvalSupported: false,\n            useSystemFonts: true\n        }).promise;\n        const meta = await pdf.getMetadata().catch(()=>null);\n        const documents = [];\n        for(let i = 1; i <= pdf.numPages; i += 1){\n            const page = await pdf.getPage(i);\n            const content = await page.getTextContent();\n            if (content.items.length === 0) {\n                continue;\n            }\n            // Eliminate excessive newlines\n            // Source: https://github.com/albertcui/pdf-parse/blob/7086fc1cc9058545cdf41dd0646d6ae5832c7107/lib/pdf-parse.js#L16\n            let lastY;\n            const textItems = [];\n            for (const item of content.items){\n                if (\"str\" in item) {\n                    if (lastY === item.transform[5] || !lastY) {\n                        textItems.push(item.str);\n                    } else {\n                        textItems.push(`\\n${item.str}`);\n                    }\n                    // eslint-disable-next-line prefer-destructuring\n                    lastY = item.transform[5];\n                }\n            }\n            const text = textItems.join(this.parsedItemSeparator);\n            documents.push(new _langchain_core_documents__WEBPACK_IMPORTED_MODULE_0__.Document({\n                pageContent: text,\n                metadata: {\n                    ...metadata,\n                    pdf: {\n                        version,\n                        info: meta?.info,\n                        metadata: meta?.metadata,\n                        totalPages: pdf.numPages\n                    },\n                    loc: {\n                        pageNumber: i\n                    }\n                }\n            }));\n        }\n        if (this.splitPages) {\n            return documents;\n        }\n        if (documents.length === 0) {\n            return [];\n        }\n        return [\n            new _langchain_core_documents__WEBPACK_IMPORTED_MODULE_0__.Document({\n                pageContent: (0,_util_document_js__WEBPACK_IMPORTED_MODULE_2__.formatDocumentsAsString)(documents),\n                metadata: {\n                    ...metadata,\n                    pdf: {\n                        version,\n                        info: meta?.info,\n                        metadata: meta?.metadata,\n                        totalPages: pdf.numPages\n                    }\n                }\n            })\n        ];\n    }\n}\nasync function PDFLoaderImports() {\n    try {\n        const { default: mod } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/pdf-parse\").then(__webpack_require__.t.bind(__webpack_require__, /*! pdf-parse/lib/pdf.js/v1.10.100/build/pdf.js */ \"(rsc)/./node_modules/pdf-parse/lib/pdf.js/v1.10.100/build/pdf.js\", 19));\n        const { getDocument, version } = mod;\n        return {\n            getDocument,\n            version\n        };\n    } catch (e) {\n        console.error(e);\n        throw new Error(\"Failed to load pdf-parse. Please install it with eg. `npm install pdf-parse`.\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvZG9jdW1lbnRfbG9hZGVycy9mcy9wZGYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFxRDtBQUNWO0FBQ3NCO0FBQ2pFOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1HLGtCQUFrQkYsb0RBQVlBO0lBQ3ZDRyxZQUFZQyxjQUFjLEVBQUUsRUFBRUMsYUFBYSxJQUFJLEVBQUVDLFFBQVFDLGdCQUFnQixFQUFFQyxzQkFBc0IsRUFBRSxFQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDekcsS0FBSyxDQUFDSjtRQUNOSyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7WUFDdENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFNBQVM7WUFDakNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLHVCQUF1QjtZQUMvQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0EsSUFBSSxDQUFDVCxVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0UsbUJBQW1CLEdBQUdBO0lBQy9CO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7S0FnQkMsR0FDRCxNQUFNTyxNQUFNQyxHQUFHLEVBQUVDLFFBQVEsRUFBRTtRQUN2QixNQUFNLEVBQUVDLFdBQVcsRUFBRUMsT0FBTyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUNiLEtBQUs7UUFDakQsTUFBTWMsTUFBTSxNQUFNRixZQUFZO1lBQzFCRyxNQUFNLElBQUlDLFdBQVdOLElBQUlPLE1BQU07WUFDL0JDLGdCQUFnQjtZQUNoQkMsaUJBQWlCO1lBQ2pCQyxnQkFBZ0I7UUFDcEIsR0FBR0MsT0FBTztRQUNWLE1BQU1DLE9BQU8sTUFBTVIsSUFBSVMsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBTTtRQUNqRCxNQUFNQyxZQUFZLEVBQUU7UUFDcEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLEtBQUtaLElBQUlhLFFBQVEsRUFBRUQsS0FBSyxFQUFHO1lBQ3ZDLE1BQU1FLE9BQU8sTUFBTWQsSUFBSWUsT0FBTyxDQUFDSDtZQUMvQixNQUFNSSxVQUFVLE1BQU1GLEtBQUtHLGNBQWM7WUFDekMsSUFBSUQsUUFBUUUsS0FBSyxDQUFDQyxNQUFNLEtBQUssR0FBRztnQkFDNUI7WUFDSjtZQUNBLCtCQUErQjtZQUMvQixvSEFBb0g7WUFDcEgsSUFBSUM7WUFDSixNQUFNQyxZQUFZLEVBQUU7WUFDcEIsS0FBSyxNQUFNQyxRQUFRTixRQUFRRSxLQUFLLENBQUU7Z0JBQzlCLElBQUksU0FBU0ksTUFBTTtvQkFDZixJQUFJRixVQUFVRSxLQUFLQyxTQUFTLENBQUMsRUFBRSxJQUFJLENBQUNILE9BQU87d0JBQ3ZDQyxVQUFVRyxJQUFJLENBQUNGLEtBQUtHLEdBQUc7b0JBQzNCLE9BQ0s7d0JBQ0RKLFVBQVVHLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRUYsS0FBS0csR0FBRyxDQUFDLENBQUM7b0JBQ2xDO29CQUNBLGdEQUFnRDtvQkFDaERMLFFBQVFFLEtBQUtDLFNBQVMsQ0FBQyxFQUFFO2dCQUM3QjtZQUNKO1lBQ0EsTUFBTUcsT0FBT0wsVUFBVU0sSUFBSSxDQUFDLElBQUksQ0FBQ3ZDLG1CQUFtQjtZQUNwRHVCLFVBQVVhLElBQUksQ0FBQyxJQUFJN0MsK0RBQVFBLENBQUM7Z0JBQ3hCaUQsYUFBYUY7Z0JBQ2I3QixVQUFVO29CQUNOLEdBQUdBLFFBQVE7b0JBQ1hHLEtBQUs7d0JBQ0REO3dCQUNBOEIsTUFBTXJCLE1BQU1xQjt3QkFDWmhDLFVBQVVXLE1BQU1YO3dCQUNoQmlDLFlBQVk5QixJQUFJYSxRQUFRO29CQUM1QjtvQkFDQWtCLEtBQUs7d0JBQ0RDLFlBQVlwQjtvQkFDaEI7Z0JBQ0o7WUFDSjtRQUNKO1FBQ0EsSUFBSSxJQUFJLENBQUMzQixVQUFVLEVBQUU7WUFDakIsT0FBTzBCO1FBQ1g7UUFDQSxJQUFJQSxVQUFVUSxNQUFNLEtBQUssR0FBRztZQUN4QixPQUFPLEVBQUU7UUFDYjtRQUNBLE9BQU87WUFDSCxJQUFJeEMsK0RBQVFBLENBQUM7Z0JBQ1RpRCxhQUFhL0MsMEVBQXVCQSxDQUFDOEI7Z0JBQ3JDZCxVQUFVO29CQUNOLEdBQUdBLFFBQVE7b0JBQ1hHLEtBQUs7d0JBQ0REO3dCQUNBOEIsTUFBTXJCLE1BQU1xQjt3QkFDWmhDLFVBQVVXLE1BQU1YO3dCQUNoQmlDLFlBQVk5QixJQUFJYSxRQUFRO29CQUM1QjtnQkFDSjtZQUNKO1NBQ0g7SUFDTDtBQUNKO0FBQ0EsZUFBZTFCO0lBQ1gsSUFBSTtRQUNBLE1BQU0sRUFBRThDLFNBQVNDLEdBQUcsRUFBRSxHQUFHLE1BQU0saVBBQXFEO1FBQ3BGLE1BQU0sRUFBRXBDLFdBQVcsRUFBRUMsT0FBTyxFQUFFLEdBQUdtQztRQUNqQyxPQUFPO1lBQUVwQztZQUFhQztRQUFRO0lBQ2xDLEVBQ0EsT0FBT29DLEdBQUc7UUFDTkMsUUFBUUMsS0FBSyxDQUFDRjtRQUNkLE1BQU0sSUFBSUcsTUFBTTtJQUNwQjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3luY2NoYXQvLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvZG9jdW1lbnRfbG9hZGVycy9mcy9wZGYuanM/OGI1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvZG9jdW1lbnRzXCI7XG5pbXBvcnQgeyBCdWZmZXJMb2FkZXIgfSBmcm9tIFwiLi9idWZmZXIuanNcIjtcbmltcG9ydCB7IGZvcm1hdERvY3VtZW50c0FzU3RyaW5nIH0gZnJvbSBcIi4uLy4uL3V0aWwvZG9jdW1lbnQuanNcIjtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGV4dGVuZHMgdGhlIGBCdWZmZXJMb2FkZXJgIGNsYXNzLiBJdCByZXByZXNlbnRzIGEgZG9jdW1lbnRcbiAqIGxvYWRlciB0aGF0IGxvYWRzIGRvY3VtZW50cyBmcm9tIFBERiBmaWxlcy5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBsb2FkZXIgPSBuZXcgUERGTG9hZGVyKFwicGF0aC90by9iaXRjb2luLnBkZlwiKTtcbiAqIGNvbnN0IGRvY3MgPSBhd2FpdCBsb2FkZXIubG9hZCgpO1xuICogY29uc29sZS5sb2coeyBkb2NzIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBQREZMb2FkZXIgZXh0ZW5kcyBCdWZmZXJMb2FkZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpbGVQYXRoT3JCbG9iLCB7IHNwbGl0UGFnZXMgPSB0cnVlLCBwZGZqcyA9IFBERkxvYWRlckltcG9ydHMsIHBhcnNlZEl0ZW1TZXBhcmF0b3IgPSBcIlwiLCB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoZmlsZVBhdGhPckJsb2IpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzcGxpdFBhZ2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBkZmpzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhcnNlZEl0ZW1TZXBhcmF0b3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zcGxpdFBhZ2VzID0gc3BsaXRQYWdlcztcbiAgICAgICAgdGhpcy5wZGZqcyA9IHBkZmpzO1xuICAgICAgICB0aGlzLnBhcnNlZEl0ZW1TZXBhcmF0b3IgPSBwYXJzZWRJdGVtU2VwYXJhdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIG1ldGhvZCB0aGF0IHRha2VzIGEgYHJhd2AgYnVmZmVyIGFuZCBgbWV0YWRhdGFgIGFzIHBhcmFtZXRlcnMgYW5kXG4gICAgICogcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBgRG9jdW1lbnRgIGluc3RhbmNlcy4gSXRcbiAgICAgKiB1c2VzIHRoZSBgZ2V0RG9jdW1lbnRgIGZ1bmN0aW9uIGZyb20gdGhlIFBERi5qcyBsaWJyYXJ5IHRvIGxvYWQgdGhlIFBERlxuICAgICAqIGZyb20gdGhlIGJ1ZmZlci4gSXQgdGhlbiBpdGVyYXRlcyBvdmVyIGVhY2ggcGFnZSBvZiB0aGUgUERGLCByZXRyaWV2ZXNcbiAgICAgKiB0aGUgdGV4dCBjb250ZW50IHVzaW5nIHRoZSBgZ2V0VGV4dENvbnRlbnRgIG1ldGhvZCwgYW5kIGpvaW5zIHRoZSB0ZXh0XG4gICAgICogaXRlbXMgdG8gZm9ybSB0aGUgcGFnZSBjb250ZW50LiBJdCBjcmVhdGVzIGEgbmV3IGBEb2N1bWVudGAgaW5zdGFuY2VcbiAgICAgKiBmb3IgZWFjaCBwYWdlIHdpdGggdGhlIGV4dHJhY3RlZCB0ZXh0IGNvbnRlbnQgYW5kIG1ldGFkYXRhLCBhbmQgYWRkcyBpdFxuICAgICAqIHRvIHRoZSBgZG9jdW1lbnRzYCBhcnJheS4gSWYgYHNwbGl0UGFnZXNgIGlzIGB0cnVlYCwgaXQgcmV0dXJucyB0aGVcbiAgICAgKiBhcnJheSBvZiBgRG9jdW1lbnRgIGluc3RhbmNlcy4gT3RoZXJ3aXNlLCBpZiB0aGVyZSBhcmUgbm8gZG9jdW1lbnRzLCBpdFxuICAgICAqIHJldHVybnMgYW4gZW1wdHkgYXJyYXkuIE90aGVyd2lzZSwgaXQgY29uY2F0ZW5hdGVzIHRoZSBwYWdlIGNvbnRlbnQgb2ZcbiAgICAgKiBhbGwgZG9jdW1lbnRzIGFuZCBjcmVhdGVzIGEgc2luZ2xlIGBEb2N1bWVudGAgaW5zdGFuY2Ugd2l0aCB0aGVcbiAgICAgKiBjb25jYXRlbmF0ZWQgY29udGVudC5cbiAgICAgKiBAcGFyYW0gcmF3IFRoZSBidWZmZXIgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSBtZXRhZGF0YSBUaGUgbWV0YWRhdGEgb2YgdGhlIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIGBEb2N1bWVudGAgaW5zdGFuY2VzLlxuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlKHJhdywgbWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBnZXREb2N1bWVudCwgdmVyc2lvbiB9ID0gYXdhaXQgdGhpcy5wZGZqcygpO1xuICAgICAgICBjb25zdCBwZGYgPSBhd2FpdCBnZXREb2N1bWVudCh7XG4gICAgICAgICAgICBkYXRhOiBuZXcgVWludDhBcnJheShyYXcuYnVmZmVyKSxcbiAgICAgICAgICAgIHVzZVdvcmtlckZldGNoOiBmYWxzZSxcbiAgICAgICAgICAgIGlzRXZhbFN1cHBvcnRlZDogZmFsc2UsXG4gICAgICAgICAgICB1c2VTeXN0ZW1Gb250czogdHJ1ZSxcbiAgICAgICAgfSkucHJvbWlzZTtcbiAgICAgICAgY29uc3QgbWV0YSA9IGF3YWl0IHBkZi5nZXRNZXRhZGF0YSgpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgICBjb25zdCBkb2N1bWVudHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcGRmLm51bVBhZ2VzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBwZGYuZ2V0UGFnZShpKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBwYWdlLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgICAgICBpZiAoY29udGVudC5pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVsaW1pbmF0ZSBleGNlc3NpdmUgbmV3bGluZXNcbiAgICAgICAgICAgIC8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FsYmVydGN1aS9wZGYtcGFyc2UvYmxvYi83MDg2ZmMxY2M5MDU4NTQ1Y2RmNDFkZDA2NDZkNmFlNTgzMmM3MTA3L2xpYi9wZGYtcGFyc2UuanMjTDE2XG4gICAgICAgICAgICBsZXQgbGFzdFk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0SXRlbXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb250ZW50Lml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwic3RyXCIgaW4gaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFkgPT09IGl0ZW0udHJhbnNmb3JtWzVdIHx8ICFsYXN0WSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEl0ZW1zLnB1c2goaXRlbS5zdHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEl0ZW1zLnB1c2goYFxcbiR7aXRlbS5zdHJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgICAgICAgICAgICAgIGxhc3RZID0gaXRlbS50cmFuc2Zvcm1bNV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHRleHRJdGVtcy5qb2luKHRoaXMucGFyc2VkSXRlbVNlcGFyYXRvcik7XG4gICAgICAgICAgICBkb2N1bWVudHMucHVzaChuZXcgRG9jdW1lbnQoe1xuICAgICAgICAgICAgICAgIHBhZ2VDb250ZW50OiB0ZXh0LFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBwZGY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvOiBtZXRhPy5pbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGE/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxQYWdlczogcGRmLm51bVBhZ2VzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsb2M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VOdW1iZXI6IGksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zcGxpdFBhZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBEb2N1bWVudCh7XG4gICAgICAgICAgICAgICAgcGFnZUNvbnRlbnQ6IGZvcm1hdERvY3VtZW50c0FzU3RyaW5nKGRvY3VtZW50cyksXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBkZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm86IG1ldGE/LmluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbWV0YT8ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFBhZ2VzOiBwZGYubnVtUGFnZXMsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIFBERkxvYWRlckltcG9ydHMoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0OiBtb2QgfSA9IGF3YWl0IGltcG9ydChcInBkZi1wYXJzZS9saWIvcGRmLmpzL3YxLjEwLjEwMC9idWlsZC9wZGYuanNcIik7XG4gICAgICAgIGNvbnN0IHsgZ2V0RG9jdW1lbnQsIHZlcnNpb24gfSA9IG1vZDtcbiAgICAgICAgcmV0dXJuIHsgZ2V0RG9jdW1lbnQsIHZlcnNpb24gfTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgcGRmLXBhcnNlLiBQbGVhc2UgaW5zdGFsbCBpdCB3aXRoIGVnLiBgbnBtIGluc3RhbGwgcGRmLXBhcnNlYC5cIik7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIkRvY3VtZW50IiwiQnVmZmVyTG9hZGVyIiwiZm9ybWF0RG9jdW1lbnRzQXNTdHJpbmciLCJQREZMb2FkZXIiLCJjb25zdHJ1Y3RvciIsImZpbGVQYXRoT3JCbG9iIiwic3BsaXRQYWdlcyIsInBkZmpzIiwiUERGTG9hZGVySW1wb3J0cyIsInBhcnNlZEl0ZW1TZXBhcmF0b3IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwicGFyc2UiLCJyYXciLCJtZXRhZGF0YSIsImdldERvY3VtZW50IiwidmVyc2lvbiIsInBkZiIsImRhdGEiLCJVaW50OEFycmF5IiwiYnVmZmVyIiwidXNlV29ya2VyRmV0Y2giLCJpc0V2YWxTdXBwb3J0ZWQiLCJ1c2VTeXN0ZW1Gb250cyIsInByb21pc2UiLCJtZXRhIiwiZ2V0TWV0YWRhdGEiLCJjYXRjaCIsImRvY3VtZW50cyIsImkiLCJudW1QYWdlcyIsInBhZ2UiLCJnZXRQYWdlIiwiY29udGVudCIsImdldFRleHRDb250ZW50IiwiaXRlbXMiLCJsZW5ndGgiLCJsYXN0WSIsInRleHRJdGVtcyIsIml0ZW0iLCJ0cmFuc2Zvcm0iLCJwdXNoIiwic3RyIiwidGV4dCIsImpvaW4iLCJwYWdlQ29udGVudCIsImluZm8iLCJ0b3RhbFBhZ2VzIiwibG9jIiwicGFnZU51bWJlciIsImRlZmF1bHQiLCJtb2QiLCJlIiwiY29uc29sZSIsImVycm9yIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langchain/dist/document_loaders/fs/pdf.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langchain/dist/text_splitter.js":
/*!******************************************************!*\
  !*** ./node_modules/langchain/dist/text_splitter.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CharacterTextSplitter: () => (/* binding */ CharacterTextSplitter),\n/* harmony export */   LatexTextSplitter: () => (/* binding */ LatexTextSplitter),\n/* harmony export */   MarkdownTextSplitter: () => (/* binding */ MarkdownTextSplitter),\n/* harmony export */   RecursiveCharacterTextSplitter: () => (/* binding */ RecursiveCharacterTextSplitter),\n/* harmony export */   SupportedTextSplitterLanguages: () => (/* binding */ SupportedTextSplitterLanguages),\n/* harmony export */   TextSplitter: () => (/* binding */ TextSplitter),\n/* harmony export */   TokenTextSplitter: () => (/* binding */ TokenTextSplitter)\n/* harmony export */ });\n/* harmony import */ var _langchain_core_documents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/core/documents */ \"(rsc)/./node_modules/@langchain/core/documents.js\");\n/* harmony import */ var _langchain_core_utils_tiktoken__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/core/utils/tiktoken */ \"(rsc)/./node_modules/@langchain/core/utils/tiktoken.js\");\n\n\nclass TextSplitter extends _langchain_core_documents__WEBPACK_IMPORTED_MODULE_0__.BaseDocumentTransformer {\n    constructor(fields){\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\n                \"langchain\",\n                \"document_transformers\",\n                \"text_splitters\"\n            ]\n        });\n        Object.defineProperty(this, \"chunkSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 1000\n        });\n        Object.defineProperty(this, \"chunkOverlap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 200\n        });\n        Object.defineProperty(this, \"keepSeparator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lengthFunction\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.chunkSize = fields?.chunkSize ?? this.chunkSize;\n        this.chunkOverlap = fields?.chunkOverlap ?? this.chunkOverlap;\n        this.keepSeparator = fields?.keepSeparator ?? this.keepSeparator;\n        this.lengthFunction = fields?.lengthFunction ?? ((text)=>text.length);\n        if (this.chunkOverlap >= this.chunkSize) {\n            throw new Error(\"Cannot have chunkOverlap >= chunkSize\");\n        }\n    }\n    async transformDocuments(documents, chunkHeaderOptions = {}) {\n        return this.splitDocuments(documents, chunkHeaderOptions);\n    }\n    splitOnSeparator(text, separator) {\n        let splits;\n        if (separator) {\n            if (this.keepSeparator) {\n                const regexEscapedSeparator = separator.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n                splits = text.split(new RegExp(`(?=${regexEscapedSeparator})`));\n            } else {\n                splits = text.split(separator);\n            }\n        } else {\n            splits = text.split(\"\");\n        }\n        return splits.filter((s)=>s !== \"\");\n    }\n    async createDocuments(texts, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadatas = [], chunkHeaderOptions = {}) {\n        // if no metadata is provided, we create an empty one for each text\n        const _metadatas = metadatas.length > 0 ? metadatas : new Array(texts.length).fill({});\n        const { chunkHeader = \"\", chunkOverlapHeader = \"(cont'd) \", appendChunkOverlapHeader = false } = chunkHeaderOptions;\n        const documents = new Array();\n        for(let i = 0; i < texts.length; i += 1){\n            const text = texts[i];\n            let lineCounterIndex = 1;\n            let prevChunk = null;\n            let indexPrevChunk = -1;\n            for (const chunk of (await this.splitText(text))){\n                let pageContent = chunkHeader;\n                // we need to count the \\n that are in the text before getting removed by the splitting\n                const indexChunk = text.indexOf(chunk, indexPrevChunk + 1);\n                if (prevChunk === null) {\n                    const newLinesBeforeFirstChunk = this.numberOfNewLines(text, 0, indexChunk);\n                    lineCounterIndex += newLinesBeforeFirstChunk;\n                } else {\n                    const indexEndPrevChunk = indexPrevChunk + await this.lengthFunction(prevChunk);\n                    if (indexEndPrevChunk < indexChunk) {\n                        const numberOfIntermediateNewLines = this.numberOfNewLines(text, indexEndPrevChunk, indexChunk);\n                        lineCounterIndex += numberOfIntermediateNewLines;\n                    } else if (indexEndPrevChunk > indexChunk) {\n                        const numberOfIntermediateNewLines = this.numberOfNewLines(text, indexChunk, indexEndPrevChunk);\n                        lineCounterIndex -= numberOfIntermediateNewLines;\n                    }\n                    if (appendChunkOverlapHeader) {\n                        pageContent += chunkOverlapHeader;\n                    }\n                }\n                const newLinesCount = this.numberOfNewLines(chunk);\n                const loc = _metadatas[i].loc && typeof _metadatas[i].loc === \"object\" ? {\n                    ..._metadatas[i].loc\n                } : {};\n                loc.lines = {\n                    from: lineCounterIndex,\n                    to: lineCounterIndex + newLinesCount\n                };\n                const metadataWithLinesNumber = {\n                    ..._metadatas[i],\n                    loc\n                };\n                pageContent += chunk;\n                documents.push(new _langchain_core_documents__WEBPACK_IMPORTED_MODULE_0__.Document({\n                    pageContent,\n                    metadata: metadataWithLinesNumber\n                }));\n                lineCounterIndex += newLinesCount;\n                prevChunk = chunk;\n                indexPrevChunk = indexChunk;\n            }\n        }\n        return documents;\n    }\n    numberOfNewLines(text, start, end) {\n        const textSection = text.slice(start, end);\n        return (textSection.match(/\\n/g) || []).length;\n    }\n    async splitDocuments(documents, chunkHeaderOptions = {}) {\n        const selectedDocuments = documents.filter((doc)=>doc.pageContent !== undefined);\n        const texts = selectedDocuments.map((doc)=>doc.pageContent);\n        const metadatas = selectedDocuments.map((doc)=>doc.metadata);\n        return this.createDocuments(texts, metadatas, chunkHeaderOptions);\n    }\n    joinDocs(docs, separator) {\n        const text = docs.join(separator).trim();\n        return text === \"\" ? null : text;\n    }\n    async mergeSplits(splits, separator) {\n        const docs = [];\n        const currentDoc = [];\n        let total = 0;\n        for (const d of splits){\n            const _len = await this.lengthFunction(d);\n            if (total + _len + (currentDoc.length > 0 ? separator.length : 0) > this.chunkSize) {\n                if (total > this.chunkSize) {\n                    console.warn(`Created a chunk of size ${total}, +\nwhich is longer than the specified ${this.chunkSize}`);\n                }\n                if (currentDoc.length > 0) {\n                    const doc = this.joinDocs(currentDoc, separator);\n                    if (doc !== null) {\n                        docs.push(doc);\n                    }\n                    // Keep on popping if:\n                    // - we have a larger chunk than in the chunk overlap\n                    // - or if we still have any chunks and the length is long\n                    while(total > this.chunkOverlap || total + _len > this.chunkSize && total > 0){\n                        total -= await this.lengthFunction(currentDoc[0]);\n                        currentDoc.shift();\n                    }\n                }\n            }\n            currentDoc.push(d);\n            total += _len;\n        }\n        const doc = this.joinDocs(currentDoc, separator);\n        if (doc !== null) {\n            docs.push(doc);\n        }\n        return docs;\n    }\n}\nclass CharacterTextSplitter extends TextSplitter {\n    static lc_name() {\n        return \"CharacterTextSplitter\";\n    }\n    constructor(fields){\n        super(fields);\n        Object.defineProperty(this, \"separator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\\n\\n\"\n        });\n        this.separator = fields?.separator ?? this.separator;\n    }\n    async splitText(text) {\n        // First we naively split the large input into a bunch of smaller ones.\n        const splits = this.splitOnSeparator(text, this.separator);\n        return this.mergeSplits(splits, this.keepSeparator ? \"\" : this.separator);\n    }\n}\nconst SupportedTextSplitterLanguages = [\n    \"cpp\",\n    \"go\",\n    \"java\",\n    \"js\",\n    \"php\",\n    \"proto\",\n    \"python\",\n    \"rst\",\n    \"ruby\",\n    \"rust\",\n    \"scala\",\n    \"swift\",\n    \"markdown\",\n    \"latex\",\n    \"html\",\n    \"sol\"\n];\nclass RecursiveCharacterTextSplitter extends TextSplitter {\n    static lc_name() {\n        return \"RecursiveCharacterTextSplitter\";\n    }\n    constructor(fields){\n        super(fields);\n        Object.defineProperty(this, \"separators\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\"\n            ]\n        });\n        this.separators = fields?.separators ?? this.separators;\n        this.keepSeparator = fields?.keepSeparator ?? true;\n    }\n    async _splitText(text, separators) {\n        const finalChunks = [];\n        // Get appropriate separator to use\n        let separator = separators[separators.length - 1];\n        let newSeparators;\n        for(let i = 0; i < separators.length; i += 1){\n            const s = separators[i];\n            if (s === \"\") {\n                separator = s;\n                break;\n            }\n            if (text.includes(s)) {\n                separator = s;\n                newSeparators = separators.slice(i + 1);\n                break;\n            }\n        }\n        // Now that we have the separator, split the text\n        const splits = this.splitOnSeparator(text, separator);\n        // Now go merging things, recursively splitting longer texts.\n        let goodSplits = [];\n        const _separator = this.keepSeparator ? \"\" : separator;\n        for (const s of splits){\n            if (await this.lengthFunction(s) < this.chunkSize) {\n                goodSplits.push(s);\n            } else {\n                if (goodSplits.length) {\n                    const mergedText = await this.mergeSplits(goodSplits, _separator);\n                    finalChunks.push(...mergedText);\n                    goodSplits = [];\n                }\n                if (!newSeparators) {\n                    finalChunks.push(s);\n                } else {\n                    const otherInfo = await this._splitText(s, newSeparators);\n                    finalChunks.push(...otherInfo);\n                }\n            }\n        }\n        if (goodSplits.length) {\n            const mergedText = await this.mergeSplits(goodSplits, _separator);\n            finalChunks.push(...mergedText);\n        }\n        return finalChunks;\n    }\n    async splitText(text) {\n        return this._splitText(text, this.separators);\n    }\n    static fromLanguage(language, options) {\n        return new RecursiveCharacterTextSplitter({\n            ...options,\n            separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(language)\n        });\n    }\n    static getSeparatorsForLanguage(language) {\n        if (language === \"cpp\") {\n            return [\n                // Split along class definitions\n                \"\\nclass \",\n                // Split along function definitions\n                \"\\nvoid \",\n                \"\\nint \",\n                \"\\nfloat \",\n                \"\\ndouble \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\"\n            ];\n        } else if (language === \"go\") {\n            return [\n                // Split along function definitions\n                \"\\nfunc \",\n                \"\\nvar \",\n                \"\\nconst \",\n                \"\\ntype \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\"\n            ];\n        } else if (language === \"java\") {\n            return [\n                // Split along class definitions\n                \"\\nclass \",\n                // Split along method definitions\n                \"\\npublic \",\n                \"\\nprotected \",\n                \"\\nprivate \",\n                \"\\nstatic \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\"\n            ];\n        } else if (language === \"js\") {\n            return [\n                // Split along function definitions\n                \"\\nfunction \",\n                \"\\nconst \",\n                \"\\nlet \",\n                \"\\nvar \",\n                \"\\nclass \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                \"\\ndefault \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\"\n            ];\n        } else if (language === \"php\") {\n            return [\n                // Split along function definitions\n                \"\\nfunction \",\n                // Split along class definitions\n                \"\\nclass \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nforeach \",\n                \"\\nwhile \",\n                \"\\ndo \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\"\n            ];\n        } else if (language === \"proto\") {\n            return [\n                // Split along message definitions\n                \"\\nmessage \",\n                // Split along service definitions\n                \"\\nservice \",\n                // Split along enum definitions\n                \"\\nenum \",\n                // Split along option definitions\n                \"\\noption \",\n                // Split along import statements\n                \"\\nimport \",\n                // Split along syntax declarations\n                \"\\nsyntax \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\"\n            ];\n        } else if (language === \"python\") {\n            return [\n                // First, try to split along class definitions\n                \"\\nclass \",\n                \"\\ndef \",\n                \"\\n\tdef \",\n                // Now split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\"\n            ];\n        } else if (language === \"rst\") {\n            return [\n                // Split along section titles\n                \"\\n===\\n\",\n                \"\\n---\\n\",\n                \"\\n***\\n\",\n                // Split along directive markers\n                \"\\n.. \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\"\n            ];\n        } else if (language === \"ruby\") {\n            return [\n                // Split along method definitions\n                \"\\ndef \",\n                \"\\nclass \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nunless \",\n                \"\\nwhile \",\n                \"\\nfor \",\n                \"\\ndo \",\n                \"\\nbegin \",\n                \"\\nrescue \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\"\n            ];\n        } else if (language === \"rust\") {\n            return [\n                // Split along function definitions\n                \"\\nfn \",\n                \"\\nconst \",\n                \"\\nlet \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nwhile \",\n                \"\\nfor \",\n                \"\\nloop \",\n                \"\\nmatch \",\n                \"\\nconst \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\"\n            ];\n        } else if (language === \"scala\") {\n            return [\n                // Split along class definitions\n                \"\\nclass \",\n                \"\\nobject \",\n                // Split along method definitions\n                \"\\ndef \",\n                \"\\nval \",\n                \"\\nvar \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nmatch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\"\n            ];\n        } else if (language === \"swift\") {\n            return [\n                // Split along function definitions\n                \"\\nfunc \",\n                // Split along class definitions\n                \"\\nclass \",\n                \"\\nstruct \",\n                \"\\nenum \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\ndo \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\"\n            ];\n        } else if (language === \"markdown\") {\n            return [\n                // First, try to split along Markdown headings (starting with level 2)\n                \"\\n## \",\n                \"\\n### \",\n                \"\\n#### \",\n                \"\\n##### \",\n                \"\\n###### \",\n                // Note the alternative syntax for headings (below) is not handled here\n                // Heading level 2\n                // ---------------\n                // End of code block\n                \"```\\n\\n\",\n                // Horizontal lines\n                \"\\n\\n***\\n\\n\",\n                \"\\n\\n---\\n\\n\",\n                \"\\n\\n___\\n\\n\",\n                // Note that this splitter doesn't handle horizontal lines defined\n                // by *three or more* of ***, ---, or ___, but this is not handled\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\"\n            ];\n        } else if (language === \"latex\") {\n            return [\n                // First, try to split along Latex sections\n                \"\\n\\\\chapter{\",\n                \"\\n\\\\section{\",\n                \"\\n\\\\subsection{\",\n                \"\\n\\\\subsubsection{\",\n                // Now split by environments\n                \"\\n\\\\begin{enumerate}\",\n                \"\\n\\\\begin{itemize}\",\n                \"\\n\\\\begin{description}\",\n                \"\\n\\\\begin{list}\",\n                \"\\n\\\\begin{quote}\",\n                \"\\n\\\\begin{quotation}\",\n                \"\\n\\\\begin{verse}\",\n                \"\\n\\\\begin{verbatim}\",\n                // Now split by math environments\n                \"\\n\\\\begin{align}\",\n                \"$$\",\n                \"$\",\n                // Now split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\"\n            ];\n        } else if (language === \"html\") {\n            return [\n                // First, try to split along HTML tags\n                \"<body>\",\n                \"<div>\",\n                \"<p>\",\n                \"<br>\",\n                \"<li>\",\n                \"<h1>\",\n                \"<h2>\",\n                \"<h3>\",\n                \"<h4>\",\n                \"<h5>\",\n                \"<h6>\",\n                \"<span>\",\n                \"<table>\",\n                \"<tr>\",\n                \"<td>\",\n                \"<th>\",\n                \"<ul>\",\n                \"<ol>\",\n                \"<header>\",\n                \"<footer>\",\n                \"<nav>\",\n                // Head\n                \"<head>\",\n                \"<style>\",\n                \"<script>\",\n                \"<meta>\",\n                \"<title>\",\n                // Normal type of lines\n                \" \",\n                \"\"\n            ];\n        } else if (language === \"sol\") {\n            return [\n                // Split along compiler informations definitions\n                \"\\npragma \",\n                \"\\nusing \",\n                // Split along contract definitions\n                \"\\ncontract \",\n                \"\\ninterface \",\n                \"\\nlibrary \",\n                // Split along method definitions\n                \"\\nconstructor \",\n                \"\\ntype \",\n                \"\\nfunction \",\n                \"\\nevent \",\n                \"\\nmodifier \",\n                \"\\nerror \",\n                \"\\nstruct \",\n                \"\\nenum \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\ndo while \",\n                \"\\nassembly \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\"\n            ];\n        } else {\n            throw new Error(`Language ${language} is not supported.`);\n        }\n    }\n}\n/**\n * Implementation of splitter which looks at tokens.\n */ class TokenTextSplitter extends TextSplitter {\n    static lc_name() {\n        return \"TokenTextSplitter\";\n    }\n    constructor(fields){\n        super(fields);\n        Object.defineProperty(this, \"encodingName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"allowedSpecial\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"disallowedSpecial\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tokenizer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.encodingName = fields?.encodingName ?? \"gpt2\";\n        this.allowedSpecial = fields?.allowedSpecial ?? [];\n        this.disallowedSpecial = fields?.disallowedSpecial ?? \"all\";\n    }\n    async splitText(text) {\n        if (!this.tokenizer) {\n            this.tokenizer = await (0,_langchain_core_utils_tiktoken__WEBPACK_IMPORTED_MODULE_1__.getEncoding)(this.encodingName);\n        }\n        const splits = [];\n        const input_ids = this.tokenizer.encode(text, this.allowedSpecial, this.disallowedSpecial);\n        let start_idx = 0;\n        while(start_idx < input_ids.length){\n            if (start_idx > 0) {\n                start_idx -= this.chunkOverlap;\n            }\n            const end_idx = Math.min(start_idx + this.chunkSize, input_ids.length);\n            const chunk_ids = input_ids.slice(start_idx, end_idx);\n            splits.push(this.tokenizer.decode(chunk_ids));\n            start_idx = end_idx;\n        }\n        return splits;\n    }\n}\nclass MarkdownTextSplitter extends RecursiveCharacterTextSplitter {\n    constructor(fields){\n        super({\n            ...fields,\n            separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(\"markdown\")\n        });\n    }\n}\nclass LatexTextSplitter extends RecursiveCharacterTextSplitter {\n    constructor(fields){\n        super({\n            ...fields,\n            separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(\"latex\")\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvdGV4dF9zcGxpdHRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBOEU7QUFDakI7QUFDdEQsTUFBTUcscUJBQXFCRiw4RUFBdUJBO0lBQ3JERyxZQUFZQyxNQUFNLENBQUU7UUFDaEIsS0FBSyxDQUFDQTtRQUNOQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGdCQUFnQjtZQUN4Q0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTztnQkFBQztnQkFBYTtnQkFBeUI7YUFBaUI7UUFDbkU7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxhQUFhO1lBQ3JDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxnQkFBZ0I7WUFDeENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU87UUFDWDtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGlCQUFpQjtZQUN6Q0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTztRQUNYO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsa0JBQWtCO1lBQzFDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQSxJQUFJLENBQUNDLFNBQVMsR0FBR1AsUUFBUU8sYUFBYSxJQUFJLENBQUNBLFNBQVM7UUFDcEQsSUFBSSxDQUFDQyxZQUFZLEdBQUdSLFFBQVFRLGdCQUFnQixJQUFJLENBQUNBLFlBQVk7UUFDN0QsSUFBSSxDQUFDQyxhQUFhLEdBQUdULFFBQVFTLGlCQUFpQixJQUFJLENBQUNBLGFBQWE7UUFDaEUsSUFBSSxDQUFDQyxjQUFjLEdBQ2ZWLFFBQVFVLGtCQUFtQixFQUFDQyxPQUFTQSxLQUFLQyxNQUFNO1FBQ3BELElBQUksSUFBSSxDQUFDSixZQUFZLElBQUksSUFBSSxDQUFDRCxTQUFTLEVBQUU7WUFDckMsTUFBTSxJQUFJTSxNQUFNO1FBQ3BCO0lBQ0o7SUFDQSxNQUFNQyxtQkFBbUJDLFNBQVMsRUFBRUMscUJBQXFCLENBQUMsQ0FBQyxFQUFFO1FBQ3pELE9BQU8sSUFBSSxDQUFDQyxjQUFjLENBQUNGLFdBQVdDO0lBQzFDO0lBQ0FFLGlCQUFpQlAsSUFBSSxFQUFFUSxTQUFTLEVBQUU7UUFDOUIsSUFBSUM7UUFDSixJQUFJRCxXQUFXO1lBQ1gsSUFBSSxJQUFJLENBQUNWLGFBQWEsRUFBRTtnQkFDcEIsTUFBTVksd0JBQXdCRixVQUFVRyxPQUFPLENBQUMsMEJBQTBCO2dCQUMxRUYsU0FBU1QsS0FBS1ksS0FBSyxDQUFDLElBQUlDLE9BQU8sQ0FBQyxHQUFHLEVBQUVILHNCQUFzQixDQUFDLENBQUM7WUFDakUsT0FDSztnQkFDREQsU0FBU1QsS0FBS1ksS0FBSyxDQUFDSjtZQUN4QjtRQUNKLE9BQ0s7WUFDREMsU0FBU1QsS0FBS1ksS0FBSyxDQUFDO1FBQ3hCO1FBQ0EsT0FBT0gsT0FBT0ssTUFBTSxDQUFDLENBQUNDLElBQU1BLE1BQU07SUFDdEM7SUFDQSxNQUFNQyxnQkFBZ0JDLEtBQUssRUFDM0IsOERBQThEO0lBQzlEQyxZQUFZLEVBQUUsRUFBRWIscUJBQXFCLENBQUMsQ0FBQyxFQUFFO1FBQ3JDLG1FQUFtRTtRQUNuRSxNQUFNYyxhQUFhRCxVQUFVakIsTUFBTSxHQUFHLElBQUlpQixZQUFZLElBQUlFLE1BQU1ILE1BQU1oQixNQUFNLEVBQUVvQixJQUFJLENBQUMsQ0FBQztRQUNwRixNQUFNLEVBQUVDLGNBQWMsRUFBRSxFQUFFQyxxQkFBcUIsV0FBVyxFQUFFQywyQkFBMkIsS0FBSyxFQUFHLEdBQUduQjtRQUNsRyxNQUFNRCxZQUFZLElBQUlnQjtRQUN0QixJQUFLLElBQUlLLElBQUksR0FBR0EsSUFBSVIsTUFBTWhCLE1BQU0sRUFBRXdCLEtBQUssRUFBRztZQUN0QyxNQUFNekIsT0FBT2lCLEtBQUssQ0FBQ1EsRUFBRTtZQUNyQixJQUFJQyxtQkFBbUI7WUFDdkIsSUFBSUMsWUFBWTtZQUNoQixJQUFJQyxpQkFBaUIsQ0FBQztZQUN0QixLQUFLLE1BQU1DLFNBQVMsT0FBTSxJQUFJLENBQUNDLFNBQVMsQ0FBQzlCLEtBQUksRUFBRztnQkFDNUMsSUFBSStCLGNBQWNUO2dCQUNsQix1RkFBdUY7Z0JBQ3ZGLE1BQU1VLGFBQWFoQyxLQUFLaUMsT0FBTyxDQUFDSixPQUFPRCxpQkFBaUI7Z0JBQ3hELElBQUlELGNBQWMsTUFBTTtvQkFDcEIsTUFBTU8sMkJBQTJCLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNuQyxNQUFNLEdBQUdnQztvQkFDaEVOLG9CQUFvQlE7Z0JBQ3hCLE9BQ0s7b0JBQ0QsTUFBTUUsb0JBQW9CUixpQkFBa0IsTUFBTSxJQUFJLENBQUM3QixjQUFjLENBQUM0QjtvQkFDdEUsSUFBSVMsb0JBQW9CSixZQUFZO3dCQUNoQyxNQUFNSywrQkFBK0IsSUFBSSxDQUFDRixnQkFBZ0IsQ0FBQ25DLE1BQU1vQyxtQkFBbUJKO3dCQUNwRk4sb0JBQW9CVztvQkFDeEIsT0FDSyxJQUFJRCxvQkFBb0JKLFlBQVk7d0JBQ3JDLE1BQU1LLCtCQUErQixJQUFJLENBQUNGLGdCQUFnQixDQUFDbkMsTUFBTWdDLFlBQVlJO3dCQUM3RVYsb0JBQW9CVztvQkFDeEI7b0JBQ0EsSUFBSWIsMEJBQTBCO3dCQUMxQk8sZUFBZVI7b0JBQ25CO2dCQUNKO2dCQUNBLE1BQU1lLGdCQUFnQixJQUFJLENBQUNILGdCQUFnQixDQUFDTjtnQkFDNUMsTUFBTVUsTUFBTXBCLFVBQVUsQ0FBQ00sRUFBRSxDQUFDYyxHQUFHLElBQUksT0FBT3BCLFVBQVUsQ0FBQ00sRUFBRSxDQUFDYyxHQUFHLEtBQUssV0FDeEQ7b0JBQUUsR0FBR3BCLFVBQVUsQ0FBQ00sRUFBRSxDQUFDYyxHQUFHO2dCQUFDLElBQ3ZCLENBQUM7Z0JBQ1BBLElBQUlDLEtBQUssR0FBRztvQkFDUkMsTUFBTWY7b0JBQ05nQixJQUFJaEIsbUJBQW1CWTtnQkFDM0I7Z0JBQ0EsTUFBTUssMEJBQTBCO29CQUM1QixHQUFHeEIsVUFBVSxDQUFDTSxFQUFFO29CQUNoQmM7Z0JBQ0o7Z0JBQ0FSLGVBQWVGO2dCQUNmekIsVUFBVXdDLElBQUksQ0FBQyxJQUFJNUQsK0RBQVFBLENBQUM7b0JBQ3hCK0M7b0JBQ0FjLFVBQVVGO2dCQUNkO2dCQUNBakIsb0JBQW9CWTtnQkFDcEJYLFlBQVlFO2dCQUNaRCxpQkFBaUJJO1lBQ3JCO1FBQ0o7UUFDQSxPQUFPNUI7SUFDWDtJQUNBK0IsaUJBQWlCbkMsSUFBSSxFQUFFOEMsS0FBSyxFQUFFQyxHQUFHLEVBQUU7UUFDL0IsTUFBTUMsY0FBY2hELEtBQUtpRCxLQUFLLENBQUNILE9BQU9DO1FBQ3RDLE9BQU8sQ0FBQ0MsWUFBWUUsS0FBSyxDQUFDLFVBQVUsRUFBRSxFQUFFakQsTUFBTTtJQUNsRDtJQUNBLE1BQU1LLGVBQWVGLFNBQVMsRUFBRUMscUJBQXFCLENBQUMsQ0FBQyxFQUFFO1FBQ3JELE1BQU04QyxvQkFBb0IvQyxVQUFVVSxNQUFNLENBQUMsQ0FBQ3NDLE1BQVFBLElBQUlyQixXQUFXLEtBQUtzQjtRQUN4RSxNQUFNcEMsUUFBUWtDLGtCQUFrQkcsR0FBRyxDQUFDLENBQUNGLE1BQVFBLElBQUlyQixXQUFXO1FBQzVELE1BQU1iLFlBQVlpQyxrQkFBa0JHLEdBQUcsQ0FBQyxDQUFDRixNQUFRQSxJQUFJUCxRQUFRO1FBQzdELE9BQU8sSUFBSSxDQUFDN0IsZUFBZSxDQUFDQyxPQUFPQyxXQUFXYjtJQUNsRDtJQUNBa0QsU0FBU0MsSUFBSSxFQUFFaEQsU0FBUyxFQUFFO1FBQ3RCLE1BQU1SLE9BQU93RCxLQUFLQyxJQUFJLENBQUNqRCxXQUFXa0QsSUFBSTtRQUN0QyxPQUFPMUQsU0FBUyxLQUFLLE9BQU9BO0lBQ2hDO0lBQ0EsTUFBTTJELFlBQVlsRCxNQUFNLEVBQUVELFNBQVMsRUFBRTtRQUNqQyxNQUFNZ0QsT0FBTyxFQUFFO1FBQ2YsTUFBTUksYUFBYSxFQUFFO1FBQ3JCLElBQUlDLFFBQVE7UUFDWixLQUFLLE1BQU1DLEtBQUtyRCxPQUFRO1lBQ3BCLE1BQU1zRCxPQUFPLE1BQU0sSUFBSSxDQUFDaEUsY0FBYyxDQUFDK0Q7WUFDdkMsSUFBSUQsUUFBUUUsT0FBUUgsQ0FBQUEsV0FBVzNELE1BQU0sR0FBRyxJQUFJTyxVQUFVUCxNQUFNLEdBQUcsS0FDM0QsSUFBSSxDQUFDTCxTQUFTLEVBQUU7Z0JBQ2hCLElBQUlpRSxRQUFRLElBQUksQ0FBQ2pFLFNBQVMsRUFBRTtvQkFDeEJvRSxRQUFRQyxJQUFJLENBQUMsQ0FBQyx3QkFBd0IsRUFBRUosTUFBTTttQ0FDL0IsRUFBRSxJQUFJLENBQUNqRSxTQUFTLENBQUMsQ0FBQztnQkFDckM7Z0JBQ0EsSUFBSWdFLFdBQVczRCxNQUFNLEdBQUcsR0FBRztvQkFDdkIsTUFBTW1ELE1BQU0sSUFBSSxDQUFDRyxRQUFRLENBQUNLLFlBQVlwRDtvQkFDdEMsSUFBSTRDLFFBQVEsTUFBTTt3QkFDZEksS0FBS1osSUFBSSxDQUFDUTtvQkFDZDtvQkFDQSxzQkFBc0I7b0JBQ3RCLHFEQUFxRDtvQkFDckQsMERBQTBEO29CQUMxRCxNQUFPUyxRQUFRLElBQUksQ0FBQ2hFLFlBQVksSUFDM0JnRSxRQUFRRSxPQUFPLElBQUksQ0FBQ25FLFNBQVMsSUFBSWlFLFFBQVEsRUFBSTt3QkFDOUNBLFNBQVMsTUFBTSxJQUFJLENBQUM5RCxjQUFjLENBQUM2RCxVQUFVLENBQUMsRUFBRTt3QkFDaERBLFdBQVdNLEtBQUs7b0JBQ3BCO2dCQUNKO1lBQ0o7WUFDQU4sV0FBV2hCLElBQUksQ0FBQ2tCO1lBQ2hCRCxTQUFTRTtRQUNiO1FBQ0EsTUFBTVgsTUFBTSxJQUFJLENBQUNHLFFBQVEsQ0FBQ0ssWUFBWXBEO1FBQ3RDLElBQUk0QyxRQUFRLE1BQU07WUFDZEksS0FBS1osSUFBSSxDQUFDUTtRQUNkO1FBQ0EsT0FBT0k7SUFDWDtBQUNKO0FBQ08sTUFBTVcsOEJBQThCaEY7SUFDdkMsT0FBT2lGLFVBQVU7UUFDYixPQUFPO0lBQ1g7SUFDQWhGLFlBQVlDLE1BQU0sQ0FBRTtRQUNoQixLQUFLLENBQUNBO1FBQ05DLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsYUFBYTtZQUNyQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTztRQUNYO1FBQ0EsSUFBSSxDQUFDYSxTQUFTLEdBQUduQixRQUFRbUIsYUFBYSxJQUFJLENBQUNBLFNBQVM7SUFDeEQ7SUFDQSxNQUFNc0IsVUFBVTlCLElBQUksRUFBRTtRQUNsQix1RUFBdUU7UUFDdkUsTUFBTVMsU0FBUyxJQUFJLENBQUNGLGdCQUFnQixDQUFDUCxNQUFNLElBQUksQ0FBQ1EsU0FBUztRQUN6RCxPQUFPLElBQUksQ0FBQ21ELFdBQVcsQ0FBQ2xELFFBQVEsSUFBSSxDQUFDWCxhQUFhLEdBQUcsS0FBSyxJQUFJLENBQUNVLFNBQVM7SUFDNUU7QUFDSjtBQUNPLE1BQU02RCxpQ0FBaUM7SUFDMUM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSCxDQUFDO0FBQ0ssTUFBTUMsdUNBQXVDbkY7SUFDaEQsT0FBT2lGLFVBQVU7UUFDYixPQUFPO0lBQ1g7SUFDQWhGLFlBQVlDLE1BQU0sQ0FBRTtRQUNoQixLQUFLLENBQUNBO1FBQ05DLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsY0FBYztZQUN0Q0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTztnQkFBQztnQkFBUTtnQkFBTTtnQkFBSzthQUFHO1FBQ2xDO1FBQ0EsSUFBSSxDQUFDNEUsVUFBVSxHQUFHbEYsUUFBUWtGLGNBQWMsSUFBSSxDQUFDQSxVQUFVO1FBQ3ZELElBQUksQ0FBQ3pFLGFBQWEsR0FBR1QsUUFBUVMsaUJBQWlCO0lBQ2xEO0lBQ0EsTUFBTTBFLFdBQVd4RSxJQUFJLEVBQUV1RSxVQUFVLEVBQUU7UUFDL0IsTUFBTUUsY0FBYyxFQUFFO1FBQ3RCLG1DQUFtQztRQUNuQyxJQUFJakUsWUFBWStELFVBQVUsQ0FBQ0EsV0FBV3RFLE1BQU0sR0FBRyxFQUFFO1FBQ2pELElBQUl5RTtRQUNKLElBQUssSUFBSWpELElBQUksR0FBR0EsSUFBSThDLFdBQVd0RSxNQUFNLEVBQUV3QixLQUFLLEVBQUc7WUFDM0MsTUFBTVYsSUFBSXdELFVBQVUsQ0FBQzlDLEVBQUU7WUFDdkIsSUFBSVYsTUFBTSxJQUFJO2dCQUNWUCxZQUFZTztnQkFDWjtZQUNKO1lBQ0EsSUFBSWYsS0FBSzJFLFFBQVEsQ0FBQzVELElBQUk7Z0JBQ2xCUCxZQUFZTztnQkFDWjJELGdCQUFnQkgsV0FBV3RCLEtBQUssQ0FBQ3hCLElBQUk7Z0JBQ3JDO1lBQ0o7UUFDSjtRQUNBLGlEQUFpRDtRQUNqRCxNQUFNaEIsU0FBUyxJQUFJLENBQUNGLGdCQUFnQixDQUFDUCxNQUFNUTtRQUMzQyw2REFBNkQ7UUFDN0QsSUFBSW9FLGFBQWEsRUFBRTtRQUNuQixNQUFNQyxhQUFhLElBQUksQ0FBQy9FLGFBQWEsR0FBRyxLQUFLVTtRQUM3QyxLQUFLLE1BQU1PLEtBQUtOLE9BQVE7WUFDcEIsSUFBSSxNQUFPLElBQUksQ0FBQ1YsY0FBYyxDQUFDZ0IsS0FBTSxJQUFJLENBQUNuQixTQUFTLEVBQUU7Z0JBQ2pEZ0YsV0FBV2hDLElBQUksQ0FBQzdCO1lBQ3BCLE9BQ0s7Z0JBQ0QsSUFBSTZELFdBQVczRSxNQUFNLEVBQUU7b0JBQ25CLE1BQU02RSxhQUFhLE1BQU0sSUFBSSxDQUFDbkIsV0FBVyxDQUFDaUIsWUFBWUM7b0JBQ3RESixZQUFZN0IsSUFBSSxJQUFJa0M7b0JBQ3BCRixhQUFhLEVBQUU7Z0JBQ25CO2dCQUNBLElBQUksQ0FBQ0YsZUFBZTtvQkFDaEJELFlBQVk3QixJQUFJLENBQUM3QjtnQkFDckIsT0FDSztvQkFDRCxNQUFNZ0UsWUFBWSxNQUFNLElBQUksQ0FBQ1AsVUFBVSxDQUFDekQsR0FBRzJEO29CQUMzQ0QsWUFBWTdCLElBQUksSUFBSW1DO2dCQUN4QjtZQUNKO1FBQ0o7UUFDQSxJQUFJSCxXQUFXM0UsTUFBTSxFQUFFO1lBQ25CLE1BQU02RSxhQUFhLE1BQU0sSUFBSSxDQUFDbkIsV0FBVyxDQUFDaUIsWUFBWUM7WUFDdERKLFlBQVk3QixJQUFJLElBQUlrQztRQUN4QjtRQUNBLE9BQU9MO0lBQ1g7SUFDQSxNQUFNM0MsVUFBVTlCLElBQUksRUFBRTtRQUNsQixPQUFPLElBQUksQ0FBQ3dFLFVBQVUsQ0FBQ3hFLE1BQU0sSUFBSSxDQUFDdUUsVUFBVTtJQUNoRDtJQUNBLE9BQU9TLGFBQWFDLFFBQVEsRUFBRUMsT0FBTyxFQUFFO1FBQ25DLE9BQU8sSUFBSVosK0JBQStCO1lBQ3RDLEdBQUdZLE9BQU87WUFDVlgsWUFBWUQsK0JBQStCYSx3QkFBd0IsQ0FBQ0Y7UUFDeEU7SUFDSjtJQUNBLE9BQU9FLHlCQUF5QkYsUUFBUSxFQUFFO1FBQ3RDLElBQUlBLGFBQWEsT0FBTztZQUNwQixPQUFPO2dCQUNILGdDQUFnQztnQkFDaEM7Z0JBQ0EsbUNBQW1DO2dCQUNuQztnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQSxzQ0FBc0M7Z0JBQ3RDO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBLG9DQUFvQztnQkFDcEM7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDSDtRQUNMLE9BQ0ssSUFBSUEsYUFBYSxNQUFNO1lBQ3hCLE9BQU87Z0JBQ0gsbUNBQW1DO2dCQUNuQztnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQSxzQ0FBc0M7Z0JBQ3RDO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBLG9DQUFvQztnQkFDcEM7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDSDtRQUNMLE9BQ0ssSUFBSUEsYUFBYSxRQUFRO1lBQzFCLE9BQU87Z0JBQ0gsZ0NBQWdDO2dCQUNoQztnQkFDQSxpQ0FBaUM7Z0JBQ2pDO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBLHNDQUFzQztnQkFDdEM7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0Esb0NBQW9DO2dCQUNwQztnQkFDQTtnQkFDQTtnQkFDQTthQUNIO1FBQ0wsT0FDSyxJQUFJQSxhQUFhLE1BQU07WUFDeEIsT0FBTztnQkFDSCxtQ0FBbUM7Z0JBQ25DO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBLHNDQUFzQztnQkFDdEM7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0Esb0NBQW9DO2dCQUNwQztnQkFDQTtnQkFDQTtnQkFDQTthQUNIO1FBQ0wsT0FDSyxJQUFJQSxhQUFhLE9BQU87WUFDekIsT0FBTztnQkFDSCxtQ0FBbUM7Z0JBQ25DO2dCQUNBLGdDQUFnQztnQkFDaEM7Z0JBQ0Esc0NBQXNDO2dCQUN0QztnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQSxvQ0FBb0M7Z0JBQ3BDO2dCQUNBO2dCQUNBO2dCQUNBO2FBQ0g7UUFDTCxPQUNLLElBQUlBLGFBQWEsU0FBUztZQUMzQixPQUFPO2dCQUNILGtDQUFrQztnQkFDbEM7Z0JBQ0Esa0NBQWtDO2dCQUNsQztnQkFDQSwrQkFBK0I7Z0JBQy9CO2dCQUNBLGlDQUFpQztnQkFDakM7Z0JBQ0EsZ0NBQWdDO2dCQUNoQztnQkFDQSxrQ0FBa0M7Z0JBQ2xDO2dCQUNBLG9DQUFvQztnQkFDcEM7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDSDtRQUNMLE9BQ0ssSUFBSUEsYUFBYSxVQUFVO1lBQzVCLE9BQU87Z0JBQ0gsOENBQThDO2dCQUM5QztnQkFDQTtnQkFDQTtnQkFDQSx3Q0FBd0M7Z0JBQ3hDO2dCQUNBO2dCQUNBO2dCQUNBO2FBQ0g7UUFDTCxPQUNLLElBQUlBLGFBQWEsT0FBTztZQUN6QixPQUFPO2dCQUNILDZCQUE2QjtnQkFDN0I7Z0JBQ0E7Z0JBQ0E7Z0JBQ0EsZ0NBQWdDO2dCQUNoQztnQkFDQSxvQ0FBb0M7Z0JBQ3BDO2dCQUNBO2dCQUNBO2dCQUNBO2FBQ0g7UUFDTCxPQUNLLElBQUlBLGFBQWEsUUFBUTtZQUMxQixPQUFPO2dCQUNILGlDQUFpQztnQkFDakM7Z0JBQ0E7Z0JBQ0Esc0NBQXNDO2dCQUN0QztnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQSxvQ0FBb0M7Z0JBQ3BDO2dCQUNBO2dCQUNBO2dCQUNBO2FBQ0g7UUFDTCxPQUNLLElBQUlBLGFBQWEsUUFBUTtZQUMxQixPQUFPO2dCQUNILG1DQUFtQztnQkFDbkM7Z0JBQ0E7Z0JBQ0E7Z0JBQ0Esc0NBQXNDO2dCQUN0QztnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQSxvQ0FBb0M7Z0JBQ3BDO2dCQUNBO2dCQUNBO2dCQUNBO2FBQ0g7UUFDTCxPQUNLLElBQUlBLGFBQWEsU0FBUztZQUMzQixPQUFPO2dCQUNILGdDQUFnQztnQkFDaEM7Z0JBQ0E7Z0JBQ0EsaUNBQWlDO2dCQUNqQztnQkFDQTtnQkFDQTtnQkFDQSxzQ0FBc0M7Z0JBQ3RDO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBLG9DQUFvQztnQkFDcEM7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDSDtRQUNMLE9BQ0ssSUFBSUEsYUFBYSxTQUFTO1lBQzNCLE9BQU87Z0JBQ0gsbUNBQW1DO2dCQUNuQztnQkFDQSxnQ0FBZ0M7Z0JBQ2hDO2dCQUNBO2dCQUNBO2dCQUNBLHNDQUFzQztnQkFDdEM7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0Esb0NBQW9DO2dCQUNwQztnQkFDQTtnQkFDQTtnQkFDQTthQUNIO1FBQ0wsT0FDSyxJQUFJQSxhQUFhLFlBQVk7WUFDOUIsT0FBTztnQkFDSCxzRUFBc0U7Z0JBQ3RFO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBLHVFQUF1RTtnQkFDdkUsa0JBQWtCO2dCQUNsQixrQkFBa0I7Z0JBQ2xCLG9CQUFvQjtnQkFDcEI7Z0JBQ0EsbUJBQW1CO2dCQUNuQjtnQkFDQTtnQkFDQTtnQkFDQSxrRUFBa0U7Z0JBQ2xFLGtFQUFrRTtnQkFDbEU7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDSDtRQUNMLE9BQ0ssSUFBSUEsYUFBYSxTQUFTO1lBQzNCLE9BQU87Z0JBQ0gsMkNBQTJDO2dCQUMzQztnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQSw0QkFBNEI7Z0JBQzVCO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBLGlDQUFpQztnQkFDakM7Z0JBQ0E7Z0JBQ0E7Z0JBQ0Esd0NBQXdDO2dCQUN4QztnQkFDQTtnQkFDQTtnQkFDQTthQUNIO1FBQ0wsT0FDSyxJQUFJQSxhQUFhLFFBQVE7WUFDMUIsT0FBTztnQkFDSCxzQ0FBc0M7Z0JBQ3RDO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBLE9BQU87Z0JBQ1A7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0EsdUJBQXVCO2dCQUN2QjtnQkFDQTthQUNIO1FBQ0wsT0FDSyxJQUFJQSxhQUFhLE9BQU87WUFDekIsT0FBTztnQkFDSCxnREFBZ0Q7Z0JBQ2hEO2dCQUNBO2dCQUNBLG1DQUFtQztnQkFDbkM7Z0JBQ0E7Z0JBQ0E7Z0JBQ0EsaUNBQWlDO2dCQUNqQztnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQSxzQ0FBc0M7Z0JBQ3RDO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBLG9DQUFvQztnQkFDcEM7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDSDtRQUNMLE9BQ0s7WUFDRCxNQUFNLElBQUkvRSxNQUFNLENBQUMsU0FBUyxFQUFFK0UsU0FBUyxrQkFBa0IsQ0FBQztRQUM1RDtJQUNKO0FBQ0o7QUFDQTs7Q0FFQyxHQUNNLE1BQU1HLDBCQUEwQmpHO0lBQ25DLE9BQU9pRixVQUFVO1FBQ2IsT0FBTztJQUNYO0lBQ0FoRixZQUFZQyxNQUFNLENBQUU7UUFDaEIsS0FBSyxDQUFDQTtRQUNOQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGdCQUFnQjtZQUN4Q0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsa0JBQWtCO1lBQzFDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxxQkFBcUI7WUFDN0NDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGFBQWE7WUFDckNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBLElBQUksQ0FBQzBGLFlBQVksR0FBR2hHLFFBQVFnRyxnQkFBZ0I7UUFDNUMsSUFBSSxDQUFDQyxjQUFjLEdBQUdqRyxRQUFRaUcsa0JBQWtCLEVBQUU7UUFDbEQsSUFBSSxDQUFDQyxpQkFBaUIsR0FBR2xHLFFBQVFrRyxxQkFBcUI7SUFDMUQ7SUFDQSxNQUFNekQsVUFBVTlCLElBQUksRUFBRTtRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDd0YsU0FBUyxFQUFFO1lBQ2pCLElBQUksQ0FBQ0EsU0FBUyxHQUFHLE1BQU10RywyRUFBV0EsQ0FBQyxJQUFJLENBQUNtRyxZQUFZO1FBQ3hEO1FBQ0EsTUFBTTVFLFNBQVMsRUFBRTtRQUNqQixNQUFNZ0YsWUFBWSxJQUFJLENBQUNELFNBQVMsQ0FBQ0UsTUFBTSxDQUFDMUYsTUFBTSxJQUFJLENBQUNzRixjQUFjLEVBQUUsSUFBSSxDQUFDQyxpQkFBaUI7UUFDekYsSUFBSUksWUFBWTtRQUNoQixNQUFPQSxZQUFZRixVQUFVeEYsTUFBTSxDQUFFO1lBQ2pDLElBQUkwRixZQUFZLEdBQUc7Z0JBQ2ZBLGFBQWEsSUFBSSxDQUFDOUYsWUFBWTtZQUNsQztZQUNBLE1BQU0rRixVQUFVQyxLQUFLQyxHQUFHLENBQUNILFlBQVksSUFBSSxDQUFDL0YsU0FBUyxFQUFFNkYsVUFBVXhGLE1BQU07WUFDckUsTUFBTThGLFlBQVlOLFVBQVV4QyxLQUFLLENBQUMwQyxXQUFXQztZQUM3Q25GLE9BQU9tQyxJQUFJLENBQUMsSUFBSSxDQUFDNEMsU0FBUyxDQUFDUSxNQUFNLENBQUNEO1lBQ2xDSixZQUFZQztRQUNoQjtRQUNBLE9BQU9uRjtJQUNYO0FBQ0o7QUFDTyxNQUFNd0YsNkJBQTZCM0I7SUFDdENsRixZQUFZQyxNQUFNLENBQUU7UUFDaEIsS0FBSyxDQUFDO1lBQ0YsR0FBR0EsTUFBTTtZQUNUa0YsWUFBWUQsK0JBQStCYSx3QkFBd0IsQ0FBQztRQUN4RTtJQUNKO0FBQ0o7QUFDTyxNQUFNZSwwQkFBMEI1QjtJQUNuQ2xGLFlBQVlDLE1BQU0sQ0FBRTtRQUNoQixLQUFLLENBQUM7WUFDRixHQUFHQSxNQUFNO1lBQ1RrRixZQUFZRCwrQkFBK0JhLHdCQUF3QixDQUFDO1FBQ3hFO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL3N5bmNjaGF0Ly4vbm9kZV9tb2R1bGVzL2xhbmdjaGFpbi9kaXN0L3RleHRfc3BsaXR0ZXIuanM/NWZiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEb2N1bWVudCwgQmFzZURvY3VtZW50VHJhbnNmb3JtZXIgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL2RvY3VtZW50c1wiO1xuaW1wb3J0IHsgZ2V0RW5jb2RpbmcgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3V0aWxzL3Rpa3Rva2VuXCI7XG5leHBvcnQgY2xhc3MgVGV4dFNwbGl0dGVyIGV4dGVuZHMgQmFzZURvY3VtZW50VHJhbnNmb3JtZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpblwiLCBcImRvY3VtZW50X3RyYW5zZm9ybWVyc1wiLCBcInRleHRfc3BsaXR0ZXJzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaHVua1NpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDEwMDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNodW5rT3ZlcmxhcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMjAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrZWVwU2VwYXJhdG9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGVuZ3RoRnVuY3Rpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaHVua1NpemUgPSBmaWVsZHM/LmNodW5rU2l6ZSA/PyB0aGlzLmNodW5rU2l6ZTtcbiAgICAgICAgdGhpcy5jaHVua092ZXJsYXAgPSBmaWVsZHM/LmNodW5rT3ZlcmxhcCA/PyB0aGlzLmNodW5rT3ZlcmxhcDtcbiAgICAgICAgdGhpcy5rZWVwU2VwYXJhdG9yID0gZmllbGRzPy5rZWVwU2VwYXJhdG9yID8/IHRoaXMua2VlcFNlcGFyYXRvcjtcbiAgICAgICAgdGhpcy5sZW5ndGhGdW5jdGlvbiA9XG4gICAgICAgICAgICBmaWVsZHM/Lmxlbmd0aEZ1bmN0aW9uID8/ICgodGV4dCkgPT4gdGV4dC5sZW5ndGgpO1xuICAgICAgICBpZiAodGhpcy5jaHVua092ZXJsYXAgPj0gdGhpcy5jaHVua1NpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBoYXZlIGNodW5rT3ZlcmxhcCA+PSBjaHVua1NpemVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdHJhbnNmb3JtRG9jdW1lbnRzKGRvY3VtZW50cywgY2h1bmtIZWFkZXJPcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXREb2N1bWVudHMoZG9jdW1lbnRzLCBjaHVua0hlYWRlck9wdGlvbnMpO1xuICAgIH1cbiAgICBzcGxpdE9uU2VwYXJhdG9yKHRleHQsIHNlcGFyYXRvcikge1xuICAgICAgICBsZXQgc3BsaXRzO1xuICAgICAgICBpZiAoc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5rZWVwU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXhFc2NhcGVkU2VwYXJhdG9yID0gc2VwYXJhdG9yLnJlcGxhY2UoL1svXFwtXFxcXF4kKis/LigpfFtcXF17fV0vZywgXCJcXFxcJCZcIik7XG4gICAgICAgICAgICAgICAgc3BsaXRzID0gdGV4dC5zcGxpdChuZXcgUmVnRXhwKGAoPz0ke3JlZ2V4RXNjYXBlZFNlcGFyYXRvcn0pYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3BsaXRzID0gdGV4dC5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3BsaXRzID0gdGV4dC5zcGxpdChcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRzLmZpbHRlcigocykgPT4gcyAhPT0gXCJcIik7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZURvY3VtZW50cyh0ZXh0cywgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBtZXRhZGF0YXMgPSBbXSwgY2h1bmtIZWFkZXJPcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gaWYgbm8gbWV0YWRhdGEgaXMgcHJvdmlkZWQsIHdlIGNyZWF0ZSBhbiBlbXB0eSBvbmUgZm9yIGVhY2ggdGV4dFxuICAgICAgICBjb25zdCBfbWV0YWRhdGFzID0gbWV0YWRhdGFzLmxlbmd0aCA+IDAgPyBtZXRhZGF0YXMgOiBuZXcgQXJyYXkodGV4dHMubGVuZ3RoKS5maWxsKHt9KTtcbiAgICAgICAgY29uc3QgeyBjaHVua0hlYWRlciA9IFwiXCIsIGNodW5rT3ZlcmxhcEhlYWRlciA9IFwiKGNvbnQnZCkgXCIsIGFwcGVuZENodW5rT3ZlcmxhcEhlYWRlciA9IGZhbHNlLCB9ID0gY2h1bmtIZWFkZXJPcHRpb25zO1xuICAgICAgICBjb25zdCBkb2N1bWVudHMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHRleHRzW2ldO1xuICAgICAgICAgICAgbGV0IGxpbmVDb3VudGVySW5kZXggPSAxO1xuICAgICAgICAgICAgbGV0IHByZXZDaHVuayA9IG51bGw7XG4gICAgICAgICAgICBsZXQgaW5kZXhQcmV2Q2h1bmsgPSAtMTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgYXdhaXQgdGhpcy5zcGxpdFRleHQodGV4dCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFnZUNvbnRlbnQgPSBjaHVua0hlYWRlcjtcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNvdW50IHRoZSBcXG4gdGhhdCBhcmUgaW4gdGhlIHRleHQgYmVmb3JlIGdldHRpbmcgcmVtb3ZlZCBieSB0aGUgc3BsaXR0aW5nXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhDaHVuayA9IHRleHQuaW5kZXhPZihjaHVuaywgaW5kZXhQcmV2Q2h1bmsgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldkNodW5rID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmVzQmVmb3JlRmlyc3RDaHVuayA9IHRoaXMubnVtYmVyT2ZOZXdMaW5lcyh0ZXh0LCAwLCBpbmRleENodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZUNvdW50ZXJJbmRleCArPSBuZXdMaW5lc0JlZm9yZUZpcnN0Q2h1bms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleEVuZFByZXZDaHVuayA9IGluZGV4UHJldkNodW5rICsgKGF3YWl0IHRoaXMubGVuZ3RoRnVuY3Rpb24ocHJldkNodW5rKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleEVuZFByZXZDaHVuayA8IGluZGV4Q2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlck9mSW50ZXJtZWRpYXRlTmV3TGluZXMgPSB0aGlzLm51bWJlck9mTmV3TGluZXModGV4dCwgaW5kZXhFbmRQcmV2Q2h1bmssIGluZGV4Q2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUNvdW50ZXJJbmRleCArPSBudW1iZXJPZkludGVybWVkaWF0ZU5ld0xpbmVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4RW5kUHJldkNodW5rID4gaW5kZXhDaHVuaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZJbnRlcm1lZGlhdGVOZXdMaW5lcyA9IHRoaXMubnVtYmVyT2ZOZXdMaW5lcyh0ZXh0LCBpbmRleENodW5rLCBpbmRleEVuZFByZXZDaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lQ291bnRlckluZGV4IC09IG51bWJlck9mSW50ZXJtZWRpYXRlTmV3TGluZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFwcGVuZENodW5rT3ZlcmxhcEhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZUNvbnRlbnQgKz0gY2h1bmtPdmVybGFwSGVhZGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmVzQ291bnQgPSB0aGlzLm51bWJlck9mTmV3TGluZXMoY2h1bmspO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYyA9IF9tZXRhZGF0YXNbaV0ubG9jICYmIHR5cGVvZiBfbWV0YWRhdGFzW2ldLmxvYyA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgICAgICA/IHsgLi4uX21ldGFkYXRhc1tpXS5sb2MgfVxuICAgICAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICAgICAgICAgIGxvYy5saW5lcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogbGluZUNvdW50ZXJJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdG86IGxpbmVDb3VudGVySW5kZXggKyBuZXdMaW5lc0NvdW50LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFXaXRoTGluZXNOdW1iZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLl9tZXRhZGF0YXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIGxvYyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBhZ2VDb250ZW50ICs9IGNodW5rO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50cy5wdXNoKG5ldyBEb2N1bWVudCh7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGFXaXRoTGluZXNOdW1iZXIsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGxpbmVDb3VudGVySW5kZXggKz0gbmV3TGluZXNDb3VudDtcbiAgICAgICAgICAgICAgICBwcmV2Q2h1bmsgPSBjaHVuaztcbiAgICAgICAgICAgICAgICBpbmRleFByZXZDaHVuayA9IGluZGV4Q2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50cztcbiAgICB9XG4gICAgbnVtYmVyT2ZOZXdMaW5lcyh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IHRleHRTZWN0aW9uID0gdGV4dC5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgcmV0dXJuICh0ZXh0U2VjdGlvbi5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGg7XG4gICAgfVxuICAgIGFzeW5jIHNwbGl0RG9jdW1lbnRzKGRvY3VtZW50cywgY2h1bmtIZWFkZXJPcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWREb2N1bWVudHMgPSBkb2N1bWVudHMuZmlsdGVyKChkb2MpID0+IGRvYy5wYWdlQ29udGVudCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgdGV4dHMgPSBzZWxlY3RlZERvY3VtZW50cy5tYXAoKGRvYykgPT4gZG9jLnBhZ2VDb250ZW50KTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGFzID0gc2VsZWN0ZWREb2N1bWVudHMubWFwKChkb2MpID0+IGRvYy5tZXRhZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURvY3VtZW50cyh0ZXh0cywgbWV0YWRhdGFzLCBjaHVua0hlYWRlck9wdGlvbnMpO1xuICAgIH1cbiAgICBqb2luRG9jcyhkb2NzLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGRvY3Muam9pbihzZXBhcmF0b3IpLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIHRleHQgPT09IFwiXCIgPyBudWxsIDogdGV4dDtcbiAgICB9XG4gICAgYXN5bmMgbWVyZ2VTcGxpdHMoc3BsaXRzLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgY29uc3QgZG9jcyA9IFtdO1xuICAgICAgICBjb25zdCBjdXJyZW50RG9jID0gW107XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgZCBvZiBzcGxpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IF9sZW4gPSBhd2FpdCB0aGlzLmxlbmd0aEZ1bmN0aW9uKGQpO1xuICAgICAgICAgICAgaWYgKHRvdGFsICsgX2xlbiArIChjdXJyZW50RG9jLmxlbmd0aCA+IDAgPyBzZXBhcmF0b3IubGVuZ3RoIDogMCkgPlxuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsID4gdGhpcy5jaHVua1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBDcmVhdGVkIGEgY2h1bmsgb2Ygc2l6ZSAke3RvdGFsfSwgK1xud2hpY2ggaXMgbG9uZ2VyIHRoYW4gdGhlIHNwZWNpZmllZCAke3RoaXMuY2h1bmtTaXplfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudERvYy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvYyA9IHRoaXMuam9pbkRvY3MoY3VycmVudERvYywgc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jcy5wdXNoKGRvYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBvbiBwb3BwaW5nIGlmOlxuICAgICAgICAgICAgICAgICAgICAvLyAtIHdlIGhhdmUgYSBsYXJnZXIgY2h1bmsgdGhhbiBpbiB0aGUgY2h1bmsgb3ZlcmxhcFxuICAgICAgICAgICAgICAgICAgICAvLyAtIG9yIGlmIHdlIHN0aWxsIGhhdmUgYW55IGNodW5rcyBhbmQgdGhlIGxlbmd0aCBpcyBsb25nXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0b3RhbCA+IHRoaXMuY2h1bmtPdmVybGFwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodG90YWwgKyBfbGVuID4gdGhpcy5jaHVua1NpemUgJiYgdG90YWwgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgLT0gYXdhaXQgdGhpcy5sZW5ndGhGdW5jdGlvbihjdXJyZW50RG9jWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREb2Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnREb2MucHVzaChkKTtcbiAgICAgICAgICAgIHRvdGFsICs9IF9sZW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9jID0gdGhpcy5qb2luRG9jcyhjdXJyZW50RG9jLCBzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoZG9jICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkb2NzLnB1c2goZG9jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jcztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ2hhcmFjdGVyVGV4dFNwbGl0dGVyIGV4dGVuZHMgVGV4dFNwbGl0dGVyIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2hhcmFjdGVyVGV4dFNwbGl0dGVyXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXBhcmF0b3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiXFxuXFxuXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VwYXJhdG9yID0gZmllbGRzPy5zZXBhcmF0b3IgPz8gdGhpcy5zZXBhcmF0b3I7XG4gICAgfVxuICAgIGFzeW5jIHNwbGl0VGV4dCh0ZXh0KSB7XG4gICAgICAgIC8vIEZpcnN0IHdlIG5haXZlbHkgc3BsaXQgdGhlIGxhcmdlIGlucHV0IGludG8gYSBidW5jaCBvZiBzbWFsbGVyIG9uZXMuXG4gICAgICAgIGNvbnN0IHNwbGl0cyA9IHRoaXMuc3BsaXRPblNlcGFyYXRvcih0ZXh0LCB0aGlzLnNlcGFyYXRvcik7XG4gICAgICAgIHJldHVybiB0aGlzLm1lcmdlU3BsaXRzKHNwbGl0cywgdGhpcy5rZWVwU2VwYXJhdG9yID8gXCJcIiA6IHRoaXMuc2VwYXJhdG9yKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgU3VwcG9ydGVkVGV4dFNwbGl0dGVyTGFuZ3VhZ2VzID0gW1xuICAgIFwiY3BwXCIsXG4gICAgXCJnb1wiLFxuICAgIFwiamF2YVwiLFxuICAgIFwianNcIixcbiAgICBcInBocFwiLFxuICAgIFwicHJvdG9cIixcbiAgICBcInB5dGhvblwiLFxuICAgIFwicnN0XCIsXG4gICAgXCJydWJ5XCIsXG4gICAgXCJydXN0XCIsXG4gICAgXCJzY2FsYVwiLFxuICAgIFwic3dpZnRcIixcbiAgICBcIm1hcmtkb3duXCIsXG4gICAgXCJsYXRleFwiLFxuICAgIFwiaHRtbFwiLFxuICAgIFwic29sXCIsXG5dO1xuZXhwb3J0IGNsYXNzIFJlY3Vyc2l2ZUNoYXJhY3RlclRleHRTcGxpdHRlciBleHRlbmRzIFRleHRTcGxpdHRlciB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJlY3Vyc2l2ZUNoYXJhY3RlclRleHRTcGxpdHRlclwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2VwYXJhdG9yc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wiXFxuXFxuXCIsIFwiXFxuXCIsIFwiIFwiLCBcIlwiXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXBhcmF0b3JzID0gZmllbGRzPy5zZXBhcmF0b3JzID8/IHRoaXMuc2VwYXJhdG9ycztcbiAgICAgICAgdGhpcy5rZWVwU2VwYXJhdG9yID0gZmllbGRzPy5rZWVwU2VwYXJhdG9yID8/IHRydWU7XG4gICAgfVxuICAgIGFzeW5jIF9zcGxpdFRleHQodGV4dCwgc2VwYXJhdG9ycykge1xuICAgICAgICBjb25zdCBmaW5hbENodW5rcyA9IFtdO1xuICAgICAgICAvLyBHZXQgYXBwcm9wcmlhdGUgc2VwYXJhdG9yIHRvIHVzZVxuICAgICAgICBsZXQgc2VwYXJhdG9yID0gc2VwYXJhdG9yc1tzZXBhcmF0b3JzLmxlbmd0aCAtIDFdO1xuICAgICAgICBsZXQgbmV3U2VwYXJhdG9ycztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXBhcmF0b3JzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBzID0gc2VwYXJhdG9yc1tpXTtcbiAgICAgICAgICAgIGlmIChzID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yID0gcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXh0LmluY2x1ZGVzKHMpKSB7XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yID0gcztcbiAgICAgICAgICAgICAgICBuZXdTZXBhcmF0b3JzID0gc2VwYXJhdG9ycy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IHRoYXQgd2UgaGF2ZSB0aGUgc2VwYXJhdG9yLCBzcGxpdCB0aGUgdGV4dFxuICAgICAgICBjb25zdCBzcGxpdHMgPSB0aGlzLnNwbGl0T25TZXBhcmF0b3IodGV4dCwgc2VwYXJhdG9yKTtcbiAgICAgICAgLy8gTm93IGdvIG1lcmdpbmcgdGhpbmdzLCByZWN1cnNpdmVseSBzcGxpdHRpbmcgbG9uZ2VyIHRleHRzLlxuICAgICAgICBsZXQgZ29vZFNwbGl0cyA9IFtdO1xuICAgICAgICBjb25zdCBfc2VwYXJhdG9yID0gdGhpcy5rZWVwU2VwYXJhdG9yID8gXCJcIiA6IHNlcGFyYXRvcjtcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHNwbGl0cykge1xuICAgICAgICAgICAgaWYgKChhd2FpdCB0aGlzLmxlbmd0aEZ1bmN0aW9uKHMpKSA8IHRoaXMuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICAgICAgZ29vZFNwbGl0cy5wdXNoKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGdvb2RTcGxpdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlZFRleHQgPSBhd2FpdCB0aGlzLm1lcmdlU3BsaXRzKGdvb2RTcGxpdHMsIF9zZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBmaW5hbENodW5rcy5wdXNoKC4uLm1lcmdlZFRleHQpO1xuICAgICAgICAgICAgICAgICAgICBnb29kU3BsaXRzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbmV3U2VwYXJhdG9ycykge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbENodW5rcy5wdXNoKHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJJbmZvID0gYXdhaXQgdGhpcy5fc3BsaXRUZXh0KHMsIG5ld1NlcGFyYXRvcnMpO1xuICAgICAgICAgICAgICAgICAgICBmaW5hbENodW5rcy5wdXNoKC4uLm90aGVySW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChnb29kU3BsaXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkVGV4dCA9IGF3YWl0IHRoaXMubWVyZ2VTcGxpdHMoZ29vZFNwbGl0cywgX3NlcGFyYXRvcik7XG4gICAgICAgICAgICBmaW5hbENodW5rcy5wdXNoKC4uLm1lcmdlZFRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5hbENodW5rcztcbiAgICB9XG4gICAgYXN5bmMgc3BsaXRUZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NwbGl0VGV4dCh0ZXh0LCB0aGlzLnNlcGFyYXRvcnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUxhbmd1YWdlKGxhbmd1YWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdXJzaXZlQ2hhcmFjdGVyVGV4dFNwbGl0dGVyKHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBzZXBhcmF0b3JzOiBSZWN1cnNpdmVDaGFyYWN0ZXJUZXh0U3BsaXR0ZXIuZ2V0U2VwYXJhdG9yc0Zvckxhbmd1YWdlKGxhbmd1YWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTZXBhcmF0b3JzRm9yTGFuZ3VhZ2UobGFuZ3VhZ2UpIHtcbiAgICAgICAgaWYgKGxhbmd1YWdlID09PSBcImNwcFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIGNsYXNzIGRlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgXCJcXG5jbGFzcyBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBmdW5jdGlvbiBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxudm9pZCBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmludCBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmZsb2F0IFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuZG91YmxlIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIGNvbnRyb2wgZmxvdyBzdGF0ZW1lbnRzXG4gICAgICAgICAgICAgICAgXCJcXG5pZiBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmZvciBcIixcbiAgICAgICAgICAgICAgICBcIlxcbndoaWxlIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuc3dpdGNoIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuY2FzZSBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBieSB0aGUgbm9ybWFsIHR5cGUgb2YgbGluZXNcbiAgICAgICAgICAgICAgICBcIlxcblxcblwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFuZ3VhZ2UgPT09IFwiZ29cIikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBmdW5jdGlvbiBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxuZnVuYyBcIixcbiAgICAgICAgICAgICAgICBcIlxcbnZhciBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmNvbnN0IFwiLFxuICAgICAgICAgICAgICAgIFwiXFxudHlwZSBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBjb250cm9sIGZsb3cgc3RhdGVtZW50c1xuICAgICAgICAgICAgICAgIFwiXFxuaWYgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5mb3IgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5zd2l0Y2ggXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5jYXNlIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGJ5IHRoZSBub3JtYWwgdHlwZSBvZiBsaW5lc1xuICAgICAgICAgICAgICAgIFwiXFxuXFxuXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cIixcbiAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYW5ndWFnZSA9PT0gXCJqYXZhXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgY2xhc3MgZGVmaW5pdGlvbnNcbiAgICAgICAgICAgICAgICBcIlxcbmNsYXNzIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIG1ldGhvZCBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxucHVibGljIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxucHJvdGVjdGVkIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxucHJpdmF0ZSBcIixcbiAgICAgICAgICAgICAgICBcIlxcbnN0YXRpYyBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBjb250cm9sIGZsb3cgc3RhdGVtZW50c1xuICAgICAgICAgICAgICAgIFwiXFxuaWYgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5mb3IgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG53aGlsZSBcIixcbiAgICAgICAgICAgICAgICBcIlxcbnN3aXRjaCBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmNhc2UgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYnkgdGhlIG5vcm1hbCB0eXBlIG9mIGxpbmVzXG4gICAgICAgICAgICAgICAgXCJcXG5cXG5cIixcbiAgICAgICAgICAgICAgICBcIlxcblwiLFxuICAgICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhbmd1YWdlID09PSBcImpzXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgZnVuY3Rpb24gZGVmaW5pdGlvbnNcbiAgICAgICAgICAgICAgICBcIlxcbmZ1bmN0aW9uIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuY29uc3QgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5sZXQgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG52YXIgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5jbGFzcyBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBjb250cm9sIGZsb3cgc3RhdGVtZW50c1xuICAgICAgICAgICAgICAgIFwiXFxuaWYgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5mb3IgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG53aGlsZSBcIixcbiAgICAgICAgICAgICAgICBcIlxcbnN3aXRjaCBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmNhc2UgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5kZWZhdWx0IFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGJ5IHRoZSBub3JtYWwgdHlwZSBvZiBsaW5lc1xuICAgICAgICAgICAgICAgIFwiXFxuXFxuXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cIixcbiAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYW5ndWFnZSA9PT0gXCJwaHBcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBmdW5jdGlvbiBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxuZnVuY3Rpb24gXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgY2xhc3MgZGVmaW5pdGlvbnNcbiAgICAgICAgICAgICAgICBcIlxcbmNsYXNzIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIGNvbnRyb2wgZmxvdyBzdGF0ZW1lbnRzXG4gICAgICAgICAgICAgICAgXCJcXG5pZiBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmZvcmVhY2ggXCIsXG4gICAgICAgICAgICAgICAgXCJcXG53aGlsZSBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmRvIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuc3dpdGNoIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuY2FzZSBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBieSB0aGUgbm9ybWFsIHR5cGUgb2YgbGluZXNcbiAgICAgICAgICAgICAgICBcIlxcblxcblwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFuZ3VhZ2UgPT09IFwicHJvdG9cIikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBtZXNzYWdlIGRlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgXCJcXG5tZXNzYWdlIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIHNlcnZpY2UgZGVmaW5pdGlvbnNcbiAgICAgICAgICAgICAgICBcIlxcbnNlcnZpY2UgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgZW51bSBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxuZW51bSBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBvcHRpb24gZGVmaW5pdGlvbnNcbiAgICAgICAgICAgICAgICBcIlxcbm9wdGlvbiBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBpbXBvcnQgc3RhdGVtZW50c1xuICAgICAgICAgICAgICAgIFwiXFxuaW1wb3J0IFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIHN5bnRheCBkZWNsYXJhdGlvbnNcbiAgICAgICAgICAgICAgICBcIlxcbnN5bnRheCBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBieSB0aGUgbm9ybWFsIHR5cGUgb2YgbGluZXNcbiAgICAgICAgICAgICAgICBcIlxcblxcblwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFuZ3VhZ2UgPT09IFwicHl0aG9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLy8gRmlyc3QsIHRyeSB0byBzcGxpdCBhbG9uZyBjbGFzcyBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxuY2xhc3MgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5kZWYgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cXHRkZWYgXCIsXG4gICAgICAgICAgICAgICAgLy8gTm93IHNwbGl0IGJ5IHRoZSBub3JtYWwgdHlwZSBvZiBsaW5lc1xuICAgICAgICAgICAgICAgIFwiXFxuXFxuXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cIixcbiAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYW5ndWFnZSA9PT0gXCJyc3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBzZWN0aW9uIHRpdGxlc1xuICAgICAgICAgICAgICAgIFwiXFxuPT09XFxuXCIsXG4gICAgICAgICAgICAgICAgXCJcXG4tLS1cXG5cIixcbiAgICAgICAgICAgICAgICBcIlxcbioqKlxcblwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIGRpcmVjdGl2ZSBtYXJrZXJzXG4gICAgICAgICAgICAgICAgXCJcXG4uLiBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBieSB0aGUgbm9ybWFsIHR5cGUgb2YgbGluZXNcbiAgICAgICAgICAgICAgICBcIlxcblxcblwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFuZ3VhZ2UgPT09IFwicnVieVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIG1ldGhvZCBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxuZGVmIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuY2xhc3MgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgY29udHJvbCBmbG93IHN0YXRlbWVudHNcbiAgICAgICAgICAgICAgICBcIlxcbmlmIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxudW5sZXNzIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxud2hpbGUgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5mb3IgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5kbyBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmJlZ2luIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxucmVzY3VlIFwiLFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGJ5IHRoZSBub3JtYWwgdHlwZSBvZiBsaW5lc1xuICAgICAgICAgICAgICAgIFwiXFxuXFxuXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cIixcbiAgICAgICAgICAgICAgICBcIiBcIixcbiAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYW5ndWFnZSA9PT0gXCJydXN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgZnVuY3Rpb24gZGVmaW5pdGlvbnNcbiAgICAgICAgICAgICAgICBcIlxcbmZuIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuY29uc3QgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5sZXQgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgY29udHJvbCBmbG93IHN0YXRlbWVudHNcbiAgICAgICAgICAgICAgICBcIlxcbmlmIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxud2hpbGUgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5mb3IgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5sb29wIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxubWF0Y2ggXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5jb25zdCBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBieSB0aGUgbm9ybWFsIHR5cGUgb2YgbGluZXNcbiAgICAgICAgICAgICAgICBcIlxcblxcblwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFuZ3VhZ2UgPT09IFwic2NhbGFcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBjbGFzcyBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxuY2xhc3MgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5vYmplY3QgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgbWV0aG9kIGRlZmluaXRpb25zXG4gICAgICAgICAgICAgICAgXCJcXG5kZWYgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG52YWwgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG52YXIgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgY29udHJvbCBmbG93IHN0YXRlbWVudHNcbiAgICAgICAgICAgICAgICBcIlxcbmlmIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuZm9yIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxud2hpbGUgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5tYXRjaCBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmNhc2UgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYnkgdGhlIG5vcm1hbCB0eXBlIG9mIGxpbmVzXG4gICAgICAgICAgICAgICAgXCJcXG5cXG5cIixcbiAgICAgICAgICAgICAgICBcIlxcblwiLFxuICAgICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhbmd1YWdlID09PSBcInN3aWZ0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgZnVuY3Rpb24gZGVmaW5pdGlvbnNcbiAgICAgICAgICAgICAgICBcIlxcbmZ1bmMgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgY2xhc3MgZGVmaW5pdGlvbnNcbiAgICAgICAgICAgICAgICBcIlxcbmNsYXNzIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuc3RydWN0IFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuZW51bSBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBjb250cm9sIGZsb3cgc3RhdGVtZW50c1xuICAgICAgICAgICAgICAgIFwiXFxuaWYgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5mb3IgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG53aGlsZSBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmRvIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuc3dpdGNoIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuY2FzZSBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBieSB0aGUgbm9ybWFsIHR5cGUgb2YgbGluZXNcbiAgICAgICAgICAgICAgICBcIlxcblxcblwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXCIsXG4gICAgICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFuZ3VhZ2UgPT09IFwibWFya2Rvd25cIikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCwgdHJ5IHRvIHNwbGl0IGFsb25nIE1hcmtkb3duIGhlYWRpbmdzIChzdGFydGluZyB3aXRoIGxldmVsIDIpXG4gICAgICAgICAgICAgICAgXCJcXG4jIyBcIixcbiAgICAgICAgICAgICAgICBcIlxcbiMjIyBcIixcbiAgICAgICAgICAgICAgICBcIlxcbiMjIyMgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG4jIyMjIyBcIixcbiAgICAgICAgICAgICAgICBcIlxcbiMjIyMjIyBcIixcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoZSBhbHRlcm5hdGl2ZSBzeW50YXggZm9yIGhlYWRpbmdzIChiZWxvdykgaXMgbm90IGhhbmRsZWQgaGVyZVxuICAgICAgICAgICAgICAgIC8vIEhlYWRpbmcgbGV2ZWwgMlxuICAgICAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgIC8vIEVuZCBvZiBjb2RlIGJsb2NrXG4gICAgICAgICAgICAgICAgXCJgYGBcXG5cXG5cIixcbiAgICAgICAgICAgICAgICAvLyBIb3Jpem9udGFsIGxpbmVzXG4gICAgICAgICAgICAgICAgXCJcXG5cXG4qKipcXG5cXG5cIixcbiAgICAgICAgICAgICAgICBcIlxcblxcbi0tLVxcblxcblwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXFxuX19fXFxuXFxuXCIsXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgc3BsaXR0ZXIgZG9lc24ndCBoYW5kbGUgaG9yaXpvbnRhbCBsaW5lcyBkZWZpbmVkXG4gICAgICAgICAgICAgICAgLy8gYnkgKnRocmVlIG9yIG1vcmUqIG9mICoqKiwgLS0tLCBvciBfX18sIGJ1dCB0aGlzIGlzIG5vdCBoYW5kbGVkXG4gICAgICAgICAgICAgICAgXCJcXG5cXG5cIixcbiAgICAgICAgICAgICAgICBcIlxcblwiLFxuICAgICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhbmd1YWdlID09PSBcImxhdGV4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLy8gRmlyc3QsIHRyeSB0byBzcGxpdCBhbG9uZyBMYXRleCBzZWN0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxuXFxcXGNoYXB0ZXJ7XCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cXFxcc2VjdGlvbntcIixcbiAgICAgICAgICAgICAgICBcIlxcblxcXFxzdWJzZWN0aW9ue1wiLFxuICAgICAgICAgICAgICAgIFwiXFxuXFxcXHN1YnN1YnNlY3Rpb257XCIsXG4gICAgICAgICAgICAgICAgLy8gTm93IHNwbGl0IGJ5IGVudmlyb25tZW50c1xuICAgICAgICAgICAgICAgIFwiXFxuXFxcXGJlZ2lue2VudW1lcmF0ZX1cIixcbiAgICAgICAgICAgICAgICBcIlxcblxcXFxiZWdpbntpdGVtaXplfVwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXFxcXGJlZ2lue2Rlc2NyaXB0aW9ufVwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXFxcXGJlZ2lue2xpc3R9XCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cXFxcYmVnaW57cXVvdGV9XCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cXFxcYmVnaW57cXVvdGF0aW9ufVwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXFxcXGJlZ2lue3ZlcnNlfVwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXFxcXGJlZ2lue3ZlcmJhdGltfVwiLFxuICAgICAgICAgICAgICAgIC8vIE5vdyBzcGxpdCBieSBtYXRoIGVudmlyb25tZW50c1xuICAgICAgICAgICAgICAgIFwiXFxuXFxcXGJlZ2lue2FsaWdufVwiLFxuICAgICAgICAgICAgICAgIFwiJCRcIixcbiAgICAgICAgICAgICAgICBcIiRcIixcbiAgICAgICAgICAgICAgICAvLyBOb3cgc3BsaXQgYnkgdGhlIG5vcm1hbCB0eXBlIG9mIGxpbmVzXG4gICAgICAgICAgICAgICAgXCJcXG5cXG5cIixcbiAgICAgICAgICAgICAgICBcIlxcblwiLFxuICAgICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhbmd1YWdlID09PSBcImh0bWxcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCwgdHJ5IHRvIHNwbGl0IGFsb25nIEhUTUwgdGFnc1xuICAgICAgICAgICAgICAgIFwiPGJvZHk+XCIsXG4gICAgICAgICAgICAgICAgXCI8ZGl2PlwiLFxuICAgICAgICAgICAgICAgIFwiPHA+XCIsXG4gICAgICAgICAgICAgICAgXCI8YnI+XCIsXG4gICAgICAgICAgICAgICAgXCI8bGk+XCIsXG4gICAgICAgICAgICAgICAgXCI8aDE+XCIsXG4gICAgICAgICAgICAgICAgXCI8aDI+XCIsXG4gICAgICAgICAgICAgICAgXCI8aDM+XCIsXG4gICAgICAgICAgICAgICAgXCI8aDQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8aDU+XCIsXG4gICAgICAgICAgICAgICAgXCI8aDY+XCIsXG4gICAgICAgICAgICAgICAgXCI8c3Bhbj5cIixcbiAgICAgICAgICAgICAgICBcIjx0YWJsZT5cIixcbiAgICAgICAgICAgICAgICBcIjx0cj5cIixcbiAgICAgICAgICAgICAgICBcIjx0ZD5cIixcbiAgICAgICAgICAgICAgICBcIjx0aD5cIixcbiAgICAgICAgICAgICAgICBcIjx1bD5cIixcbiAgICAgICAgICAgICAgICBcIjxvbD5cIixcbiAgICAgICAgICAgICAgICBcIjxoZWFkZXI+XCIsXG4gICAgICAgICAgICAgICAgXCI8Zm9vdGVyPlwiLFxuICAgICAgICAgICAgICAgIFwiPG5hdj5cIixcbiAgICAgICAgICAgICAgICAvLyBIZWFkXG4gICAgICAgICAgICAgICAgXCI8aGVhZD5cIixcbiAgICAgICAgICAgICAgICBcIjxzdHlsZT5cIixcbiAgICAgICAgICAgICAgICBcIjxzY3JpcHQ+XCIsXG4gICAgICAgICAgICAgICAgXCI8bWV0YT5cIixcbiAgICAgICAgICAgICAgICBcIjx0aXRsZT5cIixcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWwgdHlwZSBvZiBsaW5lc1xuICAgICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhbmd1YWdlID09PSBcInNvbFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGFsb25nIGNvbXBpbGVyIGluZm9ybWF0aW9ucyBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICAgIFwiXFxucHJhZ21hIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxudXNpbmcgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYWxvbmcgY29udHJhY3QgZGVmaW5pdGlvbnNcbiAgICAgICAgICAgICAgICBcIlxcbmNvbnRyYWN0IFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuaW50ZXJmYWNlIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxubGlicmFyeSBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBtZXRob2QgZGVmaW5pdGlvbnNcbiAgICAgICAgICAgICAgICBcIlxcbmNvbnN0cnVjdG9yIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxudHlwZSBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmZ1bmN0aW9uIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuZXZlbnQgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5tb2RpZmllciBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmVycm9yIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuc3RydWN0IFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuZW51bSBcIixcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhbG9uZyBjb250cm9sIGZsb3cgc3RhdGVtZW50c1xuICAgICAgICAgICAgICAgIFwiXFxuaWYgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG5mb3IgXCIsXG4gICAgICAgICAgICAgICAgXCJcXG53aGlsZSBcIixcbiAgICAgICAgICAgICAgICBcIlxcbmRvIHdoaWxlIFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuYXNzZW1ibHkgXCIsXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgYnkgdGhlIG5vcm1hbCB0eXBlIG9mIGxpbmVzXG4gICAgICAgICAgICAgICAgXCJcXG5cXG5cIixcbiAgICAgICAgICAgICAgICBcIlxcblwiLFxuICAgICAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMYW5ndWFnZSAke2xhbmd1YWdlfSBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBzcGxpdHRlciB3aGljaCBsb29rcyBhdCB0b2tlbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUb2tlblRleHRTcGxpdHRlciBleHRlbmRzIFRleHRTcGxpdHRlciB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlRva2VuVGV4dFNwbGl0dGVyXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbmNvZGluZ05hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWxsb3dlZFNwZWNpYWxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGlzYWxsb3dlZFNwZWNpYWxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9rZW5pemVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW5jb2RpbmdOYW1lID0gZmllbGRzPy5lbmNvZGluZ05hbWUgPz8gXCJncHQyXCI7XG4gICAgICAgIHRoaXMuYWxsb3dlZFNwZWNpYWwgPSBmaWVsZHM/LmFsbG93ZWRTcGVjaWFsID8/IFtdO1xuICAgICAgICB0aGlzLmRpc2FsbG93ZWRTcGVjaWFsID0gZmllbGRzPy5kaXNhbGxvd2VkU3BlY2lhbCA/PyBcImFsbFwiO1xuICAgIH1cbiAgICBhc3luYyBzcGxpdFRleHQodGV4dCkge1xuICAgICAgICBpZiAoIXRoaXMudG9rZW5pemVyKSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuaXplciA9IGF3YWl0IGdldEVuY29kaW5nKHRoaXMuZW5jb2RpbmdOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGxpdHMgPSBbXTtcbiAgICAgICAgY29uc3QgaW5wdXRfaWRzID0gdGhpcy50b2tlbml6ZXIuZW5jb2RlKHRleHQsIHRoaXMuYWxsb3dlZFNwZWNpYWwsIHRoaXMuZGlzYWxsb3dlZFNwZWNpYWwpO1xuICAgICAgICBsZXQgc3RhcnRfaWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKHN0YXJ0X2lkeCA8IGlucHV0X2lkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChzdGFydF9pZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRfaWR4IC09IHRoaXMuY2h1bmtPdmVybGFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZW5kX2lkeCA9IE1hdGgubWluKHN0YXJ0X2lkeCArIHRoaXMuY2h1bmtTaXplLCBpbnB1dF9pZHMubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rX2lkcyA9IGlucHV0X2lkcy5zbGljZShzdGFydF9pZHgsIGVuZF9pZHgpO1xuICAgICAgICAgICAgc3BsaXRzLnB1c2godGhpcy50b2tlbml6ZXIuZGVjb2RlKGNodW5rX2lkcykpO1xuICAgICAgICAgICAgc3RhcnRfaWR4ID0gZW5kX2lkeDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRzO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBNYXJrZG93blRleHRTcGxpdHRlciBleHRlbmRzIFJlY3Vyc2l2ZUNoYXJhY3RlclRleHRTcGxpdHRlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgIHNlcGFyYXRvcnM6IFJlY3Vyc2l2ZUNoYXJhY3RlclRleHRTcGxpdHRlci5nZXRTZXBhcmF0b3JzRm9yTGFuZ3VhZ2UoXCJtYXJrZG93blwiKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIExhdGV4VGV4dFNwbGl0dGVyIGV4dGVuZHMgUmVjdXJzaXZlQ2hhcmFjdGVyVGV4dFNwbGl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgc2VwYXJhdG9yczogUmVjdXJzaXZlQ2hhcmFjdGVyVGV4dFNwbGl0dGVyLmdldFNlcGFyYXRvcnNGb3JMYW5ndWFnZShcImxhdGV4XCIpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiRG9jdW1lbnQiLCJCYXNlRG9jdW1lbnRUcmFuc2Zvcm1lciIsImdldEVuY29kaW5nIiwiVGV4dFNwbGl0dGVyIiwiY29uc3RydWN0b3IiLCJmaWVsZHMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwiY2h1bmtTaXplIiwiY2h1bmtPdmVybGFwIiwia2VlcFNlcGFyYXRvciIsImxlbmd0aEZ1bmN0aW9uIiwidGV4dCIsImxlbmd0aCIsIkVycm9yIiwidHJhbnNmb3JtRG9jdW1lbnRzIiwiZG9jdW1lbnRzIiwiY2h1bmtIZWFkZXJPcHRpb25zIiwic3BsaXREb2N1bWVudHMiLCJzcGxpdE9uU2VwYXJhdG9yIiwic2VwYXJhdG9yIiwic3BsaXRzIiwicmVnZXhFc2NhcGVkU2VwYXJhdG9yIiwicmVwbGFjZSIsInNwbGl0IiwiUmVnRXhwIiwiZmlsdGVyIiwicyIsImNyZWF0ZURvY3VtZW50cyIsInRleHRzIiwibWV0YWRhdGFzIiwiX21ldGFkYXRhcyIsIkFycmF5IiwiZmlsbCIsImNodW5rSGVhZGVyIiwiY2h1bmtPdmVybGFwSGVhZGVyIiwiYXBwZW5kQ2h1bmtPdmVybGFwSGVhZGVyIiwiaSIsImxpbmVDb3VudGVySW5kZXgiLCJwcmV2Q2h1bmsiLCJpbmRleFByZXZDaHVuayIsImNodW5rIiwic3BsaXRUZXh0IiwicGFnZUNvbnRlbnQiLCJpbmRleENodW5rIiwiaW5kZXhPZiIsIm5ld0xpbmVzQmVmb3JlRmlyc3RDaHVuayIsIm51bWJlck9mTmV3TGluZXMiLCJpbmRleEVuZFByZXZDaHVuayIsIm51bWJlck9mSW50ZXJtZWRpYXRlTmV3TGluZXMiLCJuZXdMaW5lc0NvdW50IiwibG9jIiwibGluZXMiLCJmcm9tIiwidG8iLCJtZXRhZGF0YVdpdGhMaW5lc051bWJlciIsInB1c2giLCJtZXRhZGF0YSIsInN0YXJ0IiwiZW5kIiwidGV4dFNlY3Rpb24iLCJzbGljZSIsIm1hdGNoIiwic2VsZWN0ZWREb2N1bWVudHMiLCJkb2MiLCJ1bmRlZmluZWQiLCJtYXAiLCJqb2luRG9jcyIsImRvY3MiLCJqb2luIiwidHJpbSIsIm1lcmdlU3BsaXRzIiwiY3VycmVudERvYyIsInRvdGFsIiwiZCIsIl9sZW4iLCJjb25zb2xlIiwid2FybiIsInNoaWZ0IiwiQ2hhcmFjdGVyVGV4dFNwbGl0dGVyIiwibGNfbmFtZSIsIlN1cHBvcnRlZFRleHRTcGxpdHRlckxhbmd1YWdlcyIsIlJlY3Vyc2l2ZUNoYXJhY3RlclRleHRTcGxpdHRlciIsInNlcGFyYXRvcnMiLCJfc3BsaXRUZXh0IiwiZmluYWxDaHVua3MiLCJuZXdTZXBhcmF0b3JzIiwiaW5jbHVkZXMiLCJnb29kU3BsaXRzIiwiX3NlcGFyYXRvciIsIm1lcmdlZFRleHQiLCJvdGhlckluZm8iLCJmcm9tTGFuZ3VhZ2UiLCJsYW5ndWFnZSIsIm9wdGlvbnMiLCJnZXRTZXBhcmF0b3JzRm9yTGFuZ3VhZ2UiLCJUb2tlblRleHRTcGxpdHRlciIsImVuY29kaW5nTmFtZSIsImFsbG93ZWRTcGVjaWFsIiwiZGlzYWxsb3dlZFNwZWNpYWwiLCJ0b2tlbml6ZXIiLCJpbnB1dF9pZHMiLCJlbmNvZGUiLCJzdGFydF9pZHgiLCJlbmRfaWR4IiwiTWF0aCIsIm1pbiIsImNodW5rX2lkcyIsImRlY29kZSIsIk1hcmtkb3duVGV4dFNwbGl0dGVyIiwiTGF0ZXhUZXh0U3BsaXR0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langchain/dist/text_splitter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langchain/dist/util/document.js":
/*!******************************************************!*\
  !*** ./node_modules/langchain/dist/util/document.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatDocumentsAsString: () => (/* binding */ formatDocumentsAsString)\n/* harmony export */ });\n/**\n * Given a list of documents, this util formats their contents\n * into a string, separated by newlines.\n *\n * @param documents\n * @returns A string of the documents page content, separated by newlines.\n */ const formatDocumentsAsString = (documents)=>documents.map((doc)=>doc.pageContent).join(\"\\n\\n\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvdXRpbC9kb2N1bWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7OztDQU1DLEdBQ00sTUFBTUEsMEJBQTBCLENBQUNDLFlBQWNBLFVBQVVDLEdBQUcsQ0FBQyxDQUFDQyxNQUFRQSxJQUFJQyxXQUFXLEVBQUVDLElBQUksQ0FBQyxRQUFRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3luY2NoYXQvLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvdXRpbC9kb2N1bWVudC5qcz9hZmMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR2l2ZW4gYSBsaXN0IG9mIGRvY3VtZW50cywgdGhpcyB1dGlsIGZvcm1hdHMgdGhlaXIgY29udGVudHNcbiAqIGludG8gYSBzdHJpbmcsIHNlcGFyYXRlZCBieSBuZXdsaW5lcy5cbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnRzXG4gKiBAcmV0dXJucyBBIHN0cmluZyBvZiB0aGUgZG9jdW1lbnRzIHBhZ2UgY29udGVudCwgc2VwYXJhdGVkIGJ5IG5ld2xpbmVzLlxuICovXG5leHBvcnQgY29uc3QgZm9ybWF0RG9jdW1lbnRzQXNTdHJpbmcgPSAoZG9jdW1lbnRzKSA9PiBkb2N1bWVudHMubWFwKChkb2MpID0+IGRvYy5wYWdlQ29udGVudCkuam9pbihcIlxcblxcblwiKTtcbiJdLCJuYW1lcyI6WyJmb3JtYXREb2N1bWVudHNBc1N0cmluZyIsImRvY3VtZW50cyIsIm1hcCIsImRvYyIsInBhZ2VDb250ZW50Iiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langchain/dist/util/document.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langchain/document_loaders/fs/pdf.js":
/*!***********************************************************!*\
  !*** ./node_modules/langchain/document_loaders/fs/pdf.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PDFLoader: () => (/* reexport safe */ _dist_document_loaders_fs_pdf_js__WEBPACK_IMPORTED_MODULE_0__.PDFLoader)\n/* harmony export */ });\n/* harmony import */ var _dist_document_loaders_fs_pdf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/document_loaders/fs/pdf.js */ \"(rsc)/./node_modules/langchain/dist/document_loaders/fs/pdf.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2RvY3VtZW50X2xvYWRlcnMvZnMvcGRmLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3luY2NoYXQvLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2RvY3VtZW50X2xvYWRlcnMvZnMvcGRmLmpzP2ExMzIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi4vLi4vZGlzdC9kb2N1bWVudF9sb2FkZXJzL2ZzL3BkZi5qcyciXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langchain/document_loaders/fs/pdf.js\n");

/***/ })

};
;