"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(rsc)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIStream: () => (/* binding */ AIStream),\n/* harmony export */   AWSBedrockAnthropicStream: () => (/* binding */ AWSBedrockAnthropicStream),\n/* harmony export */   AWSBedrockCohereStream: () => (/* binding */ AWSBedrockCohereStream),\n/* harmony export */   AWSBedrockLlama2Stream: () => (/* binding */ AWSBedrockLlama2Stream),\n/* harmony export */   AWSBedrockStream: () => (/* binding */ AWSBedrockStream),\n/* harmony export */   AnthropicStream: () => (/* binding */ AnthropicStream),\n/* harmony export */   COMPLEX_HEADER: () => (/* binding */ COMPLEX_HEADER),\n/* harmony export */   CohereStream: () => (/* binding */ CohereStream),\n/* harmony export */   GoogleGenerativeAIStream: () => (/* binding */ GoogleGenerativeAIStream),\n/* harmony export */   HuggingFaceStream: () => (/* binding */ HuggingFaceStream),\n/* harmony export */   LangChainStream: () => (/* binding */ LangChainStream),\n/* harmony export */   OpenAIStream: () => (/* binding */ OpenAIStream),\n/* harmony export */   ReplicateStream: () => (/* binding */ ReplicateStream),\n/* harmony export */   StreamingTextResponse: () => (/* binding */ StreamingTextResponse),\n/* harmony export */   createCallbacksTransformer: () => (/* binding */ createCallbacksTransformer),\n/* harmony export */   createChunkDecoder: () => (/* binding */ createChunkDecoder),\n/* harmony export */   createEventStreamTransformer: () => (/* binding */ createEventStreamTransformer),\n/* harmony export */   createStreamDataTransformer: () => (/* binding */ createStreamDataTransformer),\n/* harmony export */   experimental_AssistantResponse: () => (/* binding */ experimental_AssistantResponse),\n/* harmony export */   experimental_StreamData: () => (/* binding */ experimental_StreamData),\n/* harmony export */   experimental_StreamingReactResponse: () => (/* binding */ experimental_StreamingReactResponse),\n/* harmony export */   isStreamStringEqualToType: () => (/* binding */ isStreamStringEqualToType),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   readableFromAsyncIterable: () => (/* binding */ readableFromAsyncIterable),\n/* harmony export */   streamToResponse: () => (/* binding */ streamToResponse),\n/* harmony export */   trimStartOfStreamHelper: () => (/* binding */ trimStartOfStreamHelper)\n/* harmony export */ });\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nanoid/non-secure */ \"(rsc)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.js\");\n// shared/utils.ts\n\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>{\n            tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\";\n        })) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallStreamPart,\n    messageAnnotationsStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\nfunction formatStreamPart(type, value) {\n    const streamPart = streamParts.find((part)=>part.name === type);\n    if (!streamPart) {\n        throw new Error(`Invalid stream part type: ${type}`);\n    }\n    return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n// shared/utils.ts\nvar nanoid = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\nvar isStreamStringEqualToType = (type, value)=>value.startsWith(`${StreamStringPrefixes[type]}:`) && value.endsWith(\"\\n\");\nvar COMPLEX_HEADER = \"X-Experimental-Stream-Data\";\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n    const textDecoder = new TextDecoder();\n    let eventSourceParser;\n    return new TransformStream({\n        async start (controller) {\n            eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_1__.createParser)((event)=>{\n                if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n                // @see https://replicate.com/docs/streaming\n                event.event === \"done\") {\n                    controller.terminate();\n                    return;\n                }\n                if (\"data\" in event) {\n                    const parsedMessage = customParser ? customParser(event.data, {\n                        event: event.event\n                    }) : event.data;\n                    if (parsedMessage) controller.enqueue(parsedMessage);\n                }\n            });\n        },\n        transform (chunk) {\n            eventSourceParser.feed(textDecoder.decode(chunk));\n        }\n    });\n}\nfunction createCallbacksTransformer(cb) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    const callbacks = cb || {};\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            controller.enqueue(textEncoder.encode(message));\n            aggregatedResponse += message;\n            if (callbacks.onToken) await callbacks.onToken(message);\n        },\n        async flush () {\n            const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal && !isOpenAICallbacks) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n    return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n    let isStreamStart = true;\n    return (text)=>{\n        if (isStreamStart) {\n            text = text.trimStart();\n            if (text) isStreamStart = false;\n        }\n        return text;\n    };\n}\nfunction AIStream(response, customParser, callbacks) {\n    if (!response.ok) {\n        if (response.body) {\n            const reader = response.body.getReader();\n            return new ReadableStream({\n                async start (controller) {\n                    const { done, value } = await reader.read();\n                    if (!done) {\n                        const errorText = new TextDecoder().decode(value);\n                        controller.error(new Error(`Response error: ${errorText}`));\n                    }\n                }\n            });\n        } else {\n            return new ReadableStream({\n                start (controller) {\n                    controller.error(new Error(\"Response error: No response body\"));\n                }\n            });\n        }\n    }\n    const responseBodyStream = response.body || createEmptyReadableStream();\n    return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n    return new ReadableStream({\n        start (controller) {\n            controller.close();\n        }\n    });\n}\nfunction readableFromAsyncIterable(iterable) {\n    let it = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await it.next();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        async cancel (reason) {\n            var _a;\n            await ((_a = it.return) == null ? void 0 : _a.call(it, reason));\n        }\n    });\n}\n// streams/stream-data.ts\nvar experimental_StreamData = class {\n    constructor(){\n        this.encoder = new TextEncoder();\n        this.controller = null;\n        // closing the stream is synchronous, but we want to return a promise\n        // in case we're doing async work\n        this.isClosedPromise = null;\n        this.isClosedPromiseResolver = void 0;\n        this.isClosed = false;\n        // array to store appended data\n        this.data = [];\n        this.messageAnnotations = [];\n        this.isClosedPromise = new Promise((resolve)=>{\n            this.isClosedPromiseResolver = resolve;\n        });\n        const self = this;\n        this.stream = new TransformStream({\n            start: async (controller)=>{\n                self.controller = controller;\n            },\n            transform: async (chunk, controller)=>{\n                if (self.data.length > 0) {\n                    const encodedData = self.encoder.encode(formatStreamPart(\"data\", self.data));\n                    self.data = [];\n                    controller.enqueue(encodedData);\n                }\n                if (self.messageAnnotations.length) {\n                    const encodedMessageAnnotations = self.encoder.encode(formatStreamPart(\"message_annotations\", self.messageAnnotations));\n                    self.messageAnnotations = [];\n                    controller.enqueue(encodedMessageAnnotations);\n                }\n                controller.enqueue(chunk);\n            },\n            async flush (controller) {\n                const warningTimeout =  true ? setTimeout(()=>{\n                    console.warn(\"The data stream is hanging. Did you forget to close it with `data.close()`?\");\n                }, 3e3) : 0;\n                await self.isClosedPromise;\n                if (warningTimeout !== null) {\n                    clearTimeout(warningTimeout);\n                }\n                if (self.data.length) {\n                    const encodedData = self.encoder.encode(formatStreamPart(\"data\", self.data));\n                    controller.enqueue(encodedData);\n                }\n                if (self.messageAnnotations.length) {\n                    const encodedData = self.encoder.encode(formatStreamPart(\"message_annotations\", self.messageAnnotations));\n                    controller.enqueue(encodedData);\n                }\n            }\n        });\n    }\n    async close() {\n        var _a;\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        (_a = this.isClosedPromiseResolver) == null ? void 0 : _a.call(this);\n        this.isClosed = true;\n    }\n    append(value) {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        this.data.push(value);\n    }\n    appendMessageAnnotation(value) {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        this.messageAnnotations.push(value);\n    }\n};\nfunction createStreamDataTransformer(experimental_streamData) {\n    if (!experimental_streamData) {\n        return new TransformStream({\n            transform: async (chunk, controller)=>{\n                controller.enqueue(chunk);\n            }\n        });\n    }\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform: async (chunk, controller)=>{\n            const message = decoder.decode(chunk);\n            controller.enqueue(encoder.encode(formatStreamPart(\"text\", message)));\n        }\n    });\n}\n// streams/anthropic-stream.ts\nfunction parseAnthropicStream() {\n    let previous = \"\";\n    return (data)=>{\n        const json = JSON.parse(data);\n        if (\"error\" in json) {\n            throw new Error(`${json.error.type}: ${json.error.message}`);\n        }\n        if (!(\"completion\" in json)) {\n            return;\n        }\n        const text = json.completion;\n        if (!previous || text.length > previous.length && text.startsWith(previous)) {\n            const delta = text.slice(previous.length);\n            previous = text;\n            return delta;\n        }\n        return text;\n    };\n}\nasync function* streamable(stream) {\n    for await (const chunk of stream){\n        if (\"completion\" in chunk) {\n            const text = chunk.completion;\n            if (text) yield text;\n        } else if (\"delta\" in chunk) {\n            const { delta } = chunk;\n            if (\"text\" in delta) {\n                const text = delta.text;\n                if (text) yield text;\n            }\n        }\n    }\n}\nfunction AnthropicStream(res, cb) {\n    if (Symbol.asyncIterator in res) {\n        return readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData));\n    } else {\n        return AIStream(res, parseAnthropicStream(), cb).pipeThrough(createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData));\n    }\n}\n// streams/assistant-response.ts\nfunction experimental_AssistantResponse({ threadId, messageId }, process2) {\n    const stream = new ReadableStream({\n        async start (controller) {\n            var _a;\n            const textEncoder = new TextEncoder();\n            const sendMessage = (message)=>{\n                controller.enqueue(textEncoder.encode(formatStreamPart(\"assistant_message\", message)));\n            };\n            const sendDataMessage = (message)=>{\n                controller.enqueue(textEncoder.encode(formatStreamPart(\"data_message\", message)));\n            };\n            const sendError = (errorMessage)=>{\n                controller.enqueue(textEncoder.encode(formatStreamPart(\"error\", errorMessage)));\n            };\n            controller.enqueue(textEncoder.encode(formatStreamPart(\"assistant_control_data\", {\n                threadId,\n                messageId\n            })));\n            try {\n                await process2({\n                    threadId,\n                    messageId,\n                    sendMessage,\n                    sendDataMessage\n                });\n            } catch (error) {\n                sendError((_a = error.message) != null ? _a : `${error}`);\n            } finally{\n                controller.close();\n            }\n        },\n        pull (controller) {},\n        cancel () {}\n    });\n    return new Response(stream, {\n        status: 200,\n        headers: {\n            \"Content-Type\": \"text/plain; charset=utf-8\"\n        }\n    });\n}\n// streams/aws-bedrock-stream.ts\nasync function* asDeltaIterable(response, extractTextDeltaFromChunk) {\n    var _a, _b;\n    const decoder = new TextDecoder();\n    for await (const chunk of (_a = response.body) != null ? _a : []){\n        const bytes = (_b = chunk.chunk) == null ? void 0 : _b.bytes;\n        if (bytes != null) {\n            const chunkText = decoder.decode(bytes);\n            const chunkJSON = JSON.parse(chunkText);\n            const delta = extractTextDeltaFromChunk(chunkJSON);\n            if (delta != null) {\n                yield delta;\n            }\n        }\n    }\n}\nfunction AWSBedrockAnthropicStream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, (chunk)=>chunk.completion);\n}\nfunction AWSBedrockCohereStream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, // As of 2023-11-17, Bedrock does not support streaming for Cohere,\n    // so we take the full generation:\n    (chunk)=>{\n        var _a, _b;\n        return (_b = (_a = chunk.generations) == null ? void 0 : _a[0]) == null ? void 0 : _b.text;\n    });\n}\nfunction AWSBedrockLlama2Stream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, (chunk)=>chunk.generation);\n}\nfunction AWSBedrockStream(response, callbacks, extractTextDeltaFromChunk) {\n    return readableFromAsyncIterable(asDeltaIterable(response, extractTextDeltaFromChunk)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData));\n}\n// streams/cohere-stream.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nasync function processLines(lines, controller) {\n    for (const line of lines){\n        const { text, is_finished } = JSON.parse(line);\n        if (!is_finished) {\n            controller.enqueue(text);\n        }\n    }\n}\nasync function readAndProcessLines(reader, controller) {\n    let segment = \"\";\n    while(true){\n        const { value: chunk, done } = await reader.read();\n        if (done) {\n            break;\n        }\n        segment += utf8Decoder.decode(chunk, {\n            stream: true\n        });\n        const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n        segment = linesArray.pop() || \"\";\n        await processLines(linesArray, controller);\n    }\n    if (segment) {\n        const linesArray = [\n            segment\n        ];\n        await processLines(linesArray, controller);\n    }\n    controller.close();\n}\nfunction createParser2(res) {\n    var _a;\n    const reader = (_a = res.body) == null ? void 0 : _a.getReader();\n    return new ReadableStream({\n        async start (controller) {\n            if (!reader) {\n                controller.close();\n                return;\n            }\n            await readAndProcessLines(reader, controller);\n        }\n    });\n}\nasync function* streamable2(stream) {\n    for await (const chunk of stream){\n        if (chunk.eventType === \"text-generation\") {\n            const text = chunk.text;\n            if (text) yield text;\n        }\n    }\n}\nfunction CohereStream(reader, callbacks) {\n    if (Symbol.asyncIterator in reader) {\n        return readableFromAsyncIterable(streamable2(reader)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData));\n    } else {\n        return createParser2(reader).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData));\n    }\n}\n// streams/google-generative-ai-stream.ts\nasync function* streamable3(response) {\n    var _a, _b, _c;\n    for await (const chunk of response.stream){\n        const parts = (_c = (_b = (_a = chunk.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts;\n        if (parts === void 0) {\n            continue;\n        }\n        const firstPart = parts[0];\n        if (typeof firstPart.text === \"string\") {\n            yield firstPart.text;\n        }\n    }\n}\nfunction GoogleGenerativeAIStream(response, cb) {\n    return readableFromAsyncIterable(streamable3(response)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData));\n}\n// streams/huggingface-stream.ts\nfunction createParser3(res) {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    return new ReadableStream({\n        async pull (controller) {\n            var _a, _b;\n            const { value, done } = await res.next();\n            if (done) {\n                controller.close();\n                return;\n            }\n            const text = trimStartOfStream((_b = (_a = value.token) == null ? void 0 : _a.text) != null ? _b : \"\");\n            if (!text) return;\n            if (value.generated_text != null && value.generated_text.length > 0) {\n                return;\n            }\n            if (text === \"</s>\" || text === \"<|endoftext|>\" || text === \"<|end|>\") {\n                return;\n            }\n            controller.enqueue(text);\n        }\n    });\n}\nfunction HuggingFaceStream(res, callbacks) {\n    return createParser3(res).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData));\n}\n// streams/langchain-stream.ts\nfunction LangChainStream(callbacks) {\n    const stream = new TransformStream();\n    const writer = stream.writable.getWriter();\n    const runs = /* @__PURE__ */ new Set();\n    const handleError = async (e, runId)=>{\n        runs.delete(runId);\n        await writer.ready;\n        await writer.abort(e);\n    };\n    const handleStart = async (runId)=>{\n        runs.add(runId);\n    };\n    const handleEnd = async (runId)=>{\n        runs.delete(runId);\n        if (runs.size === 0) {\n            await writer.ready;\n            await writer.close();\n        }\n    };\n    return {\n        stream: stream.readable.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData)),\n        writer,\n        handlers: {\n            handleLLMNewToken: async (token)=>{\n                await writer.ready;\n                await writer.write(token);\n            },\n            handleLLMStart: async (_llm, _prompts, runId)=>{\n                handleStart(runId);\n            },\n            handleLLMEnd: async (_output, runId)=>{\n                await handleEnd(runId);\n            },\n            handleLLMError: async (e, runId)=>{\n                await handleError(e, runId);\n            },\n            handleChainStart: async (_chain, _inputs, runId)=>{\n                handleStart(runId);\n            },\n            handleChainEnd: async (_outputs, runId)=>{\n                await handleEnd(runId);\n            },\n            handleChainError: async (e, runId)=>{\n                await handleError(e, runId);\n            },\n            handleToolStart: async (_tool, _input, runId)=>{\n                handleStart(runId);\n            },\n            handleToolEnd: async (_output, runId)=>{\n                await handleEnd(runId);\n            },\n            handleToolError: async (e, runId)=>{\n                await handleError(e, runId);\n            }\n        }\n    };\n}\n// streams/openai-stream.ts\nfunction parseOpenAIStream() {\n    const extract = chunkToText();\n    return (data)=>extract(JSON.parse(data));\n}\nasync function* streamable4(stream) {\n    const extract = chunkToText();\n    for await (let chunk of stream){\n        if (\"promptFilterResults\" in chunk) {\n            chunk = {\n                id: chunk.id,\n                created: chunk.created.getDate(),\n                object: chunk.object,\n                // not exposed by Azure API\n                model: chunk.model,\n                // not exposed by Azure API\n                choices: chunk.choices.map((choice)=>{\n                    var _a, _b, _c, _d, _e, _f, _g;\n                    return {\n                        delta: {\n                            content: (_a = choice.delta) == null ? void 0 : _a.content,\n                            function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n                            role: (_c = choice.delta) == null ? void 0 : _c.role,\n                            tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index)=>({\n                                    index,\n                                    id: toolCall.id,\n                                    function: toolCall.function,\n                                    type: toolCall.type\n                                })) : void 0\n                        },\n                        finish_reason: choice.finishReason,\n                        index: choice.index\n                    };\n                })\n            };\n        }\n        const text = extract(chunk);\n        if (text) yield text;\n    }\n}\nfunction chunkToText() {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    let isFunctionStreamingIn;\n    return (json)=>{\n        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;\n        if (isChatCompletionChunk(json)) {\n            const delta = (_a = json.choices[0]) == null ? void 0 : _a.delta;\n            if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n                isFunctionStreamingIn = true;\n                return `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`;\n            } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n                isFunctionStreamingIn = true;\n                const toolCall = delta.tool_calls[0];\n                if (toolCall.index === 0) {\n                    return `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`;\n                } else {\n                    return `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`;\n                }\n            } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n                return cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments);\n            } else if ((_k = (_j = delta.tool_calls) == null ? void 0 : _j[0].function) == null ? void 0 : _k.arguments) {\n                return cleanupArguments((_n = (_m = (_l = delta.tool_calls) == null ? void 0 : _l[0]) == null ? void 0 : _m.function) == null ? void 0 : _n.arguments);\n            } else if (isFunctionStreamingIn && (((_o = json.choices[0]) == null ? void 0 : _o.finish_reason) === \"function_call\" || ((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"stop\")) {\n                isFunctionStreamingIn = false;\n                return '\"}}';\n            } else if (isFunctionStreamingIn && ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"tool_calls\") {\n                isFunctionStreamingIn = false;\n                return '\"}}]}';\n            }\n        }\n        const text = trimStartOfStream(isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\");\n        return text;\n    };\n    function cleanupArguments(argumentChunk) {\n        let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n        return `${escapedPartialJson}`;\n    }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction isChatCompletionChunk(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n    const cb = callbacks;\n    let stream;\n    if (Symbol.asyncIterator in res) {\n        stream = readableFromAsyncIterable(streamable4(res)).pipeThrough(createCallbacksTransformer((cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        }));\n    } else {\n        stream = AIStream(res, parseOpenAIStream(), (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        });\n    }\n    if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n        const functionCallTransformer = createFunctionCallTransformer(cb);\n        return stream.pipeThrough(functionCallTransformer);\n    } else {\n        return stream.pipeThrough(createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData));\n    }\n}\nfunction createFunctionCallTransformer(callbacks) {\n    const textEncoder = new TextEncoder();\n    let isFirstChunk = true;\n    let aggregatedResponse = \"\";\n    let aggregatedFinalCompletionResponse = \"\";\n    let isFunctionStreamingIn = false;\n    let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n    const isComplexMode = callbacks == null ? void 0 : callbacks.experimental_streamData;\n    const decode = createChunkDecoder();\n    return new TransformStream({\n        async transform (chunk, controller) {\n            const message = decode(chunk);\n            aggregatedFinalCompletionResponse += message;\n            const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n            if (shouldHandleAsFunction) {\n                isFunctionStreamingIn = true;\n                aggregatedResponse += message;\n                isFirstChunk = false;\n                return;\n            }\n            if (!isFunctionStreamingIn) {\n                controller.enqueue(isComplexMode ? textEncoder.encode(formatStreamPart(\"text\", message)) : chunk);\n                return;\n            } else {\n                aggregatedResponse += message;\n            }\n        },\n        async flush (controller) {\n            try {\n                if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n                    isFunctionStreamingIn = false;\n                    const payload = JSON.parse(aggregatedResponse);\n                    let newFunctionCallMessages = [\n                        ...functionCallMessages\n                    ];\n                    let functionResponse = void 0;\n                    if (callbacks.experimental_onFunctionCall) {\n                        if (payload.function_call === void 0) {\n                            console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        }\n                        const argumentsPayload = JSON.parse(payload.function_call.arguments);\n                        functionResponse = await callbacks.experimental_onFunctionCall({\n                            name: payload.function_call.name,\n                            arguments: argumentsPayload\n                        }, (result)=>{\n                            newFunctionCallMessages = [\n                                ...functionCallMessages,\n                                {\n                                    role: \"assistant\",\n                                    content: \"\",\n                                    function_call: payload.function_call\n                                },\n                                {\n                                    role: \"function\",\n                                    name: payload.function_call.name,\n                                    content: JSON.stringify(result)\n                                }\n                            ];\n                            return newFunctionCallMessages;\n                        });\n                    }\n                    if (callbacks.experimental_onToolCall) {\n                        const toolCalls = {\n                            tools: []\n                        };\n                        for (const tool of payload.tool_calls){\n                            toolCalls.tools.push({\n                                id: tool.id,\n                                type: \"function\",\n                                func: {\n                                    name: tool.function.name,\n                                    arguments: tool.function.arguments\n                                }\n                            });\n                        }\n                        let responseIndex = 0;\n                        try {\n                            functionResponse = await callbacks.experimental_onToolCall(toolCalls, (result)=>{\n                                if (result) {\n                                    const { tool_call_id, function_name, tool_call_result } = result;\n                                    newFunctionCallMessages = [\n                                        ...newFunctionCallMessages,\n                                        // Only append the assistant message if it's the first response\n                                        ...responseIndex === 0 ? [\n                                            {\n                                                role: \"assistant\",\n                                                content: \"\",\n                                                tool_calls: payload.tool_calls.map((tc)=>({\n                                                        id: tc.id,\n                                                        type: \"function\",\n                                                        function: {\n                                                            name: tc.function.name,\n                                                            // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                                            arguments: JSON.stringify(tc.function.arguments)\n                                                        }\n                                                    }))\n                                            }\n                                        ] : [],\n                                        // Append the function call result message\n                                        {\n                                            role: \"tool\",\n                                            tool_call_id,\n                                            name: function_name,\n                                            content: JSON.stringify(tool_call_result)\n                                        }\n                                    ];\n                                    responseIndex++;\n                                }\n                                return newFunctionCallMessages;\n                            });\n                        } catch (e) {\n                            console.error(\"Error calling experimental_onToolCall:\", e);\n                        }\n                    }\n                    if (!functionResponse) {\n                        controller.enqueue(textEncoder.encode(isComplexMode ? formatStreamPart(payload.function_call ? \"function_call\" : \"tool_calls\", // parse to prevent double-encoding:\n                        JSON.parse(aggregatedResponse)) : aggregatedResponse));\n                        return;\n                    } else if (typeof functionResponse === \"string\") {\n                        controller.enqueue(isComplexMode ? textEncoder.encode(formatStreamPart(\"text\", functionResponse)) : textEncoder.encode(functionResponse));\n                        return;\n                    }\n                    const filteredCallbacks = {\n                        ...callbacks,\n                        onStart: void 0\n                    };\n                    callbacks.onFinal = void 0;\n                    const openAIStream = OpenAIStream(functionResponse, {\n                        ...filteredCallbacks,\n                        [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n                    });\n                    const reader = openAIStream.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        controller.enqueue(value);\n                    }\n                }\n            } finally{\n                if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n                    await callbacks.onFinal(aggregatedFinalCompletionResponse);\n                }\n            }\n        }\n    });\n}\n// streams/replicate-stream.ts\nasync function ReplicateStream(res, cb, options) {\n    var _a;\n    const url = (_a = res.urls) == null ? void 0 : _a.stream;\n    if (!url) {\n        if (res.error) throw new Error(res.error);\n        else throw new Error(\"Missing stream URL in Replicate response\");\n    }\n    const eventStream = await fetch(url, {\n        method: \"GET\",\n        headers: {\n            Accept: \"text/event-stream\",\n            ...options == null ? void 0 : options.headers\n        }\n    });\n    return AIStream(eventStream, void 0, cb).pipeThrough(createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData));\n}\n// shared/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n    const concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks){\n        concatenatedChunks.set(chunk, offset);\n        offset += chunk.length;\n    }\n    chunks.length = 0;\n    return concatenatedChunks;\n}\nasync function* readDataStream(reader, { isAborted } = {}) {\n    const decoder = new TextDecoder();\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        const concatenatedChunks = concatChunks(chunks, totalLength);\n        totalLength = 0;\n        const streamParts2 = decoder.decode(concatenatedChunks, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\").map(parseStreamPart);\n        for (const streamPart of streamParts2){\n            yield streamPart;\n        }\n        if (isAborted == null ? void 0 : isAborted()) {\n            reader.cancel();\n            break;\n        }\n    }\n}\n// shared/parse-complex-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n    if (!message || !annotations || !annotations.length) return message;\n    return {\n        ...message,\n        annotations: [\n            ...annotations\n        ]\n    };\n}\nasync function parseComplexResponse({ reader, abortControllerRef, update, onFinish, generateId = nanoid, getCurrentDate = ()=>/* @__PURE__ */ new Date() }) {\n    const createdAt = getCurrentDate();\n    const prefixMap = {\n        data: []\n    };\n    let message_annotations = void 0;\n    for await (const { type, value } of readDataStream(reader, {\n        isAborted: ()=>(abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n    })){\n        if (type === \"text\") {\n            if (prefixMap[\"text\"]) {\n                prefixMap[\"text\"] = {\n                    ...prefixMap[\"text\"],\n                    content: (prefixMap[\"text\"].content || \"\") + value\n                };\n            } else {\n                prefixMap[\"text\"] = {\n                    id: generateId(),\n                    role: \"assistant\",\n                    content: value,\n                    createdAt\n                };\n            }\n        }\n        let functionCallMessage = null;\n        if (type === \"function_call\") {\n            prefixMap[\"function_call\"] = {\n                id: generateId(),\n                role: \"assistant\",\n                content: \"\",\n                function_call: value.function_call,\n                name: value.function_call.name,\n                createdAt\n            };\n            functionCallMessage = prefixMap[\"function_call\"];\n        }\n        let toolCallMessage = null;\n        if (type === \"tool_calls\") {\n            prefixMap[\"tool_calls\"] = {\n                id: generateId(),\n                role: \"assistant\",\n                content: \"\",\n                tool_calls: value.tool_calls,\n                createdAt\n            };\n            toolCallMessage = prefixMap[\"tool_calls\"];\n        }\n        if (type === \"data\") {\n            prefixMap[\"data\"].push(...value);\n        }\n        let responseMessage = prefixMap[\"text\"];\n        if (type === \"message_annotations\") {\n            if (!message_annotations) {\n                message_annotations = [\n                    ...value\n                ];\n            } else {\n                message_annotations.push(...value);\n            }\n            functionCallMessage = assignAnnotationsToMessage(prefixMap[\"function_call\"], message_annotations);\n            toolCallMessage = assignAnnotationsToMessage(prefixMap[\"tool_calls\"], message_annotations);\n            responseMessage = assignAnnotationsToMessage(prefixMap[\"text\"], message_annotations);\n        }\n        if (message_annotations == null ? void 0 : message_annotations.length) {\n            const messagePrefixKeys = [\n                \"text\",\n                \"function_call\",\n                \"tool_calls\"\n            ];\n            messagePrefixKeys.forEach((key)=>{\n                if (prefixMap[key]) {\n                    prefixMap[key].annotations = [\n                        ...message_annotations\n                    ];\n                }\n            });\n        }\n        const merged = [\n            functionCallMessage,\n            toolCallMessage,\n            responseMessage\n        ].filter(Boolean).map((message)=>({\n                ...assignAnnotationsToMessage(message, message_annotations)\n            }));\n        update(merged, [\n            ...prefixMap[\"data\"]\n        ]);\n    }\n    onFinish == null ? void 0 : onFinish(prefixMap);\n    return {\n        messages: [\n            prefixMap.text,\n            prefixMap.function_call,\n            prefixMap.tool_calls\n        ].filter(Boolean),\n        data: prefixMap.data\n    };\n}\n// streams/streaming-react-response.ts\nvar experimental_StreamingReactResponse = class {\n    constructor(res, options){\n        var _a;\n        let resolveFunc = ()=>{};\n        let next = new Promise((resolve)=>{\n            resolveFunc = resolve;\n        });\n        if (options == null ? void 0 : options.data) {\n            const processedStream = res.pipeThrough(options.data.stream);\n            let lastPayload = void 0;\n            parseComplexResponse({\n                reader: processedStream.getReader(),\n                update: (merged, data)=>{\n                    var _a2, _b, _c;\n                    const content2 = (_b = (_a2 = merged[0]) == null ? void 0 : _a2.content) != null ? _b : \"\";\n                    const ui = ((_c = options == null ? void 0 : options.ui) == null ? void 0 : _c.call(options, {\n                        content: content2,\n                        data\n                    })) || content2;\n                    const payload = {\n                        ui,\n                        content: content2\n                    };\n                    const resolvePrevious = resolveFunc;\n                    const nextRow = new Promise((resolve)=>{\n                        resolveFunc = resolve;\n                    });\n                    resolvePrevious({\n                        next: nextRow,\n                        ...payload\n                    });\n                    lastPayload = payload;\n                },\n                generateId: (_a = options.generateId) != null ? _a : nanoid,\n                onFinish: ()=>{\n                    if (lastPayload !== void 0) {\n                        resolveFunc({\n                            next: null,\n                            ...lastPayload\n                        });\n                    }\n                }\n            });\n            return next;\n        }\n        let content = \"\";\n        const decode = createChunkDecoder();\n        const reader = res.getReader();\n        async function readChunk() {\n            var _a2;\n            const { done, value } = await reader.read();\n            if (!done) {\n                content += decode(value);\n            }\n            const ui = ((_a2 = options == null ? void 0 : options.ui) == null ? void 0 : _a2.call(options, {\n                content\n            })) || content;\n            const payload = {\n                ui,\n                content\n            };\n            const resolvePrevious = resolveFunc;\n            const nextRow = done ? null : new Promise((resolve)=>{\n                resolveFunc = resolve;\n            });\n            resolvePrevious({\n                next: nextRow,\n                ...payload\n            });\n            if (done) {\n                return;\n            }\n            await readChunk();\n        }\n        readChunk();\n        return next;\n    }\n};\n// streams/streaming-text-response.ts\nvar StreamingTextResponse = class extends Response {\n    constructor(res, init, data){\n        let processedStream = res;\n        if (data) {\n            processedStream = res.pipeThrough(data.stream);\n        }\n        super(processedStream, {\n            ...init,\n            status: 200,\n            headers: {\n                \"Content-Type\": \"text/plain; charset=utf-8\",\n                [COMPLEX_HEADER]: data ? \"true\" : \"false\",\n                ...init == null ? void 0 : init.headers\n            }\n        });\n    }\n};\nfunction streamToResponse(res, response, init) {\n    response.writeHead((init == null ? void 0 : init.status) || 200, {\n        \"Content-Type\": \"text/plain; charset=utf-8\",\n        ...init == null ? void 0 : init.headers\n    });\n    const reader = res.getReader();\n    function read() {\n        reader.read().then(({ done, value })=>{\n            if (done) {\n                response.end();\n                return;\n            }\n            response.write(value);\n            read();\n        });\n    }\n    read();\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUksRUFBRXRSLElBQUksQ0FBRTtRQUMzQixJQUFJNlEsa0JBQWtCM0w7UUFDdEIsSUFBSWxGLE1BQU07WUFDUjZRLGtCQUFrQjNMLElBQUk3QyxXQUFXLENBQUNyQyxLQUFLbEIsTUFBTTtRQUMvQztRQUNBLEtBQUssQ0FBQytSLGlCQUFpQjtZQUNyQixHQUFHUyxJQUFJO1lBQ1A1TCxRQUFRO1lBQ1JDLFNBQVM7Z0JBQ1AsZ0JBQWdCO2dCQUNoQixDQUFDckcsZUFBZSxFQUFFVSxPQUFPLFNBQVM7Z0JBQ2xDLEdBQUdzUixRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLM0wsT0FBTztZQUN6QztRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVM0TCxpQkFBaUJyTSxHQUFHLEVBQUV6RCxRQUFRLEVBQUU2UCxJQUFJO0lBQzNDN1AsU0FBUytQLFNBQVMsQ0FBQyxDQUFDRixRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLNUwsTUFBTSxLQUFLLEtBQUs7UUFDL0QsZ0JBQWdCO1FBQ2hCLEdBQUc0TCxRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLM0wsT0FBTztJQUN6QztJQUNBLE1BQU0vRCxTQUFTc0QsSUFBSXJELFNBQVM7SUFDNUIsU0FBU0c7UUFDUEosT0FBT0ksSUFBSSxHQUFHeVAsSUFBSSxDQUFDLENBQUMsRUFBRTFQLElBQUksRUFBRXZHLEtBQUssRUFBRTtZQUNqQyxJQUFJdUcsTUFBTTtnQkFDUk4sU0FBU2lRLEdBQUc7Z0JBQ1o7WUFDRjtZQUNBalEsU0FBU3lILEtBQUssQ0FBQzFOO1lBQ2Z3RztRQUNGO0lBQ0Y7SUFDQUE7QUFDRjtBQTRCRSxDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N5bmNjaGF0Ly4vbm9kZV9tb2R1bGVzL2FpL2Rpc3QvaW5kZXgubWpzPzgxZWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hhcmVkL3V0aWxzLnRzXG5pbXBvcnQgeyBjdXN0b21BbHBoYWJldCB9IGZyb20gXCJuYW5vaWQvbm9uLXNlY3VyZVwiO1xuXG4vLyBzaGFyZWQvc3RyZWFtLXBhcnRzLnRzXG52YXIgdGV4dFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMFwiLFxuICBuYW1lOiBcInRleHRcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJ0ZXh0XCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjFcIixcbiAgbmFtZTogXCJmdW5jdGlvbl9jYWxsXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImZ1bmN0aW9uX2NhbGxcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUuZnVuY3Rpb25fY2FsbCA9PSBudWxsIHx8ICEoXCJuYW1lXCIgaW4gdmFsdWUuZnVuY3Rpb25fY2FsbCkgfHwgIShcImFyZ3VtZW50c1wiIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImZ1bmN0aW9uX2NhbGxcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcImZ1bmN0aW9uX2NhbGxcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmdW5jdGlvbl9jYWxsXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgZGF0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMlwiLFxuICBuYW1lOiBcImRhdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJkYXRhXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBlcnJvclN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiM1wiLFxuICBuYW1lOiBcImVycm9yXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZXJyb3JcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI0XCIsXG4gIG5hbWU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiaWRcIiBpbiB2YWx1ZSkgfHwgIShcInJvbGVcIiBpbiB2YWx1ZSkgfHwgIShcImNvbnRlbnRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmlkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5yb2xlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUuY29udGVudCkgfHwgIXZhbHVlLmNvbnRlbnQuZXZlcnkoXG4gICAgICAoaXRlbSkgPT4gaXRlbSAhPSBudWxsICYmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiICYmIFwidHlwZVwiIGluIGl0ZW0gJiYgaXRlbS50eXBlID09PSBcInRleHRcIiAmJiBcInRleHRcIiBpbiBpdGVtICYmIGl0ZW0udGV4dCAhPSBudWxsICYmIHR5cGVvZiBpdGVtLnRleHQgPT09IFwib2JqZWN0XCIgJiYgXCJ2YWx1ZVwiIGluIGl0ZW0udGV4dCAmJiB0eXBlb2YgaXRlbS50ZXh0LnZhbHVlID09PSBcInN0cmluZ1wiXG4gICAgKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhbiBcImlkXCIsIFwicm9sZVwiLCBhbmQgXCJjb250ZW50XCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNVwiLFxuICBuYW1lOiBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidGhyZWFkSWRcIiBpbiB2YWx1ZSkgfHwgIShcIm1lc3NhZ2VJZFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudGhyZWFkSWQgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLm1lc3NhZ2VJZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0aHJlYWRJZFwiIGFuZCBcIm1lc3NhZ2VJZFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHRocmVhZElkOiB2YWx1ZS50aHJlYWRJZCxcbiAgICAgICAgbWVzc2FnZUlkOiB2YWx1ZS5tZXNzYWdlSWRcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xudmFyIGRhdGFNZXNzYWdlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI2XCIsXG4gIG5hbWU6IFwiZGF0YV9tZXNzYWdlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInJvbGVcIiBpbiB2YWx1ZSkgfHwgIShcImRhdGFcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnJvbGUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUucm9sZSAhPT0gXCJkYXRhXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZGF0YV9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJyb2xlXCIgYW5kIFwiZGF0YVwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRhdGFfbWVzc2FnZVwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIHRvb2xDYWxsU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI3XCIsXG4gIG5hbWU6IFwidG9vbF9jYWxsc1wiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0b29sX2NhbGxzXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sX2NhbGxzICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlLnRvb2xfY2FsbHMgPT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheSh2YWx1ZS50b29sX2NhbGxzKSB8fCB2YWx1ZS50b29sX2NhbGxzLnNvbWUoKHRjKSA9PiB7XG4gICAgICB0YyA9PSBudWxsIHx8IHR5cGVvZiB0YyAhPT0gXCJvYmplY3RcIiB8fCAhKFwiaWRcIiBpbiB0YykgfHwgdHlwZW9mIHRjLmlkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJ0eXBlXCIgaW4gdGMpIHx8IHR5cGVvZiB0Yy50eXBlICE9PSBcInN0cmluZ1wiIHx8ICEoXCJmdW5jdGlvblwiIGluIHRjKSB8fCB0Yy5mdW5jdGlvbiA9PSBudWxsIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbiAhPT0gXCJvYmplY3RcIiB8fCAhKFwiYXJndW1lbnRzXCIgaW4gdGMuZnVuY3Rpb24pIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbi5uYW1lICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbi5hcmd1bWVudHMgIT09IFwic3RyaW5nXCI7XG4gICAgfSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsc1wiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFRvb2xDYWxsUGF5bG9hZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0b29sX2NhbGxzXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI4XCIsXG4gIG5hbWU6IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiBwYXJ0cyBleHBlY3QgYW4gYXJyYXkgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIHN0cmVhbVBhcnRzID0gW1xuICB0ZXh0U3RyZWFtUGFydCxcbiAgZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgZGF0YVN0cmVhbVBhcnQsXG4gIGVycm9yU3RyZWFtUGFydCxcbiAgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnRcbl07XG52YXIgc3RyZWFtUGFydHNCeUNvZGUgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5jb2RlXTogdGV4dFN0cmVhbVBhcnQsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBbZGF0YVN0cmVhbVBhcnQuY29kZV06IGRhdGFTdHJlYW1QYXJ0LFxuICBbZXJyb3JTdHJlYW1QYXJ0LmNvZGVdOiBlcnJvclN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGVdOiB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0XG59O1xudmFyIFN0cmVhbVN0cmluZ1ByZWZpeGVzID0ge1xuICBbdGV4dFN0cmVhbVBhcnQubmFtZV06IHRleHRTdHJlYW1QYXJ0LmNvZGUsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0Lm5hbWVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFtkYXRhU3RyZWFtUGFydC5uYW1lXTogZGF0YVN0cmVhbVBhcnQuY29kZSxcbiAgW2Vycm9yU3RyZWFtUGFydC5uYW1lXTogZXJyb3JTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5uYW1lXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5uYW1lXTogYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlLFxuICBbdG9vbENhbGxTdHJlYW1QYXJ0Lm5hbWVdOiB0b29sQ2FsbFN0cmVhbVBhcnQuY29kZSxcbiAgW21lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQubmFtZV06IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQuY29kZVxufTtcbnZhciB2YWxpZENvZGVzID0gc3RyZWFtUGFydHMubWFwKChwYXJ0KSA9PiBwYXJ0LmNvZGUpO1xudmFyIHBhcnNlU3RyZWFtUGFydCA9IChsaW5lKSA9PiB7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICBpZiAoZmlyc3RTZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gTm8gc2VwYXJhdG9yIGZvdW5kLlwiKTtcbiAgfVxuICBjb25zdCBwcmVmaXggPSBsaW5lLnNsaWNlKDAsIGZpcnN0U2VwYXJhdG9ySW5kZXgpO1xuICBpZiAoIXZhbGlkQ29kZXMuaW5jbHVkZXMocHJlZml4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIEludmFsaWQgY29kZSAke3ByZWZpeH0uYCk7XG4gIH1cbiAgY29uc3QgY29kZSA9IHByZWZpeDtcbiAgY29uc3QgdGV4dFZhbHVlID0gbGluZS5zbGljZShmaXJzdFNlcGFyYXRvckluZGV4ICsgMSk7XG4gIGNvbnN0IGpzb25WYWx1ZSA9IEpTT04ucGFyc2UodGV4dFZhbHVlKTtcbiAgcmV0dXJuIHN0cmVhbVBhcnRzQnlDb2RlW2NvZGVdLnBhcnNlKGpzb25WYWx1ZSk7XG59O1xuZnVuY3Rpb24gZm9ybWF0U3RyZWFtUGFydCh0eXBlLCB2YWx1ZSkge1xuICBjb25zdCBzdHJlYW1QYXJ0ID0gc3RyZWFtUGFydHMuZmluZCgocGFydCkgPT4gcGFydC5uYW1lID09PSB0eXBlKTtcbiAgaWYgKCFzdHJlYW1QYXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0cmVhbSBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuICByZXR1cm4gYCR7c3RyZWFtUGFydC5jb2RlfToke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cbmA7XG59XG5cbi8vIHNoYXJlZC91dGlscy50c1xudmFyIG5hbm9pZCA9IGN1c3RvbUFscGhhYmV0KFxuICBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIsXG4gIDdcbik7XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoY29tcGxleCkge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGlmICghY29tcGxleCkge1xuICAgIHJldHVybiBmdW5jdGlvbihjaHVuaykge1xuICAgICAgaWYgKCFjaHVuaylcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KS5zcGxpdChcIlxcblwiKS5maWx0ZXIoKGxpbmUpID0+IGxpbmUgIT09IFwiXCIpO1xuICAgIHJldHVybiBkZWNvZGVkLm1hcChwYXJzZVN0cmVhbVBhcnQpLmZpbHRlcihCb29sZWFuKTtcbiAgfTtcbn1cbnZhciBpc1N0cmVhbVN0cmluZ0VxdWFsVG9UeXBlID0gKHR5cGUsIHZhbHVlKSA9PiB2YWx1ZS5zdGFydHNXaXRoKGAke1N0cmVhbVN0cmluZ1ByZWZpeGVzW3R5cGVdfTpgKSAmJiB2YWx1ZS5lbmRzV2l0aChcIlxcblwiKTtcbnZhciBDT01QTEVYX0hFQURFUiA9IFwiWC1FeHBlcmltZW50YWwtU3RyZWFtLURhdGFcIjtcblxuLy8gc3RyZWFtcy9haS1zdHJlYW0udHNcbmltcG9ydCB7XG4gIGNyZWF0ZVBhcnNlclxufSBmcm9tIFwiZXZlbnRzb3VyY2UtcGFyc2VyXCI7XG5mdW5jdGlvbiBjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyKGN1c3RvbVBhcnNlcikge1xuICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBsZXQgZXZlbnRTb3VyY2VQYXJzZXI7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBldmVudFNvdXJjZVBhcnNlciA9IGNyZWF0ZVBhcnNlcihcbiAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKFwiZGF0YVwiIGluIGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFwiZXZlbnRcIiAmJiBldmVudC5kYXRhID09PSBcIltET05FXVwiIHx8IC8vIFJlcGxpY2F0ZSBkb2Vzbid0IHNlbmQgW0RPTkVdIGJ1dCBkb2VzIHNlbmQgYSAnZG9uZScgZXZlbnRcbiAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vcmVwbGljYXRlLmNvbS9kb2NzL3N0cmVhbWluZ1xuICAgICAgICAgIGV2ZW50LmV2ZW50ID09PSBcImRvbmVcIikge1xuICAgICAgICAgICAgY29udHJvbGxlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiZGF0YVwiIGluIGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRNZXNzYWdlID0gY3VzdG9tUGFyc2VyID8gY3VzdG9tUGFyc2VyKGV2ZW50LmRhdGEsIHtcbiAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LmV2ZW50XG4gICAgICAgICAgICB9KSA6IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBpZiAocGFyc2VkTWVzc2FnZSlcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnNlZE1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIHRyYW5zZm9ybShjaHVuaykge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIuZmVlZCh0ZXh0RGVjb2Rlci5kZWNvZGUoY2h1bmspKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2IpIHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9IFwiXCI7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IGNiIHx8IHt9O1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uU3RhcnQpXG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblN0YXJ0KCk7XG4gICAgfSxcbiAgICBhc3luYyB0cmFuc2Zvcm0obWVzc2FnZSwgY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShtZXNzYWdlKSk7XG4gICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Ub2tlbilcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVG9rZW4obWVzc2FnZSk7XG4gICAgfSxcbiAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgIGNvbnN0IGlzT3BlbkFJQ2FsbGJhY2tzID0gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoY2FsbGJhY2tzKTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Db21wbGV0aW9uKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkNvbXBsZXRpb24oYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiAhaXNPcGVuQUlDYWxsYmFja3MpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoY2FsbGJhY2tzKSB7XG4gIHJldHVybiBcImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbFwiIGluIGNhbGxiYWNrcztcbn1cbmZ1bmN0aW9uIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCkge1xuICBsZXQgaXNTdHJlYW1TdGFydCA9IHRydWU7XG4gIHJldHVybiAodGV4dCkgPT4ge1xuICAgIGlmIChpc1N0cmVhbVN0YXJ0KSB7XG4gICAgICB0ZXh0ID0gdGV4dC50cmltU3RhcnQoKTtcbiAgICAgIGlmICh0ZXh0KVxuICAgICAgICBpc1N0cmVhbVN0YXJ0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufVxuZnVuY3Rpb24gQUlTdHJlYW0ocmVzcG9uc2UsIGN1c3RvbVBhcnNlciwgY2FsbGJhY2tzKSB7XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihgUmVzcG9uc2UgZXJyb3I6ICR7ZXJyb3JUZXh0fWApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKFwiUmVzcG9uc2UgZXJyb3I6IE5vIHJlc3BvbnNlIGJvZHlcIikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzcG9uc2VCb2R5U3RyZWFtID0gcmVzcG9uc2UuYm9keSB8fCBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCk7XG4gIHJldHVybiByZXNwb25zZUJvZHlTdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihjdXN0b21QYXJzZXIpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0oKSB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShpdGVyYWJsZSkge1xuICBsZXQgaXQgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSlcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgZWxzZVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgIH0sXG4gICAgYXN5bmMgY2FuY2VsKHJlYXNvbikge1xuICAgICAgdmFyIF9hO1xuICAgICAgYXdhaXQgKChfYSA9IGl0LnJldHVybikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoaXQsIHJlYXNvbikpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHN0cmVhbXMvc3RyZWFtLWRhdGEudHNcbnZhciBleHBlcmltZW50YWxfU3RyZWFtRGF0YSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbnVsbDtcbiAgICAvLyBjbG9zaW5nIHRoZSBzdHJlYW0gaXMgc3luY2hyb25vdXMsIGJ1dCB3ZSB3YW50IHRvIHJldHVybiBhIHByb21pc2VcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIGRvaW5nIGFzeW5jIHdvcmtcbiAgICB0aGlzLmlzQ2xvc2VkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5pc0Nsb3NlZFByb21pc2VSZXNvbHZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG4gICAgLy8gYXJyYXkgdG8gc3RvcmUgYXBwZW5kZWQgZGF0YVxuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMubWVzc2FnZUFubm90YXRpb25zID0gW107XG4gICAgdGhpcy5pc0Nsb3NlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5pc0Nsb3NlZFByb21pc2VSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBhc3luYyAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBzZWxmLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGlmIChzZWxmLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJkYXRhXCIsIHNlbGYuZGF0YSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHNlbGYuZGF0YSA9IFtdO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYubWVzc2FnZUFubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWRNZXNzYWdlQW5ub3RhdGlvbnMgPSBzZWxmLmVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgc2VsZi5tZXNzYWdlQW5ub3RhdGlvbnMpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZWxmLm1lc3NhZ2VBbm5vdGF0aW9ucyA9IFtdO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkTWVzc2FnZUFubm90YXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgd2FybmluZ1RpbWVvdXQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJUaGUgZGF0YSBzdHJlYW0gaXMgaGFuZ2luZy4gRGlkIHlvdSBmb3JnZXQgdG8gY2xvc2UgaXQgd2l0aCBgZGF0YS5jbG9zZSgpYD9cIlxuICAgICAgICAgICk7XG4gICAgICAgIH0sIDNlMykgOiBudWxsO1xuICAgICAgICBhd2FpdCBzZWxmLmlzQ2xvc2VkUHJvbWlzZTtcbiAgICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJkYXRhXCIsIHNlbGYuZGF0YSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYubWVzc2FnZUFubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJtZXNzYWdlX2Fubm90YXRpb25zXCIsIHNlbGYubWVzc2FnZUFubm90YXRpb25zKVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZWREYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgKF9hID0gdGhpcy5pc0Nsb3NlZFByb21pc2VSZXNvbHZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gIH1cbiAgYXBwZW5kKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5kYXRhLnB1c2godmFsdWUpO1xuICB9XG4gIGFwcGVuZE1lc3NhZ2VBbm5vdGF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlQW5ub3RhdGlvbnMucHVzaCh2YWx1ZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpIHtcbiAgaWYgKCFleHBlcmltZW50YWxfc3RyZWFtRGF0YSkge1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGRlY29kZXIuZGVjb2RlKGNodW5rKTtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KFwidGV4dFwiLCBtZXNzYWdlKSkpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHN0cmVhbXMvYW50aHJvcGljLXN0cmVhbS50c1xuZnVuY3Rpb24gcGFyc2VBbnRocm9waWNTdHJlYW0oKSB7XG4gIGxldCBwcmV2aW91cyA9IFwiXCI7XG4gIHJldHVybiAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIGlmIChcImVycm9yXCIgaW4ganNvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2pzb24uZXJyb3IudHlwZX06ICR7anNvbi5lcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBpZiAoIShcImNvbXBsZXRpb25cIiBpbiBqc29uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0ganNvbi5jb21wbGV0aW9uO1xuICAgIGlmICghcHJldmlvdXMgfHwgdGV4dC5sZW5ndGggPiBwcmV2aW91cy5sZW5ndGggJiYgdGV4dC5zdGFydHNXaXRoKHByZXZpb3VzKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSB0ZXh0LnNsaWNlKHByZXZpb3VzLmxlbmd0aCk7XG4gICAgICBwcmV2aW91cyA9IHRleHQ7XG4gICAgICByZXR1cm4gZGVsdGE7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUoc3RyZWFtKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgaWYgKFwiY29tcGxldGlvblwiIGluIGNodW5rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gY2h1bmsuY29tcGxldGlvbjtcbiAgICAgIGlmICh0ZXh0KVxuICAgICAgICB5aWVsZCB0ZXh0O1xuICAgIH0gZWxzZSBpZiAoXCJkZWx0YVwiIGluIGNodW5rKSB7XG4gICAgICBjb25zdCB7IGRlbHRhIH0gPSBjaHVuaztcbiAgICAgIGlmIChcInRleHRcIiBpbiBkZWx0YSkge1xuICAgICAgICBjb25zdCB0ZXh0ID0gZGVsdGEudGV4dDtcbiAgICAgICAgaWYgKHRleHQpXG4gICAgICAgICAgeWllbGQgdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIEFudGhyb3BpY1N0cmVhbShyZXMsIGNiKSB7XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXMpIHtcbiAgICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlKHJlcykpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNiKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfc3RyZWFtRGF0YSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBSVN0cmVhbShyZXMsIHBhcnNlQW50aHJvcGljU3RyZWFtKCksIGNiKS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcihjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzdHJlYW1zL2Fzc2lzdGFudC1yZXNwb25zZS50c1xuZnVuY3Rpb24gZXhwZXJpbWVudGFsX0Fzc2lzdGFudFJlc3BvbnNlKHsgdGhyZWFkSWQsIG1lc3NhZ2VJZCB9LCBwcm9jZXNzMikge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICBjb25zdCBzZW5kTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcImFzc2lzdGFudF9tZXNzYWdlXCIsIG1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlbmREYXRhTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcImRhdGFfbWVzc2FnZVwiLCBtZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZW5kRXJyb3IgPSAoZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcImVycm9yXCIsIGVycm9yTWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIiwge1xuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBtZXNzYWdlSWRcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvY2VzczIoe1xuICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICBzZW5kTWVzc2FnZSxcbiAgICAgICAgICBzZW5kRGF0YU1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzZW5kRXJyb3IoKF9hID0gZXJyb3IubWVzc2FnZSkgIT0gbnVsbCA/IF9hIDogYCR7ZXJyb3J9YCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICB9LFxuICAgIGNhbmNlbCgpIHtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHN0cmVhbSwge1xuICAgIHN0YXR1czogMjAwLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3RyZWFtcy9hd3MtYmVkcm9jay1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uKiBhc0RlbHRhSXRlcmFibGUocmVzcG9uc2UsIGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmspIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIChfYSA9IHJlc3BvbnNlLmJvZHkpICE9IG51bGwgPyBfYSA6IFtdKSB7XG4gICAgY29uc3QgYnl0ZXMgPSAoX2IgPSBjaHVuay5jaHVuaykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmJ5dGVzO1xuICAgIGlmIChieXRlcyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBjaHVua1RleHQgPSBkZWNvZGVyLmRlY29kZShieXRlcyk7XG4gICAgICBjb25zdCBjaHVua0pTT04gPSBKU09OLnBhcnNlKGNodW5rVGV4dCk7XG4gICAgICBjb25zdCBkZWx0YSA9IGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmsoY2h1bmtKU09OKTtcbiAgICAgIGlmIChkZWx0YSAhPSBudWxsKSB7XG4gICAgICAgIHlpZWxkIGRlbHRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gQVdTQmVkcm9ja0FudGhyb3BpY1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIChjaHVuaykgPT4gY2h1bmsuY29tcGxldGlvbik7XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrQ29oZXJlU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0oXG4gICAgcmVzcG9uc2UsXG4gICAgY2FsbGJhY2tzLFxuICAgIC8vIEFzIG9mIDIwMjMtMTEtMTcsIEJlZHJvY2sgZG9lcyBub3Qgc3VwcG9ydCBzdHJlYW1pbmcgZm9yIENvaGVyZSxcbiAgICAvLyBzbyB3ZSB0YWtlIHRoZSBmdWxsIGdlbmVyYXRpb246XG4gICAgKGNodW5rKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIChfYiA9IChfYSA9IGNodW5rLmdlbmVyYXRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYi50ZXh0O1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tMbGFtYTJTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICByZXR1cm4gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCAoY2h1bmspID0+IGNodW5rLmdlbmVyYXRpb24pO1xufVxuZnVuY3Rpb24gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCBleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKFxuICAgIGFzRGVsdGFJdGVyYWJsZShyZXNwb25zZSwgZXh0cmFjdFRleHREZWx0YUZyb21DaHVuaylcbiAgKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChcbiAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3MuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpXG4gICk7XG59XG5cbi8vIHN0cmVhbXMvY29oZXJlLXN0cmVhbS50c1xudmFyIHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzTGluZXMobGluZXMsIGNvbnRyb2xsZXIpIHtcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgY29uc3QgeyB0ZXh0LCBpc19maW5pc2hlZCB9ID0gSlNPTi5wYXJzZShsaW5lKTtcbiAgICBpZiAoIWlzX2ZpbmlzaGVkKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dCk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZWFkQW5kUHJvY2Vzc0xpbmVzKHJlYWRlciwgY29udHJvbGxlcikge1xuICBsZXQgc2VnbWVudCA9IFwiXCI7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZTogY2h1bmssIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzZWdtZW50ICs9IHV0ZjhEZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgY29uc3QgbGluZXNBcnJheSA9IHNlZ21lbnQuc3BsaXQoL1xcclxcbnxcXG58XFxyL2cpO1xuICAgIHNlZ21lbnQgPSBsaW5lc0FycmF5LnBvcCgpIHx8IFwiXCI7XG4gICAgYXdhaXQgcHJvY2Vzc0xpbmVzKGxpbmVzQXJyYXksIGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmIChzZWdtZW50KSB7XG4gICAgY29uc3QgbGluZXNBcnJheSA9IFtzZWdtZW50XTtcbiAgICBhd2FpdCBwcm9jZXNzTGluZXMobGluZXNBcnJheSwgY29udHJvbGxlcik7XG4gIH1cbiAgY29udHJvbGxlci5jbG9zZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFyc2VyMihyZXMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCByZWFkZXIgPSAoX2EgPSByZXMuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldFJlYWRlcigpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHJlYWRBbmRQcm9jZXNzTGluZXMocmVhZGVyLCBjb250cm9sbGVyKTtcbiAgICB9XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUyKHN0cmVhbSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGlmIChjaHVuay5ldmVudFR5cGUgPT09IFwidGV4dC1nZW5lcmF0aW9uXCIpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBjaHVuay50ZXh0O1xuICAgICAgaWYgKHRleHQpXG4gICAgICAgIHlpZWxkIHRleHQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBDb2hlcmVTdHJlYW0ocmVhZGVyLCBjYWxsYmFja3MpIHtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlYWRlcikge1xuICAgIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUyKHJlYWRlcikpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKFxuICAgICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKGNhbGxiYWNrcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9zdHJlYW1EYXRhKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhcnNlcjIocmVhZGVyKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcihjYWxsYmFja3MgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5leHBlcmltZW50YWxfc3RyZWFtRGF0YSlcbiAgICApO1xuICB9XG59XG5cbi8vIHN0cmVhbXMvZ29vZ2xlLWdlbmVyYXRpdmUtYWktc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZTMocmVzcG9uc2UpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVzcG9uc2Uuc3RyZWFtKSB7XG4gICAgY29uc3QgcGFydHMgPSAoX2MgPSAoX2IgPSAoX2EgPSBjaHVuay5jYW5kaWRhdGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2MucGFydHM7XG4gICAgaWYgKHBhcnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBhcnQgPSBwYXJ0c1swXTtcbiAgICBpZiAodHlwZW9mIGZpcnN0UGFydC50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB5aWVsZCBmaXJzdFBhcnQudGV4dDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIEdvb2dsZUdlbmVyYXRpdmVBSVN0cmVhbShyZXNwb25zZSwgY2IpIHtcbiAgcmV0dXJuIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZTMocmVzcG9uc2UpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYikpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcihjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpKTtcbn1cblxuLy8gc3RyZWFtcy9odWdnaW5nZmFjZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlcjMocmVzKSB7XG4gIGNvbnN0IHRyaW1TdGFydE9mU3RyZWFtID0gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVzLm5leHQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKChfYiA9IChfYSA9IHZhbHVlLnRva2VuKSA9PSBudWxsID8gdm9pZCAwIDogX2EudGV4dCkgIT0gbnVsbCA/IF9iIDogXCJcIik7XG4gICAgICBpZiAoIXRleHQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh2YWx1ZS5nZW5lcmF0ZWRfdGV4dCAhPSBudWxsICYmIHZhbHVlLmdlbmVyYXRlZF90ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQgPT09IFwiPC9zPlwiIHx8IHRleHQgPT09IFwiPHxlbmRvZnRleHR8PlwiIHx8IHRleHQgPT09IFwiPHxlbmR8PlwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gSHVnZ2luZ0ZhY2VTdHJlYW0ocmVzLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIGNyZWF0ZVBhcnNlcjMocmVzKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChcbiAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3MuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpXG4gICk7XG59XG5cbi8vIHN0cmVhbXMvbGFuZ2NoYWluLXN0cmVhbS50c1xuZnVuY3Rpb24gTGFuZ0NoYWluU3RyZWFtKGNhbGxiYWNrcykge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKCk7XG4gIGNvbnN0IHdyaXRlciA9IHN0cmVhbS53cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgY29uc3QgcnVucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGhhbmRsZUVycm9yID0gYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgcnVucy5kZWxldGUocnVuSWQpO1xuICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICBhd2FpdCB3cml0ZXIuYWJvcnQoZSk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZVN0YXJ0ID0gYXN5bmMgKHJ1bklkKSA9PiB7XG4gICAgcnVucy5hZGQocnVuSWQpO1xuICB9O1xuICBjb25zdCBoYW5kbGVFbmQgPSBhc3luYyAocnVuSWQpID0+IHtcbiAgICBydW5zLmRlbGV0ZShydW5JZCk7XG4gICAgaWYgKHJ1bnMuc2l6ZSA9PT0gMCkge1xuICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgICAgYXdhaXQgd3JpdGVyLmNsb3NlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHN0cmVhbTogc3RyZWFtLnJlYWRhYmxlLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKFxuICAgICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKGNhbGxiYWNrcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9zdHJlYW1EYXRhKVxuICAgICksXG4gICAgd3JpdGVyLFxuICAgIGhhbmRsZXJzOiB7XG4gICAgICBoYW5kbGVMTE1OZXdUb2tlbjogYXN5bmMgKHRva2VuKSA9PiB7XG4gICAgICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICAgICAgYXdhaXQgd3JpdGVyLndyaXRlKHRva2VuKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVMTE1TdGFydDogYXN5bmMgKF9sbG0sIF9wcm9tcHRzLCBydW5JZCkgPT4ge1xuICAgICAgICBoYW5kbGVTdGFydChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlTExNRW5kOiBhc3luYyAoX291dHB1dCwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRW5kKHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVMTE1FcnJvcjogYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUsIHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDaGFpblN0YXJ0OiBhc3luYyAoX2NoYWluLCBfaW5wdXRzLCBydW5JZCkgPT4ge1xuICAgICAgICBoYW5kbGVTdGFydChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlQ2hhaW5FbmQ6IGFzeW5jIChfb3V0cHV0cywgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRW5kKHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDaGFpbkVycm9yOiBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSwgcnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xTdGFydDogYXN5bmMgKF90b29sLCBfaW5wdXQsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVUb29sRW5kOiBhc3luYyAoX291dHB1dCwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRW5kKHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVUb29sRXJyb3I6IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihlLCBydW5JZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vLyBzdHJlYW1zL29wZW5haS1zdHJlYW0udHNcbmZ1bmN0aW9uIHBhcnNlT3BlbkFJU3RyZWFtKCkge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcbiAgcmV0dXJuIChkYXRhKSA9PiBleHRyYWN0KEpTT04ucGFyc2UoZGF0YSkpO1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGU0KHN0cmVhbSkge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcbiAgZm9yIGF3YWl0IChsZXQgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgaWYgKFwicHJvbXB0RmlsdGVyUmVzdWx0c1wiIGluIGNodW5rKSB7XG4gICAgICBjaHVuayA9IHtcbiAgICAgICAgaWQ6IGNodW5rLmlkLFxuICAgICAgICBjcmVhdGVkOiBjaHVuay5jcmVhdGVkLmdldERhdGUoKSxcbiAgICAgICAgb2JqZWN0OiBjaHVuay5vYmplY3QsXG4gICAgICAgIC8vIG5vdCBleHBvc2VkIGJ5IEF6dXJlIEFQSVxuICAgICAgICBtb2RlbDogY2h1bmsubW9kZWwsXG4gICAgICAgIC8vIG5vdCBleHBvc2VkIGJ5IEF6dXJlIEFQSVxuICAgICAgICBjaG9pY2VzOiBjaHVuay5jaG9pY2VzLm1hcCgoY2hvaWNlKSA9PiB7XG4gICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWx0YToge1xuICAgICAgICAgICAgICBjb250ZW50OiAoX2EgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jb250ZW50LFxuICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiAoX2IgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYi5mdW5jdGlvbkNhbGwsXG4gICAgICAgICAgICAgIHJvbGU6IChfYyA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnJvbGUsXG4gICAgICAgICAgICAgIHRvb2xfY2FsbHM6ICgoX2UgPSAoX2QgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfZC50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5sZW5ndGgpID8gKF9nID0gKF9mID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2YudG9vbENhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2cubWFwKCh0b29sQ2FsbCwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB0b29sQ2FsbC5mdW5jdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlOiB0b29sQ2FsbC50eXBlXG4gICAgICAgICAgICAgIH0pKSA6IHZvaWQgMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbmlzaF9yZWFzb246IGNob2ljZS5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICBpbmRleDogY2hvaWNlLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSBleHRyYWN0KGNodW5rKTtcbiAgICBpZiAodGV4dClcbiAgICAgIHlpZWxkIHRleHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGNodW5rVG9UZXh0KCkge1xuICBjb25zdCB0cmltU3RhcnRPZlN0cmVhbSA9IHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk7XG4gIGxldCBpc0Z1bmN0aW9uU3RyZWFtaW5nSW47XG4gIHJldHVybiAoanNvbikgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pLCBfaiwgX2ssIF9sLCBfbSwgX24sIF9vLCBfcCwgX3E7XG4gICAgaWYgKGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSAoX2EgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5kZWx0YTtcbiAgICAgIGlmICgoX2IgPSBkZWx0YS5mdW5jdGlvbl9jYWxsKSA9PSBudWxsID8gdm9pZCAwIDogX2IubmFtZSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4gYHtcImZ1bmN0aW9uX2NhbGxcIjoge1wibmFtZVwiOiBcIiR7ZGVsdGEuZnVuY3Rpb25fY2FsbC5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImA7XG4gICAgICB9IGVsc2UgaWYgKChfZSA9IChfZCA9IChfYyA9IGRlbHRhLnRvb2xfY2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfY1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2UubmFtZSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICBjb25zdCB0b29sQ2FsbCA9IGRlbHRhLnRvb2xfY2FsbHNbMF07XG4gICAgICAgIGlmICh0b29sQ2FsbC5pbmRleCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBge1widG9vbF9jYWxsc1wiOlsge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIkeyhfZiA9IHRvb2xDYWxsLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2YubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgXCJ9fSwge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIkeyhfZyA9IHRvb2xDYWxsLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2cubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChfaCA9IGRlbHRhLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfaC5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFudXBBcmd1bWVudHMoKF9pID0gZGVsdGEuZnVuY3Rpb25fY2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pLmFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2UgaWYgKChfayA9IChfaiA9IGRlbHRhLnRvb2xfY2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfalswXS5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9rLmFyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4gY2xlYW51cEFyZ3VtZW50cygoX24gPSAoX20gPSAoX2wgPSBkZWx0YS50b29sX2NhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2xbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfbS5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9uLmFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoKChfbyA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vLmZpbmlzaF9yZWFzb24pID09PSBcImZ1bmN0aW9uX2NhbGxcIiB8fCAoKF9wID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3AuZmluaXNoX3JlYXNvbikgPT09IFwic3RvcFwiKSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuICdcIn19JztcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvblN0cmVhbWluZ0luICYmICgoX3EgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcS5maW5pc2hfcmVhc29uKSA9PT0gXCJ0b29sX2NhbGxzXCIpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgIHJldHVybiAnXCJ9fV19JztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKFxuICAgICAgaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pICYmIGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50ID8ganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnQgOiBpc0NvbXBsZXRpb24oanNvbikgPyBqc29uLmNob2ljZXNbMF0udGV4dCA6IFwiXCJcbiAgICApO1xuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuICBmdW5jdGlvbiBjbGVhbnVwQXJndW1lbnRzKGFyZ3VtZW50Q2h1bmspIHtcbiAgICBsZXQgZXNjYXBlZFBhcnRpYWxKc29uID0gYXJndW1lbnRDaHVuay5yZXBsYWNlKC9cXFxcL2csIFwiXFxcXFxcXFxcIikucmVwbGFjZSgvXFwvL2csIFwiXFxcXC9cIikucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLnJlcGxhY2UoL1xcci9nLCBcIlxcXFxyXCIpLnJlcGxhY2UoL1xcdC9nLCBcIlxcXFx0XCIpLnJlcGxhY2UoL1xcZi9nLCBcIlxcXFxmXCIpO1xuICAgIHJldHVybiBgJHtlc2NhcGVkUGFydGlhbEpzb259YDtcbiAgfVxufVxudmFyIF9faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2wgPSBTeW1ib2woXG4gIFwiaW50ZXJuYWxfb3BlbmFpX2ZuX21lc3NhZ2VzXCJcbik7XG5mdW5jdGlvbiBpc0NoYXRDb21wbGV0aW9uQ2h1bmsoZGF0YSkge1xuICByZXR1cm4gXCJjaG9pY2VzXCIgaW4gZGF0YSAmJiBkYXRhLmNob2ljZXMgJiYgZGF0YS5jaG9pY2VzWzBdICYmIFwiZGVsdGFcIiBpbiBkYXRhLmNob2ljZXNbMF07XG59XG5mdW5jdGlvbiBpc0NvbXBsZXRpb24oZGF0YSkge1xuICByZXR1cm4gXCJjaG9pY2VzXCIgaW4gZGF0YSAmJiBkYXRhLmNob2ljZXMgJiYgZGF0YS5jaG9pY2VzWzBdICYmIFwidGV4dFwiIGluIGRhdGEuY2hvaWNlc1swXTtcbn1cbmZ1bmN0aW9uIE9wZW5BSVN0cmVhbShyZXMsIGNhbGxiYWNrcykge1xuICBjb25zdCBjYiA9IGNhbGxiYWNrcztcbiAgbGV0IHN0cmVhbTtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlcykge1xuICAgIHN0cmVhbSA9IHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZTQocmVzKSkucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihcbiAgICAgICAgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHx8IChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpID8ge1xuICAgICAgICAgIC4uLmNiLFxuICAgICAgICAgIG9uRmluYWw6IHZvaWQgMFxuICAgICAgICB9IDoge1xuICAgICAgICAgIC4uLmNiXG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbSA9IEFJU3RyZWFtKFxuICAgICAgcmVzLFxuICAgICAgcGFyc2VPcGVuQUlTdHJlYW0oKSxcbiAgICAgIChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB8fCAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSA/IHtcbiAgICAgICAgLi4uY2IsXG4gICAgICAgIG9uRmluYWw6IHZvaWQgMFxuICAgICAgfSA6IHtcbiAgICAgICAgLi4uY2JcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGlmIChjYiAmJiAoY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyID0gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoY2IpO1xuICAgIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9zdHJlYW1EYXRhKVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKGNhbGxiYWNrcykge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9IFwiXCI7XG4gIGxldCBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSBcIlwiO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gIGxldCBmdW5jdGlvbkNhbGxNZXNzYWdlcyA9IGNhbGxiYWNrc1tfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXSB8fCBbXTtcbiAgY29uc3QgaXNDb21wbGV4TW9kZSA9IGNhbGxiYWNrcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9zdHJlYW1EYXRhO1xuICBjb25zdCBkZWNvZGUgPSBjcmVhdGVDaHVua0RlY29kZXIoKTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGRlY29kZShjaHVuayk7XG4gICAgICBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIGNvbnN0IHNob3VsZEhhbmRsZUFzRnVuY3Rpb24gPSBpc0ZpcnN0Q2h1bmsgJiYgKG1lc3NhZ2Uuc3RhcnRzV2l0aCgne1wiZnVuY3Rpb25fY2FsbFwiOicpIHx8IG1lc3NhZ2Uuc3RhcnRzV2l0aCgne1widG9vbF9jYWxsc1wiOicpKTtcbiAgICAgIGlmIChzaG91bGRIYW5kbGVBc0Z1bmN0aW9uKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0Z1bmN0aW9uU3RyZWFtaW5nSW4pIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIGlzQ29tcGxleE1vZGUgPyB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcInRleHRcIiwgbWVzc2FnZSkpIDogY2h1bmtcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWlzRmlyc3RDaHVuayAmJiBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSkge1xuICAgICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICAgICAgbGV0IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgLi4uZnVuY3Rpb25DYWxsTWVzc2FnZXNcbiAgICAgICAgICBdO1xuICAgICAgICAgIGxldCBmdW5jdGlvblJlc3BvbnNlID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5mdW5jdGlvbl9jYWxsID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIFwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFyZ3VtZW50c1BheWxvYWQgPSBKU09OLnBhcnNlKFxuICAgICAgICAgICAgICBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3VtZW50c1BheWxvYWRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgLi4uZnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IHBheWxvYWQuZnVuY3Rpb25fY2FsbFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSB7XG4gICAgICAgICAgICAgIHRvb2xzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiBwYXlsb2FkLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgdG9vbENhbGxzLnRvb2xzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiB0b29sLmlkLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBmdW5jOiB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiB0b29sLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IHRvb2wuZnVuY3Rpb24uYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXNwb25zZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwoXG4gICAgICAgICAgICAgICAgdG9vbENhbGxzLFxuICAgICAgICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0b29sX2NhbGxfaWQsIGZ1bmN0aW9uX25hbWUsIHRvb2xfY2FsbF9yZXN1bHQgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgLi4ubmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhcHBlbmQgdGhlIGFzc2lzdGFudCBtZXNzYWdlIGlmIGl0J3MgdGhlIGZpcnN0IHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgLi4ucmVzcG9uc2VJbmRleCA9PT0gMCA/IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsczogcGF5bG9hZC50b29sX2NhbGxzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGMpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdGMuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0Yy5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzZW5kIHRoZSBhcmd1bWVudHMgYW4gb2JqZWN0IHRvIHRoZSB1c2VyLCBidXQgYXMgdGhlIEFQSSBleHBlY3RzIGEgc3RyaW5nLCB3ZSBuZWVkIHRvIHN0cmluZ2lmeSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRjLmZ1bmN0aW9uLmFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIF0gOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIGZ1bmN0aW9uIGNhbGwgcmVzdWx0IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uX25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh0b29sX2NhbGxfcmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNhbGxpbmcgZXhwZXJpbWVudGFsX29uVG9vbENhbGw6XCIsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZ1bmN0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgIGlzQ29tcGxleE1vZGUgPyBmb3JtYXRTdHJlYW1QYXJ0KFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZC5mdW5jdGlvbl9jYWxsID8gXCJmdW5jdGlvbl9jYWxsXCIgOiBcInRvb2xfY2FsbHNcIixcbiAgICAgICAgICAgICAgICAgIC8vIHBhcnNlIHRvIHByZXZlbnQgZG91YmxlLWVuY29kaW5nOlxuICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgKSA6IGFnZ3JlZ2F0ZWRSZXNwb25zZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uUmVzcG9uc2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgaXNDb21wbGV4TW9kZSA/IHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KFwidGV4dFwiLCBmdW5jdGlvblJlc3BvbnNlKSkgOiB0ZXh0RW5jb2Rlci5lbmNvZGUoZnVuY3Rpb25SZXNwb25zZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgLi4uY2FsbGJhY2tzLFxuICAgICAgICAgICAgb25TdGFydDogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYWxsYmFja3Mub25GaW5hbCA9IHZvaWQgMDtcbiAgICAgICAgICBjb25zdCBvcGVuQUlTdHJlYW0gPSBPcGVuQUlTdHJlYW0oZnVuY3Rpb25SZXNwb25zZSwge1xuICAgICAgICAgICAgLi4uZmlsdGVyZWRDYWxsYmFja3MsXG4gICAgICAgICAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF06IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gb3BlbkFJU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSkge1xuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzdHJlYW1zL3JlcGxpY2F0ZS1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIFJlcGxpY2F0ZVN0cmVhbShyZXMsIGNiLCBvcHRpb25zKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgdXJsID0gKF9hID0gcmVzLnVybHMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdHJlYW07XG4gIGlmICghdXJsKSB7XG4gICAgaWYgKHJlcy5lcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXMuZXJyb3IpO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc3RyZWFtIFVSTCBpbiBSZXBsaWNhdGUgcmVzcG9uc2VcIik7XG4gIH1cbiAgY29uc3QgZXZlbnRTdHJlYW0gPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgQWNjZXB0OiBcInRleHQvZXZlbnQtc3RyZWFtXCIsXG4gICAgICAuLi5vcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gQUlTdHJlYW0oZXZlbnRTdHJlYW0sIHZvaWQgMCwgY2IpLnBpcGVUaHJvdWdoKFxuICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcihjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpXG4gICk7XG59XG5cbi8vIHNoYXJlZC9yZWFkLWRhdGEtc3RyZWFtLnRzXG52YXIgTkVXTElORSA9IFwiXFxuXCIuY2hhckNvZGVBdCgwKTtcbmZ1bmN0aW9uIGNvbmNhdENodW5rcyhjaHVua3MsIHRvdGFsTGVuZ3RoKSB7XG4gIGNvbnN0IGNvbmNhdGVuYXRlZENodW5rcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgY29uY2F0ZW5hdGVkQ2h1bmtzLnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIGNodW5rcy5sZW5ndGggPSAwO1xuICByZXR1cm4gY29uY2F0ZW5hdGVkQ2h1bmtzO1xufVxuYXN5bmMgZnVuY3Rpb24qIHJlYWREYXRhU3RyZWFtKHJlYWRlciwge1xuICBpc0Fib3J0ZWRcbn0gPSB7fSkge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGNvbnN0IGNodW5rcyA9IFtdO1xuICBsZXQgdG90YWxMZW5ndGggPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBjaHVua3MucHVzaCh2YWx1ZSk7XG4gICAgICB0b3RhbExlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09IE5FV0xJTkUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gY29uY2F0Q2h1bmtzKGNodW5rcywgdG90YWxMZW5ndGgpO1xuICAgIHRvdGFsTGVuZ3RoID0gMDtcbiAgICBjb25zdCBzdHJlYW1QYXJ0czIgPSBkZWNvZGVyLmRlY29kZShjb25jYXRlbmF0ZWRDaHVua3MsIHsgc3RyZWFtOiB0cnVlIH0pLnNwbGl0KFwiXFxuXCIpLmZpbHRlcigobGluZSkgPT4gbGluZSAhPT0gXCJcIikubWFwKHBhcnNlU3RyZWFtUGFydCk7XG4gICAgZm9yIChjb25zdCBzdHJlYW1QYXJ0IG9mIHN0cmVhbVBhcnRzMikge1xuICAgICAgeWllbGQgc3RyZWFtUGFydDtcbiAgICB9XG4gICAgaWYgKGlzQWJvcnRlZCA9PSBudWxsID8gdm9pZCAwIDogaXNBYm9ydGVkKCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzaGFyZWQvcGFyc2UtY29tcGxleC1yZXNwb25zZS50c1xuZnVuY3Rpb24gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UobWVzc2FnZSwgYW5ub3RhdGlvbnMpIHtcbiAgaWYgKCFtZXNzYWdlIHx8ICFhbm5vdGF0aW9ucyB8fCAhYW5ub3RhdGlvbnMubGVuZ3RoKVxuICAgIHJldHVybiBtZXNzYWdlO1xuICByZXR1cm4geyAuLi5tZXNzYWdlLCBhbm5vdGF0aW9uczogWy4uLmFubm90YXRpb25zXSB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcGFyc2VDb21wbGV4UmVzcG9uc2Uoe1xuICByZWFkZXIsXG4gIGFib3J0Q29udHJvbGxlclJlZixcbiAgdXBkYXRlLFxuICBvbkZpbmlzaCxcbiAgZ2VuZXJhdGVJZCA9IG5hbm9pZCxcbiAgZ2V0Q3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxufSkge1xuICBjb25zdCBjcmVhdGVkQXQgPSBnZXRDdXJyZW50RGF0ZSgpO1xuICBjb25zdCBwcmVmaXhNYXAgPSB7XG4gICAgZGF0YTogW11cbiAgfTtcbiAgbGV0IG1lc3NhZ2VfYW5ub3RhdGlvbnMgPSB2b2lkIDA7XG4gIGZvciBhd2FpdCAoY29uc3QgeyB0eXBlLCB2YWx1ZSB9IG9mIHJlYWREYXRhU3RyZWFtKHJlYWRlciwge1xuICAgIGlzQWJvcnRlZDogKCkgPT4gKGFib3J0Q29udHJvbGxlclJlZiA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQpID09PSBudWxsXG4gIH0pKSB7XG4gICAgaWYgKHR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICBpZiAocHJlZml4TWFwW1widGV4dFwiXSkge1xuICAgICAgICBwcmVmaXhNYXBbXCJ0ZXh0XCJdID0ge1xuICAgICAgICAgIC4uLnByZWZpeE1hcFtcInRleHRcIl0sXG4gICAgICAgICAgY29udGVudDogKHByZWZpeE1hcFtcInRleHRcIl0uY29udGVudCB8fCBcIlwiKSArIHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVmaXhNYXBbXCJ0ZXh0XCJdID0ge1xuICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICBjb250ZW50OiB2YWx1ZSxcbiAgICAgICAgICBjcmVhdGVkQXRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBudWxsO1xuICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uX2NhbGxcIikge1xuICAgICAgcHJlZml4TWFwW1wiZnVuY3Rpb25fY2FsbFwiXSA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgZnVuY3Rpb25fY2FsbDogdmFsdWUuZnVuY3Rpb25fY2FsbCxcbiAgICAgICAgbmFtZTogdmFsdWUuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICBjcmVhdGVkQXRcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbkNhbGxNZXNzYWdlID0gcHJlZml4TWFwW1wiZnVuY3Rpb25fY2FsbFwiXTtcbiAgICB9XG4gICAgbGV0IHRvb2xDYWxsTWVzc2FnZSA9IG51bGw7XG4gICAgaWYgKHR5cGUgPT09IFwidG9vbF9jYWxsc1wiKSB7XG4gICAgICBwcmVmaXhNYXBbXCJ0b29sX2NhbGxzXCJdID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICB0b29sX2NhbGxzOiB2YWx1ZS50b29sX2NhbGxzLFxuICAgICAgICBjcmVhdGVkQXRcbiAgICAgIH07XG4gICAgICB0b29sQ2FsbE1lc3NhZ2UgPSBwcmVmaXhNYXBbXCJ0b29sX2NhbGxzXCJdO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJkYXRhXCIpIHtcbiAgICAgIHByZWZpeE1hcFtcImRhdGFcIl0ucHVzaCguLi52YWx1ZSk7XG4gICAgfVxuICAgIGxldCByZXNwb25zZU1lc3NhZ2UgPSBwcmVmaXhNYXBbXCJ0ZXh0XCJdO1xuICAgIGlmICh0eXBlID09PSBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIikge1xuICAgICAgaWYgKCFtZXNzYWdlX2Fubm90YXRpb25zKSB7XG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnMgPSBbLi4udmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucy5wdXNoKC4uLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwW1wiZnVuY3Rpb25fY2FsbFwiXSxcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9uc1xuICAgICAgKTtcbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbXCJ0b29sX2NhbGxzXCJdLFxuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zXG4gICAgICApO1xuICAgICAgcmVzcG9uc2VNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0sXG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlX2Fubm90YXRpb25zID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlX2Fubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgY29uc3QgbWVzc2FnZVByZWZpeEtleXMgPSBbXG4gICAgICAgIFwidGV4dFwiLFxuICAgICAgICBcImZ1bmN0aW9uX2NhbGxcIixcbiAgICAgICAgXCJ0b29sX2NhbGxzXCJcbiAgICAgIF07XG4gICAgICBtZXNzYWdlUHJlZml4S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKHByZWZpeE1hcFtrZXldKSB7XG4gICAgICAgICAgcHJlZml4TWFwW2tleV0uYW5ub3RhdGlvbnMgPSBbLi4ubWVzc2FnZV9hbm5vdGF0aW9uc107XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXJnZWQgPSBbZnVuY3Rpb25DYWxsTWVzc2FnZSwgdG9vbENhbGxNZXNzYWdlLCByZXNwb25zZU1lc3NhZ2VdLmZpbHRlcihCb29sZWFuKS5tYXAoKG1lc3NhZ2UpID0+ICh7XG4gICAgICAuLi5hc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShtZXNzYWdlLCBtZXNzYWdlX2Fubm90YXRpb25zKVxuICAgIH0pKTtcbiAgICB1cGRhdGUobWVyZ2VkLCBbLi4ucHJlZml4TWFwW1wiZGF0YVwiXV0pO1xuICB9XG4gIG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaChwcmVmaXhNYXApO1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzOiBbXG4gICAgICBwcmVmaXhNYXAudGV4dCxcbiAgICAgIHByZWZpeE1hcC5mdW5jdGlvbl9jYWxsLFxuICAgICAgcHJlZml4TWFwLnRvb2xfY2FsbHNcbiAgICBdLmZpbHRlcihCb29sZWFuKSxcbiAgICBkYXRhOiBwcmVmaXhNYXAuZGF0YVxuICB9O1xufVxuXG4vLyBzdHJlYW1zL3N0cmVhbWluZy1yZWFjdC1yZXNwb25zZS50c1xudmFyIGV4cGVyaW1lbnRhbF9TdHJlYW1pbmdSZWFjdFJlc3BvbnNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihyZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHJlc29sdmVGdW5jID0gKCkgPT4ge1xuICAgIH07XG4gICAgbGV0IG5leHQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgcmVzb2x2ZUZ1bmMgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpIHtcbiAgICAgIGNvbnN0IHByb2Nlc3NlZFN0cmVhbSA9IHJlcy5waXBlVGhyb3VnaChcbiAgICAgICAgb3B0aW9ucy5kYXRhLnN0cmVhbVxuICAgICAgKTtcbiAgICAgIGxldCBsYXN0UGF5bG9hZCA9IHZvaWQgMDtcbiAgICAgIHBhcnNlQ29tcGxleFJlc3BvbnNlKHtcbiAgICAgICAgcmVhZGVyOiBwcm9jZXNzZWRTdHJlYW0uZ2V0UmVhZGVyKCksXG4gICAgICAgIHVwZGF0ZTogKG1lcmdlZCwgZGF0YSkgPT4ge1xuICAgICAgICAgIHZhciBfYTIsIF9iLCBfYztcbiAgICAgICAgICBjb25zdCBjb250ZW50MiA9IChfYiA9IChfYTIgPSBtZXJnZWRbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY29udGVudCkgIT0gbnVsbCA/IF9iIDogXCJcIjtcbiAgICAgICAgICBjb25zdCB1aSA9ICgoX2MgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnVpKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChvcHRpb25zLCB7IGNvbnRlbnQ6IGNvbnRlbnQyLCBkYXRhIH0pKSB8fCBjb250ZW50MjtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0geyB1aSwgY29udGVudDogY29udGVudDIgfTtcbiAgICAgICAgICBjb25zdCByZXNvbHZlUHJldmlvdXMgPSByZXNvbHZlRnVuYztcbiAgICAgICAgICBjb25zdCBuZXh0Um93ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmVGdW5jID0gcmVzb2x2ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXNvbHZlUHJldmlvdXMoe1xuICAgICAgICAgICAgbmV4dDogbmV4dFJvdyxcbiAgICAgICAgICAgIC4uLnBheWxvYWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsYXN0UGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbmVyYXRlSWQ6IChfYSA9IG9wdGlvbnMuZ2VuZXJhdGVJZCkgIT0gbnVsbCA/IF9hIDogbmFub2lkLFxuICAgICAgICBvbkZpbmlzaDogKCkgPT4ge1xuICAgICAgICAgIGlmIChsYXN0UGF5bG9hZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXNvbHZlRnVuYyh7XG4gICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgIC4uLmxhc3RQYXlsb2FkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICAgIGxldCBjb250ZW50ID0gXCJcIjtcbiAgICBjb25zdCBkZWNvZGUgPSBjcmVhdGVDaHVua0RlY29kZXIoKTtcbiAgICBjb25zdCByZWFkZXIgPSByZXMuZ2V0UmVhZGVyKCk7XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZENodW5rKCkge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgY29udGVudCArPSBkZWNvZGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgdWkgPSAoKF9hMiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudWkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChvcHRpb25zLCB7IGNvbnRlbnQgfSkpIHx8IGNvbnRlbnQ7XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB1aSxcbiAgICAgICAgY29udGVudFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc29sdmVQcmV2aW91cyA9IHJlc29sdmVGdW5jO1xuICAgICAgY29uc3QgbmV4dFJvdyA9IGRvbmUgPyBudWxsIDogbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgcmVzb2x2ZUZ1bmMgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgICByZXNvbHZlUHJldmlvdXMoe1xuICAgICAgICBuZXh0OiBuZXh0Um93LFxuICAgICAgICAuLi5wYXlsb2FkXG4gICAgICB9KTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHJlYWRDaHVuaygpO1xuICAgIH1cbiAgICByZWFkQ2h1bmsoKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxufTtcblxuLy8gc3RyZWFtcy9zdHJlYW1pbmctdGV4dC1yZXNwb25zZS50c1xudmFyIFN0cmVhbWluZ1RleHRSZXNwb25zZSA9IGNsYXNzIGV4dGVuZHMgUmVzcG9uc2Uge1xuICBjb25zdHJ1Y3RvcihyZXMsIGluaXQsIGRhdGEpIHtcbiAgICBsZXQgcHJvY2Vzc2VkU3RyZWFtID0gcmVzO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBwcm9jZXNzZWRTdHJlYW0gPSByZXMucGlwZVRocm91Z2goZGF0YS5zdHJlYW0pO1xuICAgIH1cbiAgICBzdXBlcihwcm9jZXNzZWRTdHJlYW0sIHtcbiAgICAgIC4uLmluaXQsXG4gICAgICBzdGF0dXM6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgIFtDT01QTEVYX0hFQURFUl06IGRhdGEgPyBcInRydWVcIiA6IFwiZmFsc2VcIixcbiAgICAgICAgLi4uaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBzdHJlYW1Ub1Jlc3BvbnNlKHJlcywgcmVzcG9uc2UsIGluaXQpIHtcbiAgcmVzcG9uc2Uud3JpdGVIZWFkKChpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgfHwgMjAwLCB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgLi4uaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzXG4gIH0pO1xuICBjb25zdCByZWFkZXIgPSByZXMuZ2V0UmVhZGVyKCk7XG4gIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgcmVhZGVyLnJlYWQoKS50aGVuKCh7IGRvbmUsIHZhbHVlIH0pID0+IHtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHJlc3BvbnNlLmVuZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNwb25zZS53cml0ZSh2YWx1ZSk7XG4gICAgICByZWFkKCk7XG4gICAgfSk7XG4gIH1cbiAgcmVhZCgpO1xufVxuZXhwb3J0IHtcbiAgQUlTdHJlYW0sXG4gIEFXU0JlZHJvY2tBbnRocm9waWNTdHJlYW0sXG4gIEFXU0JlZHJvY2tDb2hlcmVTdHJlYW0sXG4gIEFXU0JlZHJvY2tMbGFtYTJTdHJlYW0sXG4gIEFXU0JlZHJvY2tTdHJlYW0sXG4gIEFudGhyb3BpY1N0cmVhbSxcbiAgQ09NUExFWF9IRUFERVIsXG4gIENvaGVyZVN0cmVhbSxcbiAgR29vZ2xlR2VuZXJhdGl2ZUFJU3RyZWFtLFxuICBIdWdnaW5nRmFjZVN0cmVhbSxcbiAgTGFuZ0NoYWluU3RyZWFtLFxuICBPcGVuQUlTdHJlYW0sXG4gIFJlcGxpY2F0ZVN0cmVhbSxcbiAgU3RyZWFtaW5nVGV4dFJlc3BvbnNlLFxuICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcixcbiAgY3JlYXRlQ2h1bmtEZWNvZGVyLFxuICBjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyLFxuICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIsXG4gIGV4cGVyaW1lbnRhbF9Bc3Npc3RhbnRSZXNwb25zZSxcbiAgZXhwZXJpbWVudGFsX1N0cmVhbURhdGEsXG4gIGV4cGVyaW1lbnRhbF9TdHJlYW1pbmdSZWFjdFJlc3BvbnNlLFxuICBpc1N0cmVhbVN0cmluZ0VxdWFsVG9UeXBlLFxuICBuYW5vaWQsXG4gIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUsXG4gIHN0cmVhbVRvUmVzcG9uc2UsXG4gIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJjdXN0b21BbHBoYWJldCIsInRleHRTdHJlYW1QYXJ0IiwiY29kZSIsIm5hbWUiLCJwYXJzZSIsInZhbHVlIiwiRXJyb3IiLCJ0eXBlIiwiZnVuY3Rpb25DYWxsU3RyZWFtUGFydCIsImZ1bmN0aW9uX2NhbGwiLCJhcmd1bWVudHMiLCJkYXRhU3RyZWFtUGFydCIsIkFycmF5IiwiaXNBcnJheSIsImVycm9yU3RyZWFtUGFydCIsImFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0IiwiaWQiLCJyb2xlIiwiY29udGVudCIsImV2ZXJ5IiwiaXRlbSIsInRleHQiLCJhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQiLCJ0aHJlYWRJZCIsIm1lc3NhZ2VJZCIsImRhdGFNZXNzYWdlU3RyZWFtUGFydCIsInRvb2xDYWxsU3RyZWFtUGFydCIsInRvb2xfY2FsbHMiLCJzb21lIiwidGMiLCJmdW5jdGlvbiIsIm1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQiLCJzdHJlYW1QYXJ0cyIsInN0cmVhbVBhcnRzQnlDb2RlIiwiU3RyZWFtU3RyaW5nUHJlZml4ZXMiLCJ2YWxpZENvZGVzIiwibWFwIiwicGFydCIsInBhcnNlU3RyZWFtUGFydCIsImxpbmUiLCJmaXJzdFNlcGFyYXRvckluZGV4IiwiaW5kZXhPZiIsInByZWZpeCIsInNsaWNlIiwiaW5jbHVkZXMiLCJ0ZXh0VmFsdWUiLCJqc29uVmFsdWUiLCJKU09OIiwiZm9ybWF0U3RyZWFtUGFydCIsInN0cmVhbVBhcnQiLCJmaW5kIiwic3RyaW5naWZ5IiwibmFub2lkIiwiY3JlYXRlQ2h1bmtEZWNvZGVyIiwiY29tcGxleCIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImNodW5rIiwiZGVjb2RlIiwic3RyZWFtIiwiZGVjb2RlZCIsInNwbGl0IiwiZmlsdGVyIiwiQm9vbGVhbiIsImlzU3RyZWFtU3RyaW5nRXF1YWxUb1R5cGUiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJDT01QTEVYX0hFQURFUiIsImNyZWF0ZVBhcnNlciIsImNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIiLCJjdXN0b21QYXJzZXIiLCJ0ZXh0RGVjb2RlciIsImV2ZW50U291cmNlUGFyc2VyIiwiVHJhbnNmb3JtU3RyZWFtIiwic3RhcnQiLCJjb250cm9sbGVyIiwiZXZlbnQiLCJkYXRhIiwidGVybWluYXRlIiwicGFyc2VkTWVzc2FnZSIsImVucXVldWUiLCJ0cmFuc2Zvcm0iLCJmZWVkIiwiY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIiLCJjYiIsInRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJhZ2dyZWdhdGVkUmVzcG9uc2UiLCJjYWxsYmFja3MiLCJvblN0YXJ0IiwibWVzc2FnZSIsImVuY29kZSIsIm9uVG9rZW4iLCJmbHVzaCIsImlzT3BlbkFJQ2FsbGJhY2tzIiwiaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MiLCJvbkNvbXBsZXRpb24iLCJvbkZpbmFsIiwidHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIiLCJpc1N0cmVhbVN0YXJ0IiwidHJpbVN0YXJ0IiwiQUlTdHJlYW0iLCJyZXNwb25zZSIsIm9rIiwiYm9keSIsInJlYWRlciIsImdldFJlYWRlciIsIlJlYWRhYmxlU3RyZWFtIiwiZG9uZSIsInJlYWQiLCJlcnJvclRleHQiLCJlcnJvciIsInJlc3BvbnNlQm9keVN0cmVhbSIsImNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0iLCJwaXBlVGhyb3VnaCIsImNsb3NlIiwicmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSIsIml0ZXJhYmxlIiwiaXQiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwicHVsbCIsIm5leHQiLCJjYW5jZWwiLCJyZWFzb24iLCJfYSIsInJldHVybiIsImNhbGwiLCJleHBlcmltZW50YWxfU3RyZWFtRGF0YSIsImNvbnN0cnVjdG9yIiwiZW5jb2RlciIsImlzQ2xvc2VkUHJvbWlzZSIsImlzQ2xvc2VkUHJvbWlzZVJlc29sdmVyIiwiaXNDbG9zZWQiLCJtZXNzYWdlQW5ub3RhdGlvbnMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNlbGYiLCJsZW5ndGgiLCJlbmNvZGVkRGF0YSIsImVuY29kZWRNZXNzYWdlQW5ub3RhdGlvbnMiLCJ3YXJuaW5nVGltZW91dCIsInByb2Nlc3MiLCJzZXRUaW1lb3V0IiwiY29uc29sZSIsIndhcm4iLCJjbGVhclRpbWVvdXQiLCJhcHBlbmQiLCJwdXNoIiwiYXBwZW5kTWVzc2FnZUFubm90YXRpb24iLCJjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIiLCJleHBlcmltZW50YWxfc3RyZWFtRGF0YSIsInBhcnNlQW50aHJvcGljU3RyZWFtIiwicHJldmlvdXMiLCJqc29uIiwiY29tcGxldGlvbiIsImRlbHRhIiwic3RyZWFtYWJsZSIsIkFudGhyb3BpY1N0cmVhbSIsInJlcyIsImV4cGVyaW1lbnRhbF9Bc3Npc3RhbnRSZXNwb25zZSIsInByb2Nlc3MyIiwic2VuZE1lc3NhZ2UiLCJzZW5kRGF0YU1lc3NhZ2UiLCJzZW5kRXJyb3IiLCJlcnJvck1lc3NhZ2UiLCJSZXNwb25zZSIsInN0YXR1cyIsImhlYWRlcnMiLCJhc0RlbHRhSXRlcmFibGUiLCJleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rIiwiX2IiLCJieXRlcyIsImNodW5rVGV4dCIsImNodW5rSlNPTiIsIkFXU0JlZHJvY2tBbnRocm9waWNTdHJlYW0iLCJBV1NCZWRyb2NrU3RyZWFtIiwiQVdTQmVkcm9ja0NvaGVyZVN0cmVhbSIsImdlbmVyYXRpb25zIiwiQVdTQmVkcm9ja0xsYW1hMlN0cmVhbSIsImdlbmVyYXRpb24iLCJ1dGY4RGVjb2RlciIsInByb2Nlc3NMaW5lcyIsImxpbmVzIiwiaXNfZmluaXNoZWQiLCJyZWFkQW5kUHJvY2Vzc0xpbmVzIiwic2VnbWVudCIsImxpbmVzQXJyYXkiLCJwb3AiLCJjcmVhdGVQYXJzZXIyIiwic3RyZWFtYWJsZTIiLCJldmVudFR5cGUiLCJDb2hlcmVTdHJlYW0iLCJzdHJlYW1hYmxlMyIsIl9jIiwicGFydHMiLCJjYW5kaWRhdGVzIiwiZmlyc3RQYXJ0IiwiR29vZ2xlR2VuZXJhdGl2ZUFJU3RyZWFtIiwiY3JlYXRlUGFyc2VyMyIsInRyaW1TdGFydE9mU3RyZWFtIiwidG9rZW4iLCJnZW5lcmF0ZWRfdGV4dCIsIkh1Z2dpbmdGYWNlU3RyZWFtIiwiTGFuZ0NoYWluU3RyZWFtIiwid3JpdGVyIiwid3JpdGFibGUiLCJnZXRXcml0ZXIiLCJydW5zIiwiU2V0IiwiaGFuZGxlRXJyb3IiLCJlIiwicnVuSWQiLCJkZWxldGUiLCJyZWFkeSIsImFib3J0IiwiaGFuZGxlU3RhcnQiLCJhZGQiLCJoYW5kbGVFbmQiLCJzaXplIiwicmVhZGFibGUiLCJoYW5kbGVycyIsImhhbmRsZUxMTU5ld1Rva2VuIiwid3JpdGUiLCJoYW5kbGVMTE1TdGFydCIsIl9sbG0iLCJfcHJvbXB0cyIsImhhbmRsZUxMTUVuZCIsIl9vdXRwdXQiLCJoYW5kbGVMTE1FcnJvciIsImhhbmRsZUNoYWluU3RhcnQiLCJfY2hhaW4iLCJfaW5wdXRzIiwiaGFuZGxlQ2hhaW5FbmQiLCJfb3V0cHV0cyIsImhhbmRsZUNoYWluRXJyb3IiLCJoYW5kbGVUb29sU3RhcnQiLCJfdG9vbCIsIl9pbnB1dCIsImhhbmRsZVRvb2xFbmQiLCJoYW5kbGVUb29sRXJyb3IiLCJwYXJzZU9wZW5BSVN0cmVhbSIsImV4dHJhY3QiLCJjaHVua1RvVGV4dCIsInN0cmVhbWFibGU0IiwiY3JlYXRlZCIsImdldERhdGUiLCJvYmplY3QiLCJtb2RlbCIsImNob2ljZXMiLCJjaG9pY2UiLCJfZCIsIl9lIiwiX2YiLCJfZyIsImZ1bmN0aW9uQ2FsbCIsInRvb2xDYWxscyIsInRvb2xDYWxsIiwiaW5kZXgiLCJmaW5pc2hfcmVhc29uIiwiZmluaXNoUmVhc29uIiwiaXNGdW5jdGlvblN0cmVhbWluZ0luIiwiX2giLCJfaSIsIl9qIiwiX2siLCJfbCIsIl9tIiwiX24iLCJfbyIsIl9wIiwiX3EiLCJpc0NoYXRDb21wbGV0aW9uQ2h1bmsiLCJjbGVhbnVwQXJndW1lbnRzIiwiaXNDb21wbGV0aW9uIiwiYXJndW1lbnRDaHVuayIsImVzY2FwZWRQYXJ0aWFsSnNvbiIsInJlcGxhY2UiLCJfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sIiwiT3BlbkFJU3RyZWFtIiwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIiwiZXhwZXJpbWVudGFsX29uVG9vbENhbGwiLCJmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciIsImNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyIiwiaXNGaXJzdENodW5rIiwiYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlIiwiZnVuY3Rpb25DYWxsTWVzc2FnZXMiLCJpc0NvbXBsZXhNb2RlIiwic2hvdWxkSGFuZGxlQXNGdW5jdGlvbiIsInBheWxvYWQiLCJuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyIsImZ1bmN0aW9uUmVzcG9uc2UiLCJhcmd1bWVudHNQYXlsb2FkIiwicmVzdWx0IiwidG9vbHMiLCJ0b29sIiwiZnVuYyIsInJlc3BvbnNlSW5kZXgiLCJ0b29sX2NhbGxfaWQiLCJmdW5jdGlvbl9uYW1lIiwidG9vbF9jYWxsX3Jlc3VsdCIsImZpbHRlcmVkQ2FsbGJhY2tzIiwib3BlbkFJU3RyZWFtIiwiUmVwbGljYXRlU3RyZWFtIiwib3B0aW9ucyIsInVybCIsInVybHMiLCJldmVudFN0cmVhbSIsImZldGNoIiwibWV0aG9kIiwiQWNjZXB0IiwiTkVXTElORSIsImNoYXJDb2RlQXQiLCJjb25jYXRDaHVua3MiLCJjaHVua3MiLCJ0b3RhbExlbmd0aCIsImNvbmNhdGVuYXRlZENodW5rcyIsIlVpbnQ4QXJyYXkiLCJvZmZzZXQiLCJzZXQiLCJyZWFkRGF0YVN0cmVhbSIsImlzQWJvcnRlZCIsInN0cmVhbVBhcnRzMiIsImFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlIiwiYW5ub3RhdGlvbnMiLCJwYXJzZUNvbXBsZXhSZXNwb25zZSIsImFib3J0Q29udHJvbGxlclJlZiIsInVwZGF0ZSIsIm9uRmluaXNoIiwiZ2VuZXJhdGVJZCIsImdldEN1cnJlbnREYXRlIiwiRGF0ZSIsImNyZWF0ZWRBdCIsInByZWZpeE1hcCIsIm1lc3NhZ2VfYW5ub3RhdGlvbnMiLCJjdXJyZW50IiwiZnVuY3Rpb25DYWxsTWVzc2FnZSIsInRvb2xDYWxsTWVzc2FnZSIsInJlc3BvbnNlTWVzc2FnZSIsIm1lc3NhZ2VQcmVmaXhLZXlzIiwiZm9yRWFjaCIsImtleSIsIm1lcmdlZCIsIm1lc3NhZ2VzIiwiZXhwZXJpbWVudGFsX1N0cmVhbWluZ1JlYWN0UmVzcG9uc2UiLCJyZXNvbHZlRnVuYyIsInByb2Nlc3NlZFN0cmVhbSIsImxhc3RQYXlsb2FkIiwiX2EyIiwiY29udGVudDIiLCJ1aSIsInJlc29sdmVQcmV2aW91cyIsIm5leHRSb3ciLCJyZWFkQ2h1bmsiLCJTdHJlYW1pbmdUZXh0UmVzcG9uc2UiLCJpbml0Iiwic3RyZWFtVG9SZXNwb25zZSIsIndyaXRlSGVhZCIsInRoZW4iLCJlbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/node_modules/nanoid/non-secure/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ai/node_modules/nanoid/non-secure/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),\n/* harmony export */   nanoid: () => (/* binding */ nanoid)\n/* harmony export */ });\nlet urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nlet customAlphabet = (alphabet, defaultSize = 21)=>{\n    return (size = defaultSize)=>{\n        let id = \"\";\n        let i = size;\n        while(i--){\n            id += alphabet[Math.random() * alphabet.length | 0];\n        }\n        return id;\n    };\n};\nlet nanoid = (size = 21)=>{\n    let id = \"\";\n    let i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsSUFBSUEsY0FDRjtBQUNGLElBQUlDLGlCQUFpQixDQUFDQyxVQUFVQyxjQUFjLEVBQUU7SUFDOUMsT0FBTyxDQUFDQyxPQUFPRCxXQUFXO1FBQ3hCLElBQUlFLEtBQUs7UUFDVCxJQUFJQyxJQUFJRjtRQUNSLE1BQU9FLElBQUs7WUFDVkQsTUFBTUgsUUFBUSxDQUFDLEtBQU1NLE1BQU0sS0FBS04sU0FBU08sTUFBTSxHQUFJLEVBQUU7UUFDdkQ7UUFDQSxPQUFPSjtJQUNUO0FBQ0Y7QUFDQSxJQUFJSyxTQUFTLENBQUNOLE9BQU8sRUFBRTtJQUNyQixJQUFJQyxLQUFLO0lBQ1QsSUFBSUMsSUFBSUY7SUFDUixNQUFPRSxJQUFLO1FBQ1ZELE1BQU1MLFdBQVcsQ0FBQyxLQUFNUSxNQUFNLEtBQUssS0FBTSxFQUFFO0lBQzdDO0lBQ0EsT0FBT0g7QUFDVDtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N5bmNjaGF0Ly4vbm9kZV9tb2R1bGVzL2FpL25vZGVfbW9kdWxlcy9uYW5vaWQvbm9uLXNlY3VyZS9pbmRleC5qcz8zNzRmIl0sInNvdXJjZXNDb250ZW50IjpbImxldCB1cmxBbHBoYWJldCA9XG4gICd1c2VhbmRvbS0yNlQxOTgzNDBQWDc1cHhKQUNLVkVSWU1JTkRCVVNIV09MRl9HUVpiZmdoamtscXZ3eXpyaWN0J1xubGV0IGN1c3RvbUFscGhhYmV0ID0gKGFscGhhYmV0LCBkZWZhdWx0U2l6ZSA9IDIxKSA9PiB7XG4gIHJldHVybiAoc2l6ZSA9IGRlZmF1bHRTaXplKSA9PiB7XG4gICAgbGV0IGlkID0gJydcbiAgICBsZXQgaSA9IHNpemVcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZCArPSBhbHBoYWJldFsoTWF0aC5yYW5kb20oKSAqIGFscGhhYmV0Lmxlbmd0aCkgfCAwXVxuICAgIH1cbiAgICByZXR1cm4gaWRcbiAgfVxufVxubGV0IG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gJydcbiAgbGV0IGkgPSBzaXplXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZCArPSB1cmxBbHBoYWJldFsoTWF0aC5yYW5kb20oKSAqIDY0KSB8IDBdXG4gIH1cbiAgcmV0dXJuIGlkXG59XG5leHBvcnQgeyBuYW5vaWQsIGN1c3RvbUFscGhhYmV0IH1cbiJdLCJuYW1lcyI6WyJ1cmxBbHBoYWJldCIsImN1c3RvbUFscGhhYmV0IiwiYWxwaGFiZXQiLCJkZWZhdWx0U2l6ZSIsInNpemUiLCJpZCIsImkiLCJNYXRoIiwicmFuZG9tIiwibGVuZ3RoIiwibmFub2lkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\n");

/***/ })

};
;