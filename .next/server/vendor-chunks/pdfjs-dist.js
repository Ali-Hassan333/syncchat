"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdfjs-dist";
exports.ids = ["vendor-chunks/pdfjs-dist"];
exports.modules = {

/***/ "(ssr)/./node_modules/pdfjs-dist/build/pdf.js":
/*!**********************************************!*\
  !*** ./node_modules/pdfjs-dist/build/pdf.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2023 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = root.pdfjsLib = factory();\n    else {}\n})(globalThis, ()=>{\n    return /******/ (()=>{\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = [\n            ,\n            /* 1 */ /***/ (__unused_webpack_module, exports1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.VerbosityLevel = exports1.Util = exports1.UnknownErrorException = exports1.UnexpectedResponseException = exports1.TextRenderingMode = exports1.RenderingIntentFlag = exports1.PromiseCapability = exports1.PermissionFlag = exports1.PasswordResponses = exports1.PasswordException = exports1.PageActionEventType = exports1.OPS = exports1.MissingPDFException = exports1.MAX_IMAGE_SIZE_TO_CACHE = exports1.LINE_FACTOR = exports1.LINE_DESCENT_FACTOR = exports1.InvalidPDFException = exports1.ImageKind = exports1.IDENTITY_MATRIX = exports1.FormatError = exports1.FeatureTest = exports1.FONT_IDENTITY_MATRIX = exports1.DocumentActionEventType = exports1.CMapCompressionType = exports1.BaseException = exports1.BASELINE_FACTOR = exports1.AnnotationType = exports1.AnnotationReplyType = exports1.AnnotationPrefix = exports1.AnnotationMode = exports1.AnnotationFlag = exports1.AnnotationFieldFlag = exports1.AnnotationEditorType = exports1.AnnotationEditorPrefix = exports1.AnnotationEditorParamsType = exports1.AnnotationBorderStyleType = exports1.AnnotationActionEventType = exports1.AbortException = void 0;\n                exports1.assert = assert;\n                exports1.bytesToString = bytesToString;\n                exports1.createValidAbsoluteUrl = createValidAbsoluteUrl;\n                exports1.getModificationDate = getModificationDate;\n                exports1.getUuid = getUuid;\n                exports1.getVerbosityLevel = getVerbosityLevel;\n                exports1.info = info;\n                exports1.isArrayBuffer = isArrayBuffer;\n                exports1.isArrayEqual = isArrayEqual;\n                exports1.isNodeJS = void 0;\n                exports1.normalizeUnicode = normalizeUnicode;\n                exports1.objectFromMap = objectFromMap;\n                exports1.objectSize = objectSize;\n                exports1.setVerbosityLevel = setVerbosityLevel;\n                exports1.shadow = shadow;\n                exports1.string32 = string32;\n                exports1.stringToBytes = stringToBytes;\n                exports1.stringToPDFString = stringToPDFString;\n                exports1.stringToUTF8String = stringToUTF8String;\n                exports1.unreachable = unreachable;\n                exports1.utf8StringToString = utf8StringToString;\n                exports1.warn = warn;\n                const isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\n                exports1.isNodeJS = isNodeJS;\n                const IDENTITY_MATRIX = [\n                    1,\n                    0,\n                    0,\n                    1,\n                    0,\n                    0\n                ];\n                exports1.IDENTITY_MATRIX = IDENTITY_MATRIX;\n                const FONT_IDENTITY_MATRIX = [\n                    0.001,\n                    0,\n                    0,\n                    0.001,\n                    0,\n                    0\n                ];\n                exports1.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;\n                const MAX_IMAGE_SIZE_TO_CACHE = 10e6;\n                exports1.MAX_IMAGE_SIZE_TO_CACHE = MAX_IMAGE_SIZE_TO_CACHE;\n                const LINE_FACTOR = 1.35;\n                exports1.LINE_FACTOR = LINE_FACTOR;\n                const LINE_DESCENT_FACTOR = 0.35;\n                exports1.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;\n                const BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;\n                exports1.BASELINE_FACTOR = BASELINE_FACTOR;\n                const RenderingIntentFlag = {\n                    ANY: 0x01,\n                    DISPLAY: 0x02,\n                    PRINT: 0x04,\n                    SAVE: 0x08,\n                    ANNOTATIONS_FORMS: 0x10,\n                    ANNOTATIONS_STORAGE: 0x20,\n                    ANNOTATIONS_DISABLE: 0x40,\n                    OPLIST: 0x100\n                };\n                exports1.RenderingIntentFlag = RenderingIntentFlag;\n                const AnnotationMode = {\n                    DISABLE: 0,\n                    ENABLE: 1,\n                    ENABLE_FORMS: 2,\n                    ENABLE_STORAGE: 3\n                };\n                exports1.AnnotationMode = AnnotationMode;\n                const AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\n                exports1.AnnotationEditorPrefix = AnnotationEditorPrefix;\n                const AnnotationEditorType = {\n                    DISABLE: -1,\n                    NONE: 0,\n                    FREETEXT: 3,\n                    STAMP: 13,\n                    INK: 15\n                };\n                exports1.AnnotationEditorType = AnnotationEditorType;\n                const AnnotationEditorParamsType = {\n                    RESIZE: 1,\n                    CREATE: 2,\n                    FREETEXT_SIZE: 11,\n                    FREETEXT_COLOR: 12,\n                    FREETEXT_OPACITY: 13,\n                    INK_COLOR: 21,\n                    INK_THICKNESS: 22,\n                    INK_OPACITY: 23\n                };\n                exports1.AnnotationEditorParamsType = AnnotationEditorParamsType;\n                const PermissionFlag = {\n                    PRINT: 0x04,\n                    MODIFY_CONTENTS: 0x08,\n                    COPY: 0x10,\n                    MODIFY_ANNOTATIONS: 0x20,\n                    FILL_INTERACTIVE_FORMS: 0x100,\n                    COPY_FOR_ACCESSIBILITY: 0x200,\n                    ASSEMBLE: 0x400,\n                    PRINT_HIGH_QUALITY: 0x800\n                };\n                exports1.PermissionFlag = PermissionFlag;\n                const TextRenderingMode = {\n                    FILL: 0,\n                    STROKE: 1,\n                    FILL_STROKE: 2,\n                    INVISIBLE: 3,\n                    FILL_ADD_TO_PATH: 4,\n                    STROKE_ADD_TO_PATH: 5,\n                    FILL_STROKE_ADD_TO_PATH: 6,\n                    ADD_TO_PATH: 7,\n                    FILL_STROKE_MASK: 3,\n                    ADD_TO_PATH_FLAG: 4\n                };\n                exports1.TextRenderingMode = TextRenderingMode;\n                const ImageKind = {\n                    GRAYSCALE_1BPP: 1,\n                    RGB_24BPP: 2,\n                    RGBA_32BPP: 3\n                };\n                exports1.ImageKind = ImageKind;\n                const AnnotationType = {\n                    TEXT: 1,\n                    LINK: 2,\n                    FREETEXT: 3,\n                    LINE: 4,\n                    SQUARE: 5,\n                    CIRCLE: 6,\n                    POLYGON: 7,\n                    POLYLINE: 8,\n                    HIGHLIGHT: 9,\n                    UNDERLINE: 10,\n                    SQUIGGLY: 11,\n                    STRIKEOUT: 12,\n                    STAMP: 13,\n                    CARET: 14,\n                    INK: 15,\n                    POPUP: 16,\n                    FILEATTACHMENT: 17,\n                    SOUND: 18,\n                    MOVIE: 19,\n                    WIDGET: 20,\n                    SCREEN: 21,\n                    PRINTERMARK: 22,\n                    TRAPNET: 23,\n                    WATERMARK: 24,\n                    THREED: 25,\n                    REDACT: 26\n                };\n                exports1.AnnotationType = AnnotationType;\n                const AnnotationReplyType = {\n                    GROUP: \"Group\",\n                    REPLY: \"R\"\n                };\n                exports1.AnnotationReplyType = AnnotationReplyType;\n                const AnnotationFlag = {\n                    INVISIBLE: 0x01,\n                    HIDDEN: 0x02,\n                    PRINT: 0x04,\n                    NOZOOM: 0x08,\n                    NOROTATE: 0x10,\n                    NOVIEW: 0x20,\n                    READONLY: 0x40,\n                    LOCKED: 0x80,\n                    TOGGLENOVIEW: 0x100,\n                    LOCKEDCONTENTS: 0x200\n                };\n                exports1.AnnotationFlag = AnnotationFlag;\n                const AnnotationFieldFlag = {\n                    READONLY: 0x0000001,\n                    REQUIRED: 0x0000002,\n                    NOEXPORT: 0x0000004,\n                    MULTILINE: 0x0001000,\n                    PASSWORD: 0x0002000,\n                    NOTOGGLETOOFF: 0x0004000,\n                    RADIO: 0x0008000,\n                    PUSHBUTTON: 0x0010000,\n                    COMBO: 0x0020000,\n                    EDIT: 0x0040000,\n                    SORT: 0x0080000,\n                    FILESELECT: 0x0100000,\n                    MULTISELECT: 0x0200000,\n                    DONOTSPELLCHECK: 0x0400000,\n                    DONOTSCROLL: 0x0800000,\n                    COMB: 0x1000000,\n                    RICHTEXT: 0x2000000,\n                    RADIOSINUNISON: 0x2000000,\n                    COMMITONSELCHANGE: 0x4000000\n                };\n                exports1.AnnotationFieldFlag = AnnotationFieldFlag;\n                const AnnotationBorderStyleType = {\n                    SOLID: 1,\n                    DASHED: 2,\n                    BEVELED: 3,\n                    INSET: 4,\n                    UNDERLINE: 5\n                };\n                exports1.AnnotationBorderStyleType = AnnotationBorderStyleType;\n                const AnnotationActionEventType = {\n                    E: \"Mouse Enter\",\n                    X: \"Mouse Exit\",\n                    D: \"Mouse Down\",\n                    U: \"Mouse Up\",\n                    Fo: \"Focus\",\n                    Bl: \"Blur\",\n                    PO: \"PageOpen\",\n                    PC: \"PageClose\",\n                    PV: \"PageVisible\",\n                    PI: \"PageInvisible\",\n                    K: \"Keystroke\",\n                    F: \"Format\",\n                    V: \"Validate\",\n                    C: \"Calculate\"\n                };\n                exports1.AnnotationActionEventType = AnnotationActionEventType;\n                const DocumentActionEventType = {\n                    WC: \"WillClose\",\n                    WS: \"WillSave\",\n                    DS: \"DidSave\",\n                    WP: \"WillPrint\",\n                    DP: \"DidPrint\"\n                };\n                exports1.DocumentActionEventType = DocumentActionEventType;\n                const PageActionEventType = {\n                    O: \"PageOpen\",\n                    C: \"PageClose\"\n                };\n                exports1.PageActionEventType = PageActionEventType;\n                const VerbosityLevel = {\n                    ERRORS: 0,\n                    WARNINGS: 1,\n                    INFOS: 5\n                };\n                exports1.VerbosityLevel = VerbosityLevel;\n                const CMapCompressionType = {\n                    NONE: 0,\n                    BINARY: 1\n                };\n                exports1.CMapCompressionType = CMapCompressionType;\n                const OPS = {\n                    dependency: 1,\n                    setLineWidth: 2,\n                    setLineCap: 3,\n                    setLineJoin: 4,\n                    setMiterLimit: 5,\n                    setDash: 6,\n                    setRenderingIntent: 7,\n                    setFlatness: 8,\n                    setGState: 9,\n                    save: 10,\n                    restore: 11,\n                    transform: 12,\n                    moveTo: 13,\n                    lineTo: 14,\n                    curveTo: 15,\n                    curveTo2: 16,\n                    curveTo3: 17,\n                    closePath: 18,\n                    rectangle: 19,\n                    stroke: 20,\n                    closeStroke: 21,\n                    fill: 22,\n                    eoFill: 23,\n                    fillStroke: 24,\n                    eoFillStroke: 25,\n                    closeFillStroke: 26,\n                    closeEOFillStroke: 27,\n                    endPath: 28,\n                    clip: 29,\n                    eoClip: 30,\n                    beginText: 31,\n                    endText: 32,\n                    setCharSpacing: 33,\n                    setWordSpacing: 34,\n                    setHScale: 35,\n                    setLeading: 36,\n                    setFont: 37,\n                    setTextRenderingMode: 38,\n                    setTextRise: 39,\n                    moveText: 40,\n                    setLeadingMoveText: 41,\n                    setTextMatrix: 42,\n                    nextLine: 43,\n                    showText: 44,\n                    showSpacedText: 45,\n                    nextLineShowText: 46,\n                    nextLineSetSpacingShowText: 47,\n                    setCharWidth: 48,\n                    setCharWidthAndBounds: 49,\n                    setStrokeColorSpace: 50,\n                    setFillColorSpace: 51,\n                    setStrokeColor: 52,\n                    setStrokeColorN: 53,\n                    setFillColor: 54,\n                    setFillColorN: 55,\n                    setStrokeGray: 56,\n                    setFillGray: 57,\n                    setStrokeRGBColor: 58,\n                    setFillRGBColor: 59,\n                    setStrokeCMYKColor: 60,\n                    setFillCMYKColor: 61,\n                    shadingFill: 62,\n                    beginInlineImage: 63,\n                    beginImageData: 64,\n                    endInlineImage: 65,\n                    paintXObject: 66,\n                    markPoint: 67,\n                    markPointProps: 68,\n                    beginMarkedContent: 69,\n                    beginMarkedContentProps: 70,\n                    endMarkedContent: 71,\n                    beginCompat: 72,\n                    endCompat: 73,\n                    paintFormXObjectBegin: 74,\n                    paintFormXObjectEnd: 75,\n                    beginGroup: 76,\n                    endGroup: 77,\n                    beginAnnotation: 80,\n                    endAnnotation: 81,\n                    paintImageMaskXObject: 83,\n                    paintImageMaskXObjectGroup: 84,\n                    paintImageXObject: 85,\n                    paintInlineImageXObject: 86,\n                    paintInlineImageXObjectGroup: 87,\n                    paintImageXObjectRepeat: 88,\n                    paintImageMaskXObjectRepeat: 89,\n                    paintSolidColorImageMask: 90,\n                    constructPath: 91\n                };\n                exports1.OPS = OPS;\n                const PasswordResponses = {\n                    NEED_PASSWORD: 1,\n                    INCORRECT_PASSWORD: 2\n                };\n                exports1.PasswordResponses = PasswordResponses;\n                let verbosity = VerbosityLevel.WARNINGS;\n                function setVerbosityLevel(level) {\n                    if (Number.isInteger(level)) {\n                        verbosity = level;\n                    }\n                }\n                function getVerbosityLevel() {\n                    return verbosity;\n                }\n                function info(msg) {\n                    if (verbosity >= VerbosityLevel.INFOS) {\n                        console.log(`Info: ${msg}`);\n                    }\n                }\n                function warn(msg) {\n                    if (verbosity >= VerbosityLevel.WARNINGS) {\n                        console.log(`Warning: ${msg}`);\n                    }\n                }\n                function unreachable(msg) {\n                    throw new Error(msg);\n                }\n                function assert(cond, msg) {\n                    if (!cond) {\n                        unreachable(msg);\n                    }\n                }\n                function _isValidProtocol(url) {\n                    switch(url?.protocol){\n                        case \"http:\":\n                        case \"https:\":\n                        case \"ftp:\":\n                        case \"mailto:\":\n                        case \"tel:\":\n                            return true;\n                        default:\n                            return false;\n                    }\n                }\n                function createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n                    if (!url) {\n                        return null;\n                    }\n                    try {\n                        if (options && typeof url === \"string\") {\n                            if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n                                const dots = url.match(/\\./g);\n                                if (dots?.length >= 2) {\n                                    url = `http://${url}`;\n                                }\n                            }\n                            if (options.tryConvertEncoding) {\n                                try {\n                                    url = stringToUTF8String(url);\n                                } catch  {}\n                            }\n                        }\n                        const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n                        if (_isValidProtocol(absoluteUrl)) {\n                            return absoluteUrl;\n                        }\n                    } catch  {}\n                    return null;\n                }\n                function shadow(obj, prop, value, nonSerializable = false) {\n                    Object.defineProperty(obj, prop, {\n                        value,\n                        enumerable: !nonSerializable,\n                        configurable: true,\n                        writable: false\n                    });\n                    return value;\n                }\n                const BaseException = function BaseExceptionClosure() {\n                    function BaseException(message, name) {\n                        if (this.constructor === BaseException) {\n                            unreachable(\"Cannot initialize BaseException.\");\n                        }\n                        this.message = message;\n                        this.name = name;\n                    }\n                    BaseException.prototype = new Error();\n                    BaseException.constructor = BaseException;\n                    return BaseException;\n                }();\n                exports1.BaseException = BaseException;\n                class PasswordException extends BaseException {\n                    constructor(msg, code){\n                        super(msg, \"PasswordException\");\n                        this.code = code;\n                    }\n                }\n                exports1.PasswordException = PasswordException;\n                class UnknownErrorException extends BaseException {\n                    constructor(msg, details){\n                        super(msg, \"UnknownErrorException\");\n                        this.details = details;\n                    }\n                }\n                exports1.UnknownErrorException = UnknownErrorException;\n                class InvalidPDFException extends BaseException {\n                    constructor(msg){\n                        super(msg, \"InvalidPDFException\");\n                    }\n                }\n                exports1.InvalidPDFException = InvalidPDFException;\n                class MissingPDFException extends BaseException {\n                    constructor(msg){\n                        super(msg, \"MissingPDFException\");\n                    }\n                }\n                exports1.MissingPDFException = MissingPDFException;\n                class UnexpectedResponseException extends BaseException {\n                    constructor(msg, status){\n                        super(msg, \"UnexpectedResponseException\");\n                        this.status = status;\n                    }\n                }\n                exports1.UnexpectedResponseException = UnexpectedResponseException;\n                class FormatError extends BaseException {\n                    constructor(msg){\n                        super(msg, \"FormatError\");\n                    }\n                }\n                exports1.FormatError = FormatError;\n                class AbortException extends BaseException {\n                    constructor(msg){\n                        super(msg, \"AbortException\");\n                    }\n                }\n                exports1.AbortException = AbortException;\n                function bytesToString(bytes) {\n                    if (typeof bytes !== \"object\" || bytes?.length === undefined) {\n                        unreachable(\"Invalid argument for bytesToString\");\n                    }\n                    const length = bytes.length;\n                    const MAX_ARGUMENT_COUNT = 8192;\n                    if (length < MAX_ARGUMENT_COUNT) {\n                        return String.fromCharCode.apply(null, bytes);\n                    }\n                    const strBuf = [];\n                    for(let i = 0; i < length; i += MAX_ARGUMENT_COUNT){\n                        const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n                        const chunk = bytes.subarray(i, chunkEnd);\n                        strBuf.push(String.fromCharCode.apply(null, chunk));\n                    }\n                    return strBuf.join(\"\");\n                }\n                function stringToBytes(str) {\n                    if (typeof str !== \"string\") {\n                        unreachable(\"Invalid argument for stringToBytes\");\n                    }\n                    const length = str.length;\n                    const bytes = new Uint8Array(length);\n                    for(let i = 0; i < length; ++i){\n                        bytes[i] = str.charCodeAt(i) & 0xff;\n                    }\n                    return bytes;\n                }\n                function string32(value) {\n                    return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n                }\n                function objectSize(obj) {\n                    return Object.keys(obj).length;\n                }\n                function objectFromMap(map) {\n                    const obj = Object.create(null);\n                    for (const [key, value] of map){\n                        obj[key] = value;\n                    }\n                    return obj;\n                }\n                function isLittleEndian() {\n                    const buffer8 = new Uint8Array(4);\n                    buffer8[0] = 1;\n                    const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n                    return view32[0] === 1;\n                }\n                function isEvalSupported() {\n                    try {\n                        new Function(\"\");\n                        return true;\n                    } catch  {\n                        return false;\n                    }\n                }\n                class FeatureTest {\n                    static get isLittleEndian() {\n                        return shadow(this, \"isLittleEndian\", isLittleEndian());\n                    }\n                    static get isEvalSupported() {\n                        return shadow(this, \"isEvalSupported\", isEvalSupported());\n                    }\n                    static get isOffscreenCanvasSupported() {\n                        return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n                    }\n                    static get platform() {\n                        if (typeof navigator === \"undefined\") {\n                            return shadow(this, \"platform\", {\n                                isWin: false,\n                                isMac: false\n                            });\n                        }\n                        return shadow(this, \"platform\", {\n                            isWin: navigator.platform.includes(\"Win\"),\n                            isMac: navigator.platform.includes(\"Mac\")\n                        });\n                    }\n                    static get isCSSRoundSupported() {\n                        return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n                    }\n                }\n                exports1.FeatureTest = FeatureTest;\n                const hexNumbers = [\n                    ...Array(256).keys()\n                ].map((n)=>n.toString(16).padStart(2, \"0\"));\n                class Util {\n                    static makeHexColor(r, g, b) {\n                        return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n                    }\n                    static scaleMinMax(transform, minMax) {\n                        let temp;\n                        if (transform[0]) {\n                            if (transform[0] < 0) {\n                                temp = minMax[0];\n                                minMax[0] = minMax[1];\n                                minMax[1] = temp;\n                            }\n                            minMax[0] *= transform[0];\n                            minMax[1] *= transform[0];\n                            if (transform[3] < 0) {\n                                temp = minMax[2];\n                                minMax[2] = minMax[3];\n                                minMax[3] = temp;\n                            }\n                            minMax[2] *= transform[3];\n                            minMax[3] *= transform[3];\n                        } else {\n                            temp = minMax[0];\n                            minMax[0] = minMax[2];\n                            minMax[2] = temp;\n                            temp = minMax[1];\n                            minMax[1] = minMax[3];\n                            minMax[3] = temp;\n                            if (transform[1] < 0) {\n                                temp = minMax[2];\n                                minMax[2] = minMax[3];\n                                minMax[3] = temp;\n                            }\n                            minMax[2] *= transform[1];\n                            minMax[3] *= transform[1];\n                            if (transform[2] < 0) {\n                                temp = minMax[0];\n                                minMax[0] = minMax[1];\n                                minMax[1] = temp;\n                            }\n                            minMax[0] *= transform[2];\n                            minMax[1] *= transform[2];\n                        }\n                        minMax[0] += transform[4];\n                        minMax[1] += transform[4];\n                        minMax[2] += transform[5];\n                        minMax[3] += transform[5];\n                    }\n                    static transform(m1, m2) {\n                        return [\n                            m1[0] * m2[0] + m1[2] * m2[1],\n                            m1[1] * m2[0] + m1[3] * m2[1],\n                            m1[0] * m2[2] + m1[2] * m2[3],\n                            m1[1] * m2[2] + m1[3] * m2[3],\n                            m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n                            m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n                        ];\n                    }\n                    static applyTransform(p, m) {\n                        const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n                        const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n                        return [\n                            xt,\n                            yt\n                        ];\n                    }\n                    static applyInverseTransform(p, m) {\n                        const d = m[0] * m[3] - m[1] * m[2];\n                        const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n                        const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n                        return [\n                            xt,\n                            yt\n                        ];\n                    }\n                    static getAxialAlignedBoundingBox(r, m) {\n                        const p1 = this.applyTransform(r, m);\n                        const p2 = this.applyTransform(r.slice(2, 4), m);\n                        const p3 = this.applyTransform([\n                            r[0],\n                            r[3]\n                        ], m);\n                        const p4 = this.applyTransform([\n                            r[2],\n                            r[1]\n                        ], m);\n                        return [\n                            Math.min(p1[0], p2[0], p3[0], p4[0]),\n                            Math.min(p1[1], p2[1], p3[1], p4[1]),\n                            Math.max(p1[0], p2[0], p3[0], p4[0]),\n                            Math.max(p1[1], p2[1], p3[1], p4[1])\n                        ];\n                    }\n                    static inverseTransform(m) {\n                        const d = m[0] * m[3] - m[1] * m[2];\n                        return [\n                            m[3] / d,\n                            -m[1] / d,\n                            -m[2] / d,\n                            m[0] / d,\n                            (m[2] * m[5] - m[4] * m[3]) / d,\n                            (m[4] * m[1] - m[5] * m[0]) / d\n                        ];\n                    }\n                    static singularValueDecompose2dScale(m) {\n                        const transpose = [\n                            m[0],\n                            m[2],\n                            m[1],\n                            m[3]\n                        ];\n                        const a = m[0] * transpose[0] + m[1] * transpose[2];\n                        const b = m[0] * transpose[1] + m[1] * transpose[3];\n                        const c = m[2] * transpose[0] + m[3] * transpose[2];\n                        const d = m[2] * transpose[1] + m[3] * transpose[3];\n                        const first = (a + d) / 2;\n                        const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;\n                        const sx = first + second || 1;\n                        const sy = first - second || 1;\n                        return [\n                            Math.sqrt(sx),\n                            Math.sqrt(sy)\n                        ];\n                    }\n                    static normalizeRect(rect) {\n                        const r = rect.slice(0);\n                        if (rect[0] > rect[2]) {\n                            r[0] = rect[2];\n                            r[2] = rect[0];\n                        }\n                        if (rect[1] > rect[3]) {\n                            r[1] = rect[3];\n                            r[3] = rect[1];\n                        }\n                        return r;\n                    }\n                    static intersect(rect1, rect2) {\n                        const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n                        const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n                        if (xLow > xHigh) {\n                            return null;\n                        }\n                        const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n                        const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n                        if (yLow > yHigh) {\n                            return null;\n                        }\n                        return [\n                            xLow,\n                            yLow,\n                            xHigh,\n                            yHigh\n                        ];\n                    }\n                    static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {\n                        const tvalues = [], bounds = [\n                            [],\n                            []\n                        ];\n                        let a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n                        for(let i = 0; i < 2; ++i){\n                            if (i === 0) {\n                                b = 6 * x0 - 12 * x1 + 6 * x2;\n                                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                                c = 3 * x1 - 3 * x0;\n                            } else {\n                                b = 6 * y0 - 12 * y1 + 6 * y2;\n                                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                                c = 3 * y1 - 3 * y0;\n                            }\n                            if (Math.abs(a) < 1e-12) {\n                                if (Math.abs(b) < 1e-12) {\n                                    continue;\n                                }\n                                t = -c / b;\n                                if (0 < t && t < 1) {\n                                    tvalues.push(t);\n                                }\n                                continue;\n                            }\n                            b2ac = b * b - 4 * c * a;\n                            sqrtb2ac = Math.sqrt(b2ac);\n                            if (b2ac < 0) {\n                                continue;\n                            }\n                            t1 = (-b + sqrtb2ac) / (2 * a);\n                            if (0 < t1 && t1 < 1) {\n                                tvalues.push(t1);\n                            }\n                            t2 = (-b - sqrtb2ac) / (2 * a);\n                            if (0 < t2 && t2 < 1) {\n                                tvalues.push(t2);\n                            }\n                        }\n                        let j = tvalues.length, mt;\n                        const jlen = j;\n                        while(j--){\n                            t = tvalues[j];\n                            mt = 1 - t;\n                            bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n                            bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n                        }\n                        bounds[0][jlen] = x0;\n                        bounds[1][jlen] = y0;\n                        bounds[0][jlen + 1] = x3;\n                        bounds[1][jlen + 1] = y3;\n                        bounds[0].length = bounds[1].length = jlen + 2;\n                        return [\n                            Math.min(...bounds[0]),\n                            Math.min(...bounds[1]),\n                            Math.max(...bounds[0]),\n                            Math.max(...bounds[1])\n                        ];\n                    }\n                }\n                exports1.Util = Util;\n                const PDFStringTranslateTable = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0x2d8,\n                    0x2c7,\n                    0x2c6,\n                    0x2d9,\n                    0x2dd,\n                    0x2db,\n                    0x2da,\n                    0x2dc,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0x2022,\n                    0x2020,\n                    0x2021,\n                    0x2026,\n                    0x2014,\n                    0x2013,\n                    0x192,\n                    0x2044,\n                    0x2039,\n                    0x203a,\n                    0x2212,\n                    0x2030,\n                    0x201e,\n                    0x201c,\n                    0x201d,\n                    0x2018,\n                    0x2019,\n                    0x201a,\n                    0x2122,\n                    0xfb01,\n                    0xfb02,\n                    0x141,\n                    0x152,\n                    0x160,\n                    0x178,\n                    0x17d,\n                    0x131,\n                    0x142,\n                    0x153,\n                    0x161,\n                    0x17e,\n                    0,\n                    0x20ac\n                ];\n                function stringToPDFString(str) {\n                    if (str[0] >= \"\\xef\") {\n                        let encoding;\n                        if (str[0] === \"\\xfe\" && str[1] === \"\\xff\") {\n                            encoding = \"utf-16be\";\n                        } else if (str[0] === \"\\xff\" && str[1] === \"\\xfe\") {\n                            encoding = \"utf-16le\";\n                        } else if (str[0] === \"\\xef\" && str[1] === \"\\xbb\" && str[2] === \"\\xbf\") {\n                            encoding = \"utf-8\";\n                        }\n                        if (encoding) {\n                            try {\n                                const decoder = new TextDecoder(encoding, {\n                                    fatal: true\n                                });\n                                const buffer = stringToBytes(str);\n                                return decoder.decode(buffer);\n                            } catch (ex) {\n                                warn(`stringToPDFString: \"${ex}\".`);\n                            }\n                        }\n                    }\n                    const strBuf = [];\n                    for(let i = 0, ii = str.length; i < ii; i++){\n                        const code = PDFStringTranslateTable[str.charCodeAt(i)];\n                        strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n                    }\n                    return strBuf.join(\"\");\n                }\n                function stringToUTF8String(str) {\n                    return decodeURIComponent(escape(str));\n                }\n                function utf8StringToString(str) {\n                    return unescape(encodeURIComponent(str));\n                }\n                function isArrayBuffer(v) {\n                    return typeof v === \"object\" && v?.byteLength !== undefined;\n                }\n                function isArrayEqual(arr1, arr2) {\n                    if (arr1.length !== arr2.length) {\n                        return false;\n                    }\n                    for(let i = 0, ii = arr1.length; i < ii; i++){\n                        if (arr1[i] !== arr2[i]) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                function getModificationDate(date = new Date()) {\n                    const buffer = [\n                        date.getUTCFullYear().toString(),\n                        (date.getUTCMonth() + 1).toString().padStart(2, \"0\"),\n                        date.getUTCDate().toString().padStart(2, \"0\"),\n                        date.getUTCHours().toString().padStart(2, \"0\"),\n                        date.getUTCMinutes().toString().padStart(2, \"0\"),\n                        date.getUTCSeconds().toString().padStart(2, \"0\")\n                    ];\n                    return buffer.join(\"\");\n                }\n                class PromiseCapability {\n                    #settled;\n                    constructor(){\n                        this.#settled = false;\n                        this.promise = new Promise((resolve, reject)=>{\n                            this.resolve = (data)=>{\n                                this.#settled = true;\n                                resolve(data);\n                            };\n                            this.reject = (reason)=>{\n                                this.#settled = true;\n                                reject(reason);\n                            };\n                        });\n                    }\n                    get settled() {\n                        return this.#settled;\n                    }\n                }\n                exports1.PromiseCapability = PromiseCapability;\n                let NormalizeRegex = null;\n                let NormalizationMap = null;\n                function normalizeUnicode(str) {\n                    if (!NormalizeRegex) {\n                        NormalizeRegex = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n                        NormalizationMap = new Map([\n                            [\n                                \"ﬅ\",\n                                \"ſt\"\n                            ]\n                        ]);\n                    }\n                    return str.replaceAll(NormalizeRegex, (_, p1, p2)=>{\n                        return p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2);\n                    });\n                }\n                function getUuid() {\n                    if (typeof crypto !== \"undefined\" && typeof crypto?.randomUUID === \"function\") {\n                        return crypto.randomUUID();\n                    }\n                    const buf = new Uint8Array(32);\n                    if (typeof crypto !== \"undefined\" && typeof crypto?.getRandomValues === \"function\") {\n                        crypto.getRandomValues(buf);\n                    } else {\n                        for(let i = 0; i < 32; i++){\n                            buf[i] = Math.floor(Math.random() * 255);\n                        }\n                    }\n                    return bytesToString(buf);\n                }\n                const AnnotationPrefix = \"pdfjs_internal_id_\";\n                exports1.AnnotationPrefix = AnnotationPrefix;\n            /***/ },\n            /* 2 */ /***/ (__unused_webpack_module, exports, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports, \"__esModule\", {\n                    value: true\n                });\n                exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;\n                Object.defineProperty(exports, \"SVGGraphics\", {\n                    enumerable: true,\n                    get: function() {\n                        return _displaySvg.SVGGraphics;\n                    }\n                });\n                exports.build = void 0;\n                exports.getDocument = getDocument;\n                exports.version = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _annotation_storage = __w_pdfjs_require__(3);\n                var _display_utils = __w_pdfjs_require__(6);\n                var _font_loader = __w_pdfjs_require__(9);\n                var _displayNode_utils = __w_pdfjs_require__(10);\n                var _canvas = __w_pdfjs_require__(11);\n                var _worker_options = __w_pdfjs_require__(14);\n                var _message_handler = __w_pdfjs_require__(15);\n                var _metadata = __w_pdfjs_require__(16);\n                var _optional_content_config = __w_pdfjs_require__(17);\n                var _transport_stream = __w_pdfjs_require__(18);\n                var _displayFetch_stream = __w_pdfjs_require__(19);\n                var _displayNetwork = __w_pdfjs_require__(22);\n                var _displayNode_stream = __w_pdfjs_require__(23);\n                var _displaySvg = __w_pdfjs_require__(24);\n                var _xfa_text = __w_pdfjs_require__(25);\n                const DEFAULT_RANGE_CHUNK_SIZE = 65536;\n                const RENDERING_CANCELLED_TIMEOUT = 100;\n                const DELAYED_CLEANUP_TIMEOUT = 5000;\n                const DefaultCanvasFactory = _util.isNodeJS ? _displayNode_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;\n                exports.DefaultCanvasFactory = DefaultCanvasFactory;\n                const DefaultCMapReaderFactory = _util.isNodeJS ? _displayNode_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;\n                exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;\n                const DefaultFilterFactory = _util.isNodeJS ? _displayNode_utils.NodeFilterFactory : _display_utils.DOMFilterFactory;\n                exports.DefaultFilterFactory = DefaultFilterFactory;\n                const DefaultStandardFontDataFactory = _util.isNodeJS ? _displayNode_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;\n                exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;\n                function getDocument(src) {\n                    if (typeof src === \"string\" || src instanceof URL) {\n                        src = {\n                            url: src\n                        };\n                    } else if ((0, _util.isArrayBuffer)(src)) {\n                        src = {\n                            data: src\n                        };\n                    }\n                    if (typeof src !== \"object\") {\n                        throw new Error(\"Invalid parameter in getDocument, need parameter object.\");\n                    }\n                    if (!src.url && !src.data && !src.range) {\n                        throw new Error(\"Invalid parameter object: need either .data, .range or .url\");\n                    }\n                    const task = new PDFDocumentLoadingTask();\n                    const { docId } = task;\n                    const url = src.url ? getUrlProp(src.url) : null;\n                    const data = src.data ? getDataProp(src.data) : null;\n                    const httpHeaders = src.httpHeaders || null;\n                    const withCredentials = src.withCredentials === true;\n                    const password = src.password ?? null;\n                    const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;\n                    const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;\n                    let worker = src.worker instanceof PDFWorker ? src.worker : null;\n                    const verbosity = src.verbosity;\n                    const docBaseUrl = typeof src.docBaseUrl === \"string\" && !(0, _display_utils.isDataScheme)(src.docBaseUrl) ? src.docBaseUrl : null;\n                    const cMapUrl = typeof src.cMapUrl === \"string\" ? src.cMapUrl : null;\n                    const cMapPacked = src.cMapPacked !== false;\n                    const CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;\n                    const standardFontDataUrl = typeof src.standardFontDataUrl === \"string\" ? src.standardFontDataUrl : null;\n                    const StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;\n                    const ignoreErrors = src.stopAtErrors !== true;\n                    const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;\n                    const isEvalSupported = src.isEvalSupported !== false;\n                    const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === \"boolean\" ? src.isOffscreenCanvasSupported : !_util.isNodeJS;\n                    const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;\n                    const disableFontFace = typeof src.disableFontFace === \"boolean\" ? src.disableFontFace : _util.isNodeJS;\n                    const fontExtraProperties = src.fontExtraProperties === true;\n                    const enableXfa = src.enableXfa === true;\n                    const ownerDocument = src.ownerDocument || globalThis.document;\n                    const disableRange = src.disableRange === true;\n                    const disableStream = src.disableStream === true;\n                    const disableAutoFetch = src.disableAutoFetch === true;\n                    const pdfBug = src.pdfBug === true;\n                    const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;\n                    const useSystemFonts = typeof src.useSystemFonts === \"boolean\" ? src.useSystemFonts : !_util.isNodeJS && !disableFontFace;\n                    const useWorkerFetch = typeof src.useWorkerFetch === \"boolean\" ? src.useWorkerFetch : CMapReaderFactory === _display_utils.DOMCMapReaderFactory && StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory && cMapUrl && standardFontDataUrl && (0, _display_utils.isValidFetchUrl)(cMapUrl, document.baseURI) && (0, _display_utils.isValidFetchUrl)(standardFontDataUrl, document.baseURI);\n                    const canvasFactory = src.canvasFactory || new DefaultCanvasFactory({\n                        ownerDocument\n                    });\n                    const filterFactory = src.filterFactory || new DefaultFilterFactory({\n                        docId,\n                        ownerDocument\n                    });\n                    const styleElement = null;\n                    (0, _util.setVerbosityLevel)(verbosity);\n                    const transportFactory = {\n                        canvasFactory,\n                        filterFactory\n                    };\n                    if (!useWorkerFetch) {\n                        transportFactory.cMapReaderFactory = new CMapReaderFactory({\n                            baseUrl: cMapUrl,\n                            isCompressed: cMapPacked\n                        });\n                        transportFactory.standardFontDataFactory = new StandardFontDataFactory({\n                            baseUrl: standardFontDataUrl\n                        });\n                    }\n                    if (!worker) {\n                        const workerParams = {\n                            verbosity,\n                            port: _worker_options.GlobalWorkerOptions.workerPort\n                        };\n                        worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n                        task._worker = worker;\n                    }\n                    const fetchDocParams = {\n                        docId,\n                        apiVersion: \"3.11.174\",\n                        data,\n                        password,\n                        disableAutoFetch,\n                        rangeChunkSize,\n                        length,\n                        docBaseUrl,\n                        enableXfa,\n                        evaluatorOptions: {\n                            maxImageSize,\n                            disableFontFace,\n                            ignoreErrors,\n                            isEvalSupported,\n                            isOffscreenCanvasSupported,\n                            canvasMaxAreaInBytes,\n                            fontExtraProperties,\n                            useSystemFonts,\n                            cMapUrl: useWorkerFetch ? cMapUrl : null,\n                            standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null\n                        }\n                    };\n                    const transportParams = {\n                        ignoreErrors,\n                        isEvalSupported,\n                        disableFontFace,\n                        fontExtraProperties,\n                        enableXfa,\n                        ownerDocument,\n                        disableAutoFetch,\n                        pdfBug,\n                        styleElement\n                    };\n                    worker.promise.then(function() {\n                        if (task.destroyed) {\n                            throw new Error(\"Loading aborted\");\n                        }\n                        const workerIdPromise = _fetchDocument(worker, fetchDocParams);\n                        const networkStreamPromise = new Promise(function(resolve) {\n                            let networkStream;\n                            if (rangeTransport) {\n                                networkStream = new _transport_stream.PDFDataTransportStream({\n                                    length,\n                                    initialData: rangeTransport.initialData,\n                                    progressiveDone: rangeTransport.progressiveDone,\n                                    contentDispositionFilename: rangeTransport.contentDispositionFilename,\n                                    disableRange,\n                                    disableStream\n                                }, rangeTransport);\n                            } else if (!data) {\n                                const createPDFNetworkStream = (params)=>{\n                                    if (_util.isNodeJS) {\n                                        return new _displayNode_stream.PDFNodeStream(params);\n                                    }\n                                    return (0, _display_utils.isValidFetchUrl)(params.url) ? new _displayFetch_stream.PDFFetchStream(params) : new _displayNetwork.PDFNetworkStream(params);\n                                };\n                                networkStream = createPDFNetworkStream({\n                                    url,\n                                    length,\n                                    httpHeaders,\n                                    withCredentials,\n                                    rangeChunkSize,\n                                    disableRange,\n                                    disableStream\n                                });\n                            }\n                            resolve(networkStream);\n                        });\n                        return Promise.all([\n                            workerIdPromise,\n                            networkStreamPromise\n                        ]).then(function([workerId, networkStream]) {\n                            if (task.destroyed) {\n                                throw new Error(\"Loading aborted\");\n                            }\n                            const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);\n                            const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);\n                            task._transport = transport;\n                            messageHandler.send(\"Ready\", null);\n                        });\n                    }).catch(task._capability.reject);\n                    return task;\n                }\n                async function _fetchDocument(worker, source) {\n                    if (worker.destroyed) {\n                        throw new Error(\"Worker was destroyed\");\n                    }\n                    const workerId = await worker.messageHandler.sendWithPromise(\"GetDocRequest\", source, source.data ? [\n                        source.data.buffer\n                    ] : null);\n                    if (worker.destroyed) {\n                        throw new Error(\"Worker was destroyed\");\n                    }\n                    return workerId;\n                }\n                function getUrlProp(val) {\n                    if (val instanceof URL) {\n                        return val.href;\n                    }\n                    try {\n                        return new URL(val, window.location).href;\n                    } catch  {\n                        if (_util.isNodeJS && typeof val === \"string\") {\n                            return val;\n                        }\n                    }\n                    throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n                }\n                function getDataProp(val) {\n                    if (_util.isNodeJS && typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n                        throw new Error(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n                    }\n                    if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {\n                        return val;\n                    }\n                    if (typeof val === \"string\") {\n                        return (0, _util.stringToBytes)(val);\n                    }\n                    if (typeof val === \"object\" && !isNaN(val?.length) || (0, _util.isArrayBuffer)(val)) {\n                        return new Uint8Array(val);\n                    }\n                    throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n                }\n                class PDFDocumentLoadingTask {\n                    static #docId = 0;\n                    constructor(){\n                        this._capability = new _util.PromiseCapability();\n                        this._transport = null;\n                        this._worker = null;\n                        this.docId = `d${PDFDocumentLoadingTask.#docId++}`;\n                        this.destroyed = false;\n                        this.onPassword = null;\n                        this.onProgress = null;\n                    }\n                    get promise() {\n                        return this._capability.promise;\n                    }\n                    async destroy() {\n                        this.destroyed = true;\n                        try {\n                            if (this._worker?.port) {\n                                this._worker._pendingDestroy = true;\n                            }\n                            await this._transport?.destroy();\n                        } catch (ex) {\n                            if (this._worker?.port) {\n                                delete this._worker._pendingDestroy;\n                            }\n                            throw ex;\n                        }\n                        this._transport = null;\n                        if (this._worker) {\n                            this._worker.destroy();\n                            this._worker = null;\n                        }\n                    }\n                }\n                exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;\n                class PDFDataRangeTransport {\n                    constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null){\n                        this.length = length;\n                        this.initialData = initialData;\n                        this.progressiveDone = progressiveDone;\n                        this.contentDispositionFilename = contentDispositionFilename;\n                        this._rangeListeners = [];\n                        this._progressListeners = [];\n                        this._progressiveReadListeners = [];\n                        this._progressiveDoneListeners = [];\n                        this._readyCapability = new _util.PromiseCapability();\n                    }\n                    addRangeListener(listener) {\n                        this._rangeListeners.push(listener);\n                    }\n                    addProgressListener(listener) {\n                        this._progressListeners.push(listener);\n                    }\n                    addProgressiveReadListener(listener) {\n                        this._progressiveReadListeners.push(listener);\n                    }\n                    addProgressiveDoneListener(listener) {\n                        this._progressiveDoneListeners.push(listener);\n                    }\n                    onDataRange(begin, chunk) {\n                        for (const listener of this._rangeListeners){\n                            listener(begin, chunk);\n                        }\n                    }\n                    onDataProgress(loaded, total) {\n                        this._readyCapability.promise.then(()=>{\n                            for (const listener of this._progressListeners){\n                                listener(loaded, total);\n                            }\n                        });\n                    }\n                    onDataProgressiveRead(chunk) {\n                        this._readyCapability.promise.then(()=>{\n                            for (const listener of this._progressiveReadListeners){\n                                listener(chunk);\n                            }\n                        });\n                    }\n                    onDataProgressiveDone() {\n                        this._readyCapability.promise.then(()=>{\n                            for (const listener of this._progressiveDoneListeners){\n                                listener();\n                            }\n                        });\n                    }\n                    transportReady() {\n                        this._readyCapability.resolve();\n                    }\n                    requestDataRange(begin, end) {\n                        (0, _util.unreachable)(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n                    }\n                    abort() {}\n                }\n                exports.PDFDataRangeTransport = PDFDataRangeTransport;\n                class PDFDocumentProxy {\n                    constructor(pdfInfo, transport){\n                        this._pdfInfo = pdfInfo;\n                        this._transport = transport;\n                        Object.defineProperty(this, \"getJavaScript\", {\n                            value: ()=>{\n                                (0, _display_utils.deprecated)(\"`PDFDocumentProxy.getJavaScript`, \" + \"please use `PDFDocumentProxy.getJSActions` instead.\");\n                                return this.getJSActions().then((js)=>{\n                                    if (!js) {\n                                        return js;\n                                    }\n                                    const jsArr = [];\n                                    for(const name in js){\n                                        jsArr.push(...js[name]);\n                                    }\n                                    return jsArr;\n                                });\n                            }\n                        });\n                    }\n                    get annotationStorage() {\n                        return this._transport.annotationStorage;\n                    }\n                    get filterFactory() {\n                        return this._transport.filterFactory;\n                    }\n                    get numPages() {\n                        return this._pdfInfo.numPages;\n                    }\n                    get fingerprints() {\n                        return this._pdfInfo.fingerprints;\n                    }\n                    get isPureXfa() {\n                        return (0, _util.shadow)(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n                    }\n                    get allXfaHtml() {\n                        return this._transport._htmlForXfa;\n                    }\n                    getPage(pageNumber) {\n                        return this._transport.getPage(pageNumber);\n                    }\n                    getPageIndex(ref) {\n                        return this._transport.getPageIndex(ref);\n                    }\n                    getDestinations() {\n                        return this._transport.getDestinations();\n                    }\n                    getDestination(id) {\n                        return this._transport.getDestination(id);\n                    }\n                    getPageLabels() {\n                        return this._transport.getPageLabels();\n                    }\n                    getPageLayout() {\n                        return this._transport.getPageLayout();\n                    }\n                    getPageMode() {\n                        return this._transport.getPageMode();\n                    }\n                    getViewerPreferences() {\n                        return this._transport.getViewerPreferences();\n                    }\n                    getOpenAction() {\n                        return this._transport.getOpenAction();\n                    }\n                    getAttachments() {\n                        return this._transport.getAttachments();\n                    }\n                    getJSActions() {\n                        return this._transport.getDocJSActions();\n                    }\n                    getOutline() {\n                        return this._transport.getOutline();\n                    }\n                    getOptionalContentConfig() {\n                        return this._transport.getOptionalContentConfig();\n                    }\n                    getPermissions() {\n                        return this._transport.getPermissions();\n                    }\n                    getMetadata() {\n                        return this._transport.getMetadata();\n                    }\n                    getMarkInfo() {\n                        return this._transport.getMarkInfo();\n                    }\n                    getData() {\n                        return this._transport.getData();\n                    }\n                    saveDocument() {\n                        return this._transport.saveDocument();\n                    }\n                    getDownloadInfo() {\n                        return this._transport.downloadInfoCapability.promise;\n                    }\n                    cleanup(keepLoadedFonts = false) {\n                        return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n                    }\n                    destroy() {\n                        return this.loadingTask.destroy();\n                    }\n                    get loadingParams() {\n                        return this._transport.loadingParams;\n                    }\n                    get loadingTask() {\n                        return this._transport.loadingTask;\n                    }\n                    getFieldObjects() {\n                        return this._transport.getFieldObjects();\n                    }\n                    hasJSActions() {\n                        return this._transport.hasJSActions();\n                    }\n                    getCalculationOrderIds() {\n                        return this._transport.getCalculationOrderIds();\n                    }\n                }\n                exports.PDFDocumentProxy = PDFDocumentProxy;\n                class PDFPageProxy {\n                    #delayedCleanupTimeout;\n                    #pendingCleanup;\n                    constructor(pageIndex, pageInfo, transport, pdfBug = false){\n                        this.#delayedCleanupTimeout = null;\n                        this.#pendingCleanup = false;\n                        this._pageIndex = pageIndex;\n                        this._pageInfo = pageInfo;\n                        this._transport = transport;\n                        this._stats = pdfBug ? new _display_utils.StatTimer() : null;\n                        this._pdfBug = pdfBug;\n                        this.commonObjs = transport.commonObjs;\n                        this.objs = new PDFObjects();\n                        this._maybeCleanupAfterRender = false;\n                        this._intentStates = new Map();\n                        this.destroyed = false;\n                    }\n                    get pageNumber() {\n                        return this._pageIndex + 1;\n                    }\n                    get rotate() {\n                        return this._pageInfo.rotate;\n                    }\n                    get ref() {\n                        return this._pageInfo.ref;\n                    }\n                    get userUnit() {\n                        return this._pageInfo.userUnit;\n                    }\n                    get view() {\n                        return this._pageInfo.view;\n                    }\n                    getViewport({ scale, rotation = this.rotate, offsetX = 0, offsetY = 0, dontFlip = false } = {}) {\n                        return new _display_utils.PageViewport({\n                            viewBox: this.view,\n                            scale,\n                            rotation,\n                            offsetX,\n                            offsetY,\n                            dontFlip\n                        });\n                    }\n                    getAnnotations({ intent = \"display\" } = {}) {\n                        const intentArgs = this._transport.getRenderingIntent(intent);\n                        return this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);\n                    }\n                    getJSActions() {\n                        return this._transport.getPageJSActions(this._pageIndex);\n                    }\n                    get filterFactory() {\n                        return this._transport.filterFactory;\n                    }\n                    get isPureXfa() {\n                        return (0, _util.shadow)(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n                    }\n                    async getXfa() {\n                        return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n                    }\n                    render({ canvasContext, viewport, intent = \"display\", annotationMode = _util.AnnotationMode.ENABLE, transform = null, background = null, optionalContentConfigPromise = null, annotationCanvasMap = null, pageColors = null, printAnnotationStorage = null }) {\n                        this._stats?.time(\"Overall\");\n                        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);\n                        this.#pendingCleanup = false;\n                        this.#abortDelayedCleanup();\n                        if (!optionalContentConfigPromise) {\n                            optionalContentConfigPromise = this._transport.getOptionalContentConfig();\n                        }\n                        let intentState = this._intentStates.get(intentArgs.cacheKey);\n                        if (!intentState) {\n                            intentState = Object.create(null);\n                            this._intentStates.set(intentArgs.cacheKey, intentState);\n                        }\n                        if (intentState.streamReaderCancelTimeout) {\n                            clearTimeout(intentState.streamReaderCancelTimeout);\n                            intentState.streamReaderCancelTimeout = null;\n                        }\n                        const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);\n                        if (!intentState.displayReadyCapability) {\n                            intentState.displayReadyCapability = new _util.PromiseCapability();\n                            intentState.operatorList = {\n                                fnArray: [],\n                                argsArray: [],\n                                lastChunk: false,\n                                separateAnnots: null\n                            };\n                            this._stats?.time(\"Page Request\");\n                            this._pumpOperatorList(intentArgs);\n                        }\n                        const complete = (error)=>{\n                            intentState.renderTasks.delete(internalRenderTask);\n                            if (this._maybeCleanupAfterRender || intentPrint) {\n                                this.#pendingCleanup = true;\n                            }\n                            this.#tryCleanup(!intentPrint);\n                            if (error) {\n                                internalRenderTask.capability.reject(error);\n                                this._abortOperatorList({\n                                    intentState,\n                                    reason: error instanceof Error ? error : new Error(error)\n                                });\n                            } else {\n                                internalRenderTask.capability.resolve();\n                            }\n                            this._stats?.timeEnd(\"Rendering\");\n                            this._stats?.timeEnd(\"Overall\");\n                        };\n                        const internalRenderTask = new InternalRenderTask({\n                            callback: complete,\n                            params: {\n                                canvasContext,\n                                viewport,\n                                transform,\n                                background\n                            },\n                            objs: this.objs,\n                            commonObjs: this.commonObjs,\n                            annotationCanvasMap,\n                            operatorList: intentState.operatorList,\n                            pageIndex: this._pageIndex,\n                            canvasFactory: this._transport.canvasFactory,\n                            filterFactory: this._transport.filterFactory,\n                            useRequestAnimationFrame: !intentPrint,\n                            pdfBug: this._pdfBug,\n                            pageColors\n                        });\n                        (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n                        const renderTask = internalRenderTask.task;\n                        Promise.all([\n                            intentState.displayReadyCapability.promise,\n                            optionalContentConfigPromise\n                        ]).then(([transparency, optionalContentConfig])=>{\n                            if (this.destroyed) {\n                                complete();\n                                return;\n                            }\n                            this._stats?.time(\"Rendering\");\n                            internalRenderTask.initializeGraphics({\n                                transparency,\n                                optionalContentConfig\n                            });\n                            internalRenderTask.operatorListChanged();\n                        }).catch(complete);\n                        return renderTask;\n                    }\n                    getOperatorList({ intent = \"display\", annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null } = {}) {\n                        function operatorListChanged() {\n                            if (intentState.operatorList.lastChunk) {\n                                intentState.opListReadCapability.resolve(intentState.operatorList);\n                                intentState.renderTasks.delete(opListTask);\n                            }\n                        }\n                        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);\n                        let intentState = this._intentStates.get(intentArgs.cacheKey);\n                        if (!intentState) {\n                            intentState = Object.create(null);\n                            this._intentStates.set(intentArgs.cacheKey, intentState);\n                        }\n                        let opListTask;\n                        if (!intentState.opListReadCapability) {\n                            opListTask = Object.create(null);\n                            opListTask.operatorListChanged = operatorListChanged;\n                            intentState.opListReadCapability = new _util.PromiseCapability();\n                            (intentState.renderTasks ||= new Set()).add(opListTask);\n                            intentState.operatorList = {\n                                fnArray: [],\n                                argsArray: [],\n                                lastChunk: false,\n                                separateAnnots: null\n                            };\n                            this._stats?.time(\"Page Request\");\n                            this._pumpOperatorList(intentArgs);\n                        }\n                        return intentState.opListReadCapability.promise;\n                    }\n                    streamTextContent({ includeMarkedContent = false, disableNormalization = false } = {}) {\n                        const TEXT_CONTENT_CHUNK_SIZE = 100;\n                        return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n                            pageIndex: this._pageIndex,\n                            includeMarkedContent: includeMarkedContent === true,\n                            disableNormalization: disableNormalization === true\n                        }, {\n                            highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n                            size (textContent) {\n                                return textContent.items.length;\n                            }\n                        });\n                    }\n                    getTextContent(params = {}) {\n                        if (this._transport._htmlForXfa) {\n                            return this.getXfa().then((xfa)=>{\n                                return _xfa_text.XfaText.textContent(xfa);\n                            });\n                        }\n                        const readableStream = this.streamTextContent(params);\n                        return new Promise(function(resolve, reject) {\n                            function pump() {\n                                reader.read().then(function({ value, done }) {\n                                    if (done) {\n                                        resolve(textContent);\n                                        return;\n                                    }\n                                    Object.assign(textContent.styles, value.styles);\n                                    textContent.items.push(...value.items);\n                                    pump();\n                                }, reject);\n                            }\n                            const reader = readableStream.getReader();\n                            const textContent = {\n                                items: [],\n                                styles: Object.create(null)\n                            };\n                            pump();\n                        });\n                    }\n                    getStructTree() {\n                        return this._transport.getStructTree(this._pageIndex);\n                    }\n                    _destroy() {\n                        this.destroyed = true;\n                        const waitOn = [];\n                        for (const intentState of this._intentStates.values()){\n                            this._abortOperatorList({\n                                intentState,\n                                reason: new Error(\"Page was destroyed.\"),\n                                force: true\n                            });\n                            if (intentState.opListReadCapability) {\n                                continue;\n                            }\n                            for (const internalRenderTask of intentState.renderTasks){\n                                waitOn.push(internalRenderTask.completed);\n                                internalRenderTask.cancel();\n                            }\n                        }\n                        this.objs.clear();\n                        this.#pendingCleanup = false;\n                        this.#abortDelayedCleanup();\n                        return Promise.all(waitOn);\n                    }\n                    cleanup(resetStats = false) {\n                        this.#pendingCleanup = true;\n                        const success = this.#tryCleanup(false);\n                        if (resetStats && success) {\n                            this._stats &&= new _display_utils.StatTimer();\n                        }\n                        return success;\n                    }\n                    #tryCleanup(delayed = false) {\n                        this.#abortDelayedCleanup();\n                        if (!this.#pendingCleanup || this.destroyed) {\n                            return false;\n                        }\n                        if (delayed) {\n                            this.#delayedCleanupTimeout = setTimeout(()=>{\n                                this.#delayedCleanupTimeout = null;\n                                this.#tryCleanup(false);\n                            }, DELAYED_CLEANUP_TIMEOUT);\n                            return false;\n                        }\n                        for (const { renderTasks, operatorList } of this._intentStates.values()){\n                            if (renderTasks.size > 0 || !operatorList.lastChunk) {\n                                return false;\n                            }\n                        }\n                        this._intentStates.clear();\n                        this.objs.clear();\n                        this.#pendingCleanup = false;\n                        return true;\n                    }\n                    #abortDelayedCleanup() {\n                        if (this.#delayedCleanupTimeout) {\n                            clearTimeout(this.#delayedCleanupTimeout);\n                            this.#delayedCleanupTimeout = null;\n                        }\n                    }\n                    _startRenderPage(transparency, cacheKey) {\n                        const intentState = this._intentStates.get(cacheKey);\n                        if (!intentState) {\n                            return;\n                        }\n                        this._stats?.timeEnd(\"Page Request\");\n                        intentState.displayReadyCapability?.resolve(transparency);\n                    }\n                    _renderPageChunk(operatorListChunk, intentState) {\n                        for(let i = 0, ii = operatorListChunk.length; i < ii; i++){\n                            intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n                            intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n                        }\n                        intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n                        intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n                        for (const internalRenderTask of intentState.renderTasks){\n                            internalRenderTask.operatorListChanged();\n                        }\n                        if (operatorListChunk.lastChunk) {\n                            this.#tryCleanup(true);\n                        }\n                    }\n                    _pumpOperatorList({ renderingIntent, cacheKey, annotationStorageSerializable }) {\n                        const { map, transfers } = annotationStorageSerializable;\n                        const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n                            pageIndex: this._pageIndex,\n                            intent: renderingIntent,\n                            cacheKey,\n                            annotationStorage: map\n                        }, transfers);\n                        const reader = readableStream.getReader();\n                        const intentState = this._intentStates.get(cacheKey);\n                        intentState.streamReader = reader;\n                        const pump = ()=>{\n                            reader.read().then(({ value, done })=>{\n                                if (done) {\n                                    intentState.streamReader = null;\n                                    return;\n                                }\n                                if (this._transport.destroyed) {\n                                    return;\n                                }\n                                this._renderPageChunk(value, intentState);\n                                pump();\n                            }, (reason)=>{\n                                intentState.streamReader = null;\n                                if (this._transport.destroyed) {\n                                    return;\n                                }\n                                if (intentState.operatorList) {\n                                    intentState.operatorList.lastChunk = true;\n                                    for (const internalRenderTask of intentState.renderTasks){\n                                        internalRenderTask.operatorListChanged();\n                                    }\n                                    this.#tryCleanup(true);\n                                }\n                                if (intentState.displayReadyCapability) {\n                                    intentState.displayReadyCapability.reject(reason);\n                                } else if (intentState.opListReadCapability) {\n                                    intentState.opListReadCapability.reject(reason);\n                                } else {\n                                    throw reason;\n                                }\n                            });\n                        };\n                        pump();\n                    }\n                    _abortOperatorList({ intentState, reason, force = false }) {\n                        if (!intentState.streamReader) {\n                            return;\n                        }\n                        if (intentState.streamReaderCancelTimeout) {\n                            clearTimeout(intentState.streamReaderCancelTimeout);\n                            intentState.streamReaderCancelTimeout = null;\n                        }\n                        if (!force) {\n                            if (intentState.renderTasks.size > 0) {\n                                return;\n                            }\n                            if (reason instanceof _display_utils.RenderingCancelledException) {\n                                let delay = RENDERING_CANCELLED_TIMEOUT;\n                                if (reason.extraDelay > 0 && reason.extraDelay < 1000) {\n                                    delay += reason.extraDelay;\n                                }\n                                intentState.streamReaderCancelTimeout = setTimeout(()=>{\n                                    intentState.streamReaderCancelTimeout = null;\n                                    this._abortOperatorList({\n                                        intentState,\n                                        reason,\n                                        force: true\n                                    });\n                                }, delay);\n                                return;\n                            }\n                        }\n                        intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(()=>{});\n                        intentState.streamReader = null;\n                        if (this._transport.destroyed) {\n                            return;\n                        }\n                        for (const [curCacheKey, curIntentState] of this._intentStates){\n                            if (curIntentState === intentState) {\n                                this._intentStates.delete(curCacheKey);\n                                break;\n                            }\n                        }\n                        this.cleanup();\n                    }\n                    get stats() {\n                        return this._stats;\n                    }\n                }\n                exports.PDFPageProxy = PDFPageProxy;\n                class LoopbackPort {\n                    #listeners;\n                    #deferred;\n                    postMessage(obj, transfer) {\n                        const event = {\n                            data: structuredClone(obj, transfer ? {\n                                transfer\n                            } : null)\n                        };\n                        this.#deferred.then(()=>{\n                            for (const listener of this.#listeners){\n                                listener.call(this, event);\n                            }\n                        });\n                    }\n                    addEventListener(name, listener) {\n                        this.#listeners.add(listener);\n                    }\n                    removeEventListener(name, listener) {\n                        this.#listeners.delete(listener);\n                    }\n                    terminate() {\n                        this.#listeners.clear();\n                    }\n                    constructor(){\n                        this.#listeners = new Set();\n                        this.#deferred = Promise.resolve();\n                    }\n                }\n                exports.LoopbackPort = LoopbackPort;\n                const PDFWorkerUtil = {\n                    isWorkerDisabled: false,\n                    fallbackWorkerSrc: null,\n                    fakeWorkerId: 0\n                };\n                exports.PDFWorkerUtil = PDFWorkerUtil;\n                {\n                    if (_util.isNodeJS && \"function\" === \"function\") {\n                        PDFWorkerUtil.isWorkerDisabled = true;\n                        PDFWorkerUtil.fallbackWorkerSrc = \"./pdf.worker.js\";\n                    } else if (typeof document === \"object\") {\n                        const pdfjsFilePath = document?.currentScript?.src;\n                        if (pdfjsFilePath) {\n                            PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, \".worker$1$2\");\n                        }\n                    }\n                    PDFWorkerUtil.isSameOrigin = function(baseUrl, otherUrl) {\n                        let base;\n                        try {\n                            base = new URL(baseUrl);\n                            if (!base.origin || base.origin === \"null\") {\n                                return false;\n                            }\n                        } catch  {\n                            return false;\n                        }\n                        const other = new URL(otherUrl, base);\n                        return base.origin === other.origin;\n                    };\n                    PDFWorkerUtil.createCDNWrapper = function(url) {\n                        const wrapper = `importScripts(\"${url}\");`;\n                        return URL.createObjectURL(new Blob([\n                            wrapper\n                        ]));\n                    };\n                }\n                class PDFWorker {\n                    static #workerPorts;\n                    constructor({ name = null, port = null, verbosity = (0, _util.getVerbosityLevel)() } = {}){\n                        this.name = name;\n                        this.destroyed = false;\n                        this.verbosity = verbosity;\n                        this._readyCapability = new _util.PromiseCapability();\n                        this._port = null;\n                        this._webWorker = null;\n                        this._messageHandler = null;\n                        if (port) {\n                            if (PDFWorker.#workerPorts?.has(port)) {\n                                throw new Error(\"Cannot use more than one PDFWorker per port.\");\n                            }\n                            (PDFWorker.#workerPorts ||= new WeakMap()).set(port, this);\n                            this._initializeFromPort(port);\n                            return;\n                        }\n                        this._initialize();\n                    }\n                    get promise() {\n                        return this._readyCapability.promise;\n                    }\n                    get port() {\n                        return this._port;\n                    }\n                    get messageHandler() {\n                        return this._messageHandler;\n                    }\n                    _initializeFromPort(port) {\n                        this._port = port;\n                        this._messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", port);\n                        this._messageHandler.on(\"ready\", function() {});\n                        this._readyCapability.resolve();\n                        this._messageHandler.send(\"configure\", {\n                            verbosity: this.verbosity\n                        });\n                    }\n                    _initialize() {\n                        if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {\n                            let { workerSrc } = PDFWorker;\n                            try {\n                                if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {\n                                    workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);\n                                }\n                                const worker = new Worker(workerSrc);\n                                const messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", worker);\n                                const terminateEarly = ()=>{\n                                    worker.removeEventListener(\"error\", onWorkerError);\n                                    messageHandler.destroy();\n                                    worker.terminate();\n                                    if (this.destroyed) {\n                                        this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                                    } else {\n                                        this._setupFakeWorker();\n                                    }\n                                };\n                                const onWorkerError = ()=>{\n                                    if (!this._webWorker) {\n                                        terminateEarly();\n                                    }\n                                };\n                                worker.addEventListener(\"error\", onWorkerError);\n                                messageHandler.on(\"test\", (data)=>{\n                                    worker.removeEventListener(\"error\", onWorkerError);\n                                    if (this.destroyed) {\n                                        terminateEarly();\n                                        return;\n                                    }\n                                    if (data) {\n                                        this._messageHandler = messageHandler;\n                                        this._port = worker;\n                                        this._webWorker = worker;\n                                        this._readyCapability.resolve();\n                                        messageHandler.send(\"configure\", {\n                                            verbosity: this.verbosity\n                                        });\n                                    } else {\n                                        this._setupFakeWorker();\n                                        messageHandler.destroy();\n                                        worker.terminate();\n                                    }\n                                });\n                                messageHandler.on(\"ready\", (data)=>{\n                                    worker.removeEventListener(\"error\", onWorkerError);\n                                    if (this.destroyed) {\n                                        terminateEarly();\n                                        return;\n                                    }\n                                    try {\n                                        sendTest();\n                                    } catch  {\n                                        this._setupFakeWorker();\n                                    }\n                                });\n                                const sendTest = ()=>{\n                                    const testObj = new Uint8Array();\n                                    messageHandler.send(\"test\", testObj, [\n                                        testObj.buffer\n                                    ]);\n                                };\n                                sendTest();\n                                return;\n                            } catch  {\n                                (0, _util.info)(\"The worker has been disabled.\");\n                            }\n                        }\n                        this._setupFakeWorker();\n                    }\n                    _setupFakeWorker() {\n                        if (!PDFWorkerUtil.isWorkerDisabled) {\n                            (0, _util.warn)(\"Setting up fake worker.\");\n                            PDFWorkerUtil.isWorkerDisabled = true;\n                        }\n                        PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler)=>{\n                            if (this.destroyed) {\n                                this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                                return;\n                            }\n                            const port = new LoopbackPort();\n                            this._port = port;\n                            const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;\n                            const workerHandler = new _message_handler.MessageHandler(id + \"_worker\", id, port);\n                            WorkerMessageHandler.setup(workerHandler, port);\n                            const messageHandler = new _message_handler.MessageHandler(id, id + \"_worker\", port);\n                            this._messageHandler = messageHandler;\n                            this._readyCapability.resolve();\n                            messageHandler.send(\"configure\", {\n                                verbosity: this.verbosity\n                            });\n                        }).catch((reason)=>{\n                            this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n                        });\n                    }\n                    destroy() {\n                        this.destroyed = true;\n                        if (this._webWorker) {\n                            this._webWorker.terminate();\n                            this._webWorker = null;\n                        }\n                        PDFWorker.#workerPorts?.delete(this._port);\n                        this._port = null;\n                        if (this._messageHandler) {\n                            this._messageHandler.destroy();\n                            this._messageHandler = null;\n                        }\n                    }\n                    static fromPort(params) {\n                        if (!params?.port) {\n                            throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n                        }\n                        const cachedPort = this.#workerPorts?.get(params.port);\n                        if (cachedPort) {\n                            if (cachedPort._pendingDestroy) {\n                                throw new Error(\"PDFWorker.fromPort - the worker is being destroyed.\\n\" + \"Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.\");\n                            }\n                            return cachedPort;\n                        }\n                        return new PDFWorker(params);\n                    }\n                    static get workerSrc() {\n                        if (_worker_options.GlobalWorkerOptions.workerSrc) {\n                            return _worker_options.GlobalWorkerOptions.workerSrc;\n                        }\n                        if (PDFWorkerUtil.fallbackWorkerSrc !== null) {\n                            if (!_util.isNodeJS) {\n                                (0, _display_utils.deprecated)('No \"GlobalWorkerOptions.workerSrc\" specified.');\n                            }\n                            return PDFWorkerUtil.fallbackWorkerSrc;\n                        }\n                        throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n                    }\n                    static get _mainThreadWorkerMessageHandler() {\n                        try {\n                            return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n                        } catch  {\n                            return null;\n                        }\n                    }\n                    static get _setupFakeWorkerGlobal() {\n                        const loader = async ()=>{\n                            const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;\n                            if (mainWorkerMessageHandler) {\n                                return mainWorkerMessageHandler;\n                            }\n                            if (_util.isNodeJS && \"function\" === \"function\") {\n                                const worker = eval(\"require\")(this.workerSrc);\n                                return worker.WorkerMessageHandler;\n                            }\n                            await (0, _display_utils.loadScript)(this.workerSrc);\n                            return window.pdfjsWorker.WorkerMessageHandler;\n                        };\n                        return (0, _util.shadow)(this, \"_setupFakeWorkerGlobal\", loader());\n                    }\n                }\n                exports.PDFWorker = PDFWorker;\n                class WorkerTransport {\n                    #methodPromises;\n                    #pageCache;\n                    #pagePromises;\n                    #passwordCapability;\n                    constructor(messageHandler, loadingTask, networkStream, params, factory){\n                        this.#methodPromises = new Map();\n                        this.#pageCache = new Map();\n                        this.#pagePromises = new Map();\n                        this.#passwordCapability = null;\n                        this.messageHandler = messageHandler;\n                        this.loadingTask = loadingTask;\n                        this.commonObjs = new PDFObjects();\n                        this.fontLoader = new _font_loader.FontLoader({\n                            ownerDocument: params.ownerDocument,\n                            styleElement: params.styleElement\n                        });\n                        this._params = params;\n                        this.canvasFactory = factory.canvasFactory;\n                        this.filterFactory = factory.filterFactory;\n                        this.cMapReaderFactory = factory.cMapReaderFactory;\n                        this.standardFontDataFactory = factory.standardFontDataFactory;\n                        this.destroyed = false;\n                        this.destroyCapability = null;\n                        this._networkStream = networkStream;\n                        this._fullReader = null;\n                        this._lastProgress = null;\n                        this.downloadInfoCapability = new _util.PromiseCapability();\n                        this.setupMessageHandler();\n                    }\n                    #cacheSimpleMethod(name, data = null) {\n                        const cachedPromise = this.#methodPromises.get(name);\n                        if (cachedPromise) {\n                            return cachedPromise;\n                        }\n                        const promise = this.messageHandler.sendWithPromise(name, data);\n                        this.#methodPromises.set(name, promise);\n                        return promise;\n                    }\n                    get annotationStorage() {\n                        return (0, _util.shadow)(this, \"annotationStorage\", new _annotation_storage.AnnotationStorage());\n                    }\n                    getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null, isOpList = false) {\n                        let renderingIntent = _util.RenderingIntentFlag.DISPLAY;\n                        let annotationStorageSerializable = _annotation_storage.SerializableEmpty;\n                        switch(intent){\n                            case \"any\":\n                                renderingIntent = _util.RenderingIntentFlag.ANY;\n                                break;\n                            case \"display\":\n                                break;\n                            case \"print\":\n                                renderingIntent = _util.RenderingIntentFlag.PRINT;\n                                break;\n                            default:\n                                (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);\n                        }\n                        switch(annotationMode){\n                            case _util.AnnotationMode.DISABLE:\n                                renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;\n                                break;\n                            case _util.AnnotationMode.ENABLE:\n                                break;\n                            case _util.AnnotationMode.ENABLE_FORMS:\n                                renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;\n                                break;\n                            case _util.AnnotationMode.ENABLE_STORAGE:\n                                renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;\n                                const annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n                                annotationStorageSerializable = annotationStorage.serializable;\n                                break;\n                            default:\n                                (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n                        }\n                        if (isOpList) {\n                            renderingIntent += _util.RenderingIntentFlag.OPLIST;\n                        }\n                        return {\n                            renderingIntent,\n                            cacheKey: `${renderingIntent}_${annotationStorageSerializable.hash}`,\n                            annotationStorageSerializable\n                        };\n                    }\n                    destroy() {\n                        if (this.destroyCapability) {\n                            return this.destroyCapability.promise;\n                        }\n                        this.destroyed = true;\n                        this.destroyCapability = new _util.PromiseCapability();\n                        this.#passwordCapability?.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n                        const waitOn = [];\n                        for (const page of this.#pageCache.values()){\n                            waitOn.push(page._destroy());\n                        }\n                        this.#pageCache.clear();\n                        this.#pagePromises.clear();\n                        if (this.hasOwnProperty(\"annotationStorage\")) {\n                            this.annotationStorage.resetModified();\n                        }\n                        const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n                        waitOn.push(terminated);\n                        Promise.all(waitOn).then(()=>{\n                            this.commonObjs.clear();\n                            this.fontLoader.clear();\n                            this.#methodPromises.clear();\n                            this.filterFactory.destroy();\n                            this._networkStream?.cancelAllRequests(new _util.AbortException(\"Worker was terminated.\"));\n                            if (this.messageHandler) {\n                                this.messageHandler.destroy();\n                                this.messageHandler = null;\n                            }\n                            this.destroyCapability.resolve();\n                        }, this.destroyCapability.reject);\n                        return this.destroyCapability.promise;\n                    }\n                    setupMessageHandler() {\n                        const { messageHandler, loadingTask } = this;\n                        messageHandler.on(\"GetReader\", (data, sink)=>{\n                            (0, _util.assert)(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n                            this._fullReader = this._networkStream.getFullReader();\n                            this._fullReader.onProgress = (evt)=>{\n                                this._lastProgress = {\n                                    loaded: evt.loaded,\n                                    total: evt.total\n                                };\n                            };\n                            sink.onPull = ()=>{\n                                this._fullReader.read().then(function({ value, done }) {\n                                    if (done) {\n                                        sink.close();\n                                        return;\n                                    }\n                                    (0, _util.assert)(value instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n                                    sink.enqueue(new Uint8Array(value), 1, [\n                                        value\n                                    ]);\n                                }).catch((reason)=>{\n                                    sink.error(reason);\n                                });\n                            };\n                            sink.onCancel = (reason)=>{\n                                this._fullReader.cancel(reason);\n                                sink.ready.catch((readyReason)=>{\n                                    if (this.destroyed) {\n                                        return;\n                                    }\n                                    throw readyReason;\n                                });\n                            };\n                        });\n                        messageHandler.on(\"ReaderHeadersReady\", (data)=>{\n                            const headersCapability = new _util.PromiseCapability();\n                            const fullReader = this._fullReader;\n                            fullReader.headersReady.then(()=>{\n                                if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\n                                    if (this._lastProgress) {\n                                        loadingTask.onProgress?.(this._lastProgress);\n                                    }\n                                    fullReader.onProgress = (evt)=>{\n                                        loadingTask.onProgress?.({\n                                            loaded: evt.loaded,\n                                            total: evt.total\n                                        });\n                                    };\n                                }\n                                headersCapability.resolve({\n                                    isStreamingSupported: fullReader.isStreamingSupported,\n                                    isRangeSupported: fullReader.isRangeSupported,\n                                    contentLength: fullReader.contentLength\n                                });\n                            }, headersCapability.reject);\n                            return headersCapability.promise;\n                        });\n                        messageHandler.on(\"GetRangeReader\", (data, sink)=>{\n                            (0, _util.assert)(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n                            const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n                            if (!rangeReader) {\n                                sink.close();\n                                return;\n                            }\n                            sink.onPull = ()=>{\n                                rangeReader.read().then(function({ value, done }) {\n                                    if (done) {\n                                        sink.close();\n                                        return;\n                                    }\n                                    (0, _util.assert)(value instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n                                    sink.enqueue(new Uint8Array(value), 1, [\n                                        value\n                                    ]);\n                                }).catch((reason)=>{\n                                    sink.error(reason);\n                                });\n                            };\n                            sink.onCancel = (reason)=>{\n                                rangeReader.cancel(reason);\n                                sink.ready.catch((readyReason)=>{\n                                    if (this.destroyed) {\n                                        return;\n                                    }\n                                    throw readyReason;\n                                });\n                            };\n                        });\n                        messageHandler.on(\"GetDoc\", ({ pdfInfo })=>{\n                            this._numPages = pdfInfo.numPages;\n                            this._htmlForXfa = pdfInfo.htmlForXfa;\n                            delete pdfInfo.htmlForXfa;\n                            loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n                        });\n                        messageHandler.on(\"DocException\", function(ex) {\n                            let reason;\n                            switch(ex.name){\n                                case \"PasswordException\":\n                                    reason = new _util.PasswordException(ex.message, ex.code);\n                                    break;\n                                case \"InvalidPDFException\":\n                                    reason = new _util.InvalidPDFException(ex.message);\n                                    break;\n                                case \"MissingPDFException\":\n                                    reason = new _util.MissingPDFException(ex.message);\n                                    break;\n                                case \"UnexpectedResponseException\":\n                                    reason = new _util.UnexpectedResponseException(ex.message, ex.status);\n                                    break;\n                                case \"UnknownErrorException\":\n                                    reason = new _util.UnknownErrorException(ex.message, ex.details);\n                                    break;\n                                default:\n                                    (0, _util.unreachable)(\"DocException - expected a valid Error.\");\n                            }\n                            loadingTask._capability.reject(reason);\n                        });\n                        messageHandler.on(\"PasswordRequest\", (exception)=>{\n                            this.#passwordCapability = new _util.PromiseCapability();\n                            if (loadingTask.onPassword) {\n                                const updatePassword = (password)=>{\n                                    if (password instanceof Error) {\n                                        this.#passwordCapability.reject(password);\n                                    } else {\n                                        this.#passwordCapability.resolve({\n                                            password\n                                        });\n                                    }\n                                };\n                                try {\n                                    loadingTask.onPassword(updatePassword, exception.code);\n                                } catch (ex) {\n                                    this.#passwordCapability.reject(ex);\n                                }\n                            } else {\n                                this.#passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));\n                            }\n                            return this.#passwordCapability.promise;\n                        });\n                        messageHandler.on(\"DataLoaded\", (data)=>{\n                            loadingTask.onProgress?.({\n                                loaded: data.length,\n                                total: data.length\n                            });\n                            this.downloadInfoCapability.resolve(data);\n                        });\n                        messageHandler.on(\"StartRenderPage\", (data)=>{\n                            if (this.destroyed) {\n                                return;\n                            }\n                            const page = this.#pageCache.get(data.pageIndex);\n                            page._startRenderPage(data.transparency, data.cacheKey);\n                        });\n                        messageHandler.on(\"commonobj\", ([id, type, exportedData])=>{\n                            if (this.destroyed) {\n                                return;\n                            }\n                            if (this.commonObjs.has(id)) {\n                                return;\n                            }\n                            switch(type){\n                                case \"Font\":\n                                    const params = this._params;\n                                    if (\"error\" in exportedData) {\n                                        const exportedError = exportedData.error;\n                                        (0, _util.warn)(`Error during font loading: ${exportedError}`);\n                                        this.commonObjs.resolve(id, exportedError);\n                                        break;\n                                    }\n                                    const inspectFont = params.pdfBug && globalThis.FontInspector?.enabled ? (font, url)=>globalThis.FontInspector.fontAdded(font, url) : null;\n                                    const font = new _font_loader.FontFaceObject(exportedData, {\n                                        isEvalSupported: params.isEvalSupported,\n                                        disableFontFace: params.disableFontFace,\n                                        ignoreErrors: params.ignoreErrors,\n                                        inspectFont\n                                    });\n                                    this.fontLoader.bind(font).catch((reason)=>{\n                                        return messageHandler.sendWithPromise(\"FontFallback\", {\n                                            id\n                                        });\n                                    }).finally(()=>{\n                                        if (!params.fontExtraProperties && font.data) {\n                                            font.data = null;\n                                        }\n                                        this.commonObjs.resolve(id, font);\n                                    });\n                                    break;\n                                case \"FontPath\":\n                                case \"Image\":\n                                case \"Pattern\":\n                                    this.commonObjs.resolve(id, exportedData);\n                                    break;\n                                default:\n                                    throw new Error(`Got unknown common object type ${type}`);\n                            }\n                        });\n                        messageHandler.on(\"obj\", ([id, pageIndex, type, imageData])=>{\n                            if (this.destroyed) {\n                                return;\n                            }\n                            const pageProxy = this.#pageCache.get(pageIndex);\n                            if (pageProxy.objs.has(id)) {\n                                return;\n                            }\n                            switch(type){\n                                case \"Image\":\n                                    pageProxy.objs.resolve(id, imageData);\n                                    if (imageData) {\n                                        let length;\n                                        if (imageData.bitmap) {\n                                            const { width, height } = imageData;\n                                            length = width * height * 4;\n                                        } else {\n                                            length = imageData.data?.length || 0;\n                                        }\n                                        if (length > _util.MAX_IMAGE_SIZE_TO_CACHE) {\n                                            pageProxy._maybeCleanupAfterRender = true;\n                                        }\n                                    }\n                                    break;\n                                case \"Pattern\":\n                                    pageProxy.objs.resolve(id, imageData);\n                                    break;\n                                default:\n                                    throw new Error(`Got unknown object type ${type}`);\n                            }\n                        });\n                        messageHandler.on(\"DocProgress\", (data)=>{\n                            if (this.destroyed) {\n                                return;\n                            }\n                            loadingTask.onProgress?.({\n                                loaded: data.loaded,\n                                total: data.total\n                            });\n                        });\n                        messageHandler.on(\"FetchBuiltInCMap\", (data)=>{\n                            if (this.destroyed) {\n                                return Promise.reject(new Error(\"Worker was destroyed.\"));\n                            }\n                            if (!this.cMapReaderFactory) {\n                                return Promise.reject(new Error(\"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\"));\n                            }\n                            return this.cMapReaderFactory.fetch(data);\n                        });\n                        messageHandler.on(\"FetchStandardFontData\", (data)=>{\n                            if (this.destroyed) {\n                                return Promise.reject(new Error(\"Worker was destroyed.\"));\n                            }\n                            if (!this.standardFontDataFactory) {\n                                return Promise.reject(new Error(\"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\"));\n                            }\n                            return this.standardFontDataFactory.fetch(data);\n                        });\n                    }\n                    getData() {\n                        return this.messageHandler.sendWithPromise(\"GetData\", null);\n                    }\n                    saveDocument() {\n                        if (this.annotationStorage.size <= 0) {\n                            (0, _util.warn)(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n                        }\n                        const { map, transfers } = this.annotationStorage.serializable;\n                        return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n                            isPureXfa: !!this._htmlForXfa,\n                            numPages: this._numPages,\n                            annotationStorage: map,\n                            filename: this._fullReader?.filename ?? null\n                        }, transfers).finally(()=>{\n                            this.annotationStorage.resetModified();\n                        });\n                    }\n                    getPage(pageNumber) {\n                        if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n                            return Promise.reject(new Error(\"Invalid page request.\"));\n                        }\n                        const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex);\n                        if (cachedPromise) {\n                            return cachedPromise;\n                        }\n                        const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n                            pageIndex\n                        }).then((pageInfo)=>{\n                            if (this.destroyed) {\n                                throw new Error(\"Transport destroyed\");\n                            }\n                            const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);\n                            this.#pageCache.set(pageIndex, page);\n                            return page;\n                        });\n                        this.#pagePromises.set(pageIndex, promise);\n                        return promise;\n                    }\n                    getPageIndex(ref) {\n                        if (typeof ref !== \"object\" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {\n                            return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n                        }\n                        return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n                            num: ref.num,\n                            gen: ref.gen\n                        });\n                    }\n                    getAnnotations(pageIndex, intent) {\n                        return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n                            pageIndex,\n                            intent\n                        });\n                    }\n                    getFieldObjects() {\n                        return this.#cacheSimpleMethod(\"GetFieldObjects\");\n                    }\n                    hasJSActions() {\n                        return this.#cacheSimpleMethod(\"HasJSActions\");\n                    }\n                    getCalculationOrderIds() {\n                        return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n                    }\n                    getDestinations() {\n                        return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n                    }\n                    getDestination(id) {\n                        if (typeof id !== \"string\") {\n                            return Promise.reject(new Error(\"Invalid destination request.\"));\n                        }\n                        return this.messageHandler.sendWithPromise(\"GetDestination\", {\n                            id\n                        });\n                    }\n                    getPageLabels() {\n                        return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n                    }\n                    getPageLayout() {\n                        return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n                    }\n                    getPageMode() {\n                        return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n                    }\n                    getViewerPreferences() {\n                        return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n                    }\n                    getOpenAction() {\n                        return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n                    }\n                    getAttachments() {\n                        return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n                    }\n                    getDocJSActions() {\n                        return this.#cacheSimpleMethod(\"GetDocJSActions\");\n                    }\n                    getPageJSActions(pageIndex) {\n                        return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n                            pageIndex\n                        });\n                    }\n                    getStructTree(pageIndex) {\n                        return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n                            pageIndex\n                        });\n                    }\n                    getOutline() {\n                        return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n                    }\n                    getOptionalContentConfig() {\n                        return this.messageHandler.sendWithPromise(\"GetOptionalContentConfig\", null).then((results)=>{\n                            return new _optional_content_config.OptionalContentConfig(results);\n                        });\n                    }\n                    getPermissions() {\n                        return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n                    }\n                    getMetadata() {\n                        const name = \"GetMetadata\", cachedPromise = this.#methodPromises.get(name);\n                        if (cachedPromise) {\n                            return cachedPromise;\n                        }\n                        const promise = this.messageHandler.sendWithPromise(name, null).then((results)=>{\n                            return {\n                                info: results[0],\n                                metadata: results[1] ? new _metadata.Metadata(results[1]) : null,\n                                contentDispositionFilename: this._fullReader?.filename ?? null,\n                                contentLength: this._fullReader?.contentLength ?? null\n                            };\n                        });\n                        this.#methodPromises.set(name, promise);\n                        return promise;\n                    }\n                    getMarkInfo() {\n                        return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n                    }\n                    async startCleanup(keepLoadedFonts = false) {\n                        if (this.destroyed) {\n                            return;\n                        }\n                        await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n                        for (const page of this.#pageCache.values()){\n                            const cleanupSuccessful = page.cleanup();\n                            if (!cleanupSuccessful) {\n                                throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n                            }\n                        }\n                        this.commonObjs.clear();\n                        if (!keepLoadedFonts) {\n                            this.fontLoader.clear();\n                        }\n                        this.#methodPromises.clear();\n                        this.filterFactory.destroy(true);\n                    }\n                    get loadingParams() {\n                        const { disableAutoFetch, enableXfa } = this._params;\n                        return (0, _util.shadow)(this, \"loadingParams\", {\n                            disableAutoFetch,\n                            enableXfa\n                        });\n                    }\n                }\n                class PDFObjects {\n                    #objs;\n                    #ensureObj(objId) {\n                        return this.#objs[objId] ||= {\n                            capability: new _util.PromiseCapability(),\n                            data: null\n                        };\n                    }\n                    get(objId, callback = null) {\n                        if (callback) {\n                            const obj = this.#ensureObj(objId);\n                            obj.capability.promise.then(()=>callback(obj.data));\n                            return null;\n                        }\n                        const obj = this.#objs[objId];\n                        if (!obj?.capability.settled) {\n                            throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n                        }\n                        return obj.data;\n                    }\n                    has(objId) {\n                        const obj = this.#objs[objId];\n                        return obj?.capability.settled || false;\n                    }\n                    resolve(objId, data = null) {\n                        const obj = this.#ensureObj(objId);\n                        obj.data = data;\n                        obj.capability.resolve();\n                    }\n                    clear() {\n                        for(const objId in this.#objs){\n                            const { data } = this.#objs[objId];\n                            data?.bitmap?.close();\n                        }\n                        this.#objs = Object.create(null);\n                    }\n                    constructor(){\n                        this.#objs = Object.create(null);\n                    }\n                }\n                class RenderTask {\n                    #internalRenderTask;\n                    constructor(internalRenderTask){\n                        this.#internalRenderTask = null;\n                        this.#internalRenderTask = internalRenderTask;\n                        this.onContinue = null;\n                    }\n                    get promise() {\n                        return this.#internalRenderTask.capability.promise;\n                    }\n                    cancel(extraDelay = 0) {\n                        this.#internalRenderTask.cancel(null, extraDelay);\n                    }\n                    get separateAnnots() {\n                        const { separateAnnots } = this.#internalRenderTask.operatorList;\n                        if (!separateAnnots) {\n                            return false;\n                        }\n                        const { annotationCanvasMap } = this.#internalRenderTask;\n                        return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n                    }\n                }\n                exports.RenderTask = RenderTask;\n                class InternalRenderTask {\n                    static #canvasInUse = new WeakSet();\n                    constructor({ callback, params, objs, commonObjs, annotationCanvasMap, operatorList, pageIndex, canvasFactory, filterFactory, useRequestAnimationFrame = false, pdfBug = false, pageColors = null }){\n                        this.callback = callback;\n                        this.params = params;\n                        this.objs = objs;\n                        this.commonObjs = commonObjs;\n                        this.annotationCanvasMap = annotationCanvasMap;\n                        this.operatorListIdx = null;\n                        this.operatorList = operatorList;\n                        this._pageIndex = pageIndex;\n                        this.canvasFactory = canvasFactory;\n                        this.filterFactory = filterFactory;\n                        this._pdfBug = pdfBug;\n                        this.pageColors = pageColors;\n                        this.running = false;\n                        this.graphicsReadyCallback = null;\n                        this.graphicsReady = false;\n                        this._useRequestAnimationFrame = useRequestAnimationFrame === true && \"undefined\" !== \"undefined\";\n                        this.cancelled = false;\n                        this.capability = new _util.PromiseCapability();\n                        this.task = new RenderTask(this);\n                        this._cancelBound = this.cancel.bind(this);\n                        this._continueBound = this._continue.bind(this);\n                        this._scheduleNextBound = this._scheduleNext.bind(this);\n                        this._nextBound = this._next.bind(this);\n                        this._canvas = params.canvasContext.canvas;\n                    }\n                    get completed() {\n                        return this.capability.promise.catch(function() {});\n                    }\n                    initializeGraphics({ transparency = false, optionalContentConfig }) {\n                        if (this.cancelled) {\n                            return;\n                        }\n                        if (this._canvas) {\n                            if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n                                throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n                            }\n                            InternalRenderTask.#canvasInUse.add(this._canvas);\n                        }\n                        if (this._pdfBug && globalThis.StepperManager?.enabled) {\n                            this.stepper = globalThis.StepperManager.create(this._pageIndex);\n                            this.stepper.init(this.operatorList);\n                            this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n                        }\n                        const { canvasContext, viewport, transform, background } = this.params;\n                        this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n                            optionalContentConfig\n                        }, this.annotationCanvasMap, this.pageColors);\n                        this.gfx.beginDrawing({\n                            transform,\n                            viewport,\n                            transparency,\n                            background\n                        });\n                        this.operatorListIdx = 0;\n                        this.graphicsReady = true;\n                        this.graphicsReadyCallback?.();\n                    }\n                    cancel(error = null, extraDelay = 0) {\n                        this.running = false;\n                        this.cancelled = true;\n                        this.gfx?.endDrawing();\n                        InternalRenderTask.#canvasInUse.delete(this._canvas);\n                        this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));\n                    }\n                    operatorListChanged() {\n                        if (!this.graphicsReady) {\n                            this.graphicsReadyCallback ||= this._continueBound;\n                            return;\n                        }\n                        this.stepper?.updateOperatorList(this.operatorList);\n                        if (this.running) {\n                            return;\n                        }\n                        this._continue();\n                    }\n                    _continue() {\n                        this.running = true;\n                        if (this.cancelled) {\n                            return;\n                        }\n                        if (this.task.onContinue) {\n                            this.task.onContinue(this._scheduleNextBound);\n                        } else {\n                            this._scheduleNext();\n                        }\n                    }\n                    _scheduleNext() {\n                        if (this._useRequestAnimationFrame) {\n                            window.requestAnimationFrame(()=>{\n                                this._nextBound().catch(this._cancelBound);\n                            });\n                        } else {\n                            Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n                        }\n                    }\n                    async _next() {\n                        if (this.cancelled) {\n                            return;\n                        }\n                        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n                        if (this.operatorListIdx === this.operatorList.argsArray.length) {\n                            this.running = false;\n                            if (this.operatorList.lastChunk) {\n                                this.gfx.endDrawing();\n                                InternalRenderTask.#canvasInUse.delete(this._canvas);\n                                this.callback();\n                            }\n                        }\n                    }\n                }\n                const version = \"3.11.174\";\n                exports.version = version;\n                const build = \"ce8716743\";\n                exports.build = build;\n            /***/ },\n            /* 3 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.SerializableEmpty = exports1.PrintAnnotationStorage = exports1.AnnotationStorage = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _editor = __w_pdfjs_require__(4);\n                var _murmurhash = __w_pdfjs_require__(8);\n                const SerializableEmpty = Object.freeze({\n                    map: null,\n                    hash: \"\",\n                    transfers: undefined\n                });\n                exports1.SerializableEmpty = SerializableEmpty;\n                class AnnotationStorage {\n                    #modified;\n                    #storage;\n                    constructor(){\n                        this.#modified = false;\n                        this.#storage = new Map();\n                        this.onSetModified = null;\n                        this.onResetModified = null;\n                        this.onAnnotationEditor = null;\n                    }\n                    getValue(key, defaultValue) {\n                        const value = this.#storage.get(key);\n                        if (value === undefined) {\n                            return defaultValue;\n                        }\n                        return Object.assign(defaultValue, value);\n                    }\n                    getRawValue(key) {\n                        return this.#storage.get(key);\n                    }\n                    remove(key) {\n                        this.#storage.delete(key);\n                        if (this.#storage.size === 0) {\n                            this.resetModified();\n                        }\n                        if (typeof this.onAnnotationEditor === \"function\") {\n                            for (const value of this.#storage.values()){\n                                if (value instanceof _editor.AnnotationEditor) {\n                                    return;\n                                }\n                            }\n                            this.onAnnotationEditor(null);\n                        }\n                    }\n                    setValue(key, value) {\n                        const obj = this.#storage.get(key);\n                        let modified = false;\n                        if (obj !== undefined) {\n                            for (const [entry, val] of Object.entries(value)){\n                                if (obj[entry] !== val) {\n                                    modified = true;\n                                    obj[entry] = val;\n                                }\n                            }\n                        } else {\n                            modified = true;\n                            this.#storage.set(key, value);\n                        }\n                        if (modified) {\n                            this.#setModified();\n                        }\n                        if (value instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === \"function\") {\n                            this.onAnnotationEditor(value.constructor._type);\n                        }\n                    }\n                    has(key) {\n                        return this.#storage.has(key);\n                    }\n                    getAll() {\n                        return this.#storage.size > 0 ? (0, _util.objectFromMap)(this.#storage) : null;\n                    }\n                    setAll(obj) {\n                        for (const [key, val] of Object.entries(obj)){\n                            this.setValue(key, val);\n                        }\n                    }\n                    get size() {\n                        return this.#storage.size;\n                    }\n                    #setModified() {\n                        if (!this.#modified) {\n                            this.#modified = true;\n                            if (typeof this.onSetModified === \"function\") {\n                                this.onSetModified();\n                            }\n                        }\n                    }\n                    resetModified() {\n                        if (this.#modified) {\n                            this.#modified = false;\n                            if (typeof this.onResetModified === \"function\") {\n                                this.onResetModified();\n                            }\n                        }\n                    }\n                    get print() {\n                        return new PrintAnnotationStorage(this);\n                    }\n                    get serializable() {\n                        if (this.#storage.size === 0) {\n                            return SerializableEmpty;\n                        }\n                        const map = new Map(), hash = new _murmurhash.MurmurHash3_64(), transfers = [];\n                        const context = Object.create(null);\n                        let hasBitmap = false;\n                        for (const [key, val] of this.#storage){\n                            const serialized = val instanceof _editor.AnnotationEditor ? val.serialize(false, context) : val;\n                            if (serialized) {\n                                map.set(key, serialized);\n                                hash.update(`${key}:${JSON.stringify(serialized)}`);\n                                hasBitmap ||= !!serialized.bitmap;\n                            }\n                        }\n                        if (hasBitmap) {\n                            for (const value of map.values()){\n                                if (value.bitmap) {\n                                    transfers.push(value.bitmap);\n                                }\n                            }\n                        }\n                        return map.size > 0 ? {\n                            map,\n                            hash: hash.hexdigest(),\n                            transfers\n                        } : SerializableEmpty;\n                    }\n                }\n                exports1.AnnotationStorage = AnnotationStorage;\n                class PrintAnnotationStorage extends AnnotationStorage {\n                    #serializable;\n                    constructor(parent){\n                        super();\n                        const { map, hash, transfers } = parent.serializable;\n                        const clone = structuredClone(map, transfers ? {\n                            transfer: transfers\n                        } : null);\n                        this.#serializable = {\n                            map: clone,\n                            hash,\n                            transfers\n                        };\n                    }\n                    get print() {\n                        (0, _util.unreachable)(\"Should not call PrintAnnotationStorage.print\");\n                    }\n                    get serializable() {\n                        return this.#serializable;\n                    }\n                }\n                exports1.PrintAnnotationStorage = PrintAnnotationStorage;\n            /***/ },\n            /* 4 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.AnnotationEditor = void 0;\n                var _tools = __w_pdfjs_require__(5);\n                var _util = __w_pdfjs_require__(1);\n                var _display_utils = __w_pdfjs_require__(6);\n                class AnnotationEditor {\n                    #altText;\n                    #altTextDecorative;\n                    #altTextButton;\n                    #altTextTooltip;\n                    #altTextTooltipTimeout;\n                    #keepAspectRatio;\n                    #resizersDiv;\n                    #boundFocusin;\n                    #boundFocusout;\n                    #hasBeenClicked;\n                    #isEditing;\n                    #isInEditMode;\n                    #isDraggable;\n                    #zIndex;\n                    static{\n                        this._borderLineWidth = -1;\n                    }\n                    static{\n                        this._colorManager = new _tools.ColorManager();\n                    }\n                    static{\n                        this._zIndex = 1;\n                    }\n                    static{\n                        this.SMALL_EDITOR_SIZE = 0;\n                    }\n                    constructor(parameters){\n                        this.#altText = \"\";\n                        this.#altTextDecorative = false;\n                        this.#altTextButton = null;\n                        this.#altTextTooltip = null;\n                        this.#altTextTooltipTimeout = null;\n                        this.#keepAspectRatio = false;\n                        this.#resizersDiv = null;\n                        this.#boundFocusin = this.focusin.bind(this);\n                        this.#boundFocusout = this.focusout.bind(this);\n                        this.#hasBeenClicked = false;\n                        this.#isEditing = false;\n                        this.#isInEditMode = false;\n                        this._initialOptions = Object.create(null);\n                        this._uiManager = null;\n                        this._focusEventsAllowed = true;\n                        this._l10nPromise = null;\n                        this.#isDraggable = false;\n                        this.#zIndex = AnnotationEditor._zIndex++;\n                        if (this.constructor === AnnotationEditor) {\n                            (0, _util.unreachable)(\"Cannot initialize AnnotationEditor.\");\n                        }\n                        this.parent = parameters.parent;\n                        this.id = parameters.id;\n                        this.width = this.height = null;\n                        this.pageIndex = parameters.parent.pageIndex;\n                        this.name = parameters.name;\n                        this.div = null;\n                        this._uiManager = parameters.uiManager;\n                        this.annotationElementId = null;\n                        this._willKeepAspectRatio = false;\n                        this._initialOptions.isCentered = parameters.isCentered;\n                        this._structTreeParentId = null;\n                        const { rotation, rawDims: { pageWidth, pageHeight, pageX, pageY } } = this.parent.viewport;\n                        this.rotation = rotation;\n                        this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;\n                        this.pageDimensions = [\n                            pageWidth,\n                            pageHeight\n                        ];\n                        this.pageTranslation = [\n                            pageX,\n                            pageY\n                        ];\n                        const [width, height] = this.parentDimensions;\n                        this.x = parameters.x / width;\n                        this.y = parameters.y / height;\n                        this.isAttachedToDOM = false;\n                        this.deleted = false;\n                    }\n                    get editorType() {\n                        return Object.getPrototypeOf(this).constructor._type;\n                    }\n                    static get _defaultLineColor() {\n                        return (0, _util.shadow)(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n                    }\n                    static deleteAnnotationElement(editor) {\n                        const fakeEditor = new FakeEditor({\n                            id: editor.parent.getNextId(),\n                            parent: editor.parent,\n                            uiManager: editor._uiManager\n                        });\n                        fakeEditor.annotationElementId = editor.annotationElementId;\n                        fakeEditor.deleted = true;\n                        fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);\n                    }\n                    static initialize(l10n, options = null) {\n                        AnnotationEditor._l10nPromise ||= new Map([\n                            \"editor_alt_text_button_label\",\n                            \"editor_alt_text_edit_button_label\",\n                            \"editor_alt_text_decorative_tooltip\"\n                        ].map((str)=>[\n                                str,\n                                l10n.get(str)\n                            ]));\n                        if (options?.strings) {\n                            for (const str of options.strings){\n                                AnnotationEditor._l10nPromise.set(str, l10n.get(str));\n                            }\n                        }\n                        if (AnnotationEditor._borderLineWidth !== -1) {\n                            return;\n                        }\n                        const style = getComputedStyle(document.documentElement);\n                        AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n                    }\n                    static updateDefaultParams(_type, _value) {}\n                    static get defaultPropertiesToUpdate() {\n                        return [];\n                    }\n                    static isHandlingMimeForPasting(mime) {\n                        return false;\n                    }\n                    static paste(item, parent) {\n                        (0, _util.unreachable)(\"Not implemented\");\n                    }\n                    get propertiesToUpdate() {\n                        return [];\n                    }\n                    get _isDraggable() {\n                        return this.#isDraggable;\n                    }\n                    set _isDraggable(value) {\n                        this.#isDraggable = value;\n                        this.div?.classList.toggle(\"draggable\", value);\n                    }\n                    center() {\n                        const [pageWidth, pageHeight] = this.pageDimensions;\n                        switch(this.parentRotation){\n                            case 90:\n                                this.x -= this.height * pageHeight / (pageWidth * 2);\n                                this.y += this.width * pageWidth / (pageHeight * 2);\n                                break;\n                            case 180:\n                                this.x += this.width / 2;\n                                this.y += this.height / 2;\n                                break;\n                            case 270:\n                                this.x += this.height * pageHeight / (pageWidth * 2);\n                                this.y -= this.width * pageWidth / (pageHeight * 2);\n                                break;\n                            default:\n                                this.x -= this.width / 2;\n                                this.y -= this.height / 2;\n                                break;\n                        }\n                        this.fixAndSetPosition();\n                    }\n                    addCommands(params) {\n                        this._uiManager.addCommands(params);\n                    }\n                    get currentLayer() {\n                        return this._uiManager.currentLayer;\n                    }\n                    setInBackground() {\n                        this.div.style.zIndex = 0;\n                    }\n                    setInForeground() {\n                        this.div.style.zIndex = this.#zIndex;\n                    }\n                    setParent(parent) {\n                        if (parent !== null) {\n                            this.pageIndex = parent.pageIndex;\n                            this.pageDimensions = parent.pageDimensions;\n                        }\n                        this.parent = parent;\n                    }\n                    focusin(event) {\n                        if (!this._focusEventsAllowed) {\n                            return;\n                        }\n                        if (!this.#hasBeenClicked) {\n                            this.parent.setSelected(this);\n                        } else {\n                            this.#hasBeenClicked = false;\n                        }\n                    }\n                    focusout(event) {\n                        if (!this._focusEventsAllowed) {\n                            return;\n                        }\n                        if (!this.isAttachedToDOM) {\n                            return;\n                        }\n                        const target = event.relatedTarget;\n                        if (target?.closest(`#${this.id}`)) {\n                            return;\n                        }\n                        event.preventDefault();\n                        if (!this.parent?.isMultipleSelection) {\n                            this.commitOrRemove();\n                        }\n                    }\n                    commitOrRemove() {\n                        if (this.isEmpty()) {\n                            this.remove();\n                        } else {\n                            this.commit();\n                        }\n                    }\n                    commit() {\n                        this.addToAnnotationStorage();\n                    }\n                    addToAnnotationStorage() {\n                        this._uiManager.addToAnnotationStorage(this);\n                    }\n                    setAt(x, y, tx, ty) {\n                        const [width, height] = this.parentDimensions;\n                        [tx, ty] = this.screenToPageTranslation(tx, ty);\n                        this.x = (x + tx) / width;\n                        this.y = (y + ty) / height;\n                        this.fixAndSetPosition();\n                    }\n                    #translate([width, height], x, y) {\n                        [x, y] = this.screenToPageTranslation(x, y);\n                        this.x += x / width;\n                        this.y += y / height;\n                        this.fixAndSetPosition();\n                    }\n                    translate(x, y) {\n                        this.#translate(this.parentDimensions, x, y);\n                    }\n                    translateInPage(x, y) {\n                        this.#translate(this.pageDimensions, x, y);\n                        this.div.scrollIntoView({\n                            block: \"nearest\"\n                        });\n                    }\n                    drag(tx, ty) {\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        this.x += tx / parentWidth;\n                        this.y += ty / parentHeight;\n                        if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {\n                            const { x, y } = this.div.getBoundingClientRect();\n                            if (this.parent.findNewParent(this, x, y)) {\n                                this.x -= Math.floor(this.x);\n                                this.y -= Math.floor(this.y);\n                            }\n                        }\n                        let { x, y } = this;\n                        const [bx, by] = this.#getBaseTranslation();\n                        x += bx;\n                        y += by;\n                        this.div.style.left = `${(100 * x).toFixed(2)}%`;\n                        this.div.style.top = `${(100 * y).toFixed(2)}%`;\n                        this.div.scrollIntoView({\n                            block: \"nearest\"\n                        });\n                    }\n                    #getBaseTranslation() {\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        const { _borderLineWidth } = AnnotationEditor;\n                        const x = _borderLineWidth / parentWidth;\n                        const y = _borderLineWidth / parentHeight;\n                        switch(this.rotation){\n                            case 90:\n                                return [\n                                    -x,\n                                    y\n                                ];\n                            case 180:\n                                return [\n                                    x,\n                                    y\n                                ];\n                            case 270:\n                                return [\n                                    x,\n                                    -y\n                                ];\n                            default:\n                                return [\n                                    -x,\n                                    -y\n                                ];\n                        }\n                    }\n                    fixAndSetPosition() {\n                        const [pageWidth, pageHeight] = this.pageDimensions;\n                        let { x, y, width, height } = this;\n                        width *= pageWidth;\n                        height *= pageHeight;\n                        x *= pageWidth;\n                        y *= pageHeight;\n                        switch(this.rotation){\n                            case 0:\n                                x = Math.max(0, Math.min(pageWidth - width, x));\n                                y = Math.max(0, Math.min(pageHeight - height, y));\n                                break;\n                            case 90:\n                                x = Math.max(0, Math.min(pageWidth - height, x));\n                                y = Math.min(pageHeight, Math.max(width, y));\n                                break;\n                            case 180:\n                                x = Math.min(pageWidth, Math.max(width, x));\n                                y = Math.min(pageHeight, Math.max(height, y));\n                                break;\n                            case 270:\n                                x = Math.min(pageWidth, Math.max(height, x));\n                                y = Math.max(0, Math.min(pageHeight - width, y));\n                                break;\n                        }\n                        this.x = x /= pageWidth;\n                        this.y = y /= pageHeight;\n                        const [bx, by] = this.#getBaseTranslation();\n                        x += bx;\n                        y += by;\n                        const { style } = this.div;\n                        style.left = `${(100 * x).toFixed(2)}%`;\n                        style.top = `${(100 * y).toFixed(2)}%`;\n                        this.moveInDOM();\n                    }\n                    static #rotatePoint(x, y, angle) {\n                        switch(angle){\n                            case 90:\n                                return [\n                                    y,\n                                    -x\n                                ];\n                            case 180:\n                                return [\n                                    -x,\n                                    -y\n                                ];\n                            case 270:\n                                return [\n                                    -y,\n                                    x\n                                ];\n                            default:\n                                return [\n                                    x,\n                                    y\n                                ];\n                        }\n                    }\n                    screenToPageTranslation(x, y) {\n                        return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);\n                    }\n                    pageTranslationToScreen(x, y) {\n                        return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);\n                    }\n                    #getRotationMatrix(rotation) {\n                        switch(rotation){\n                            case 90:\n                                {\n                                    const [pageWidth, pageHeight] = this.pageDimensions;\n                                    return [\n                                        0,\n                                        -pageWidth / pageHeight,\n                                        pageHeight / pageWidth,\n                                        0\n                                    ];\n                                }\n                            case 180:\n                                return [\n                                    -1,\n                                    0,\n                                    0,\n                                    -1\n                                ];\n                            case 270:\n                                {\n                                    const [pageWidth, pageHeight] = this.pageDimensions;\n                                    return [\n                                        0,\n                                        pageWidth / pageHeight,\n                                        -pageHeight / pageWidth,\n                                        0\n                                    ];\n                                }\n                            default:\n                                return [\n                                    1,\n                                    0,\n                                    0,\n                                    1\n                                ];\n                        }\n                    }\n                    get parentScale() {\n                        return this._uiManager.viewParameters.realScale;\n                    }\n                    get parentRotation() {\n                        return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n                    }\n                    get parentDimensions() {\n                        const { parentScale, pageDimensions: [pageWidth, pageHeight] } = this;\n                        const scaledWidth = pageWidth * parentScale;\n                        const scaledHeight = pageHeight * parentScale;\n                        return _util.FeatureTest.isCSSRoundSupported ? [\n                            Math.round(scaledWidth),\n                            Math.round(scaledHeight)\n                        ] : [\n                            scaledWidth,\n                            scaledHeight\n                        ];\n                    }\n                    setDims(width, height) {\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        this.div.style.width = `${(100 * width / parentWidth).toFixed(2)}%`;\n                        if (!this.#keepAspectRatio) {\n                            this.div.style.height = `${(100 * height / parentHeight).toFixed(2)}%`;\n                        }\n                        this.#altTextButton?.classList.toggle(\"small\", width < AnnotationEditor.SMALL_EDITOR_SIZE || height < AnnotationEditor.SMALL_EDITOR_SIZE);\n                    }\n                    fixDims() {\n                        const { style } = this.div;\n                        const { height, width } = style;\n                        const widthPercent = width.endsWith(\"%\");\n                        const heightPercent = !this.#keepAspectRatio && height.endsWith(\"%\");\n                        if (widthPercent && heightPercent) {\n                            return;\n                        }\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        if (!widthPercent) {\n                            style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;\n                        }\n                        if (!this.#keepAspectRatio && !heightPercent) {\n                            style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;\n                        }\n                    }\n                    getInitialTranslation() {\n                        return [\n                            0,\n                            0\n                        ];\n                    }\n                    #createResizers() {\n                        if (this.#resizersDiv) {\n                            return;\n                        }\n                        this.#resizersDiv = document.createElement(\"div\");\n                        this.#resizersDiv.classList.add(\"resizers\");\n                        const classes = [\n                            \"topLeft\",\n                            \"topRight\",\n                            \"bottomRight\",\n                            \"bottomLeft\"\n                        ];\n                        if (!this._willKeepAspectRatio) {\n                            classes.push(\"topMiddle\", \"middleRight\", \"bottomMiddle\", \"middleLeft\");\n                        }\n                        for (const name of classes){\n                            const div = document.createElement(\"div\");\n                            this.#resizersDiv.append(div);\n                            div.classList.add(\"resizer\", name);\n                            div.addEventListener(\"pointerdown\", this.#resizerPointerdown.bind(this, name));\n                            div.addEventListener(\"contextmenu\", _display_utils.noContextMenu);\n                        }\n                        this.div.prepend(this.#resizersDiv);\n                    }\n                    #resizerPointerdown(name, event) {\n                        event.preventDefault();\n                        const { isMac } = _util.FeatureTest.platform;\n                        if (event.button !== 0 || event.ctrlKey && isMac) {\n                            return;\n                        }\n                        const boundResizerPointermove = this.#resizerPointermove.bind(this, name);\n                        const savedDraggable = this._isDraggable;\n                        this._isDraggable = false;\n                        const pointerMoveOptions = {\n                            passive: true,\n                            capture: true\n                        };\n                        window.addEventListener(\"pointermove\", boundResizerPointermove, pointerMoveOptions);\n                        const savedX = this.x;\n                        const savedY = this.y;\n                        const savedWidth = this.width;\n                        const savedHeight = this.height;\n                        const savedParentCursor = this.parent.div.style.cursor;\n                        const savedCursor = this.div.style.cursor;\n                        this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;\n                        const pointerUpCallback = ()=>{\n                            this._isDraggable = savedDraggable;\n                            window.removeEventListener(\"pointerup\", pointerUpCallback);\n                            window.removeEventListener(\"blur\", pointerUpCallback);\n                            window.removeEventListener(\"pointermove\", boundResizerPointermove, pointerMoveOptions);\n                            this.parent.div.style.cursor = savedParentCursor;\n                            this.div.style.cursor = savedCursor;\n                            const newX = this.x;\n                            const newY = this.y;\n                            const newWidth = this.width;\n                            const newHeight = this.height;\n                            if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {\n                                return;\n                            }\n                            this.addCommands({\n                                cmd: ()=>{\n                                    this.width = newWidth;\n                                    this.height = newHeight;\n                                    this.x = newX;\n                                    this.y = newY;\n                                    const [parentWidth, parentHeight] = this.parentDimensions;\n                                    this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n                                    this.fixAndSetPosition();\n                                },\n                                undo: ()=>{\n                                    this.width = savedWidth;\n                                    this.height = savedHeight;\n                                    this.x = savedX;\n                                    this.y = savedY;\n                                    const [parentWidth, parentHeight] = this.parentDimensions;\n                                    this.setDims(parentWidth * savedWidth, parentHeight * savedHeight);\n                                    this.fixAndSetPosition();\n                                },\n                                mustExec: true\n                            });\n                        };\n                        window.addEventListener(\"pointerup\", pointerUpCallback);\n                        window.addEventListener(\"blur\", pointerUpCallback);\n                    }\n                    #resizerPointermove(name, event) {\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        const savedX = this.x;\n                        const savedY = this.y;\n                        const savedWidth = this.width;\n                        const savedHeight = this.height;\n                        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n                        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n                        const round = (x)=>Math.round(x * 10000) / 10000;\n                        const rotationMatrix = this.#getRotationMatrix(this.rotation);\n                        const transf = (x, y)=>[\n                                rotationMatrix[0] * x + rotationMatrix[2] * y,\n                                rotationMatrix[1] * x + rotationMatrix[3] * y\n                            ];\n                        const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);\n                        const invTransf = (x, y)=>[\n                                invRotationMatrix[0] * x + invRotationMatrix[2] * y,\n                                invRotationMatrix[1] * x + invRotationMatrix[3] * y\n                            ];\n                        let getPoint;\n                        let getOpposite;\n                        let isDiagonal = false;\n                        let isHorizontal = false;\n                        switch(name){\n                            case \"topLeft\":\n                                isDiagonal = true;\n                                getPoint = (w, h)=>[\n                                        0,\n                                        0\n                                    ];\n                                getOpposite = (w, h)=>[\n                                        w,\n                                        h\n                                    ];\n                                break;\n                            case \"topMiddle\":\n                                getPoint = (w, h)=>[\n                                        w / 2,\n                                        0\n                                    ];\n                                getOpposite = (w, h)=>[\n                                        w / 2,\n                                        h\n                                    ];\n                                break;\n                            case \"topRight\":\n                                isDiagonal = true;\n                                getPoint = (w, h)=>[\n                                        w,\n                                        0\n                                    ];\n                                getOpposite = (w, h)=>[\n                                        0,\n                                        h\n                                    ];\n                                break;\n                            case \"middleRight\":\n                                isHorizontal = true;\n                                getPoint = (w, h)=>[\n                                        w,\n                                        h / 2\n                                    ];\n                                getOpposite = (w, h)=>[\n                                        0,\n                                        h / 2\n                                    ];\n                                break;\n                            case \"bottomRight\":\n                                isDiagonal = true;\n                                getPoint = (w, h)=>[\n                                        w,\n                                        h\n                                    ];\n                                getOpposite = (w, h)=>[\n                                        0,\n                                        0\n                                    ];\n                                break;\n                            case \"bottomMiddle\":\n                                getPoint = (w, h)=>[\n                                        w / 2,\n                                        h\n                                    ];\n                                getOpposite = (w, h)=>[\n                                        w / 2,\n                                        0\n                                    ];\n                                break;\n                            case \"bottomLeft\":\n                                isDiagonal = true;\n                                getPoint = (w, h)=>[\n                                        0,\n                                        h\n                                    ];\n                                getOpposite = (w, h)=>[\n                                        w,\n                                        0\n                                    ];\n                                break;\n                            case \"middleLeft\":\n                                isHorizontal = true;\n                                getPoint = (w, h)=>[\n                                        0,\n                                        h / 2\n                                    ];\n                                getOpposite = (w, h)=>[\n                                        w,\n                                        h / 2\n                                    ];\n                                break;\n                        }\n                        const point = getPoint(savedWidth, savedHeight);\n                        const oppositePoint = getOpposite(savedWidth, savedHeight);\n                        let transfOppositePoint = transf(...oppositePoint);\n                        const oppositeX = round(savedX + transfOppositePoint[0]);\n                        const oppositeY = round(savedY + transfOppositePoint[1]);\n                        let ratioX = 1;\n                        let ratioY = 1;\n                        let [deltaX, deltaY] = this.screenToPageTranslation(event.movementX, event.movementY);\n                        [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);\n                        if (isDiagonal) {\n                            const oldDiag = Math.hypot(savedWidth, savedHeight);\n                            ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n                        } else if (isHorizontal) {\n                            ratioX = Math.max(minWidth, Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))) / savedWidth;\n                        } else {\n                            ratioY = Math.max(minHeight, Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))) / savedHeight;\n                        }\n                        const newWidth = round(savedWidth * ratioX);\n                        const newHeight = round(savedHeight * ratioY);\n                        transfOppositePoint = transf(...getOpposite(newWidth, newHeight));\n                        const newX = oppositeX - transfOppositePoint[0];\n                        const newY = oppositeY - transfOppositePoint[1];\n                        this.width = newWidth;\n                        this.height = newHeight;\n                        this.x = newX;\n                        this.y = newY;\n                        this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n                        this.fixAndSetPosition();\n                    }\n                    async addAltTextButton() {\n                        if (this.#altTextButton) {\n                            return;\n                        }\n                        const altText = this.#altTextButton = document.createElement(\"button\");\n                        altText.className = \"altText\";\n                        const msg = await AnnotationEditor._l10nPromise.get(\"editor_alt_text_button_label\");\n                        altText.textContent = msg;\n                        altText.setAttribute(\"aria-label\", msg);\n                        altText.tabIndex = \"0\";\n                        altText.addEventListener(\"contextmenu\", _display_utils.noContextMenu);\n                        altText.addEventListener(\"pointerdown\", (event)=>event.stopPropagation());\n                        altText.addEventListener(\"click\", (event)=>{\n                            event.preventDefault();\n                            this._uiManager.editAltText(this);\n                        }, {\n                            capture: true\n                        });\n                        altText.addEventListener(\"keydown\", (event)=>{\n                            if (event.target === altText && event.key === \"Enter\") {\n                                event.preventDefault();\n                                this._uiManager.editAltText(this);\n                            }\n                        });\n                        this.#setAltTextButtonState();\n                        this.div.append(altText);\n                        if (!AnnotationEditor.SMALL_EDITOR_SIZE) {\n                            const PERCENT = 40;\n                            AnnotationEditor.SMALL_EDITOR_SIZE = Math.min(128, Math.round(altText.getBoundingClientRect().width * (1 + PERCENT / 100)));\n                        }\n                    }\n                    async #setAltTextButtonState() {\n                        const button = this.#altTextButton;\n                        if (!button) {\n                            return;\n                        }\n                        if (!this.#altText && !this.#altTextDecorative) {\n                            button.classList.remove(\"done\");\n                            this.#altTextTooltip?.remove();\n                            return;\n                        }\n                        AnnotationEditor._l10nPromise.get(\"editor_alt_text_edit_button_label\").then((msg)=>{\n                            button.setAttribute(\"aria-label\", msg);\n                        });\n                        let tooltip = this.#altTextTooltip;\n                        if (!tooltip) {\n                            this.#altTextTooltip = tooltip = document.createElement(\"span\");\n                            tooltip.className = \"tooltip\";\n                            tooltip.setAttribute(\"role\", \"tooltip\");\n                            const id = tooltip.id = `alt-text-tooltip-${this.id}`;\n                            button.setAttribute(\"aria-describedby\", id);\n                            const DELAY_TO_SHOW_TOOLTIP = 100;\n                            button.addEventListener(\"mouseenter\", ()=>{\n                                this.#altTextTooltipTimeout = setTimeout(()=>{\n                                    this.#altTextTooltipTimeout = null;\n                                    this.#altTextTooltip.classList.add(\"show\");\n                                    this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n                                        source: this,\n                                        details: {\n                                            type: \"editing\",\n                                            subtype: this.editorType,\n                                            data: {\n                                                action: \"alt_text_tooltip\"\n                                            }\n                                        }\n                                    });\n                                }, DELAY_TO_SHOW_TOOLTIP);\n                            });\n                            button.addEventListener(\"mouseleave\", ()=>{\n                                clearTimeout(this.#altTextTooltipTimeout);\n                                this.#altTextTooltipTimeout = null;\n                                this.#altTextTooltip?.classList.remove(\"show\");\n                            });\n                        }\n                        button.classList.add(\"done\");\n                        tooltip.innerText = this.#altTextDecorative ? await AnnotationEditor._l10nPromise.get(\"editor_alt_text_decorative_tooltip\") : this.#altText;\n                        if (!tooltip.parentNode) {\n                            button.append(tooltip);\n                        }\n                    }\n                    getClientDimensions() {\n                        return this.div.getBoundingClientRect();\n                    }\n                    get altTextData() {\n                        return {\n                            altText: this.#altText,\n                            decorative: this.#altTextDecorative\n                        };\n                    }\n                    set altTextData({ altText, decorative }) {\n                        if (this.#altText === altText && this.#altTextDecorative === decorative) {\n                            return;\n                        }\n                        this.#altText = altText;\n                        this.#altTextDecorative = decorative;\n                        this.#setAltTextButtonState();\n                    }\n                    render() {\n                        this.div = document.createElement(\"div\");\n                        this.div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n                        this.div.className = this.name;\n                        this.div.setAttribute(\"id\", this.id);\n                        this.div.setAttribute(\"tabIndex\", 0);\n                        this.setInForeground();\n                        this.div.addEventListener(\"focusin\", this.#boundFocusin);\n                        this.div.addEventListener(\"focusout\", this.#boundFocusout);\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        if (this.parentRotation % 180 !== 0) {\n                            this.div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;\n                            this.div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;\n                        }\n                        const [tx, ty] = this.getInitialTranslation();\n                        this.translate(tx, ty);\n                        (0, _tools.bindEvents)(this, this.div, [\n                            \"pointerdown\"\n                        ]);\n                        return this.div;\n                    }\n                    pointerdown(event) {\n                        const { isMac } = _util.FeatureTest.platform;\n                        if (event.button !== 0 || event.ctrlKey && isMac) {\n                            event.preventDefault();\n                            return;\n                        }\n                        this.#hasBeenClicked = true;\n                        this.#setUpDragSession(event);\n                    }\n                    #setUpDragSession(event) {\n                        if (!this._isDraggable) {\n                            return;\n                        }\n                        const isSelected = this._uiManager.isSelected(this);\n                        this._uiManager.setUpDragSession();\n                        let pointerMoveOptions, pointerMoveCallback;\n                        if (isSelected) {\n                            pointerMoveOptions = {\n                                passive: true,\n                                capture: true\n                            };\n                            pointerMoveCallback = (e)=>{\n                                const [tx, ty] = this.screenToPageTranslation(e.movementX, e.movementY);\n                                this._uiManager.dragSelectedEditors(tx, ty);\n                            };\n                            window.addEventListener(\"pointermove\", pointerMoveCallback, pointerMoveOptions);\n                        }\n                        const pointerUpCallback = ()=>{\n                            window.removeEventListener(\"pointerup\", pointerUpCallback);\n                            window.removeEventListener(\"blur\", pointerUpCallback);\n                            if (isSelected) {\n                                window.removeEventListener(\"pointermove\", pointerMoveCallback, pointerMoveOptions);\n                            }\n                            this.#hasBeenClicked = false;\n                            if (!this._uiManager.endDragSession()) {\n                                const { isMac } = _util.FeatureTest.platform;\n                                if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n                                    this.parent.toggleSelected(this);\n                                } else {\n                                    this.parent.setSelected(this);\n                                }\n                            }\n                        };\n                        window.addEventListener(\"pointerup\", pointerUpCallback);\n                        window.addEventListener(\"blur\", pointerUpCallback);\n                    }\n                    moveInDOM() {\n                        this.parent?.moveEditorInDOM(this);\n                    }\n                    _setParentAndPosition(parent, x, y) {\n                        parent.changeParent(this);\n                        this.x = x;\n                        this.y = y;\n                        this.fixAndSetPosition();\n                    }\n                    getRect(tx, ty) {\n                        const scale = this.parentScale;\n                        const [pageWidth, pageHeight] = this.pageDimensions;\n                        const [pageX, pageY] = this.pageTranslation;\n                        const shiftX = tx / scale;\n                        const shiftY = ty / scale;\n                        const x = this.x * pageWidth;\n                        const y = this.y * pageHeight;\n                        const width = this.width * pageWidth;\n                        const height = this.height * pageHeight;\n                        switch(this.rotation){\n                            case 0:\n                                return [\n                                    x + shiftX + pageX,\n                                    pageHeight - y - shiftY - height + pageY,\n                                    x + shiftX + width + pageX,\n                                    pageHeight - y - shiftY + pageY\n                                ];\n                            case 90:\n                                return [\n                                    x + shiftY + pageX,\n                                    pageHeight - y + shiftX + pageY,\n                                    x + shiftY + height + pageX,\n                                    pageHeight - y + shiftX + width + pageY\n                                ];\n                            case 180:\n                                return [\n                                    x - shiftX - width + pageX,\n                                    pageHeight - y + shiftY + pageY,\n                                    x - shiftX + pageX,\n                                    pageHeight - y + shiftY + height + pageY\n                                ];\n                            case 270:\n                                return [\n                                    x - shiftY - height + pageX,\n                                    pageHeight - y - shiftX - width + pageY,\n                                    x - shiftY + pageX,\n                                    pageHeight - y - shiftX + pageY\n                                ];\n                            default:\n                                throw new Error(\"Invalid rotation\");\n                        }\n                    }\n                    getRectInCurrentCoords(rect, pageHeight) {\n                        const [x1, y1, x2, y2] = rect;\n                        const width = x2 - x1;\n                        const height = y2 - y1;\n                        switch(this.rotation){\n                            case 0:\n                                return [\n                                    x1,\n                                    pageHeight - y2,\n                                    width,\n                                    height\n                                ];\n                            case 90:\n                                return [\n                                    x1,\n                                    pageHeight - y1,\n                                    height,\n                                    width\n                                ];\n                            case 180:\n                                return [\n                                    x2,\n                                    pageHeight - y1,\n                                    width,\n                                    height\n                                ];\n                            case 270:\n                                return [\n                                    x2,\n                                    pageHeight - y2,\n                                    height,\n                                    width\n                                ];\n                            default:\n                                throw new Error(\"Invalid rotation\");\n                        }\n                    }\n                    onceAdded() {}\n                    isEmpty() {\n                        return false;\n                    }\n                    enableEditMode() {\n                        this.#isInEditMode = true;\n                    }\n                    disableEditMode() {\n                        this.#isInEditMode = false;\n                    }\n                    isInEditMode() {\n                        return this.#isInEditMode;\n                    }\n                    shouldGetKeyboardEvents() {\n                        return false;\n                    }\n                    needsToBeRebuilt() {\n                        return this.div && !this.isAttachedToDOM;\n                    }\n                    rebuild() {\n                        this.div?.addEventListener(\"focusin\", this.#boundFocusin);\n                        this.div?.addEventListener(\"focusout\", this.#boundFocusout);\n                    }\n                    serialize(isForCopying = false, context = null) {\n                        (0, _util.unreachable)(\"An editor must be serializable\");\n                    }\n                    static deserialize(data, parent, uiManager) {\n                        const editor = new this.prototype.constructor({\n                            parent,\n                            id: parent.getNextId(),\n                            uiManager\n                        });\n                        editor.rotation = data.rotation;\n                        const [pageWidth, pageHeight] = editor.pageDimensions;\n                        const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n                        editor.x = x / pageWidth;\n                        editor.y = y / pageHeight;\n                        editor.width = width / pageWidth;\n                        editor.height = height / pageHeight;\n                        return editor;\n                    }\n                    remove() {\n                        this.div.removeEventListener(\"focusin\", this.#boundFocusin);\n                        this.div.removeEventListener(\"focusout\", this.#boundFocusout);\n                        if (!this.isEmpty()) {\n                            this.commit();\n                        }\n                        if (this.parent) {\n                            this.parent.remove(this);\n                        } else {\n                            this._uiManager.removeEditor(this);\n                        }\n                        this.#altTextButton?.remove();\n                        this.#altTextButton = null;\n                        this.#altTextTooltip = null;\n                    }\n                    get isResizable() {\n                        return false;\n                    }\n                    makeResizable() {\n                        if (this.isResizable) {\n                            this.#createResizers();\n                            this.#resizersDiv.classList.remove(\"hidden\");\n                        }\n                    }\n                    select() {\n                        this.makeResizable();\n                        this.div?.classList.add(\"selectedEditor\");\n                    }\n                    unselect() {\n                        this.#resizersDiv?.classList.add(\"hidden\");\n                        this.div?.classList.remove(\"selectedEditor\");\n                        if (this.div?.contains(document.activeElement)) {\n                            this._uiManager.currentLayer.div.focus();\n                        }\n                    }\n                    updateParams(type, value) {}\n                    disableEditing() {\n                        if (this.#altTextButton) {\n                            this.#altTextButton.hidden = true;\n                        }\n                    }\n                    enableEditing() {\n                        if (this.#altTextButton) {\n                            this.#altTextButton.hidden = false;\n                        }\n                    }\n                    enterInEditMode() {}\n                    get contentDiv() {\n                        return this.div;\n                    }\n                    get isEditing() {\n                        return this.#isEditing;\n                    }\n                    set isEditing(value) {\n                        this.#isEditing = value;\n                        if (!this.parent) {\n                            return;\n                        }\n                        if (value) {\n                            this.parent.setSelected(this);\n                            this.parent.setActiveEditor(this);\n                        } else {\n                            this.parent.setActiveEditor(null);\n                        }\n                    }\n                    setAspectRatio(width, height) {\n                        this.#keepAspectRatio = true;\n                        const aspectRatio = width / height;\n                        const { style } = this.div;\n                        style.aspectRatio = aspectRatio;\n                        style.height = \"auto\";\n                    }\n                    static get MIN_SIZE() {\n                        return 16;\n                    }\n                }\n                exports1.AnnotationEditor = AnnotationEditor;\n                class FakeEditor extends AnnotationEditor {\n                    constructor(params){\n                        super(params);\n                        this.annotationElementId = params.annotationElementId;\n                        this.deleted = true;\n                    }\n                    serialize() {\n                        return {\n                            id: this.annotationElementId,\n                            deleted: true,\n                            pageIndex: this.pageIndex\n                        };\n                    }\n                }\n            /***/ },\n            /* 5 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.KeyboardManager = exports1.CommandManager = exports1.ColorManager = exports1.AnnotationEditorUIManager = void 0;\n                exports1.bindEvents = bindEvents;\n                exports1.opacityToHex = opacityToHex;\n                var _util = __w_pdfjs_require__(1);\n                var _display_utils = __w_pdfjs_require__(6);\n                function bindEvents(obj, element, names) {\n                    for (const name of names){\n                        element.addEventListener(name, obj[name].bind(obj));\n                    }\n                }\n                function opacityToHex(opacity) {\n                    return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, \"0\");\n                }\n                class IdManager {\n                    #id;\n                    getId() {\n                        return `${_util.AnnotationEditorPrefix}${this.#id++}`;\n                    }\n                    constructor(){\n                        this.#id = 0;\n                    }\n                }\n                class ImageManager {\n                    #baseId;\n                    #id;\n                    #cache;\n                    static get _isSVGFittingCanvas() {\n                        const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n                        const canvas = new OffscreenCanvas(1, 3);\n                        const ctx = canvas.getContext(\"2d\");\n                        const image = new Image();\n                        image.src = svg;\n                        const promise = image.decode().then(()=>{\n                            ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n                            return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n                        });\n                        return (0, _util.shadow)(this, \"_isSVGFittingCanvas\", promise);\n                    }\n                    async #get(key, rawData) {\n                        this.#cache ||= new Map();\n                        let data = this.#cache.get(key);\n                        if (data === null) {\n                            return null;\n                        }\n                        if (data?.bitmap) {\n                            data.refCounter += 1;\n                            return data;\n                        }\n                        try {\n                            data ||= {\n                                bitmap: null,\n                                id: `image_${this.#baseId}_${this.#id++}`,\n                                refCounter: 0,\n                                isSvg: false\n                            };\n                            let image;\n                            if (typeof rawData === \"string\") {\n                                data.url = rawData;\n                                const response = await fetch(rawData);\n                                if (!response.ok) {\n                                    throw new Error(response.statusText);\n                                }\n                                image = await response.blob();\n                            } else {\n                                image = data.file = rawData;\n                            }\n                            if (image.type === \"image/svg+xml\") {\n                                const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;\n                                const fileReader = new FileReader();\n                                const imageElement = new Image();\n                                const imagePromise = new Promise((resolve, reject)=>{\n                                    imageElement.onload = ()=>{\n                                        data.bitmap = imageElement;\n                                        data.isSvg = true;\n                                        resolve();\n                                    };\n                                    fileReader.onload = async ()=>{\n                                        const url = data.svgUrl = fileReader.result;\n                                        imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;\n                                    };\n                                    imageElement.onerror = fileReader.onerror = reject;\n                                });\n                                fileReader.readAsDataURL(image);\n                                await imagePromise;\n                            } else {\n                                data.bitmap = await createImageBitmap(image);\n                            }\n                            data.refCounter = 1;\n                        } catch (e) {\n                            console.error(e);\n                            data = null;\n                        }\n                        this.#cache.set(key, data);\n                        if (data) {\n                            this.#cache.set(data.id, data);\n                        }\n                        return data;\n                    }\n                    async getFromFile(file) {\n                        const { lastModified, name, size, type } = file;\n                        return this.#get(`${lastModified}_${name}_${size}_${type}`, file);\n                    }\n                    async getFromUrl(url) {\n                        return this.#get(url, url);\n                    }\n                    async getFromId(id) {\n                        this.#cache ||= new Map();\n                        const data = this.#cache.get(id);\n                        if (!data) {\n                            return null;\n                        }\n                        if (data.bitmap) {\n                            data.refCounter += 1;\n                            return data;\n                        }\n                        if (data.file) {\n                            return this.getFromFile(data.file);\n                        }\n                        return this.getFromUrl(data.url);\n                    }\n                    getSvgUrl(id) {\n                        const data = this.#cache.get(id);\n                        if (!data?.isSvg) {\n                            return null;\n                        }\n                        return data.svgUrl;\n                    }\n                    deleteId(id) {\n                        this.#cache ||= new Map();\n                        const data = this.#cache.get(id);\n                        if (!data) {\n                            return;\n                        }\n                        data.refCounter -= 1;\n                        if (data.refCounter !== 0) {\n                            return;\n                        }\n                        data.bitmap = null;\n                    }\n                    isValidId(id) {\n                        return id.startsWith(`image_${this.#baseId}_`);\n                    }\n                    constructor(){\n                        this.#baseId = (0, _util.getUuid)();\n                        this.#id = 0;\n                        this.#cache = null;\n                    }\n                }\n                class CommandManager {\n                    #commands;\n                    #locked;\n                    #maxSize;\n                    #position;\n                    constructor(maxSize = 128){\n                        this.#commands = [];\n                        this.#locked = false;\n                        this.#position = -1;\n                        this.#maxSize = maxSize;\n                    }\n                    add({ cmd, undo, mustExec, type = NaN, overwriteIfSameType = false, keepUndo = false }) {\n                        if (mustExec) {\n                            cmd();\n                        }\n                        if (this.#locked) {\n                            return;\n                        }\n                        const save = {\n                            cmd,\n                            undo,\n                            type\n                        };\n                        if (this.#position === -1) {\n                            if (this.#commands.length > 0) {\n                                this.#commands.length = 0;\n                            }\n                            this.#position = 0;\n                            this.#commands.push(save);\n                            return;\n                        }\n                        if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n                            if (keepUndo) {\n                                save.undo = this.#commands[this.#position].undo;\n                            }\n                            this.#commands[this.#position] = save;\n                            return;\n                        }\n                        const next = this.#position + 1;\n                        if (next === this.#maxSize) {\n                            this.#commands.splice(0, 1);\n                        } else {\n                            this.#position = next;\n                            if (next < this.#commands.length) {\n                                this.#commands.splice(next);\n                            }\n                        }\n                        this.#commands.push(save);\n                    }\n                    undo() {\n                        if (this.#position === -1) {\n                            return;\n                        }\n                        this.#locked = true;\n                        this.#commands[this.#position].undo();\n                        this.#locked = false;\n                        this.#position -= 1;\n                    }\n                    redo() {\n                        if (this.#position < this.#commands.length - 1) {\n                            this.#position += 1;\n                            this.#locked = true;\n                            this.#commands[this.#position].cmd();\n                            this.#locked = false;\n                        }\n                    }\n                    hasSomethingToUndo() {\n                        return this.#position !== -1;\n                    }\n                    hasSomethingToRedo() {\n                        return this.#position < this.#commands.length - 1;\n                    }\n                    destroy() {\n                        this.#commands = null;\n                    }\n                }\n                exports1.CommandManager = CommandManager;\n                class KeyboardManager {\n                    constructor(callbacks){\n                        this.buffer = [];\n                        this.callbacks = new Map();\n                        this.allKeys = new Set();\n                        const { isMac } = _util.FeatureTest.platform;\n                        for (const [keys, callback, options = {}] of callbacks){\n                            for (const key of keys){\n                                const isMacKey = key.startsWith(\"mac+\");\n                                if (isMac && isMacKey) {\n                                    this.callbacks.set(key.slice(4), {\n                                        callback,\n                                        options\n                                    });\n                                    this.allKeys.add(key.split(\"+\").at(-1));\n                                } else if (!isMac && !isMacKey) {\n                                    this.callbacks.set(key, {\n                                        callback,\n                                        options\n                                    });\n                                    this.allKeys.add(key.split(\"+\").at(-1));\n                                }\n                            }\n                        }\n                    }\n                    #serialize(event) {\n                        if (event.altKey) {\n                            this.buffer.push(\"alt\");\n                        }\n                        if (event.ctrlKey) {\n                            this.buffer.push(\"ctrl\");\n                        }\n                        if (event.metaKey) {\n                            this.buffer.push(\"meta\");\n                        }\n                        if (event.shiftKey) {\n                            this.buffer.push(\"shift\");\n                        }\n                        this.buffer.push(event.key);\n                        const str = this.buffer.join(\"+\");\n                        this.buffer.length = 0;\n                        return str;\n                    }\n                    exec(self, event) {\n                        if (!this.allKeys.has(event.key)) {\n                            return;\n                        }\n                        const info = this.callbacks.get(this.#serialize(event));\n                        if (!info) {\n                            return;\n                        }\n                        const { callback, options: { bubbles = false, args = [], checker = null } } = info;\n                        if (checker && !checker(self, event)) {\n                            return;\n                        }\n                        callback.bind(self, ...args)();\n                        if (!bubbles) {\n                            event.stopPropagation();\n                            event.preventDefault();\n                        }\n                    }\n                }\n                exports1.KeyboardManager = KeyboardManager;\n                class ColorManager {\n                    static{\n                        this._colorsMapping = new Map([\n                            [\n                                \"CanvasText\",\n                                [\n                                    0,\n                                    0,\n                                    0\n                                ]\n                            ],\n                            [\n                                \"Canvas\",\n                                [\n                                    255,\n                                    255,\n                                    255\n                                ]\n                            ]\n                        ]);\n                    }\n                    get _colors() {\n                        const colors = new Map([\n                            [\n                                \"CanvasText\",\n                                null\n                            ],\n                            [\n                                \"Canvas\",\n                                null\n                            ]\n                        ]);\n                        (0, _display_utils.getColorValues)(colors);\n                        return (0, _util.shadow)(this, \"_colors\", colors);\n                    }\n                    convert(color) {\n                        const rgb = (0, _display_utils.getRGB)(color);\n                        if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n                            return rgb;\n                        }\n                        for (const [name, RGB] of this._colors){\n                            if (RGB.every((x, i)=>x === rgb[i])) {\n                                return ColorManager._colorsMapping.get(name);\n                            }\n                        }\n                        return rgb;\n                    }\n                    getHexCode(name) {\n                        const rgb = this._colors.get(name);\n                        if (!rgb) {\n                            return name;\n                        }\n                        return _util.Util.makeHexColor(...rgb);\n                    }\n                }\n                exports1.ColorManager = ColorManager;\n                class AnnotationEditorUIManager {\n                    #activeEditor;\n                    #allEditors;\n                    #allLayers;\n                    #altTextManager;\n                    #annotationStorage;\n                    #commandManager;\n                    #currentPageIndex;\n                    #deletedAnnotationsElementIds;\n                    #draggingEditors;\n                    #editorTypes;\n                    #editorsToRescale;\n                    #filterFactory;\n                    #idManager;\n                    #isEnabled;\n                    #isWaiting;\n                    #lastActiveElement;\n                    #mode;\n                    #selectedEditors;\n                    #pageColors;\n                    #boundBlur;\n                    #boundFocus;\n                    #boundCopy;\n                    #boundCut;\n                    #boundPaste;\n                    #boundKeydown;\n                    #boundOnEditingAction;\n                    #boundOnPageChanging;\n                    #boundOnScaleChanging;\n                    #boundOnRotationChanging;\n                    #previousStates;\n                    #translation;\n                    #translationTimeoutId;\n                    #container;\n                    #viewer;\n                    static{\n                        this.TRANSLATE_SMALL = 1;\n                    }\n                    static{\n                        this.TRANSLATE_BIG = 10;\n                    }\n                    static get _keyboardManager() {\n                        const proto = AnnotationEditorUIManager.prototype;\n                        const arrowChecker = (self)=>{\n                            const { activeElement } = document;\n                            return activeElement && self.#container.contains(activeElement) && self.hasSomethingToControl();\n                        };\n                        const small = this.TRANSLATE_SMALL;\n                        const big = this.TRANSLATE_BIG;\n                        return (0, _util.shadow)(this, \"_keyboardManager\", new KeyboardManager([\n                            [\n                                [\n                                    \"ctrl+a\",\n                                    \"mac+meta+a\"\n                                ],\n                                proto.selectAll\n                            ],\n                            [\n                                [\n                                    \"ctrl+z\",\n                                    \"mac+meta+z\"\n                                ],\n                                proto.undo\n                            ],\n                            [\n                                [\n                                    \"ctrl+y\",\n                                    \"ctrl+shift+z\",\n                                    \"mac+meta+shift+z\",\n                                    \"ctrl+shift+Z\",\n                                    \"mac+meta+shift+Z\"\n                                ],\n                                proto.redo\n                            ],\n                            [\n                                [\n                                    \"Backspace\",\n                                    \"alt+Backspace\",\n                                    \"ctrl+Backspace\",\n                                    \"shift+Backspace\",\n                                    \"mac+Backspace\",\n                                    \"mac+alt+Backspace\",\n                                    \"mac+ctrl+Backspace\",\n                                    \"Delete\",\n                                    \"ctrl+Delete\",\n                                    \"shift+Delete\",\n                                    \"mac+Delete\"\n                                ],\n                                proto.delete\n                            ],\n                            [\n                                [\n                                    \"Escape\",\n                                    \"mac+Escape\"\n                                ],\n                                proto.unselectAll\n                            ],\n                            [\n                                [\n                                    \"ArrowLeft\",\n                                    \"mac+ArrowLeft\"\n                                ],\n                                proto.translateSelectedEditors,\n                                {\n                                    args: [\n                                        -small,\n                                        0\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowLeft\",\n                                    \"mac+shift+ArrowLeft\"\n                                ],\n                                proto.translateSelectedEditors,\n                                {\n                                    args: [\n                                        -big,\n                                        0\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowRight\",\n                                    \"mac+ArrowRight\"\n                                ],\n                                proto.translateSelectedEditors,\n                                {\n                                    args: [\n                                        small,\n                                        0\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowRight\",\n                                    \"mac+shift+ArrowRight\"\n                                ],\n                                proto.translateSelectedEditors,\n                                {\n                                    args: [\n                                        big,\n                                        0\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowUp\",\n                                    \"mac+ArrowUp\"\n                                ],\n                                proto.translateSelectedEditors,\n                                {\n                                    args: [\n                                        0,\n                                        -small\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowUp\",\n                                    \"mac+shift+ArrowUp\"\n                                ],\n                                proto.translateSelectedEditors,\n                                {\n                                    args: [\n                                        0,\n                                        -big\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowDown\",\n                                    \"mac+ArrowDown\"\n                                ],\n                                proto.translateSelectedEditors,\n                                {\n                                    args: [\n                                        0,\n                                        small\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowDown\",\n                                    \"mac+shift+ArrowDown\"\n                                ],\n                                proto.translateSelectedEditors,\n                                {\n                                    args: [\n                                        0,\n                                        big\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ]\n                        ]));\n                    }\n                    constructor(container, viewer, altTextManager, eventBus, pdfDocument, pageColors){\n                        this.#activeEditor = null;\n                        this.#allEditors = new Map();\n                        this.#allLayers = new Map();\n                        this.#altTextManager = null;\n                        this.#annotationStorage = null;\n                        this.#commandManager = new CommandManager();\n                        this.#currentPageIndex = 0;\n                        this.#deletedAnnotationsElementIds = new Set();\n                        this.#draggingEditors = null;\n                        this.#editorTypes = null;\n                        this.#editorsToRescale = new Set();\n                        this.#filterFactory = null;\n                        this.#idManager = new IdManager();\n                        this.#isEnabled = false;\n                        this.#isWaiting = false;\n                        this.#lastActiveElement = null;\n                        this.#mode = _util.AnnotationEditorType.NONE;\n                        this.#selectedEditors = new Set();\n                        this.#pageColors = null;\n                        this.#boundBlur = this.blur.bind(this);\n                        this.#boundFocus = this.focus.bind(this);\n                        this.#boundCopy = this.copy.bind(this);\n                        this.#boundCut = this.cut.bind(this);\n                        this.#boundPaste = this.paste.bind(this);\n                        this.#boundKeydown = this.keydown.bind(this);\n                        this.#boundOnEditingAction = this.onEditingAction.bind(this);\n                        this.#boundOnPageChanging = this.onPageChanging.bind(this);\n                        this.#boundOnScaleChanging = this.onScaleChanging.bind(this);\n                        this.#boundOnRotationChanging = this.onRotationChanging.bind(this);\n                        this.#previousStates = {\n                            isEditing: false,\n                            isEmpty: true,\n                            hasSomethingToUndo: false,\n                            hasSomethingToRedo: false,\n                            hasSelectedEditor: false\n                        };\n                        this.#translation = [\n                            0,\n                            0\n                        ];\n                        this.#translationTimeoutId = null;\n                        this.#container = null;\n                        this.#viewer = null;\n                        this.#container = container;\n                        this.#viewer = viewer;\n                        this.#altTextManager = altTextManager;\n                        this._eventBus = eventBus;\n                        this._eventBus._on(\"editingaction\", this.#boundOnEditingAction);\n                        this._eventBus._on(\"pagechanging\", this.#boundOnPageChanging);\n                        this._eventBus._on(\"scalechanging\", this.#boundOnScaleChanging);\n                        this._eventBus._on(\"rotationchanging\", this.#boundOnRotationChanging);\n                        this.#annotationStorage = pdfDocument.annotationStorage;\n                        this.#filterFactory = pdfDocument.filterFactory;\n                        this.#pageColors = pageColors;\n                        this.viewParameters = {\n                            realScale: _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS,\n                            rotation: 0\n                        };\n                    }\n                    destroy() {\n                        this.#removeKeyboardManager();\n                        this.#removeFocusManager();\n                        this._eventBus._off(\"editingaction\", this.#boundOnEditingAction);\n                        this._eventBus._off(\"pagechanging\", this.#boundOnPageChanging);\n                        this._eventBus._off(\"scalechanging\", this.#boundOnScaleChanging);\n                        this._eventBus._off(\"rotationchanging\", this.#boundOnRotationChanging);\n                        for (const layer of this.#allLayers.values()){\n                            layer.destroy();\n                        }\n                        this.#allLayers.clear();\n                        this.#allEditors.clear();\n                        this.#editorsToRescale.clear();\n                        this.#activeEditor = null;\n                        this.#selectedEditors.clear();\n                        this.#commandManager.destroy();\n                        this.#altTextManager.destroy();\n                    }\n                    get hcmFilter() {\n                        return (0, _util.shadow)(this, \"hcmFilter\", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : \"none\");\n                    }\n                    get direction() {\n                        return (0, _util.shadow)(this, \"direction\", getComputedStyle(this.#container).direction);\n                    }\n                    editAltText(editor) {\n                        this.#altTextManager?.editAltText(this, editor);\n                    }\n                    onPageChanging({ pageNumber }) {\n                        this.#currentPageIndex = pageNumber - 1;\n                    }\n                    focusMainContainer() {\n                        this.#container.focus();\n                    }\n                    findParent(x, y) {\n                        for (const layer of this.#allLayers.values()){\n                            const { x: layerX, y: layerY, width, height } = layer.div.getBoundingClientRect();\n                            if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {\n                                return layer;\n                            }\n                        }\n                        return null;\n                    }\n                    disableUserSelect(value = false) {\n                        this.#viewer.classList.toggle(\"noUserSelect\", value);\n                    }\n                    addShouldRescale(editor) {\n                        this.#editorsToRescale.add(editor);\n                    }\n                    removeShouldRescale(editor) {\n                        this.#editorsToRescale.delete(editor);\n                    }\n                    onScaleChanging({ scale }) {\n                        this.commitOrRemove();\n                        this.viewParameters.realScale = scale * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS;\n                        for (const editor of this.#editorsToRescale){\n                            editor.onScaleChanging();\n                        }\n                    }\n                    onRotationChanging({ pagesRotation }) {\n                        this.commitOrRemove();\n                        this.viewParameters.rotation = pagesRotation;\n                    }\n                    addToAnnotationStorage(editor) {\n                        if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {\n                            this.#annotationStorage.setValue(editor.id, editor);\n                        }\n                    }\n                    #addFocusManager() {\n                        window.addEventListener(\"focus\", this.#boundFocus);\n                        window.addEventListener(\"blur\", this.#boundBlur);\n                    }\n                    #removeFocusManager() {\n                        window.removeEventListener(\"focus\", this.#boundFocus);\n                        window.removeEventListener(\"blur\", this.#boundBlur);\n                    }\n                    blur() {\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        const { activeElement } = document;\n                        for (const editor of this.#selectedEditors){\n                            if (editor.div.contains(activeElement)) {\n                                this.#lastActiveElement = [\n                                    editor,\n                                    activeElement\n                                ];\n                                editor._focusEventsAllowed = false;\n                                break;\n                            }\n                        }\n                    }\n                    focus() {\n                        if (!this.#lastActiveElement) {\n                            return;\n                        }\n                        const [lastEditor, lastActiveElement] = this.#lastActiveElement;\n                        this.#lastActiveElement = null;\n                        lastActiveElement.addEventListener(\"focusin\", ()=>{\n                            lastEditor._focusEventsAllowed = true;\n                        }, {\n                            once: true\n                        });\n                        lastActiveElement.focus();\n                    }\n                    #addKeyboardManager() {\n                        window.addEventListener(\"keydown\", this.#boundKeydown, {\n                            capture: true\n                        });\n                    }\n                    #removeKeyboardManager() {\n                        window.removeEventListener(\"keydown\", this.#boundKeydown, {\n                            capture: true\n                        });\n                    }\n                    #addCopyPasteListeners() {\n                        document.addEventListener(\"copy\", this.#boundCopy);\n                        document.addEventListener(\"cut\", this.#boundCut);\n                        document.addEventListener(\"paste\", this.#boundPaste);\n                    }\n                    #removeCopyPasteListeners() {\n                        document.removeEventListener(\"copy\", this.#boundCopy);\n                        document.removeEventListener(\"cut\", this.#boundCut);\n                        document.removeEventListener(\"paste\", this.#boundPaste);\n                    }\n                    addEditListeners() {\n                        this.#addKeyboardManager();\n                        this.#addCopyPasteListeners();\n                    }\n                    removeEditListeners() {\n                        this.#removeKeyboardManager();\n                        this.#removeCopyPasteListeners();\n                    }\n                    copy(event) {\n                        event.preventDefault();\n                        this.#activeEditor?.commitOrRemove();\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        const editors = [];\n                        for (const editor of this.#selectedEditors){\n                            const serialized = editor.serialize(true);\n                            if (serialized) {\n                                editors.push(serialized);\n                            }\n                        }\n                        if (editors.length === 0) {\n                            return;\n                        }\n                        event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors));\n                    }\n                    cut(event) {\n                        this.copy(event);\n                        this.delete();\n                    }\n                    paste(event) {\n                        event.preventDefault();\n                        const { clipboardData } = event;\n                        for (const item of clipboardData.items){\n                            for (const editorType of this.#editorTypes){\n                                if (editorType.isHandlingMimeForPasting(item.type)) {\n                                    editorType.paste(item, this.currentLayer);\n                                    return;\n                                }\n                            }\n                        }\n                        let data = clipboardData.getData(\"application/pdfjs\");\n                        if (!data) {\n                            return;\n                        }\n                        try {\n                            data = JSON.parse(data);\n                        } catch (ex) {\n                            (0, _util.warn)(`paste: \"${ex.message}\".`);\n                            return;\n                        }\n                        if (!Array.isArray(data)) {\n                            return;\n                        }\n                        this.unselectAll();\n                        const layer = this.currentLayer;\n                        try {\n                            const newEditors = [];\n                            for (const editor of data){\n                                const deserializedEditor = layer.deserialize(editor);\n                                if (!deserializedEditor) {\n                                    return;\n                                }\n                                newEditors.push(deserializedEditor);\n                            }\n                            const cmd = ()=>{\n                                for (const editor of newEditors){\n                                    this.#addEditorToLayer(editor);\n                                }\n                                this.#selectEditors(newEditors);\n                            };\n                            const undo = ()=>{\n                                for (const editor of newEditors){\n                                    editor.remove();\n                                }\n                            };\n                            this.addCommands({\n                                cmd,\n                                undo,\n                                mustExec: true\n                            });\n                        } catch (ex) {\n                            (0, _util.warn)(`paste: \"${ex.message}\".`);\n                        }\n                    }\n                    keydown(event) {\n                        if (!this.getActive()?.shouldGetKeyboardEvents()) {\n                            AnnotationEditorUIManager._keyboardManager.exec(this, event);\n                        }\n                    }\n                    onEditingAction(details) {\n                        if ([\n                            \"undo\",\n                            \"redo\",\n                            \"delete\",\n                            \"selectAll\"\n                        ].includes(details.name)) {\n                            this[details.name]();\n                        }\n                    }\n                    #dispatchUpdateStates(details) {\n                        const hasChanged = Object.entries(details).some(([key, value])=>this.#previousStates[key] !== value);\n                        if (hasChanged) {\n                            this._eventBus.dispatch(\"annotationeditorstateschanged\", {\n                                source: this,\n                                details: Object.assign(this.#previousStates, details)\n                            });\n                        }\n                    }\n                    #dispatchUpdateUI(details) {\n                        this._eventBus.dispatch(\"annotationeditorparamschanged\", {\n                            source: this,\n                            details\n                        });\n                    }\n                    setEditingState(isEditing) {\n                        if (isEditing) {\n                            this.#addFocusManager();\n                            this.#addKeyboardManager();\n                            this.#addCopyPasteListeners();\n                            this.#dispatchUpdateStates({\n                                isEditing: this.#mode !== _util.AnnotationEditorType.NONE,\n                                isEmpty: this.#isEmpty(),\n                                hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n                                hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n                                hasSelectedEditor: false\n                            });\n                        } else {\n                            this.#removeFocusManager();\n                            this.#removeKeyboardManager();\n                            this.#removeCopyPasteListeners();\n                            this.#dispatchUpdateStates({\n                                isEditing: false\n                            });\n                            this.disableUserSelect(false);\n                        }\n                    }\n                    registerEditorTypes(types) {\n                        if (this.#editorTypes) {\n                            return;\n                        }\n                        this.#editorTypes = types;\n                        for (const editorType of this.#editorTypes){\n                            this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n                        }\n                    }\n                    getId() {\n                        return this.#idManager.getId();\n                    }\n                    get currentLayer() {\n                        return this.#allLayers.get(this.#currentPageIndex);\n                    }\n                    getLayer(pageIndex) {\n                        return this.#allLayers.get(pageIndex);\n                    }\n                    get currentPageIndex() {\n                        return this.#currentPageIndex;\n                    }\n                    addLayer(layer) {\n                        this.#allLayers.set(layer.pageIndex, layer);\n                        if (this.#isEnabled) {\n                            layer.enable();\n                        } else {\n                            layer.disable();\n                        }\n                    }\n                    removeLayer(layer) {\n                        this.#allLayers.delete(layer.pageIndex);\n                    }\n                    updateMode(mode, editId = null) {\n                        if (this.#mode === mode) {\n                            return;\n                        }\n                        this.#mode = mode;\n                        if (mode === _util.AnnotationEditorType.NONE) {\n                            this.setEditingState(false);\n                            this.#disableAll();\n                            return;\n                        }\n                        this.setEditingState(true);\n                        this.#enableAll();\n                        this.unselectAll();\n                        for (const layer of this.#allLayers.values()){\n                            layer.updateMode(mode);\n                        }\n                        if (!editId) {\n                            return;\n                        }\n                        for (const editor of this.#allEditors.values()){\n                            if (editor.annotationElementId === editId) {\n                                this.setSelected(editor);\n                                editor.enterInEditMode();\n                                break;\n                            }\n                        }\n                    }\n                    updateToolbar(mode) {\n                        if (mode === this.#mode) {\n                            return;\n                        }\n                        this._eventBus.dispatch(\"switchannotationeditormode\", {\n                            source: this,\n                            mode\n                        });\n                    }\n                    updateParams(type, value) {\n                        if (!this.#editorTypes) {\n                            return;\n                        }\n                        if (type === _util.AnnotationEditorParamsType.CREATE) {\n                            this.currentLayer.addNewEditor(type);\n                            return;\n                        }\n                        for (const editor of this.#selectedEditors){\n                            editor.updateParams(type, value);\n                        }\n                        for (const editorType of this.#editorTypes){\n                            editorType.updateDefaultParams(type, value);\n                        }\n                    }\n                    enableWaiting(mustWait = false) {\n                        if (this.#isWaiting === mustWait) {\n                            return;\n                        }\n                        this.#isWaiting = mustWait;\n                        for (const layer of this.#allLayers.values()){\n                            if (mustWait) {\n                                layer.disableClick();\n                            } else {\n                                layer.enableClick();\n                            }\n                            layer.div.classList.toggle(\"waiting\", mustWait);\n                        }\n                    }\n                    #enableAll() {\n                        if (!this.#isEnabled) {\n                            this.#isEnabled = true;\n                            for (const layer of this.#allLayers.values()){\n                                layer.enable();\n                            }\n                        }\n                    }\n                    #disableAll() {\n                        this.unselectAll();\n                        if (this.#isEnabled) {\n                            this.#isEnabled = false;\n                            for (const layer of this.#allLayers.values()){\n                                layer.disable();\n                            }\n                        }\n                    }\n                    getEditors(pageIndex) {\n                        const editors = [];\n                        for (const editor of this.#allEditors.values()){\n                            if (editor.pageIndex === pageIndex) {\n                                editors.push(editor);\n                            }\n                        }\n                        return editors;\n                    }\n                    getEditor(id) {\n                        return this.#allEditors.get(id);\n                    }\n                    addEditor(editor) {\n                        this.#allEditors.set(editor.id, editor);\n                    }\n                    removeEditor(editor) {\n                        this.#allEditors.delete(editor.id);\n                        this.unselect(editor);\n                        if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {\n                            this.#annotationStorage?.remove(editor.id);\n                        }\n                    }\n                    addDeletedAnnotationElement(editor) {\n                        this.#deletedAnnotationsElementIds.add(editor.annotationElementId);\n                        editor.deleted = true;\n                    }\n                    isDeletedAnnotationElement(annotationElementId) {\n                        return this.#deletedAnnotationsElementIds.has(annotationElementId);\n                    }\n                    removeDeletedAnnotationElement(editor) {\n                        this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);\n                        editor.deleted = false;\n                    }\n                    #addEditorToLayer(editor) {\n                        const layer = this.#allLayers.get(editor.pageIndex);\n                        if (layer) {\n                            layer.addOrRebuild(editor);\n                        } else {\n                            this.addEditor(editor);\n                        }\n                    }\n                    setActiveEditor(editor) {\n                        if (this.#activeEditor === editor) {\n                            return;\n                        }\n                        this.#activeEditor = editor;\n                        if (editor) {\n                            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n                        }\n                    }\n                    toggleSelected(editor) {\n                        if (this.#selectedEditors.has(editor)) {\n                            this.#selectedEditors.delete(editor);\n                            editor.unselect();\n                            this.#dispatchUpdateStates({\n                                hasSelectedEditor: this.hasSelection\n                            });\n                            return;\n                        }\n                        this.#selectedEditors.add(editor);\n                        editor.select();\n                        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n                        this.#dispatchUpdateStates({\n                            hasSelectedEditor: true\n                        });\n                    }\n                    setSelected(editor) {\n                        for (const ed of this.#selectedEditors){\n                            if (ed !== editor) {\n                                ed.unselect();\n                            }\n                        }\n                        this.#selectedEditors.clear();\n                        this.#selectedEditors.add(editor);\n                        editor.select();\n                        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n                        this.#dispatchUpdateStates({\n                            hasSelectedEditor: true\n                        });\n                    }\n                    isSelected(editor) {\n                        return this.#selectedEditors.has(editor);\n                    }\n                    unselect(editor) {\n                        editor.unselect();\n                        this.#selectedEditors.delete(editor);\n                        this.#dispatchUpdateStates({\n                            hasSelectedEditor: this.hasSelection\n                        });\n                    }\n                    get hasSelection() {\n                        return this.#selectedEditors.size !== 0;\n                    }\n                    undo() {\n                        this.#commandManager.undo();\n                        this.#dispatchUpdateStates({\n                            hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n                            hasSomethingToRedo: true,\n                            isEmpty: this.#isEmpty()\n                        });\n                    }\n                    redo() {\n                        this.#commandManager.redo();\n                        this.#dispatchUpdateStates({\n                            hasSomethingToUndo: true,\n                            hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n                            isEmpty: this.#isEmpty()\n                        });\n                    }\n                    addCommands(params) {\n                        this.#commandManager.add(params);\n                        this.#dispatchUpdateStates({\n                            hasSomethingToUndo: true,\n                            hasSomethingToRedo: false,\n                            isEmpty: this.#isEmpty()\n                        });\n                    }\n                    #isEmpty() {\n                        if (this.#allEditors.size === 0) {\n                            return true;\n                        }\n                        if (this.#allEditors.size === 1) {\n                            for (const editor of this.#allEditors.values()){\n                                return editor.isEmpty();\n                            }\n                        }\n                        return false;\n                    }\n                    delete() {\n                        this.commitOrRemove();\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        const editors = [\n                            ...this.#selectedEditors\n                        ];\n                        const cmd = ()=>{\n                            for (const editor of editors){\n                                editor.remove();\n                            }\n                        };\n                        const undo = ()=>{\n                            for (const editor of editors){\n                                this.#addEditorToLayer(editor);\n                            }\n                        };\n                        this.addCommands({\n                            cmd,\n                            undo,\n                            mustExec: true\n                        });\n                    }\n                    commitOrRemove() {\n                        this.#activeEditor?.commitOrRemove();\n                    }\n                    hasSomethingToControl() {\n                        return this.#activeEditor || this.hasSelection;\n                    }\n                    #selectEditors(editors) {\n                        this.#selectedEditors.clear();\n                        for (const editor of editors){\n                            if (editor.isEmpty()) {\n                                continue;\n                            }\n                            this.#selectedEditors.add(editor);\n                            editor.select();\n                        }\n                        this.#dispatchUpdateStates({\n                            hasSelectedEditor: true\n                        });\n                    }\n                    selectAll() {\n                        for (const editor of this.#selectedEditors){\n                            editor.commit();\n                        }\n                        this.#selectEditors(this.#allEditors.values());\n                    }\n                    unselectAll() {\n                        if (this.#activeEditor) {\n                            this.#activeEditor.commitOrRemove();\n                            return;\n                        }\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        for (const editor of this.#selectedEditors){\n                            editor.unselect();\n                        }\n                        this.#selectedEditors.clear();\n                        this.#dispatchUpdateStates({\n                            hasSelectedEditor: false\n                        });\n                    }\n                    translateSelectedEditors(x, y, noCommit = false) {\n                        if (!noCommit) {\n                            this.commitOrRemove();\n                        }\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        this.#translation[0] += x;\n                        this.#translation[1] += y;\n                        const [totalX, totalY] = this.#translation;\n                        const editors = [\n                            ...this.#selectedEditors\n                        ];\n                        const TIME_TO_WAIT = 1000;\n                        if (this.#translationTimeoutId) {\n                            clearTimeout(this.#translationTimeoutId);\n                        }\n                        this.#translationTimeoutId = setTimeout(()=>{\n                            this.#translationTimeoutId = null;\n                            this.#translation[0] = this.#translation[1] = 0;\n                            this.addCommands({\n                                cmd: ()=>{\n                                    for (const editor of editors){\n                                        if (this.#allEditors.has(editor.id)) {\n                                            editor.translateInPage(totalX, totalY);\n                                        }\n                                    }\n                                },\n                                undo: ()=>{\n                                    for (const editor of editors){\n                                        if (this.#allEditors.has(editor.id)) {\n                                            editor.translateInPage(-totalX, -totalY);\n                                        }\n                                    }\n                                },\n                                mustExec: false\n                            });\n                        }, TIME_TO_WAIT);\n                        for (const editor of editors){\n                            editor.translateInPage(x, y);\n                        }\n                    }\n                    setUpDragSession() {\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        this.disableUserSelect(true);\n                        this.#draggingEditors = new Map();\n                        for (const editor of this.#selectedEditors){\n                            this.#draggingEditors.set(editor, {\n                                savedX: editor.x,\n                                savedY: editor.y,\n                                savedPageIndex: editor.pageIndex,\n                                newX: 0,\n                                newY: 0,\n                                newPageIndex: -1\n                            });\n                        }\n                    }\n                    endDragSession() {\n                        if (!this.#draggingEditors) {\n                            return false;\n                        }\n                        this.disableUserSelect(false);\n                        const map = this.#draggingEditors;\n                        this.#draggingEditors = null;\n                        let mustBeAddedInUndoStack = false;\n                        for (const [{ x, y, pageIndex }, value] of map){\n                            value.newX = x;\n                            value.newY = y;\n                            value.newPageIndex = pageIndex;\n                            mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;\n                        }\n                        if (!mustBeAddedInUndoStack) {\n                            return false;\n                        }\n                        const move = (editor, x, y, pageIndex)=>{\n                            if (this.#allEditors.has(editor.id)) {\n                                const parent = this.#allLayers.get(pageIndex);\n                                if (parent) {\n                                    editor._setParentAndPosition(parent, x, y);\n                                } else {\n                                    editor.pageIndex = pageIndex;\n                                    editor.x = x;\n                                    editor.y = y;\n                                }\n                            }\n                        };\n                        this.addCommands({\n                            cmd: ()=>{\n                                for (const [editor, { newX, newY, newPageIndex }] of map){\n                                    move(editor, newX, newY, newPageIndex);\n                                }\n                            },\n                            undo: ()=>{\n                                for (const [editor, { savedX, savedY, savedPageIndex }] of map){\n                                    move(editor, savedX, savedY, savedPageIndex);\n                                }\n                            },\n                            mustExec: true\n                        });\n                        return true;\n                    }\n                    dragSelectedEditors(tx, ty) {\n                        if (!this.#draggingEditors) {\n                            return;\n                        }\n                        for (const editor of this.#draggingEditors.keys()){\n                            editor.drag(tx, ty);\n                        }\n                    }\n                    rebuild(editor) {\n                        if (editor.parent === null) {\n                            const parent = this.getLayer(editor.pageIndex);\n                            if (parent) {\n                                parent.changeParent(editor);\n                                parent.addOrRebuild(editor);\n                            } else {\n                                this.addEditor(editor);\n                                this.addToAnnotationStorage(editor);\n                                editor.rebuild();\n                            }\n                        } else {\n                            editor.parent.addOrRebuild(editor);\n                        }\n                    }\n                    isActive(editor) {\n                        return this.#activeEditor === editor;\n                    }\n                    getActive() {\n                        return this.#activeEditor;\n                    }\n                    getMode() {\n                        return this.#mode;\n                    }\n                    get imageManager() {\n                        return (0, _util.shadow)(this, \"imageManager\", new ImageManager());\n                    }\n                }\n                exports1.AnnotationEditorUIManager = AnnotationEditorUIManager;\n            /***/ },\n            /* 6 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.StatTimer = exports1.RenderingCancelledException = exports1.PixelsPerInch = exports1.PageViewport = exports1.PDFDateString = exports1.DOMStandardFontDataFactory = exports1.DOMSVGFactory = exports1.DOMFilterFactory = exports1.DOMCanvasFactory = exports1.DOMCMapReaderFactory = void 0;\n                exports1.deprecated = deprecated;\n                exports1.getColorValues = getColorValues;\n                exports1.getCurrentTransform = getCurrentTransform;\n                exports1.getCurrentTransformInverse = getCurrentTransformInverse;\n                exports1.getFilenameFromUrl = getFilenameFromUrl;\n                exports1.getPdfFilenameFromUrl = getPdfFilenameFromUrl;\n                exports1.getRGB = getRGB;\n                exports1.getXfaPageViewport = getXfaPageViewport;\n                exports1.isDataScheme = isDataScheme;\n                exports1.isPdfFile = isPdfFile;\n                exports1.isValidFetchUrl = isValidFetchUrl;\n                exports1.loadScript = loadScript;\n                exports1.noContextMenu = noContextMenu;\n                exports1.setLayerDimensions = setLayerDimensions;\n                var _base_factory = __w_pdfjs_require__(7);\n                var _util = __w_pdfjs_require__(1);\n                const SVG_NS = \"http://www.w3.org/2000/svg\";\n                class PixelsPerInch {\n                    static{\n                        this.CSS = 96.0;\n                    }\n                    static{\n                        this.PDF = 72.0;\n                    }\n                    static{\n                        this.PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n                    }\n                }\n                exports1.PixelsPerInch = PixelsPerInch;\n                class DOMFilterFactory extends _base_factory.BaseFilterFactory {\n                    #_cache;\n                    #_defs;\n                    #docId;\n                    #document;\n                    #hcmFilter;\n                    #hcmKey;\n                    #hcmUrl;\n                    #hcmHighlightFilter;\n                    #hcmHighlightKey;\n                    #hcmHighlightUrl;\n                    #id;\n                    constructor({ docId, ownerDocument = globalThis.document } = {}){\n                        super();\n                        this.#id = 0;\n                        this.#docId = docId;\n                        this.#document = ownerDocument;\n                    }\n                    get #cache() {\n                        return this.#_cache ||= new Map();\n                    }\n                    get #defs() {\n                        if (!this.#_defs) {\n                            const div = this.#document.createElement(\"div\");\n                            const { style } = div;\n                            style.visibility = \"hidden\";\n                            style.contain = \"strict\";\n                            style.width = style.height = 0;\n                            style.position = \"absolute\";\n                            style.top = style.left = 0;\n                            style.zIndex = -1;\n                            const svg = this.#document.createElementNS(SVG_NS, \"svg\");\n                            svg.setAttribute(\"width\", 0);\n                            svg.setAttribute(\"height\", 0);\n                            this.#_defs = this.#document.createElementNS(SVG_NS, \"defs\");\n                            div.append(svg);\n                            svg.append(this.#_defs);\n                            this.#document.body.append(div);\n                        }\n                        return this.#_defs;\n                    }\n                    addFilter(maps) {\n                        if (!maps) {\n                            return \"none\";\n                        }\n                        let value = this.#cache.get(maps);\n                        if (value) {\n                            return value;\n                        }\n                        let tableR, tableG, tableB, key;\n                        if (maps.length === 1) {\n                            const mapR = maps[0];\n                            const buffer = new Array(256);\n                            for(let i = 0; i < 256; i++){\n                                buffer[i] = mapR[i] / 255;\n                            }\n                            key = tableR = tableG = tableB = buffer.join(\",\");\n                        } else {\n                            const [mapR, mapG, mapB] = maps;\n                            const bufferR = new Array(256);\n                            const bufferG = new Array(256);\n                            const bufferB = new Array(256);\n                            for(let i = 0; i < 256; i++){\n                                bufferR[i] = mapR[i] / 255;\n                                bufferG[i] = mapG[i] / 255;\n                                bufferB[i] = mapB[i] / 255;\n                            }\n                            tableR = bufferR.join(\",\");\n                            tableG = bufferG.join(\",\");\n                            tableB = bufferB.join(\",\");\n                            key = `${tableR}${tableG}${tableB}`;\n                        }\n                        value = this.#cache.get(key);\n                        if (value) {\n                            this.#cache.set(maps, value);\n                            return value;\n                        }\n                        const id = `g_${this.#docId}_transfer_map_${this.#id++}`;\n                        const url = `url(#${id})`;\n                        this.#cache.set(maps, url);\n                        this.#cache.set(key, url);\n                        const filter = this.#createFilter(id);\n                        this.#addTransferMapConversion(tableR, tableG, tableB, filter);\n                        return url;\n                    }\n                    addHCMFilter(fgColor, bgColor) {\n                        const key = `${fgColor}-${bgColor}`;\n                        if (this.#hcmKey === key) {\n                            return this.#hcmUrl;\n                        }\n                        this.#hcmKey = key;\n                        this.#hcmUrl = \"none\";\n                        this.#hcmFilter?.remove();\n                        if (!fgColor || !bgColor) {\n                            return this.#hcmUrl;\n                        }\n                        const fgRGB = this.#getRGB(fgColor);\n                        fgColor = _util.Util.makeHexColor(...fgRGB);\n                        const bgRGB = this.#getRGB(bgColor);\n                        bgColor = _util.Util.makeHexColor(...bgRGB);\n                        this.#defs.style.color = \"\";\n                        if (fgColor === \"#000000\" && bgColor === \"#ffffff\" || fgColor === bgColor) {\n                            return this.#hcmUrl;\n                        }\n                        const map = new Array(256);\n                        for(let i = 0; i <= 255; i++){\n                            const x = i / 255;\n                            map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n                        }\n                        const table = map.join(\",\");\n                        const id = `g_${this.#docId}_hcm_filter`;\n                        const filter = this.#hcmHighlightFilter = this.#createFilter(id);\n                        this.#addTransferMapConversion(table, table, table, filter);\n                        this.#addGrayConversion(filter);\n                        const getSteps = (c, n)=>{\n                            const start = fgRGB[c] / 255;\n                            const end = bgRGB[c] / 255;\n                            const arr = new Array(n + 1);\n                            for(let i = 0; i <= n; i++){\n                                arr[i] = start + i / n * (end - start);\n                            }\n                            return arr.join(\",\");\n                        };\n                        this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);\n                        this.#hcmUrl = `url(#${id})`;\n                        return this.#hcmUrl;\n                    }\n                    addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {\n                        const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;\n                        if (this.#hcmHighlightKey === key) {\n                            return this.#hcmHighlightUrl;\n                        }\n                        this.#hcmHighlightKey = key;\n                        this.#hcmHighlightUrl = \"none\";\n                        this.#hcmHighlightFilter?.remove();\n                        if (!fgColor || !bgColor) {\n                            return this.#hcmHighlightUrl;\n                        }\n                        const [fgRGB, bgRGB] = [\n                            fgColor,\n                            bgColor\n                        ].map(this.#getRGB.bind(this));\n                        let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);\n                        let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);\n                        let [newFgRGB, newBgRGB] = [\n                            newFgColor,\n                            newBgColor\n                        ].map(this.#getRGB.bind(this));\n                        if (bgGray < fgGray) {\n                            [fgGray, bgGray, newFgRGB, newBgRGB] = [\n                                bgGray,\n                                fgGray,\n                                newBgRGB,\n                                newFgRGB\n                            ];\n                        }\n                        this.#defs.style.color = \"\";\n                        const getSteps = (fg, bg, n)=>{\n                            const arr = new Array(256);\n                            const step = (bgGray - fgGray) / n;\n                            const newStart = fg / 255;\n                            const newStep = (bg - fg) / (255 * n);\n                            let prev = 0;\n                            for(let i = 0; i <= n; i++){\n                                const k = Math.round(fgGray + i * step);\n                                const value = newStart + i * newStep;\n                                for(let j = prev; j <= k; j++){\n                                    arr[j] = value;\n                                }\n                                prev = k + 1;\n                            }\n                            for(let i = prev; i < 256; i++){\n                                arr[i] = arr[prev - 1];\n                            }\n                            return arr.join(\",\");\n                        };\n                        const id = `g_${this.#docId}_hcm_highlight_filter`;\n                        const filter = this.#hcmHighlightFilter = this.#createFilter(id);\n                        this.#addGrayConversion(filter);\n                        this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);\n                        this.#hcmHighlightUrl = `url(#${id})`;\n                        return this.#hcmHighlightUrl;\n                    }\n                    destroy(keepHCM = false) {\n                        if (keepHCM && (this.#hcmUrl || this.#hcmHighlightUrl)) {\n                            return;\n                        }\n                        if (this.#_defs) {\n                            this.#_defs.parentNode.parentNode.remove();\n                            this.#_defs = null;\n                        }\n                        if (this.#_cache) {\n                            this.#_cache.clear();\n                            this.#_cache = null;\n                        }\n                        this.#id = 0;\n                    }\n                    #addGrayConversion(filter) {\n                        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n                        feColorMatrix.setAttribute(\"type\", \"matrix\");\n                        feColorMatrix.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n                        filter.append(feColorMatrix);\n                    }\n                    #createFilter(id) {\n                        const filter = this.#document.createElementNS(SVG_NS, \"filter\");\n                        filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n                        filter.setAttribute(\"id\", id);\n                        this.#defs.append(filter);\n                        return filter;\n                    }\n                    #appendFeFunc(feComponentTransfer, func, table) {\n                        const feFunc = this.#document.createElementNS(SVG_NS, func);\n                        feFunc.setAttribute(\"type\", \"discrete\");\n                        feFunc.setAttribute(\"tableValues\", table);\n                        feComponentTransfer.append(feFunc);\n                    }\n                    #addTransferMapConversion(rTable, gTable, bTable, filter) {\n                        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n                        filter.append(feComponentTransfer);\n                        this.#appendFeFunc(feComponentTransfer, \"feFuncR\", rTable);\n                        this.#appendFeFunc(feComponentTransfer, \"feFuncG\", gTable);\n                        this.#appendFeFunc(feComponentTransfer, \"feFuncB\", bTable);\n                    }\n                    #getRGB(color) {\n                        this.#defs.style.color = color;\n                        return getRGB(getComputedStyle(this.#defs).getPropertyValue(\"color\"));\n                    }\n                }\n                exports1.DOMFilterFactory = DOMFilterFactory;\n                class DOMCanvasFactory extends _base_factory.BaseCanvasFactory {\n                    constructor({ ownerDocument = globalThis.document } = {}){\n                        super();\n                        this._document = ownerDocument;\n                    }\n                    _createCanvas(width, height) {\n                        const canvas = this._document.createElement(\"canvas\");\n                        canvas.width = width;\n                        canvas.height = height;\n                        return canvas;\n                    }\n                }\n                exports1.DOMCanvasFactory = DOMCanvasFactory;\n                async function fetchData(url, asTypedArray = false) {\n                    if (isValidFetchUrl(url, document.baseURI)) {\n                        const response = await fetch(url);\n                        if (!response.ok) {\n                            throw new Error(response.statusText);\n                        }\n                        return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util.stringToBytes)(await response.text());\n                    }\n                    return new Promise((resolve, reject)=>{\n                        const request = new XMLHttpRequest();\n                        request.open(\"GET\", url, true);\n                        if (asTypedArray) {\n                            request.responseType = \"arraybuffer\";\n                        }\n                        request.onreadystatechange = ()=>{\n                            if (request.readyState !== XMLHttpRequest.DONE) {\n                                return;\n                            }\n                            if (request.status === 200 || request.status === 0) {\n                                let data;\n                                if (asTypedArray && request.response) {\n                                    data = new Uint8Array(request.response);\n                                } else if (!asTypedArray && request.responseText) {\n                                    data = (0, _util.stringToBytes)(request.responseText);\n                                }\n                                if (data) {\n                                    resolve(data);\n                                    return;\n                                }\n                            }\n                            reject(new Error(request.statusText));\n                        };\n                        request.send(null);\n                    });\n                }\n                class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {\n                    _fetchData(url, compressionType) {\n                        return fetchData(url, this.isCompressed).then((data)=>{\n                            return {\n                                cMapData: data,\n                                compressionType\n                            };\n                        });\n                    }\n                }\n                exports1.DOMCMapReaderFactory = DOMCMapReaderFactory;\n                class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {\n                    _fetchData(url) {\n                        return fetchData(url, true);\n                    }\n                }\n                exports1.DOMStandardFontDataFactory = DOMStandardFontDataFactory;\n                class DOMSVGFactory extends _base_factory.BaseSVGFactory {\n                    _createSVG(type) {\n                        return document.createElementNS(SVG_NS, type);\n                    }\n                }\n                exports1.DOMSVGFactory = DOMSVGFactory;\n                class PageViewport {\n                    constructor({ viewBox, scale, rotation, offsetX = 0, offsetY = 0, dontFlip = false }){\n                        this.viewBox = viewBox;\n                        this.scale = scale;\n                        this.rotation = rotation;\n                        this.offsetX = offsetX;\n                        this.offsetY = offsetY;\n                        const centerX = (viewBox[2] + viewBox[0]) / 2;\n                        const centerY = (viewBox[3] + viewBox[1]) / 2;\n                        let rotateA, rotateB, rotateC, rotateD;\n                        rotation %= 360;\n                        if (rotation < 0) {\n                            rotation += 360;\n                        }\n                        switch(rotation){\n                            case 180:\n                                rotateA = -1;\n                                rotateB = 0;\n                                rotateC = 0;\n                                rotateD = 1;\n                                break;\n                            case 90:\n                                rotateA = 0;\n                                rotateB = 1;\n                                rotateC = 1;\n                                rotateD = 0;\n                                break;\n                            case 270:\n                                rotateA = 0;\n                                rotateB = -1;\n                                rotateC = -1;\n                                rotateD = 0;\n                                break;\n                            case 0:\n                                rotateA = 1;\n                                rotateB = 0;\n                                rotateC = 0;\n                                rotateD = -1;\n                                break;\n                            default:\n                                throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n                        }\n                        if (dontFlip) {\n                            rotateC = -rotateC;\n                            rotateD = -rotateD;\n                        }\n                        let offsetCanvasX, offsetCanvasY;\n                        let width, height;\n                        if (rotateA === 0) {\n                            offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n                            offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n                            width = (viewBox[3] - viewBox[1]) * scale;\n                            height = (viewBox[2] - viewBox[0]) * scale;\n                        } else {\n                            offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n                            offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n                            width = (viewBox[2] - viewBox[0]) * scale;\n                            height = (viewBox[3] - viewBox[1]) * scale;\n                        }\n                        this.transform = [\n                            rotateA * scale,\n                            rotateB * scale,\n                            rotateC * scale,\n                            rotateD * scale,\n                            offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,\n                            offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY\n                        ];\n                        this.width = width;\n                        this.height = height;\n                    }\n                    get rawDims() {\n                        const { viewBox } = this;\n                        return (0, _util.shadow)(this, \"rawDims\", {\n                            pageWidth: viewBox[2] - viewBox[0],\n                            pageHeight: viewBox[3] - viewBox[1],\n                            pageX: viewBox[0],\n                            pageY: viewBox[1]\n                        });\n                    }\n                    clone({ scale = this.scale, rotation = this.rotation, offsetX = this.offsetX, offsetY = this.offsetY, dontFlip = false } = {}) {\n                        return new PageViewport({\n                            viewBox: this.viewBox.slice(),\n                            scale,\n                            rotation,\n                            offsetX,\n                            offsetY,\n                            dontFlip\n                        });\n                    }\n                    convertToViewportPoint(x, y) {\n                        return _util.Util.applyTransform([\n                            x,\n                            y\n                        ], this.transform);\n                    }\n                    convertToViewportRectangle(rect) {\n                        const topLeft = _util.Util.applyTransform([\n                            rect[0],\n                            rect[1]\n                        ], this.transform);\n                        const bottomRight = _util.Util.applyTransform([\n                            rect[2],\n                            rect[3]\n                        ], this.transform);\n                        return [\n                            topLeft[0],\n                            topLeft[1],\n                            bottomRight[0],\n                            bottomRight[1]\n                        ];\n                    }\n                    convertToPdfPoint(x, y) {\n                        return _util.Util.applyInverseTransform([\n                            x,\n                            y\n                        ], this.transform);\n                    }\n                }\n                exports1.PageViewport = PageViewport;\n                class RenderingCancelledException extends _util.BaseException {\n                    constructor(msg, extraDelay = 0){\n                        super(msg, \"RenderingCancelledException\");\n                        this.extraDelay = extraDelay;\n                    }\n                }\n                exports1.RenderingCancelledException = RenderingCancelledException;\n                function isDataScheme(url) {\n                    const ii = url.length;\n                    let i = 0;\n                    while(i < ii && url[i].trim() === \"\"){\n                        i++;\n                    }\n                    return url.substring(i, i + 5).toLowerCase() === \"data:\";\n                }\n                function isPdfFile(filename) {\n                    return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n                }\n                function getFilenameFromUrl(url, onlyStripPath = false) {\n                    if (!onlyStripPath) {\n                        [url] = url.split(/[#?]/, 1);\n                    }\n                    return url.substring(url.lastIndexOf(\"/\") + 1);\n                }\n                function getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n                    if (typeof url !== \"string\") {\n                        return defaultFilename;\n                    }\n                    if (isDataScheme(url)) {\n                        (0, _util.warn)('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n                        return defaultFilename;\n                    }\n                    const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n                    const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n                    const splitURI = reURI.exec(url);\n                    let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);\n                    if (suggestedFilename) {\n                        suggestedFilename = suggestedFilename[0];\n                        if (suggestedFilename.includes(\"%\")) {\n                            try {\n                                suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n                            } catch  {}\n                        }\n                    }\n                    return suggestedFilename || defaultFilename;\n                }\n                class StatTimer {\n                    time(name) {\n                        if (name in this.started) {\n                            (0, _util.warn)(`Timer is already running for ${name}`);\n                        }\n                        this.started[name] = Date.now();\n                    }\n                    timeEnd(name) {\n                        if (!(name in this.started)) {\n                            (0, _util.warn)(`Timer has not been started for ${name}`);\n                        }\n                        this.times.push({\n                            name,\n                            start: this.started[name],\n                            end: Date.now()\n                        });\n                        delete this.started[name];\n                    }\n                    toString() {\n                        const outBuf = [];\n                        let longest = 0;\n                        for (const { name } of this.times){\n                            longest = Math.max(name.length, longest);\n                        }\n                        for (const { name, start, end } of this.times){\n                            outBuf.push(`${name.padEnd(longest)} ${end - start}ms\\n`);\n                        }\n                        return outBuf.join(\"\");\n                    }\n                    constructor(){\n                        this.started = Object.create(null);\n                        this.times = [];\n                    }\n                }\n                exports1.StatTimer = StatTimer;\n                function isValidFetchUrl(url, baseUrl) {\n                    try {\n                        const { protocol } = baseUrl ? new URL(url, baseUrl) : new URL(url);\n                        return protocol === \"http:\" || protocol === \"https:\";\n                    } catch  {\n                        return false;\n                    }\n                }\n                function noContextMenu(e) {\n                    e.preventDefault();\n                }\n                function loadScript(src, removeScriptElement = false) {\n                    return new Promise((resolve, reject)=>{\n                        const script = document.createElement(\"script\");\n                        script.src = src;\n                        script.onload = function(evt) {\n                            if (removeScriptElement) {\n                                script.remove();\n                            }\n                            resolve(evt);\n                        };\n                        script.onerror = function() {\n                            reject(new Error(`Cannot load script at: ${script.src}`));\n                        };\n                        (document.head || document.documentElement).append(script);\n                    });\n                }\n                function deprecated(details) {\n                    console.log(\"Deprecated API usage: \" + details);\n                }\n                let pdfDateStringRegex;\n                class PDFDateString {\n                    static toDateObject(input) {\n                        if (!input || typeof input !== \"string\") {\n                            return null;\n                        }\n                        pdfDateStringRegex ||= new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n                        const matches = pdfDateStringRegex.exec(input);\n                        if (!matches) {\n                            return null;\n                        }\n                        const year = parseInt(matches[1], 10);\n                        let month = parseInt(matches[2], 10);\n                        month = month >= 1 && month <= 12 ? month - 1 : 0;\n                        let day = parseInt(matches[3], 10);\n                        day = day >= 1 && day <= 31 ? day : 1;\n                        let hour = parseInt(matches[4], 10);\n                        hour = hour >= 0 && hour <= 23 ? hour : 0;\n                        let minute = parseInt(matches[5], 10);\n                        minute = minute >= 0 && minute <= 59 ? minute : 0;\n                        let second = parseInt(matches[6], 10);\n                        second = second >= 0 && second <= 59 ? second : 0;\n                        const universalTimeRelation = matches[7] || \"Z\";\n                        let offsetHour = parseInt(matches[8], 10);\n                        offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n                        let offsetMinute = parseInt(matches[9], 10) || 0;\n                        offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n                        if (universalTimeRelation === \"-\") {\n                            hour += offsetHour;\n                            minute += offsetMinute;\n                        } else if (universalTimeRelation === \"+\") {\n                            hour -= offsetHour;\n                            minute -= offsetMinute;\n                        }\n                        return new Date(Date.UTC(year, month, day, hour, minute, second));\n                    }\n                }\n                exports1.PDFDateString = PDFDateString;\n                function getXfaPageViewport(xfaPage, { scale = 1, rotation = 0 }) {\n                    const { width, height } = xfaPage.attributes.style;\n                    const viewBox = [\n                        0,\n                        0,\n                        parseInt(width),\n                        parseInt(height)\n                    ];\n                    return new PageViewport({\n                        viewBox,\n                        scale,\n                        rotation\n                    });\n                }\n                function getRGB(color) {\n                    if (color.startsWith(\"#\")) {\n                        const colorRGB = parseInt(color.slice(1), 16);\n                        return [\n                            (colorRGB & 0xff0000) >> 16,\n                            (colorRGB & 0x00ff00) >> 8,\n                            colorRGB & 0x0000ff\n                        ];\n                    }\n                    if (color.startsWith(\"rgb(\")) {\n                        return color.slice(4, -1).split(\",\").map((x)=>parseInt(x));\n                    }\n                    if (color.startsWith(\"rgba(\")) {\n                        return color.slice(5, -1).split(\",\").map((x)=>parseInt(x)).slice(0, 3);\n                    }\n                    (0, _util.warn)(`Not a valid color format: \"${color}\"`);\n                    return [\n                        0,\n                        0,\n                        0\n                    ];\n                }\n                function getColorValues(colors) {\n                    const span = document.createElement(\"span\");\n                    span.style.visibility = \"hidden\";\n                    document.body.append(span);\n                    for (const name of colors.keys()){\n                        span.style.color = name;\n                        const computedColor = window.getComputedStyle(span).color;\n                        colors.set(name, getRGB(computedColor));\n                    }\n                    span.remove();\n                }\n                function getCurrentTransform(ctx) {\n                    const { a, b, c, d, e, f } = ctx.getTransform();\n                    return [\n                        a,\n                        b,\n                        c,\n                        d,\n                        e,\n                        f\n                    ];\n                }\n                function getCurrentTransformInverse(ctx) {\n                    const { a, b, c, d, e, f } = ctx.getTransform().invertSelf();\n                    return [\n                        a,\n                        b,\n                        c,\n                        d,\n                        e,\n                        f\n                    ];\n                }\n                function setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {\n                    if (viewport instanceof PageViewport) {\n                        const { pageWidth, pageHeight } = viewport.rawDims;\n                        const { style } = div;\n                        const useRound = _util.FeatureTest.isCSSRoundSupported;\n                        const w = `var(--scale-factor) * ${pageWidth}px`, h = `var(--scale-factor) * ${pageHeight}px`;\n                        const widthStr = useRound ? `round(${w}, 1px)` : `calc(${w})`, heightStr = useRound ? `round(${h}, 1px)` : `calc(${h})`;\n                        if (!mustFlip || viewport.rotation % 180 === 0) {\n                            style.width = widthStr;\n                            style.height = heightStr;\n                        } else {\n                            style.width = heightStr;\n                            style.height = widthStr;\n                        }\n                    }\n                    if (mustRotate) {\n                        div.setAttribute(\"data-main-rotation\", viewport.rotation);\n                    }\n                }\n            /***/ },\n            /* 7 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.BaseStandardFontDataFactory = exports1.BaseSVGFactory = exports1.BaseFilterFactory = exports1.BaseCanvasFactory = exports1.BaseCMapReaderFactory = void 0;\n                var _util = __w_pdfjs_require__(1);\n                class BaseFilterFactory {\n                    constructor(){\n                        if (this.constructor === BaseFilterFactory) {\n                            (0, _util.unreachable)(\"Cannot initialize BaseFilterFactory.\");\n                        }\n                    }\n                    addFilter(maps) {\n                        return \"none\";\n                    }\n                    addHCMFilter(fgColor, bgColor) {\n                        return \"none\";\n                    }\n                    addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {\n                        return \"none\";\n                    }\n                    destroy(keepHCM = false) {}\n                }\n                exports1.BaseFilterFactory = BaseFilterFactory;\n                class BaseCanvasFactory {\n                    constructor(){\n                        if (this.constructor === BaseCanvasFactory) {\n                            (0, _util.unreachable)(\"Cannot initialize BaseCanvasFactory.\");\n                        }\n                    }\n                    create(width, height) {\n                        if (width <= 0 || height <= 0) {\n                            throw new Error(\"Invalid canvas size\");\n                        }\n                        const canvas = this._createCanvas(width, height);\n                        return {\n                            canvas,\n                            context: canvas.getContext(\"2d\")\n                        };\n                    }\n                    reset(canvasAndContext, width, height) {\n                        if (!canvasAndContext.canvas) {\n                            throw new Error(\"Canvas is not specified\");\n                        }\n                        if (width <= 0 || height <= 0) {\n                            throw new Error(\"Invalid canvas size\");\n                        }\n                        canvasAndContext.canvas.width = width;\n                        canvasAndContext.canvas.height = height;\n                    }\n                    destroy(canvasAndContext) {\n                        if (!canvasAndContext.canvas) {\n                            throw new Error(\"Canvas is not specified\");\n                        }\n                        canvasAndContext.canvas.width = 0;\n                        canvasAndContext.canvas.height = 0;\n                        canvasAndContext.canvas = null;\n                        canvasAndContext.context = null;\n                    }\n                    _createCanvas(width, height) {\n                        (0, _util.unreachable)(\"Abstract method `_createCanvas` called.\");\n                    }\n                }\n                exports1.BaseCanvasFactory = BaseCanvasFactory;\n                class BaseCMapReaderFactory {\n                    constructor({ baseUrl = null, isCompressed = true }){\n                        if (this.constructor === BaseCMapReaderFactory) {\n                            (0, _util.unreachable)(\"Cannot initialize BaseCMapReaderFactory.\");\n                        }\n                        this.baseUrl = baseUrl;\n                        this.isCompressed = isCompressed;\n                    }\n                    async fetch({ name }) {\n                        if (!this.baseUrl) {\n                            throw new Error('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.');\n                        }\n                        if (!name) {\n                            throw new Error(\"CMap name must be specified.\");\n                        }\n                        const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n                        const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;\n                        return this._fetchData(url, compressionType).catch((reason)=>{\n                            throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n                        });\n                    }\n                    _fetchData(url, compressionType) {\n                        (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n                    }\n                }\n                exports1.BaseCMapReaderFactory = BaseCMapReaderFactory;\n                class BaseStandardFontDataFactory {\n                    constructor({ baseUrl = null }){\n                        if (this.constructor === BaseStandardFontDataFactory) {\n                            (0, _util.unreachable)(\"Cannot initialize BaseStandardFontDataFactory.\");\n                        }\n                        this.baseUrl = baseUrl;\n                    }\n                    async fetch({ filename }) {\n                        if (!this.baseUrl) {\n                            throw new Error('The standard font \"baseUrl\" parameter must be specified, ensure that ' + 'the \"standardFontDataUrl\" API parameter is provided.');\n                        }\n                        if (!filename) {\n                            throw new Error(\"Font filename must be specified.\");\n                        }\n                        const url = `${this.baseUrl}${filename}`;\n                        return this._fetchData(url).catch((reason)=>{\n                            throw new Error(`Unable to load font data at: ${url}`);\n                        });\n                    }\n                    _fetchData(url) {\n                        (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n                    }\n                }\n                exports1.BaseStandardFontDataFactory = BaseStandardFontDataFactory;\n                class BaseSVGFactory {\n                    constructor(){\n                        if (this.constructor === BaseSVGFactory) {\n                            (0, _util.unreachable)(\"Cannot initialize BaseSVGFactory.\");\n                        }\n                    }\n                    create(width, height, skipDimensions = false) {\n                        if (width <= 0 || height <= 0) {\n                            throw new Error(\"Invalid SVG dimensions\");\n                        }\n                        const svg = this._createSVG(\"svg:svg\");\n                        svg.setAttribute(\"version\", \"1.1\");\n                        if (!skipDimensions) {\n                            svg.setAttribute(\"width\", `${width}px`);\n                            svg.setAttribute(\"height\", `${height}px`);\n                        }\n                        svg.setAttribute(\"preserveAspectRatio\", \"none\");\n                        svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n                        return svg;\n                    }\n                    createElement(type) {\n                        if (typeof type !== \"string\") {\n                            throw new Error(\"Invalid SVG element type\");\n                        }\n                        return this._createSVG(type);\n                    }\n                    _createSVG(type) {\n                        (0, _util.unreachable)(\"Abstract method `_createSVG` called.\");\n                    }\n                }\n                exports1.BaseSVGFactory = BaseSVGFactory;\n            /***/ },\n            /* 8 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.MurmurHash3_64 = void 0;\n                var _util = __w_pdfjs_require__(1);\n                const SEED = 0xc3d2e1f0;\n                const MASK_HIGH = 0xffff0000;\n                const MASK_LOW = 0xffff;\n                class MurmurHash3_64 {\n                    constructor(seed){\n                        this.h1 = seed ? seed & 0xffffffff : SEED;\n                        this.h2 = seed ? seed & 0xffffffff : SEED;\n                    }\n                    update(input) {\n                        let data, length;\n                        if (typeof input === \"string\") {\n                            data = new Uint8Array(input.length * 2);\n                            length = 0;\n                            for(let i = 0, ii = input.length; i < ii; i++){\n                                const code = input.charCodeAt(i);\n                                if (code <= 0xff) {\n                                    data[length++] = code;\n                                } else {\n                                    data[length++] = code >>> 8;\n                                    data[length++] = code & 0xff;\n                                }\n                            }\n                        } else if ((0, _util.isArrayBuffer)(input)) {\n                            data = input.slice();\n                            length = data.byteLength;\n                        } else {\n                            throw new Error(\"Wrong data format in MurmurHash3_64_update. \" + \"Input must be a string or array.\");\n                        }\n                        const blockCounts = length >> 2;\n                        const tailLength = length - blockCounts * 4;\n                        const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n                        let k1 = 0, k2 = 0;\n                        let h1 = this.h1, h2 = this.h2;\n                        const C1 = 0xcc9e2d51, C2 = 0x1b873593;\n                        const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;\n                        for(let i = 0; i < blockCounts; i++){\n                            if (i & 1) {\n                                k1 = dataUint32[i];\n                                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                                k1 = k1 << 15 | k1 >>> 17;\n                                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                                h1 ^= k1;\n                                h1 = h1 << 13 | h1 >>> 19;\n                                h1 = h1 * 5 + 0xe6546b64;\n                            } else {\n                                k2 = dataUint32[i];\n                                k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n                                k2 = k2 << 15 | k2 >>> 17;\n                                k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n                                h2 ^= k2;\n                                h2 = h2 << 13 | h2 >>> 19;\n                                h2 = h2 * 5 + 0xe6546b64;\n                            }\n                        }\n                        k1 = 0;\n                        switch(tailLength){\n                            case 3:\n                                k1 ^= data[blockCounts * 4 + 2] << 16;\n                            case 2:\n                                k1 ^= data[blockCounts * 4 + 1] << 8;\n                            case 1:\n                                k1 ^= data[blockCounts * 4];\n                                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                                k1 = k1 << 15 | k1 >>> 17;\n                                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                                if (blockCounts & 1) {\n                                    h1 ^= k1;\n                                } else {\n                                    h2 ^= k1;\n                                }\n                        }\n                        this.h1 = h1;\n                        this.h2 = h2;\n                    }\n                    hexdigest() {\n                        let h1 = this.h1, h2 = this.h2;\n                        h1 ^= h2 >>> 1;\n                        h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n                        h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n                        h1 ^= h2 >>> 1;\n                        h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n                        h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n                        h1 ^= h2 >>> 1;\n                        return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n                    }\n                }\n                exports1.MurmurHash3_64 = MurmurHash3_64;\n            /***/ },\n            /* 9 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.FontLoader = exports1.FontFaceObject = void 0;\n                var _util = __w_pdfjs_require__(1);\n                class FontLoader {\n                    #systemFonts;\n                    constructor({ ownerDocument = globalThis.document, styleElement = null }){\n                        this.#systemFonts = new Set();\n                        this._document = ownerDocument;\n                        this.nativeFontFaces = new Set();\n                        this.styleElement = null;\n                        this.loadingRequests = [];\n                        this.loadTestFontId = 0;\n                    }\n                    addNativeFontFace(nativeFontFace) {\n                        this.nativeFontFaces.add(nativeFontFace);\n                        this._document.fonts.add(nativeFontFace);\n                    }\n                    removeNativeFontFace(nativeFontFace) {\n                        this.nativeFontFaces.delete(nativeFontFace);\n                        this._document.fonts.delete(nativeFontFace);\n                    }\n                    insertRule(rule) {\n                        if (!this.styleElement) {\n                            this.styleElement = this._document.createElement(\"style\");\n                            this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n                        }\n                        const styleSheet = this.styleElement.sheet;\n                        styleSheet.insertRule(rule, styleSheet.cssRules.length);\n                    }\n                    clear() {\n                        for (const nativeFontFace of this.nativeFontFaces){\n                            this._document.fonts.delete(nativeFontFace);\n                        }\n                        this.nativeFontFaces.clear();\n                        this.#systemFonts.clear();\n                        if (this.styleElement) {\n                            this.styleElement.remove();\n                            this.styleElement = null;\n                        }\n                    }\n                    async loadSystemFont(info) {\n                        if (!info || this.#systemFonts.has(info.loadedName)) {\n                            return;\n                        }\n                        (0, _util.assert)(!this.disableFontFace, \"loadSystemFont shouldn't be called when `disableFontFace` is set.\");\n                        if (this.isFontLoadingAPISupported) {\n                            const { loadedName, src, style } = info;\n                            const fontFace = new FontFace(loadedName, src, style);\n                            this.addNativeFontFace(fontFace);\n                            try {\n                                await fontFace.load();\n                                this.#systemFonts.add(loadedName);\n                            } catch  {\n                                (0, _util.warn)(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);\n                                this.removeNativeFontFace(fontFace);\n                            }\n                            return;\n                        }\n                        (0, _util.unreachable)(\"Not implemented: loadSystemFont without the Font Loading API.\");\n                    }\n                    async bind(font) {\n                        if (font.attached || font.missingFile && !font.systemFontInfo) {\n                            return;\n                        }\n                        font.attached = true;\n                        if (font.systemFontInfo) {\n                            await this.loadSystemFont(font.systemFontInfo);\n                            return;\n                        }\n                        if (this.isFontLoadingAPISupported) {\n                            const nativeFontFace = font.createNativeFontFace();\n                            if (nativeFontFace) {\n                                this.addNativeFontFace(nativeFontFace);\n                                try {\n                                    await nativeFontFace.loaded;\n                                } catch (ex) {\n                                    (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n                                    font.disableFontFace = true;\n                                    throw ex;\n                                }\n                            }\n                            return;\n                        }\n                        const rule = font.createFontFaceRule();\n                        if (rule) {\n                            this.insertRule(rule);\n                            if (this.isSyncFontLoadingSupported) {\n                                return;\n                            }\n                            await new Promise((resolve)=>{\n                                const request = this._queueLoadingCallback(resolve);\n                                this._prepareFontLoadEvent(font, request);\n                            });\n                        }\n                    }\n                    get isFontLoadingAPISupported() {\n                        const hasFonts = !!this._document?.fonts;\n                        return (0, _util.shadow)(this, \"isFontLoadingAPISupported\", hasFonts);\n                    }\n                    get isSyncFontLoadingSupported() {\n                        let supported = false;\n                        if (_util.isNodeJS) {\n                            supported = true;\n                        } else if (typeof navigator !== \"undefined\" && /Mozilla\\/5.0.*?rv:\\d+.*? Gecko/.test(navigator.userAgent)) {\n                            supported = true;\n                        }\n                        return (0, _util.shadow)(this, \"isSyncFontLoadingSupported\", supported);\n                    }\n                    _queueLoadingCallback(callback) {\n                        function completeRequest() {\n                            (0, _util.assert)(!request.done, \"completeRequest() cannot be called twice.\");\n                            request.done = true;\n                            while(loadingRequests.length > 0 && loadingRequests[0].done){\n                                const otherRequest = loadingRequests.shift();\n                                setTimeout(otherRequest.callback, 0);\n                            }\n                        }\n                        const { loadingRequests } = this;\n                        const request = {\n                            done: false,\n                            complete: completeRequest,\n                            callback\n                        };\n                        loadingRequests.push(request);\n                        return request;\n                    }\n                    get _loadTestFont() {\n                        const testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n                        return (0, _util.shadow)(this, \"_loadTestFont\", testFont);\n                    }\n                    _prepareFontLoadEvent(font, request) {\n                        function int32(data, offset) {\n                            return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n                        }\n                        function spliceString(s, offset, remove, insert) {\n                            const chunk1 = s.substring(0, offset);\n                            const chunk2 = s.substring(offset + remove);\n                            return chunk1 + insert + chunk2;\n                        }\n                        let i, ii;\n                        const canvas = this._document.createElement(\"canvas\");\n                        canvas.width = 1;\n                        canvas.height = 1;\n                        const ctx = canvas.getContext(\"2d\");\n                        let called = 0;\n                        function isFontReady(name, callback) {\n                            if (++called > 30) {\n                                (0, _util.warn)(\"Load test font never loaded.\");\n                                callback();\n                                return;\n                            }\n                            ctx.font = \"30px \" + name;\n                            ctx.fillText(\".\", 0, 20);\n                            const imageData = ctx.getImageData(0, 0, 1, 1);\n                            if (imageData.data[3] > 0) {\n                                callback();\n                                return;\n                            }\n                            setTimeout(isFontReady.bind(null, name, callback));\n                        }\n                        const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n                        let data = this._loadTestFont;\n                        const COMMENT_OFFSET = 976;\n                        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n                        const CFF_CHECKSUM_OFFSET = 16;\n                        const XXXX_VALUE = 0x58585858;\n                        let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n                        for(i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4){\n                            checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n                        }\n                        if (i < loadTestFontId.length) {\n                            checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n                        }\n                        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));\n                        const url = `url(data:font/opentype;base64,${btoa(data)});`;\n                        const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n                        this.insertRule(rule);\n                        const div = this._document.createElement(\"div\");\n                        div.style.visibility = \"hidden\";\n                        div.style.width = div.style.height = \"10px\";\n                        div.style.position = \"absolute\";\n                        div.style.top = div.style.left = \"0px\";\n                        for (const name of [\n                            font.loadedName,\n                            loadTestFontId\n                        ]){\n                            const span = this._document.createElement(\"span\");\n                            span.textContent = \"Hi\";\n                            span.style.fontFamily = name;\n                            div.append(span);\n                        }\n                        this._document.body.append(div);\n                        isFontReady(loadTestFontId, ()=>{\n                            div.remove();\n                            request.complete();\n                        });\n                    }\n                }\n                exports1.FontLoader = FontLoader;\n                class FontFaceObject {\n                    constructor(translatedData, { isEvalSupported = true, disableFontFace = false, ignoreErrors = false, inspectFont = null }){\n                        this.compiledGlyphs = Object.create(null);\n                        for(const i in translatedData){\n                            this[i] = translatedData[i];\n                        }\n                        this.isEvalSupported = isEvalSupported !== false;\n                        this.disableFontFace = disableFontFace === true;\n                        this.ignoreErrors = ignoreErrors === true;\n                        this._inspectFont = inspectFont;\n                    }\n                    createNativeFontFace() {\n                        if (!this.data || this.disableFontFace) {\n                            return null;\n                        }\n                        let nativeFontFace;\n                        if (!this.cssFontInfo) {\n                            nativeFontFace = new FontFace(this.loadedName, this.data, {});\n                        } else {\n                            const css = {\n                                weight: this.cssFontInfo.fontWeight\n                            };\n                            if (this.cssFontInfo.italicAngle) {\n                                css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n                            }\n                            nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n                        }\n                        this._inspectFont?.(this);\n                        return nativeFontFace;\n                    }\n                    createFontFaceRule() {\n                        if (!this.data || this.disableFontFace) {\n                            return null;\n                        }\n                        const data = (0, _util.bytesToString)(this.data);\n                        const url = `url(data:${this.mimetype};base64,${btoa(data)});`;\n                        let rule;\n                        if (!this.cssFontInfo) {\n                            rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n                        } else {\n                            let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n                            if (this.cssFontInfo.italicAngle) {\n                                css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n                            }\n                            rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n                        }\n                        this._inspectFont?.(this, url);\n                        return rule;\n                    }\n                    getPathGenerator(objs, character) {\n                        if (this.compiledGlyphs[character] !== undefined) {\n                            return this.compiledGlyphs[character];\n                        }\n                        let cmds;\n                        try {\n                            cmds = objs.get(this.loadedName + \"_path_\" + character);\n                        } catch (ex) {\n                            if (!this.ignoreErrors) {\n                                throw ex;\n                            }\n                            (0, _util.warn)(`getPathGenerator - ignoring character: \"${ex}\".`);\n                            return this.compiledGlyphs[character] = function(c, size) {};\n                        }\n                        if (this.isEvalSupported && _util.FeatureTest.isEvalSupported) {\n                            const jsBuf = [];\n                            for (const current of cmds){\n                                const args = current.args !== undefined ? current.args.join(\",\") : \"\";\n                                jsBuf.push(\"c.\", current.cmd, \"(\", args, \");\\n\");\n                            }\n                            return this.compiledGlyphs[character] = new Function(\"c\", \"size\", jsBuf.join(\"\"));\n                        }\n                        return this.compiledGlyphs[character] = function(c, size) {\n                            for (const current of cmds){\n                                if (current.cmd === \"scale\") {\n                                    current.args = [\n                                        size,\n                                        -size\n                                    ];\n                                }\n                                c[current.cmd].apply(c, current.args);\n                            }\n                        };\n                    }\n                }\n                exports1.FontFaceObject = FontFaceObject;\n            /***/ },\n            /* 10 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.NodeStandardFontDataFactory = exports1.NodeFilterFactory = exports1.NodeCanvasFactory = exports1.NodeCMapReaderFactory = void 0;\n                var _base_factory = __w_pdfjs_require__(7);\n                var _util = __w_pdfjs_require__(1);\n                ;\n                ;\n                const fetchData = function(url) {\n                    return new Promise((resolve, reject)=>{\n                        const fs = __webpack_require__(/*! fs */ \"fs\");\n                        fs.readFile(url, (error, data)=>{\n                            if (error || !data) {\n                                reject(new Error(error));\n                                return;\n                            }\n                            resolve(new Uint8Array(data));\n                        });\n                    });\n                };\n                class NodeFilterFactory extends _base_factory.BaseFilterFactory {\n                }\n                exports1.NodeFilterFactory = NodeFilterFactory;\n                class NodeCanvasFactory extends _base_factory.BaseCanvasFactory {\n                    _createCanvas(width, height) {\n                        const Canvas = __webpack_require__(/*! canvas */ \"?8412\");\n                        return Canvas.createCanvas(width, height);\n                    }\n                }\n                exports1.NodeCanvasFactory = NodeCanvasFactory;\n                class NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {\n                    _fetchData(url, compressionType) {\n                        return fetchData(url).then((data)=>{\n                            return {\n                                cMapData: data,\n                                compressionType\n                            };\n                        });\n                    }\n                }\n                exports1.NodeCMapReaderFactory = NodeCMapReaderFactory;\n                class NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {\n                    _fetchData(url) {\n                        return fetchData(url);\n                    }\n                }\n                exports1.NodeStandardFontDataFactory = NodeStandardFontDataFactory;\n            /***/ },\n            /* 11 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.CanvasGraphics = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _display_utils = __w_pdfjs_require__(6);\n                var _pattern_helper = __w_pdfjs_require__(12);\n                var _image_utils = __w_pdfjs_require__(13);\n                const MIN_FONT_SIZE = 16;\n                const MAX_FONT_SIZE = 100;\n                const MAX_GROUP_SIZE = 4096;\n                const EXECUTION_TIME = 15;\n                const EXECUTION_STEPS = 10;\n                const MAX_SIZE_TO_COMPILE = 1000;\n                const FULL_CHUNK_HEIGHT = 16;\n                function mirrorContextOperations(ctx, destCtx) {\n                    if (ctx._removeMirroring) {\n                        throw new Error(\"Context is already forwarding operations.\");\n                    }\n                    ctx.__originalSave = ctx.save;\n                    ctx.__originalRestore = ctx.restore;\n                    ctx.__originalRotate = ctx.rotate;\n                    ctx.__originalScale = ctx.scale;\n                    ctx.__originalTranslate = ctx.translate;\n                    ctx.__originalTransform = ctx.transform;\n                    ctx.__originalSetTransform = ctx.setTransform;\n                    ctx.__originalResetTransform = ctx.resetTransform;\n                    ctx.__originalClip = ctx.clip;\n                    ctx.__originalMoveTo = ctx.moveTo;\n                    ctx.__originalLineTo = ctx.lineTo;\n                    ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n                    ctx.__originalRect = ctx.rect;\n                    ctx.__originalClosePath = ctx.closePath;\n                    ctx.__originalBeginPath = ctx.beginPath;\n                    ctx._removeMirroring = ()=>{\n                        ctx.save = ctx.__originalSave;\n                        ctx.restore = ctx.__originalRestore;\n                        ctx.rotate = ctx.__originalRotate;\n                        ctx.scale = ctx.__originalScale;\n                        ctx.translate = ctx.__originalTranslate;\n                        ctx.transform = ctx.__originalTransform;\n                        ctx.setTransform = ctx.__originalSetTransform;\n                        ctx.resetTransform = ctx.__originalResetTransform;\n                        ctx.clip = ctx.__originalClip;\n                        ctx.moveTo = ctx.__originalMoveTo;\n                        ctx.lineTo = ctx.__originalLineTo;\n                        ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n                        ctx.rect = ctx.__originalRect;\n                        ctx.closePath = ctx.__originalClosePath;\n                        ctx.beginPath = ctx.__originalBeginPath;\n                        delete ctx._removeMirroring;\n                    };\n                    ctx.save = function ctxSave() {\n                        destCtx.save();\n                        this.__originalSave();\n                    };\n                    ctx.restore = function ctxRestore() {\n                        destCtx.restore();\n                        this.__originalRestore();\n                    };\n                    ctx.translate = function ctxTranslate(x, y) {\n                        destCtx.translate(x, y);\n                        this.__originalTranslate(x, y);\n                    };\n                    ctx.scale = function ctxScale(x, y) {\n                        destCtx.scale(x, y);\n                        this.__originalScale(x, y);\n                    };\n                    ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n                        destCtx.transform(a, b, c, d, e, f);\n                        this.__originalTransform(a, b, c, d, e, f);\n                    };\n                    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n                        destCtx.setTransform(a, b, c, d, e, f);\n                        this.__originalSetTransform(a, b, c, d, e, f);\n                    };\n                    ctx.resetTransform = function ctxResetTransform() {\n                        destCtx.resetTransform();\n                        this.__originalResetTransform();\n                    };\n                    ctx.rotate = function ctxRotate(angle) {\n                        destCtx.rotate(angle);\n                        this.__originalRotate(angle);\n                    };\n                    ctx.clip = function ctxRotate(rule) {\n                        destCtx.clip(rule);\n                        this.__originalClip(rule);\n                    };\n                    ctx.moveTo = function(x, y) {\n                        destCtx.moveTo(x, y);\n                        this.__originalMoveTo(x, y);\n                    };\n                    ctx.lineTo = function(x, y) {\n                        destCtx.lineTo(x, y);\n                        this.__originalLineTo(x, y);\n                    };\n                    ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n                        destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n                        this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n                    };\n                    ctx.rect = function(x, y, width, height) {\n                        destCtx.rect(x, y, width, height);\n                        this.__originalRect(x, y, width, height);\n                    };\n                    ctx.closePath = function() {\n                        destCtx.closePath();\n                        this.__originalClosePath();\n                    };\n                    ctx.beginPath = function() {\n                        destCtx.beginPath();\n                        this.__originalBeginPath();\n                    };\n                }\n                class CachedCanvases {\n                    constructor(canvasFactory){\n                        this.canvasFactory = canvasFactory;\n                        this.cache = Object.create(null);\n                    }\n                    getCanvas(id, width, height) {\n                        let canvasEntry;\n                        if (this.cache[id] !== undefined) {\n                            canvasEntry = this.cache[id];\n                            this.canvasFactory.reset(canvasEntry, width, height);\n                        } else {\n                            canvasEntry = this.canvasFactory.create(width, height);\n                            this.cache[id] = canvasEntry;\n                        }\n                        return canvasEntry;\n                    }\n                    delete(id) {\n                        delete this.cache[id];\n                    }\n                    clear() {\n                        for(const id in this.cache){\n                            const canvasEntry = this.cache[id];\n                            this.canvasFactory.destroy(canvasEntry);\n                            delete this.cache[id];\n                        }\n                    }\n                }\n                function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n                    const [a, b, c, d, tx, ty] = (0, _display_utils.getCurrentTransform)(ctx);\n                    if (b === 0 && c === 0) {\n                        const tlX = destX * a + tx;\n                        const rTlX = Math.round(tlX);\n                        const tlY = destY * d + ty;\n                        const rTlY = Math.round(tlY);\n                        const brX = (destX + destW) * a + tx;\n                        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n                        const brY = (destY + destH) * d + ty;\n                        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n                        ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n                        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n                        ctx.setTransform(a, b, c, d, tx, ty);\n                        return [\n                            rWidth,\n                            rHeight\n                        ];\n                    }\n                    if (a === 0 && d === 0) {\n                        const tlX = destY * c + tx;\n                        const rTlX = Math.round(tlX);\n                        const tlY = destX * b + ty;\n                        const rTlY = Math.round(tlY);\n                        const brX = (destY + destH) * c + tx;\n                        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n                        const brY = (destX + destW) * b + ty;\n                        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n                        ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n                        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n                        ctx.setTransform(a, b, c, d, tx, ty);\n                        return [\n                            rHeight,\n                            rWidth\n                        ];\n                    }\n                    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n                    const scaleX = Math.hypot(a, b);\n                    const scaleY = Math.hypot(c, d);\n                    return [\n                        scaleX * destW,\n                        scaleY * destH\n                    ];\n                }\n                function compileType3Glyph(imgData) {\n                    const { width, height } = imgData;\n                    if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {\n                        return null;\n                    }\n                    const POINT_TO_PROCESS_LIMIT = 1000;\n                    const POINT_TYPES = new Uint8Array([\n                        0,\n                        2,\n                        4,\n                        0,\n                        1,\n                        0,\n                        5,\n                        4,\n                        8,\n                        10,\n                        0,\n                        8,\n                        0,\n                        2,\n                        1,\n                        0\n                    ]);\n                    const width1 = width + 1;\n                    let points = new Uint8Array(width1 * (height + 1));\n                    let i, j, j0;\n                    const lineSize = width + 7 & ~7;\n                    let data = new Uint8Array(lineSize * height), pos = 0;\n                    for (const elem of imgData.data){\n                        let mask = 128;\n                        while(mask > 0){\n                            data[pos++] = elem & mask ? 0 : 255;\n                            mask >>= 1;\n                        }\n                    }\n                    let count = 0;\n                    pos = 0;\n                    if (data[pos] !== 0) {\n                        points[0] = 1;\n                        ++count;\n                    }\n                    for(j = 1; j < width; j++){\n                        if (data[pos] !== data[pos + 1]) {\n                            points[j] = data[pos] ? 2 : 1;\n                            ++count;\n                        }\n                        pos++;\n                    }\n                    if (data[pos] !== 0) {\n                        points[j] = 2;\n                        ++count;\n                    }\n                    for(i = 1; i < height; i++){\n                        pos = i * lineSize;\n                        j0 = i * width1;\n                        if (data[pos - lineSize] !== data[pos]) {\n                            points[j0] = data[pos] ? 1 : 8;\n                            ++count;\n                        }\n                        let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n                        for(j = 1; j < width; j++){\n                            sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n                            if (POINT_TYPES[sum]) {\n                                points[j0 + j] = POINT_TYPES[sum];\n                                ++count;\n                            }\n                            pos++;\n                        }\n                        if (data[pos - lineSize] !== data[pos]) {\n                            points[j0 + j] = data[pos] ? 2 : 4;\n                            ++count;\n                        }\n                        if (count > POINT_TO_PROCESS_LIMIT) {\n                            return null;\n                        }\n                    }\n                    pos = lineSize * (height - 1);\n                    j0 = i * width1;\n                    if (data[pos] !== 0) {\n                        points[j0] = 8;\n                        ++count;\n                    }\n                    for(j = 1; j < width; j++){\n                        if (data[pos] !== data[pos + 1]) {\n                            points[j0 + j] = data[pos] ? 4 : 8;\n                            ++count;\n                        }\n                        pos++;\n                    }\n                    if (data[pos] !== 0) {\n                        points[j0 + j] = 4;\n                        ++count;\n                    }\n                    if (count > POINT_TO_PROCESS_LIMIT) {\n                        return null;\n                    }\n                    const steps = new Int32Array([\n                        0,\n                        width1,\n                        -1,\n                        0,\n                        -width1,\n                        0,\n                        0,\n                        0,\n                        1\n                    ]);\n                    const path = new Path2D();\n                    for(i = 0; count && i <= height; i++){\n                        let p = i * width1;\n                        const end = p + width;\n                        while(p < end && !points[p]){\n                            p++;\n                        }\n                        if (p === end) {\n                            continue;\n                        }\n                        path.moveTo(p % width1, i);\n                        const p0 = p;\n                        let type = points[p];\n                        do {\n                            const step = steps[type];\n                            do {\n                                p += step;\n                            }while (!points[p]);\n                            const pp = points[p];\n                            if (pp !== 5 && pp !== 10) {\n                                type = pp;\n                                points[p] = 0;\n                            } else {\n                                type = pp & 0x33 * type >> 4;\n                                points[p] &= type >> 2 | type << 2;\n                            }\n                            path.lineTo(p % width1, p / width1 | 0);\n                            if (!points[p]) {\n                                --count;\n                            }\n                        }while (p0 !== p);\n                        --i;\n                    }\n                    data = null;\n                    points = null;\n                    const drawOutline = function(c) {\n                        c.save();\n                        c.scale(1 / width, -1 / height);\n                        c.translate(0, -height);\n                        c.fill(path);\n                        c.beginPath();\n                        c.restore();\n                    };\n                    return drawOutline;\n                }\n                class CanvasExtraState {\n                    constructor(width, height){\n                        this.alphaIsShape = false;\n                        this.fontSize = 0;\n                        this.fontSizeScale = 1;\n                        this.textMatrix = _util.IDENTITY_MATRIX;\n                        this.textMatrixScale = 1;\n                        this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n                        this.leading = 0;\n                        this.x = 0;\n                        this.y = 0;\n                        this.lineX = 0;\n                        this.lineY = 0;\n                        this.charSpacing = 0;\n                        this.wordSpacing = 0;\n                        this.textHScale = 1;\n                        this.textRenderingMode = _util.TextRenderingMode.FILL;\n                        this.textRise = 0;\n                        this.fillColor = \"#000000\";\n                        this.strokeColor = \"#000000\";\n                        this.patternFill = false;\n                        this.fillAlpha = 1;\n                        this.strokeAlpha = 1;\n                        this.lineWidth = 1;\n                        this.activeSMask = null;\n                        this.transferMaps = \"none\";\n                        this.startNewPathAndClipBox([\n                            0,\n                            0,\n                            width,\n                            height\n                        ]);\n                    }\n                    clone() {\n                        const clone = Object.create(this);\n                        clone.clipBox = this.clipBox.slice();\n                        return clone;\n                    }\n                    setCurrentPoint(x, y) {\n                        this.x = x;\n                        this.y = y;\n                    }\n                    updatePathMinMax(transform, x, y) {\n                        [x, y] = _util.Util.applyTransform([\n                            x,\n                            y\n                        ], transform);\n                        this.minX = Math.min(this.minX, x);\n                        this.minY = Math.min(this.minY, y);\n                        this.maxX = Math.max(this.maxX, x);\n                        this.maxY = Math.max(this.maxY, y);\n                    }\n                    updateRectMinMax(transform, rect) {\n                        const p1 = _util.Util.applyTransform(rect, transform);\n                        const p2 = _util.Util.applyTransform(rect.slice(2), transform);\n                        this.minX = Math.min(this.minX, p1[0], p2[0]);\n                        this.minY = Math.min(this.minY, p1[1], p2[1]);\n                        this.maxX = Math.max(this.maxX, p1[0], p2[0]);\n                        this.maxY = Math.max(this.maxY, p1[1], p2[1]);\n                    }\n                    updateScalingPathMinMax(transform, minMax) {\n                        _util.Util.scaleMinMax(transform, minMax);\n                        this.minX = Math.min(this.minX, minMax[0]);\n                        this.maxX = Math.max(this.maxX, minMax[1]);\n                        this.minY = Math.min(this.minY, minMax[2]);\n                        this.maxY = Math.max(this.maxY, minMax[3]);\n                    }\n                    updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n                        const box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);\n                        if (minMax) {\n                            minMax[0] = Math.min(minMax[0], box[0], box[2]);\n                            minMax[1] = Math.max(minMax[1], box[0], box[2]);\n                            minMax[2] = Math.min(minMax[2], box[1], box[3]);\n                            minMax[3] = Math.max(minMax[3], box[1], box[3]);\n                            return;\n                        }\n                        this.updateRectMinMax(transform, box);\n                    }\n                    getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {\n                        const box = [\n                            this.minX,\n                            this.minY,\n                            this.maxX,\n                            this.maxY\n                        ];\n                        if (pathType === _pattern_helper.PathType.STROKE) {\n                            if (!transform) {\n                                (0, _util.unreachable)(\"Stroke bounding box must include transform.\");\n                            }\n                            const scale = _util.Util.singularValueDecompose2dScale(transform);\n                            const xStrokePad = scale[0] * this.lineWidth / 2;\n                            const yStrokePad = scale[1] * this.lineWidth / 2;\n                            box[0] -= xStrokePad;\n                            box[1] -= yStrokePad;\n                            box[2] += xStrokePad;\n                            box[3] += yStrokePad;\n                        }\n                        return box;\n                    }\n                    updateClipFromPath() {\n                        const intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());\n                        this.startNewPathAndClipBox(intersect || [\n                            0,\n                            0,\n                            0,\n                            0\n                        ]);\n                    }\n                    isEmptyClip() {\n                        return this.minX === Infinity;\n                    }\n                    startNewPathAndClipBox(box) {\n                        this.clipBox = box;\n                        this.minX = Infinity;\n                        this.minY = Infinity;\n                        this.maxX = 0;\n                        this.maxY = 0;\n                    }\n                    getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {\n                        return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n                    }\n                }\n                function putBinaryImageData(ctx, imgData) {\n                    if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\n                        ctx.putImageData(imgData, 0, 0);\n                        return;\n                    }\n                    const height = imgData.height, width = imgData.width;\n                    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n                    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n                    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n                    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n                    let srcPos = 0, destPos;\n                    const src = imgData.data;\n                    const dest = chunkImgData.data;\n                    let i, j, thisChunkHeight, elemsInThisChunk;\n                    if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {\n                        const srcLength = src.byteLength;\n                        const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n                        const dest32DataLength = dest32.length;\n                        const fullSrcDiff = width + 7 >> 3;\n                        const white = 0xffffffff;\n                        const black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n                        for(i = 0; i < totalChunks; i++){\n                            thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n                            destPos = 0;\n                            for(j = 0; j < thisChunkHeight; j++){\n                                const srcDiff = srcLength - srcPos;\n                                let k = 0;\n                                const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n                                const kEndUnrolled = kEnd & ~7;\n                                let mask = 0;\n                                let srcByte = 0;\n                                for(; k < kEndUnrolled; k += 8){\n                                    srcByte = src[srcPos++];\n                                    dest32[destPos++] = srcByte & 128 ? white : black;\n                                    dest32[destPos++] = srcByte & 64 ? white : black;\n                                    dest32[destPos++] = srcByte & 32 ? white : black;\n                                    dest32[destPos++] = srcByte & 16 ? white : black;\n                                    dest32[destPos++] = srcByte & 8 ? white : black;\n                                    dest32[destPos++] = srcByte & 4 ? white : black;\n                                    dest32[destPos++] = srcByte & 2 ? white : black;\n                                    dest32[destPos++] = srcByte & 1 ? white : black;\n                                }\n                                for(; k < kEnd; k++){\n                                    if (mask === 0) {\n                                        srcByte = src[srcPos++];\n                                        mask = 128;\n                                    }\n                                    dest32[destPos++] = srcByte & mask ? white : black;\n                                    mask >>= 1;\n                                }\n                            }\n                            while(destPos < dest32DataLength){\n                                dest32[destPos++] = 0;\n                            }\n                            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n                        }\n                    } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {\n                        j = 0;\n                        elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n                        for(i = 0; i < fullChunks; i++){\n                            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n                            srcPos += elemsInThisChunk;\n                            ctx.putImageData(chunkImgData, 0, j);\n                            j += FULL_CHUNK_HEIGHT;\n                        }\n                        if (i < totalChunks) {\n                            elemsInThisChunk = width * partialChunkHeight * 4;\n                            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n                            ctx.putImageData(chunkImgData, 0, j);\n                        }\n                    } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {\n                        thisChunkHeight = FULL_CHUNK_HEIGHT;\n                        elemsInThisChunk = width * thisChunkHeight;\n                        for(i = 0; i < totalChunks; i++){\n                            if (i >= fullChunks) {\n                                thisChunkHeight = partialChunkHeight;\n                                elemsInThisChunk = width * thisChunkHeight;\n                            }\n                            destPos = 0;\n                            for(j = elemsInThisChunk; j--;){\n                                dest[destPos++] = src[srcPos++];\n                                dest[destPos++] = src[srcPos++];\n                                dest[destPos++] = src[srcPos++];\n                                dest[destPos++] = 255;\n                            }\n                            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n                        }\n                    } else {\n                        throw new Error(`bad image kind: ${imgData.kind}`);\n                    }\n                }\n                function putBinaryImageMask(ctx, imgData) {\n                    if (imgData.bitmap) {\n                        ctx.drawImage(imgData.bitmap, 0, 0);\n                        return;\n                    }\n                    const height = imgData.height, width = imgData.width;\n                    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n                    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n                    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n                    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n                    let srcPos = 0;\n                    const src = imgData.data;\n                    const dest = chunkImgData.data;\n                    for(let i = 0; i < totalChunks; i++){\n                        const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n                        ({ srcPos } = (0, _image_utils.convertBlackAndWhiteToRGBA)({\n                            src,\n                            srcPos,\n                            dest,\n                            width,\n                            height: thisChunkHeight,\n                            nonBlackColor: 0\n                        }));\n                        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n                    }\n                }\n                function copyCtxState(sourceCtx, destCtx) {\n                    const properties = [\n                        \"strokeStyle\",\n                        \"fillStyle\",\n                        \"fillRule\",\n                        \"globalAlpha\",\n                        \"lineWidth\",\n                        \"lineCap\",\n                        \"lineJoin\",\n                        \"miterLimit\",\n                        \"globalCompositeOperation\",\n                        \"font\",\n                        \"filter\"\n                    ];\n                    for (const property of properties){\n                        if (sourceCtx[property] !== undefined) {\n                            destCtx[property] = sourceCtx[property];\n                        }\n                    }\n                    if (sourceCtx.setLineDash !== undefined) {\n                        destCtx.setLineDash(sourceCtx.getLineDash());\n                        destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n                    }\n                }\n                function resetCtxToDefault(ctx) {\n                    ctx.strokeStyle = ctx.fillStyle = \"#000000\";\n                    ctx.fillRule = \"nonzero\";\n                    ctx.globalAlpha = 1;\n                    ctx.lineWidth = 1;\n                    ctx.lineCap = \"butt\";\n                    ctx.lineJoin = \"miter\";\n                    ctx.miterLimit = 10;\n                    ctx.globalCompositeOperation = \"source-over\";\n                    ctx.font = \"10px sans-serif\";\n                    if (ctx.setLineDash !== undefined) {\n                        ctx.setLineDash([]);\n                        ctx.lineDashOffset = 0;\n                    }\n                    if (!_util.isNodeJS) {\n                        const { filter } = ctx;\n                        if (filter !== \"none\" && filter !== \"\") {\n                            ctx.filter = \"none\";\n                        }\n                    }\n                }\n                function composeSMaskBackdrop(bytes, r0, g0, b0) {\n                    const length = bytes.length;\n                    for(let i = 3; i < length; i += 4){\n                        const alpha = bytes[i];\n                        if (alpha === 0) {\n                            bytes[i - 3] = r0;\n                            bytes[i - 2] = g0;\n                            bytes[i - 1] = b0;\n                        } else if (alpha < 255) {\n                            const alpha_ = 255 - alpha;\n                            bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\n                            bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\n                            bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\n                        }\n                    }\n                }\n                function composeSMaskAlpha(maskData, layerData, transferMap) {\n                    const length = maskData.length;\n                    const scale = 1 / 255;\n                    for(let i = 3; i < length; i += 4){\n                        const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\n                        layerData[i] = layerData[i] * alpha * scale | 0;\n                    }\n                }\n                function composeSMaskLuminosity(maskData, layerData, transferMap) {\n                    const length = maskData.length;\n                    for(let i = 3; i < length; i += 4){\n                        const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;\n                        layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\n                    }\n                }\n                function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n                    const hasBackdrop = !!backdrop;\n                    const r0 = hasBackdrop ? backdrop[0] : 0;\n                    const g0 = hasBackdrop ? backdrop[1] : 0;\n                    const b0 = hasBackdrop ? backdrop[2] : 0;\n                    const composeFn = subtype === \"Luminosity\" ? composeSMaskLuminosity : composeSMaskAlpha;\n                    const PIXELS_TO_PROCESS = 1048576;\n                    const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n                    for(let row = 0; row < height; row += chunkSize){\n                        const chunkHeight = Math.min(chunkSize, height - row);\n                        const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);\n                        const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);\n                        if (hasBackdrop) {\n                            composeSMaskBackdrop(maskData.data, r0, g0, b0);\n                        }\n                        composeFn(maskData.data, layerData.data, transferMap);\n                        layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);\n                    }\n                }\n                function composeSMask(ctx, smask, layerCtx, layerBox) {\n                    const layerOffsetX = layerBox[0];\n                    const layerOffsetY = layerBox[1];\n                    const layerWidth = layerBox[2] - layerOffsetX;\n                    const layerHeight = layerBox[3] - layerOffsetY;\n                    if (layerWidth === 0 || layerHeight === 0) {\n                        return;\n                    }\n                    genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n                    ctx.save();\n                    ctx.globalAlpha = 1;\n                    ctx.globalCompositeOperation = \"source-over\";\n                    ctx.setTransform(1, 0, 0, 1, 0, 0);\n                    ctx.drawImage(layerCtx.canvas, 0, 0);\n                    ctx.restore();\n                }\n                function getImageSmoothingEnabled(transform, interpolate) {\n                    const scale = _util.Util.singularValueDecompose2dScale(transform);\n                    scale[0] = Math.fround(scale[0]);\n                    scale[1] = Math.fround(scale[1]);\n                    const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n                    if (interpolate !== undefined) {\n                        return interpolate;\n                    } else if (scale[0] <= actualScale || scale[1] <= actualScale) {\n                        return true;\n                    }\n                    return false;\n                }\n                const LINE_CAP_STYLES = [\n                    \"butt\",\n                    \"round\",\n                    \"square\"\n                ];\n                const LINE_JOIN_STYLES = [\n                    \"miter\",\n                    \"round\",\n                    \"bevel\"\n                ];\n                const NORMAL_CLIP = {};\n                const EO_CLIP = {};\n                class CanvasGraphics {\n                    constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, { optionalContentConfig, markedContentStack = null }, annotationCanvasMap, pageColors){\n                        this.ctx = canvasCtx;\n                        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n                        this.stateStack = [];\n                        this.pendingClip = null;\n                        this.pendingEOFill = false;\n                        this.res = null;\n                        this.xobjs = null;\n                        this.commonObjs = commonObjs;\n                        this.objs = objs;\n                        this.canvasFactory = canvasFactory;\n                        this.filterFactory = filterFactory;\n                        this.groupStack = [];\n                        this.processingType3 = null;\n                        this.baseTransform = null;\n                        this.baseTransformStack = [];\n                        this.groupLevel = 0;\n                        this.smaskStack = [];\n                        this.smaskCounter = 0;\n                        this.tempSMask = null;\n                        this.suspendedCtx = null;\n                        this.contentVisible = true;\n                        this.markedContentStack = markedContentStack || [];\n                        this.optionalContentConfig = optionalContentConfig;\n                        this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n                        this.cachedPatterns = new Map();\n                        this.annotationCanvasMap = annotationCanvasMap;\n                        this.viewportScale = 1;\n                        this.outputScaleX = 1;\n                        this.outputScaleY = 1;\n                        this.pageColors = pageColors;\n                        this._cachedScaleForStroking = [\n                            -1,\n                            0\n                        ];\n                        this._cachedGetSinglePixelWidth = null;\n                        this._cachedBitmapsMap = new Map();\n                    }\n                    getObject(data, fallback = null) {\n                        if (typeof data === \"string\") {\n                            return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n                        }\n                        return fallback;\n                    }\n                    beginDrawing({ transform, viewport, transparency = false, background = null }) {\n                        const width = this.ctx.canvas.width;\n                        const height = this.ctx.canvas.height;\n                        const savedFillStyle = this.ctx.fillStyle;\n                        this.ctx.fillStyle = background || \"#ffffff\";\n                        this.ctx.fillRect(0, 0, width, height);\n                        this.ctx.fillStyle = savedFillStyle;\n                        if (transparency) {\n                            const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n                            this.compositeCtx = this.ctx;\n                            this.transparentCanvas = transparentCanvas.canvas;\n                            this.ctx = transparentCanvas.context;\n                            this.ctx.save();\n                            this.ctx.transform(...(0, _display_utils.getCurrentTransform)(this.compositeCtx));\n                        }\n                        this.ctx.save();\n                        resetCtxToDefault(this.ctx);\n                        if (transform) {\n                            this.ctx.transform(...transform);\n                            this.outputScaleX = transform[0];\n                            this.outputScaleY = transform[0];\n                        }\n                        this.ctx.transform(...viewport.transform);\n                        this.viewportScale = viewport.scale;\n                        this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);\n                    }\n                    executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n                        const argsArray = operatorList.argsArray;\n                        const fnArray = operatorList.fnArray;\n                        let i = executionStartIdx || 0;\n                        const argsArrayLen = argsArray.length;\n                        if (argsArrayLen === i) {\n                            return i;\n                        }\n                        const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n                        const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n                        let steps = 0;\n                        const commonObjs = this.commonObjs;\n                        const objs = this.objs;\n                        let fnId;\n                        while(true){\n                            if (stepper !== undefined && i === stepper.nextBreakPoint) {\n                                stepper.breakIt(i, continueCallback);\n                                return i;\n                            }\n                            fnId = fnArray[i];\n                            if (fnId !== _util.OPS.dependency) {\n                                this[fnId].apply(this, argsArray[i]);\n                            } else {\n                                for (const depObjId of argsArray[i]){\n                                    const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n                                    if (!objsPool.has(depObjId)) {\n                                        objsPool.get(depObjId, continueCallback);\n                                        return i;\n                                    }\n                                }\n                            }\n                            i++;\n                            if (i === argsArrayLen) {\n                                return i;\n                            }\n                            if (chunkOperations && ++steps > EXECUTION_STEPS) {\n                                if (Date.now() > endTime) {\n                                    continueCallback();\n                                    return i;\n                                }\n                                steps = 0;\n                            }\n                        }\n                    }\n                    #restoreInitialState() {\n                        while(this.stateStack.length || this.inSMaskMode){\n                            this.restore();\n                        }\n                        this.ctx.restore();\n                        if (this.transparentCanvas) {\n                            this.ctx = this.compositeCtx;\n                            this.ctx.save();\n                            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n                            this.ctx.drawImage(this.transparentCanvas, 0, 0);\n                            this.ctx.restore();\n                            this.transparentCanvas = null;\n                        }\n                    }\n                    endDrawing() {\n                        this.#restoreInitialState();\n                        this.cachedCanvases.clear();\n                        this.cachedPatterns.clear();\n                        for (const cache of this._cachedBitmapsMap.values()){\n                            for (const canvas of cache.values()){\n                                if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n                                    canvas.width = canvas.height = 0;\n                                }\n                            }\n                            cache.clear();\n                        }\n                        this._cachedBitmapsMap.clear();\n                        this.#drawFilter();\n                    }\n                    #drawFilter() {\n                        if (this.pageColors) {\n                            const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n                            if (hcmFilterId !== \"none\") {\n                                const savedFilter = this.ctx.filter;\n                                this.ctx.filter = hcmFilterId;\n                                this.ctx.drawImage(this.ctx.canvas, 0, 0);\n                                this.ctx.filter = savedFilter;\n                            }\n                        }\n                    }\n                    _scaleImage(img, inverseTransform) {\n                        const width = img.width;\n                        const height = img.height;\n                        let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n                        let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n                        let paintWidth = width, paintHeight = height;\n                        let tmpCanvasId = \"prescale1\";\n                        let tmpCanvas, tmpCtx;\n                        while(widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1){\n                            let newWidth = paintWidth, newHeight = paintHeight;\n                            if (widthScale > 2 && paintWidth > 1) {\n                                newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);\n                                widthScale /= paintWidth / newWidth;\n                            }\n                            if (heightScale > 2 && paintHeight > 1) {\n                                newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;\n                                heightScale /= paintHeight / newHeight;\n                            }\n                            tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n                            tmpCtx = tmpCanvas.context;\n                            tmpCtx.clearRect(0, 0, newWidth, newHeight);\n                            tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n                            img = tmpCanvas.canvas;\n                            paintWidth = newWidth;\n                            paintHeight = newHeight;\n                            tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n                        }\n                        return {\n                            img,\n                            paintWidth,\n                            paintHeight\n                        };\n                    }\n                    _createMaskCanvas(img) {\n                        const ctx = this.ctx;\n                        const { width, height } = img;\n                        const fillColor = this.current.fillColor;\n                        const isPatternFill = this.current.patternFill;\n                        const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n                        let cache, cacheKey, scaled, maskCanvas;\n                        if ((img.bitmap || img.data) && img.count > 1) {\n                            const mainKey = img.bitmap || img.data.buffer;\n                            cacheKey = JSON.stringify(isPatternFill ? currentTransform : [\n                                currentTransform.slice(0, 4),\n                                fillColor\n                            ]);\n                            cache = this._cachedBitmapsMap.get(mainKey);\n                            if (!cache) {\n                                cache = new Map();\n                                this._cachedBitmapsMap.set(mainKey, cache);\n                            }\n                            const cachedImage = cache.get(cacheKey);\n                            if (cachedImage && !isPatternFill) {\n                                const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n                                const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n                                return {\n                                    canvas: cachedImage,\n                                    offsetX,\n                                    offsetY\n                                };\n                            }\n                            scaled = cachedImage;\n                        }\n                        if (!scaled) {\n                            maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n                            putBinaryImageMask(maskCanvas.context, img);\n                        }\n                        let maskToCanvas = _util.Util.transform(currentTransform, [\n                            1 / width,\n                            0,\n                            0,\n                            -1 / height,\n                            0,\n                            0\n                        ]);\n                        maskToCanvas = _util.Util.transform(maskToCanvas, [\n                            1,\n                            0,\n                            0,\n                            1,\n                            0,\n                            -height\n                        ]);\n                        const cord1 = _util.Util.applyTransform([\n                            0,\n                            0\n                        ], maskToCanvas);\n                        const cord2 = _util.Util.applyTransform([\n                            width,\n                            height\n                        ], maskToCanvas);\n                        const rect = _util.Util.normalizeRect([\n                            cord1[0],\n                            cord1[1],\n                            cord2[0],\n                            cord2[1]\n                        ]);\n                        const drawnWidth = Math.round(rect[2] - rect[0]) || 1;\n                        const drawnHeight = Math.round(rect[3] - rect[1]) || 1;\n                        const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n                        const fillCtx = fillCanvas.context;\n                        const offsetX = Math.min(cord1[0], cord2[0]);\n                        const offsetY = Math.min(cord1[1], cord2[1]);\n                        fillCtx.translate(-offsetX, -offsetY);\n                        fillCtx.transform(...maskToCanvas);\n                        if (!scaled) {\n                            scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils.getCurrentTransformInverse)(fillCtx));\n                            scaled = scaled.img;\n                            if (cache && isPatternFill) {\n                                cache.set(cacheKey, scaled);\n                            }\n                        }\n                        fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(fillCtx), img.interpolate);\n                        drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n                        fillCtx.globalCompositeOperation = \"source-in\";\n                        const inverse = _util.Util.transform((0, _display_utils.getCurrentTransformInverse)(fillCtx), [\n                            1,\n                            0,\n                            0,\n                            1,\n                            -offsetX,\n                            -offsetY\n                        ]);\n                        fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;\n                        fillCtx.fillRect(0, 0, width, height);\n                        if (cache && !isPatternFill) {\n                            this.cachedCanvases.delete(\"fillCanvas\");\n                            cache.set(cacheKey, fillCanvas.canvas);\n                        }\n                        return {\n                            canvas: fillCanvas.canvas,\n                            offsetX: Math.round(offsetX),\n                            offsetY: Math.round(offsetY)\n                        };\n                    }\n                    setLineWidth(width) {\n                        if (width !== this.current.lineWidth) {\n                            this._cachedScaleForStroking[0] = -1;\n                        }\n                        this.current.lineWidth = width;\n                        this.ctx.lineWidth = width;\n                    }\n                    setLineCap(style) {\n                        this.ctx.lineCap = LINE_CAP_STYLES[style];\n                    }\n                    setLineJoin(style) {\n                        this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n                    }\n                    setMiterLimit(limit) {\n                        this.ctx.miterLimit = limit;\n                    }\n                    setDash(dashArray, dashPhase) {\n                        const ctx = this.ctx;\n                        if (ctx.setLineDash !== undefined) {\n                            ctx.setLineDash(dashArray);\n                            ctx.lineDashOffset = dashPhase;\n                        }\n                    }\n                    setRenderingIntent(intent) {}\n                    setFlatness(flatness) {}\n                    setGState(states) {\n                        for (const [key, value] of states){\n                            switch(key){\n                                case \"LW\":\n                                    this.setLineWidth(value);\n                                    break;\n                                case \"LC\":\n                                    this.setLineCap(value);\n                                    break;\n                                case \"LJ\":\n                                    this.setLineJoin(value);\n                                    break;\n                                case \"ML\":\n                                    this.setMiterLimit(value);\n                                    break;\n                                case \"D\":\n                                    this.setDash(value[0], value[1]);\n                                    break;\n                                case \"RI\":\n                                    this.setRenderingIntent(value);\n                                    break;\n                                case \"FL\":\n                                    this.setFlatness(value);\n                                    break;\n                                case \"Font\":\n                                    this.setFont(value[0], value[1]);\n                                    break;\n                                case \"CA\":\n                                    this.current.strokeAlpha = value;\n                                    break;\n                                case \"ca\":\n                                    this.current.fillAlpha = value;\n                                    this.ctx.globalAlpha = value;\n                                    break;\n                                case \"BM\":\n                                    this.ctx.globalCompositeOperation = value;\n                                    break;\n                                case \"SMask\":\n                                    this.current.activeSMask = value ? this.tempSMask : null;\n                                    this.tempSMask = null;\n                                    this.checkSMaskState();\n                                    break;\n                                case \"TR\":\n                                    this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);\n                                    break;\n                            }\n                        }\n                    }\n                    get inSMaskMode() {\n                        return !!this.suspendedCtx;\n                    }\n                    checkSMaskState() {\n                        const inSMaskMode = this.inSMaskMode;\n                        if (this.current.activeSMask && !inSMaskMode) {\n                            this.beginSMaskMode();\n                        } else if (!this.current.activeSMask && inSMaskMode) {\n                            this.endSMaskMode();\n                        }\n                    }\n                    beginSMaskMode() {\n                        if (this.inSMaskMode) {\n                            throw new Error(\"beginSMaskMode called while already in smask mode\");\n                        }\n                        const drawnWidth = this.ctx.canvas.width;\n                        const drawnHeight = this.ctx.canvas.height;\n                        const cacheId = \"smaskGroupAt\" + this.groupLevel;\n                        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n                        this.suspendedCtx = this.ctx;\n                        this.ctx = scratchCanvas.context;\n                        const ctx = this.ctx;\n                        ctx.setTransform(...(0, _display_utils.getCurrentTransform)(this.suspendedCtx));\n                        copyCtxState(this.suspendedCtx, ctx);\n                        mirrorContextOperations(ctx, this.suspendedCtx);\n                        this.setGState([\n                            [\n                                \"BM\",\n                                \"source-over\"\n                            ],\n                            [\n                                \"ca\",\n                                1\n                            ],\n                            [\n                                \"CA\",\n                                1\n                            ]\n                        ]);\n                    }\n                    endSMaskMode() {\n                        if (!this.inSMaskMode) {\n                            throw new Error(\"endSMaskMode called while not in smask mode\");\n                        }\n                        this.ctx._removeMirroring();\n                        copyCtxState(this.ctx, this.suspendedCtx);\n                        this.ctx = this.suspendedCtx;\n                        this.suspendedCtx = null;\n                    }\n                    compose(dirtyBox) {\n                        if (!this.current.activeSMask) {\n                            return;\n                        }\n                        if (!dirtyBox) {\n                            dirtyBox = [\n                                0,\n                                0,\n                                this.ctx.canvas.width,\n                                this.ctx.canvas.height\n                            ];\n                        } else {\n                            dirtyBox[0] = Math.floor(dirtyBox[0]);\n                            dirtyBox[1] = Math.floor(dirtyBox[1]);\n                            dirtyBox[2] = Math.ceil(dirtyBox[2]);\n                            dirtyBox[3] = Math.ceil(dirtyBox[3]);\n                        }\n                        const smask = this.current.activeSMask;\n                        const suspendedCtx = this.suspendedCtx;\n                        composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n                        this.ctx.save();\n                        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n                        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n                        this.ctx.restore();\n                    }\n                    save() {\n                        if (this.inSMaskMode) {\n                            copyCtxState(this.ctx, this.suspendedCtx);\n                            this.suspendedCtx.save();\n                        } else {\n                            this.ctx.save();\n                        }\n                        const old = this.current;\n                        this.stateStack.push(old);\n                        this.current = old.clone();\n                    }\n                    restore() {\n                        if (this.stateStack.length === 0 && this.inSMaskMode) {\n                            this.endSMaskMode();\n                        }\n                        if (this.stateStack.length !== 0) {\n                            this.current = this.stateStack.pop();\n                            if (this.inSMaskMode) {\n                                this.suspendedCtx.restore();\n                                copyCtxState(this.suspendedCtx, this.ctx);\n                            } else {\n                                this.ctx.restore();\n                            }\n                            this.checkSMaskState();\n                            this.pendingClip = null;\n                            this._cachedScaleForStroking[0] = -1;\n                            this._cachedGetSinglePixelWidth = null;\n                        }\n                    }\n                    transform(a, b, c, d, e, f) {\n                        this.ctx.transform(a, b, c, d, e, f);\n                        this._cachedScaleForStroking[0] = -1;\n                        this._cachedGetSinglePixelWidth = null;\n                    }\n                    constructPath(ops, args, minMax) {\n                        const ctx = this.ctx;\n                        const current = this.current;\n                        let x = current.x, y = current.y;\n                        let startX, startY;\n                        const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n                        const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;\n                        const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;\n                        for(let i = 0, j = 0, ii = ops.length; i < ii; i++){\n                            switch(ops[i] | 0){\n                                case _util.OPS.rectangle:\n                                    x = args[j++];\n                                    y = args[j++];\n                                    const width = args[j++];\n                                    const height = args[j++];\n                                    const xw = x + width;\n                                    const yh = y + height;\n                                    ctx.moveTo(x, y);\n                                    if (width === 0 || height === 0) {\n                                        ctx.lineTo(xw, yh);\n                                    } else {\n                                        ctx.lineTo(xw, y);\n                                        ctx.lineTo(xw, yh);\n                                        ctx.lineTo(x, yh);\n                                    }\n                                    if (!isScalingMatrix) {\n                                        current.updateRectMinMax(currentTransform, [\n                                            x,\n                                            y,\n                                            xw,\n                                            yh\n                                        ]);\n                                    }\n                                    ctx.closePath();\n                                    break;\n                                case _util.OPS.moveTo:\n                                    x = args[j++];\n                                    y = args[j++];\n                                    ctx.moveTo(x, y);\n                                    if (!isScalingMatrix) {\n                                        current.updatePathMinMax(currentTransform, x, y);\n                                    }\n                                    break;\n                                case _util.OPS.lineTo:\n                                    x = args[j++];\n                                    y = args[j++];\n                                    ctx.lineTo(x, y);\n                                    if (!isScalingMatrix) {\n                                        current.updatePathMinMax(currentTransform, x, y);\n                                    }\n                                    break;\n                                case _util.OPS.curveTo:\n                                    startX = x;\n                                    startY = y;\n                                    x = args[j + 4];\n                                    y = args[j + 5];\n                                    ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n                                    current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);\n                                    j += 6;\n                                    break;\n                                case _util.OPS.curveTo2:\n                                    startX = x;\n                                    startY = y;\n                                    ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n                                    current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);\n                                    x = args[j + 2];\n                                    y = args[j + 3];\n                                    j += 4;\n                                    break;\n                                case _util.OPS.curveTo3:\n                                    startX = x;\n                                    startY = y;\n                                    x = args[j + 2];\n                                    y = args[j + 3];\n                                    ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n                                    current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);\n                                    j += 4;\n                                    break;\n                                case _util.OPS.closePath:\n                                    ctx.closePath();\n                                    break;\n                            }\n                        }\n                        if (isScalingMatrix) {\n                            current.updateScalingPathMinMax(currentTransform, minMaxForBezier);\n                        }\n                        current.setCurrentPoint(x, y);\n                    }\n                    closePath() {\n                        this.ctx.closePath();\n                    }\n                    stroke(consumePath = true) {\n                        const ctx = this.ctx;\n                        const strokeColor = this.current.strokeColor;\n                        ctx.globalAlpha = this.current.strokeAlpha;\n                        if (this.contentVisible) {\n                            if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n                                ctx.save();\n                                ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);\n                                this.rescaleAndStroke(false);\n                                ctx.restore();\n                            } else {\n                                this.rescaleAndStroke(true);\n                            }\n                        }\n                        if (consumePath) {\n                            this.consumePath(this.current.getClippedPathBoundingBox());\n                        }\n                        ctx.globalAlpha = this.current.fillAlpha;\n                    }\n                    closeStroke() {\n                        this.closePath();\n                        this.stroke();\n                    }\n                    fill(consumePath = true) {\n                        const ctx = this.ctx;\n                        const fillColor = this.current.fillColor;\n                        const isPatternFill = this.current.patternFill;\n                        let needRestore = false;\n                        if (isPatternFill) {\n                            ctx.save();\n                            ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);\n                            needRestore = true;\n                        }\n                        const intersect = this.current.getClippedPathBoundingBox();\n                        if (this.contentVisible && intersect !== null) {\n                            if (this.pendingEOFill) {\n                                ctx.fill(\"evenodd\");\n                                this.pendingEOFill = false;\n                            } else {\n                                ctx.fill();\n                            }\n                        }\n                        if (needRestore) {\n                            ctx.restore();\n                        }\n                        if (consumePath) {\n                            this.consumePath(intersect);\n                        }\n                    }\n                    eoFill() {\n                        this.pendingEOFill = true;\n                        this.fill();\n                    }\n                    fillStroke() {\n                        this.fill(false);\n                        this.stroke(false);\n                        this.consumePath();\n                    }\n                    eoFillStroke() {\n                        this.pendingEOFill = true;\n                        this.fillStroke();\n                    }\n                    closeFillStroke() {\n                        this.closePath();\n                        this.fillStroke();\n                    }\n                    closeEOFillStroke() {\n                        this.pendingEOFill = true;\n                        this.closePath();\n                        this.fillStroke();\n                    }\n                    endPath() {\n                        this.consumePath();\n                    }\n                    clip() {\n                        this.pendingClip = NORMAL_CLIP;\n                    }\n                    eoClip() {\n                        this.pendingClip = EO_CLIP;\n                    }\n                    beginText() {\n                        this.current.textMatrix = _util.IDENTITY_MATRIX;\n                        this.current.textMatrixScale = 1;\n                        this.current.x = this.current.lineX = 0;\n                        this.current.y = this.current.lineY = 0;\n                    }\n                    endText() {\n                        const paths = this.pendingTextPaths;\n                        const ctx = this.ctx;\n                        if (paths === undefined) {\n                            ctx.beginPath();\n                            return;\n                        }\n                        ctx.save();\n                        ctx.beginPath();\n                        for (const path of paths){\n                            ctx.setTransform(...path.transform);\n                            ctx.translate(path.x, path.y);\n                            path.addToPath(ctx, path.fontSize);\n                        }\n                        ctx.restore();\n                        ctx.clip();\n                        ctx.beginPath();\n                        delete this.pendingTextPaths;\n                    }\n                    setCharSpacing(spacing) {\n                        this.current.charSpacing = spacing;\n                    }\n                    setWordSpacing(spacing) {\n                        this.current.wordSpacing = spacing;\n                    }\n                    setHScale(scale) {\n                        this.current.textHScale = scale / 100;\n                    }\n                    setLeading(leading) {\n                        this.current.leading = -leading;\n                    }\n                    setFont(fontRefName, size) {\n                        const fontObj = this.commonObjs.get(fontRefName);\n                        const current = this.current;\n                        if (!fontObj) {\n                            throw new Error(`Can't find font for ${fontRefName}`);\n                        }\n                        current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n                        if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n                            (0, _util.warn)(\"Invalid font matrix for font \" + fontRefName);\n                        }\n                        if (size < 0) {\n                            size = -size;\n                            current.fontDirection = -1;\n                        } else {\n                            current.fontDirection = 1;\n                        }\n                        this.current.font = fontObj;\n                        this.current.fontSize = size;\n                        if (fontObj.isType3Font) {\n                            return;\n                        }\n                        const name = fontObj.loadedName || \"sans-serif\";\n                        const typeface = fontObj.systemFontInfo?.css || `\"${name}\", ${fontObj.fallbackName}`;\n                        let bold = \"normal\";\n                        if (fontObj.black) {\n                            bold = \"900\";\n                        } else if (fontObj.bold) {\n                            bold = \"bold\";\n                        }\n                        const italic = fontObj.italic ? \"italic\" : \"normal\";\n                        let browserFontSize = size;\n                        if (size < MIN_FONT_SIZE) {\n                            browserFontSize = MIN_FONT_SIZE;\n                        } else if (size > MAX_FONT_SIZE) {\n                            browserFontSize = MAX_FONT_SIZE;\n                        }\n                        this.current.fontSizeScale = size / browserFontSize;\n                        this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n                    }\n                    setTextRenderingMode(mode) {\n                        this.current.textRenderingMode = mode;\n                    }\n                    setTextRise(rise) {\n                        this.current.textRise = rise;\n                    }\n                    moveText(x, y) {\n                        this.current.x = this.current.lineX += x;\n                        this.current.y = this.current.lineY += y;\n                    }\n                    setLeadingMoveText(x, y) {\n                        this.setLeading(-y);\n                        this.moveText(x, y);\n                    }\n                    setTextMatrix(a, b, c, d, e, f) {\n                        this.current.textMatrix = [\n                            a,\n                            b,\n                            c,\n                            d,\n                            e,\n                            f\n                        ];\n                        this.current.textMatrixScale = Math.hypot(a, b);\n                        this.current.x = this.current.lineX = 0;\n                        this.current.y = this.current.lineY = 0;\n                    }\n                    nextLine() {\n                        this.moveText(0, this.current.leading);\n                    }\n                    paintChar(character, x, y, patternTransform) {\n                        const ctx = this.ctx;\n                        const current = this.current;\n                        const font = current.font;\n                        const textRenderingMode = current.textRenderingMode;\n                        const fontSize = current.fontSize / current.fontSizeScale;\n                        const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n                        const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);\n                        const patternFill = current.patternFill && !font.missingFile;\n                        let addToPath;\n                        if (font.disableFontFace || isAddToPathSet || patternFill) {\n                            addToPath = font.getPathGenerator(this.commonObjs, character);\n                        }\n                        if (font.disableFontFace || patternFill) {\n                            ctx.save();\n                            ctx.translate(x, y);\n                            ctx.beginPath();\n                            addToPath(ctx, fontSize);\n                            if (patternTransform) {\n                                ctx.setTransform(...patternTransform);\n                            }\n                            if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                                ctx.fill();\n                            }\n                            if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                                ctx.stroke();\n                            }\n                            ctx.restore();\n                        } else {\n                            if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                                ctx.fillText(character, x, y);\n                            }\n                            if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                                ctx.strokeText(character, x, y);\n                            }\n                        }\n                        if (isAddToPathSet) {\n                            const paths = this.pendingTextPaths ||= [];\n                            paths.push({\n                                transform: (0, _display_utils.getCurrentTransform)(ctx),\n                                x,\n                                y,\n                                fontSize,\n                                addToPath\n                            });\n                        }\n                    }\n                    get isFontSubpixelAAEnabled() {\n                        const { context: ctx } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n                        ctx.scale(1.5, 1);\n                        ctx.fillText(\"I\", 0, 10);\n                        const data = ctx.getImageData(0, 0, 10, 10).data;\n                        let enabled = false;\n                        for(let i = 3; i < data.length; i += 4){\n                            if (data[i] > 0 && data[i] < 255) {\n                                enabled = true;\n                                break;\n                            }\n                        }\n                        return (0, _util.shadow)(this, \"isFontSubpixelAAEnabled\", enabled);\n                    }\n                    showText(glyphs) {\n                        const current = this.current;\n                        const font = current.font;\n                        if (font.isType3Font) {\n                            return this.showType3Text(glyphs);\n                        }\n                        const fontSize = current.fontSize;\n                        if (fontSize === 0) {\n                            return undefined;\n                        }\n                        const ctx = this.ctx;\n                        const fontSizeScale = current.fontSizeScale;\n                        const charSpacing = current.charSpacing;\n                        const wordSpacing = current.wordSpacing;\n                        const fontDirection = current.fontDirection;\n                        const textHScale = current.textHScale * fontDirection;\n                        const glyphsLength = glyphs.length;\n                        const vertical = font.vertical;\n                        const spacingDir = vertical ? 1 : -1;\n                        const defaultVMetrics = font.defaultVMetrics;\n                        const widthAdvanceScale = fontSize * current.fontMatrix[0];\n                        const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n                        ctx.save();\n                        ctx.transform(...current.textMatrix);\n                        ctx.translate(current.x, current.y + current.textRise);\n                        if (fontDirection > 0) {\n                            ctx.scale(textHScale, -1);\n                        } else {\n                            ctx.scale(textHScale, 1);\n                        }\n                        let patternTransform;\n                        if (current.patternFill) {\n                            ctx.save();\n                            const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);\n                            patternTransform = (0, _display_utils.getCurrentTransform)(ctx);\n                            ctx.restore();\n                            ctx.fillStyle = pattern;\n                        }\n                        let lineWidth = current.lineWidth;\n                        const scale = current.textMatrixScale;\n                        if (scale === 0 || lineWidth === 0) {\n                            const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n                            if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                                lineWidth = this.getSinglePixelWidth();\n                            }\n                        } else {\n                            lineWidth /= scale;\n                        }\n                        if (fontSizeScale !== 1.0) {\n                            ctx.scale(fontSizeScale, fontSizeScale);\n                            lineWidth /= fontSizeScale;\n                        }\n                        ctx.lineWidth = lineWidth;\n                        if (font.isInvalidPDFjsFont) {\n                            const chars = [];\n                            let width = 0;\n                            for (const glyph of glyphs){\n                                chars.push(glyph.unicode);\n                                width += glyph.width;\n                            }\n                            ctx.fillText(chars.join(\"\"), 0, 0);\n                            current.x += width * widthAdvanceScale * textHScale;\n                            ctx.restore();\n                            this.compose();\n                            return undefined;\n                        }\n                        let x = 0, i;\n                        for(i = 0; i < glyphsLength; ++i){\n                            const glyph = glyphs[i];\n                            if (typeof glyph === \"number\") {\n                                x += spacingDir * glyph * fontSize / 1000;\n                                continue;\n                            }\n                            let restoreNeeded = false;\n                            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n                            const character = glyph.fontChar;\n                            const accent = glyph.accent;\n                            let scaledX, scaledY;\n                            let width = glyph.width;\n                            if (vertical) {\n                                const vmetric = glyph.vmetric || defaultVMetrics;\n                                const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n                                const vy = vmetric[2] * widthAdvanceScale;\n                                width = vmetric ? -vmetric[0] : width;\n                                scaledX = vx / fontSizeScale;\n                                scaledY = (x + vy) / fontSizeScale;\n                            } else {\n                                scaledX = x / fontSizeScale;\n                                scaledY = 0;\n                            }\n                            if (font.remeasure && width > 0) {\n                                const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n                                if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n                                    const characterScaleX = width / measuredWidth;\n                                    restoreNeeded = true;\n                                    ctx.save();\n                                    ctx.scale(characterScaleX, 1);\n                                    scaledX /= characterScaleX;\n                                } else if (width !== measuredWidth) {\n                                    scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n                                }\n                            }\n                            if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n                                if (simpleFillText && !accent) {\n                                    ctx.fillText(character, scaledX, scaledY);\n                                } else {\n                                    this.paintChar(character, scaledX, scaledY, patternTransform);\n                                    if (accent) {\n                                        const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n                                        const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n                                        this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);\n                                    }\n                                }\n                            }\n                            const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n                            x += charWidth;\n                            if (restoreNeeded) {\n                                ctx.restore();\n                            }\n                        }\n                        if (vertical) {\n                            current.y -= x;\n                        } else {\n                            current.x += x * textHScale;\n                        }\n                        ctx.restore();\n                        this.compose();\n                        return undefined;\n                    }\n                    showType3Text(glyphs) {\n                        const ctx = this.ctx;\n                        const current = this.current;\n                        const font = current.font;\n                        const fontSize = current.fontSize;\n                        const fontDirection = current.fontDirection;\n                        const spacingDir = font.vertical ? 1 : -1;\n                        const charSpacing = current.charSpacing;\n                        const wordSpacing = current.wordSpacing;\n                        const textHScale = current.textHScale * fontDirection;\n                        const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n                        const glyphsLength = glyphs.length;\n                        const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;\n                        let i, glyph, width, spacingLength;\n                        if (isTextInvisible || fontSize === 0) {\n                            return;\n                        }\n                        this._cachedScaleForStroking[0] = -1;\n                        this._cachedGetSinglePixelWidth = null;\n                        ctx.save();\n                        ctx.transform(...current.textMatrix);\n                        ctx.translate(current.x, current.y);\n                        ctx.scale(textHScale, fontDirection);\n                        for(i = 0; i < glyphsLength; ++i){\n                            glyph = glyphs[i];\n                            if (typeof glyph === \"number\") {\n                                spacingLength = spacingDir * glyph * fontSize / 1000;\n                                this.ctx.translate(spacingLength, 0);\n                                current.x += spacingLength * textHScale;\n                                continue;\n                            }\n                            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n                            const operatorList = font.charProcOperatorList[glyph.operatorListId];\n                            if (!operatorList) {\n                                (0, _util.warn)(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n                                continue;\n                            }\n                            if (this.contentVisible) {\n                                this.processingType3 = glyph;\n                                this.save();\n                                ctx.scale(fontSize, fontSize);\n                                ctx.transform(...fontMatrix);\n                                this.executeOperatorList(operatorList);\n                                this.restore();\n                            }\n                            const transformed = _util.Util.applyTransform([\n                                glyph.width,\n                                0\n                            ], fontMatrix);\n                            width = transformed[0] * fontSize + spacing;\n                            ctx.translate(width, 0);\n                            current.x += width * textHScale;\n                        }\n                        ctx.restore();\n                        this.processingType3 = null;\n                    }\n                    setCharWidth(xWidth, yWidth) {}\n                    setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n                        this.ctx.rect(llx, lly, urx - llx, ury - lly);\n                        this.ctx.clip();\n                        this.endPath();\n                    }\n                    getColorN_Pattern(IR) {\n                        let pattern;\n                        if (IR[0] === \"TilingPattern\") {\n                            const color = IR[1];\n                            const baseTransform = this.baseTransform || (0, _display_utils.getCurrentTransform)(this.ctx);\n                            const canvasGraphicsFactory = {\n                                createCanvasGraphics: (ctx)=>{\n                                    return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n                                        optionalContentConfig: this.optionalContentConfig,\n                                        markedContentStack: this.markedContentStack\n                                    });\n                                }\n                            };\n                            pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n                        } else {\n                            pattern = this._getPattern(IR[1], IR[2]);\n                        }\n                        return pattern;\n                    }\n                    setStrokeColorN() {\n                        this.current.strokeColor = this.getColorN_Pattern(arguments);\n                    }\n                    setFillColorN() {\n                        this.current.fillColor = this.getColorN_Pattern(arguments);\n                        this.current.patternFill = true;\n                    }\n                    setStrokeRGBColor(r, g, b) {\n                        const color = _util.Util.makeHexColor(r, g, b);\n                        this.ctx.strokeStyle = color;\n                        this.current.strokeColor = color;\n                    }\n                    setFillRGBColor(r, g, b) {\n                        const color = _util.Util.makeHexColor(r, g, b);\n                        this.ctx.fillStyle = color;\n                        this.current.fillColor = color;\n                        this.current.patternFill = false;\n                    }\n                    _getPattern(objId, matrix = null) {\n                        let pattern;\n                        if (this.cachedPatterns.has(objId)) {\n                            pattern = this.cachedPatterns.get(objId);\n                        } else {\n                            pattern = (0, _pattern_helper.getShadingPattern)(this.getObject(objId));\n                            this.cachedPatterns.set(objId, pattern);\n                        }\n                        if (matrix) {\n                            pattern.matrix = matrix;\n                        }\n                        return pattern;\n                    }\n                    shadingFill(objId) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const ctx = this.ctx;\n                        this.save();\n                        const pattern = this._getPattern(objId);\n                        ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);\n                        const inv = (0, _display_utils.getCurrentTransformInverse)(ctx);\n                        if (inv) {\n                            const { width, height } = ctx.canvas;\n                            const [x0, y0, x1, y1] = _util.Util.getAxialAlignedBoundingBox([\n                                0,\n                                0,\n                                width,\n                                height\n                            ], inv);\n                            this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n                        } else {\n                            this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n                        }\n                        this.compose(this.current.getClippedPathBoundingBox());\n                        this.restore();\n                    }\n                    beginInlineImage() {\n                        (0, _util.unreachable)(\"Should not call beginInlineImage\");\n                    }\n                    beginImageData() {\n                        (0, _util.unreachable)(\"Should not call beginImageData\");\n                    }\n                    paintFormXObjectBegin(matrix, bbox) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        this.save();\n                        this.baseTransformStack.push(this.baseTransform);\n                        if (Array.isArray(matrix) && matrix.length === 6) {\n                            this.transform(...matrix);\n                        }\n                        this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);\n                        if (bbox) {\n                            const width = bbox[2] - bbox[0];\n                            const height = bbox[3] - bbox[1];\n                            this.ctx.rect(bbox[0], bbox[1], width, height);\n                            this.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(this.ctx), bbox);\n                            this.clip();\n                            this.endPath();\n                        }\n                    }\n                    paintFormXObjectEnd() {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        this.restore();\n                        this.baseTransform = this.baseTransformStack.pop();\n                    }\n                    beginGroup(group) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        this.save();\n                        if (this.inSMaskMode) {\n                            this.endSMaskMode();\n                            this.current.activeSMask = null;\n                        }\n                        const currentCtx = this.ctx;\n                        if (!group.isolated) {\n                            (0, _util.info)(\"TODO: Support non-isolated groups.\");\n                        }\n                        if (group.knockout) {\n                            (0, _util.warn)(\"Knockout groups not supported.\");\n                        }\n                        const currentTransform = (0, _display_utils.getCurrentTransform)(currentCtx);\n                        if (group.matrix) {\n                            currentCtx.transform(...group.matrix);\n                        }\n                        if (!group.bbox) {\n                            throw new Error(\"Bounding box is required.\");\n                        }\n                        let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils.getCurrentTransform)(currentCtx));\n                        const canvasBounds = [\n                            0,\n                            0,\n                            currentCtx.canvas.width,\n                            currentCtx.canvas.height\n                        ];\n                        bounds = _util.Util.intersect(bounds, canvasBounds) || [\n                            0,\n                            0,\n                            0,\n                            0\n                        ];\n                        const offsetX = Math.floor(bounds[0]);\n                        const offsetY = Math.floor(bounds[1]);\n                        let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n                        let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n                        let scaleX = 1, scaleY = 1;\n                        if (drawnWidth > MAX_GROUP_SIZE) {\n                            scaleX = drawnWidth / MAX_GROUP_SIZE;\n                            drawnWidth = MAX_GROUP_SIZE;\n                        }\n                        if (drawnHeight > MAX_GROUP_SIZE) {\n                            scaleY = drawnHeight / MAX_GROUP_SIZE;\n                            drawnHeight = MAX_GROUP_SIZE;\n                        }\n                        this.current.startNewPathAndClipBox([\n                            0,\n                            0,\n                            drawnWidth,\n                            drawnHeight\n                        ]);\n                        let cacheId = \"groupAt\" + this.groupLevel;\n                        if (group.smask) {\n                            cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n                        }\n                        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n                        const groupCtx = scratchCanvas.context;\n                        groupCtx.scale(1 / scaleX, 1 / scaleY);\n                        groupCtx.translate(-offsetX, -offsetY);\n                        groupCtx.transform(...currentTransform);\n                        if (group.smask) {\n                            this.smaskStack.push({\n                                canvas: scratchCanvas.canvas,\n                                context: groupCtx,\n                                offsetX,\n                                offsetY,\n                                scaleX,\n                                scaleY,\n                                subtype: group.smask.subtype,\n                                backdrop: group.smask.backdrop,\n                                transferMap: group.smask.transferMap || null,\n                                startTransformInverse: null\n                            });\n                        } else {\n                            currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n                            currentCtx.translate(offsetX, offsetY);\n                            currentCtx.scale(scaleX, scaleY);\n                            currentCtx.save();\n                        }\n                        copyCtxState(currentCtx, groupCtx);\n                        this.ctx = groupCtx;\n                        this.setGState([\n                            [\n                                \"BM\",\n                                \"source-over\"\n                            ],\n                            [\n                                \"ca\",\n                                1\n                            ],\n                            [\n                                \"CA\",\n                                1\n                            ]\n                        ]);\n                        this.groupStack.push(currentCtx);\n                        this.groupLevel++;\n                    }\n                    endGroup(group) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        this.groupLevel--;\n                        const groupCtx = this.ctx;\n                        const ctx = this.groupStack.pop();\n                        this.ctx = ctx;\n                        this.ctx.imageSmoothingEnabled = false;\n                        if (group.smask) {\n                            this.tempSMask = this.smaskStack.pop();\n                            this.restore();\n                        } else {\n                            this.ctx.restore();\n                            const currentMtx = (0, _display_utils.getCurrentTransform)(this.ctx);\n                            this.restore();\n                            this.ctx.save();\n                            this.ctx.setTransform(...currentMtx);\n                            const dirtyBox = _util.Util.getAxialAlignedBoundingBox([\n                                0,\n                                0,\n                                groupCtx.canvas.width,\n                                groupCtx.canvas.height\n                            ], currentMtx);\n                            this.ctx.drawImage(groupCtx.canvas, 0, 0);\n                            this.ctx.restore();\n                            this.compose(dirtyBox);\n                        }\n                    }\n                    beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {\n                        this.#restoreInitialState();\n                        resetCtxToDefault(this.ctx);\n                        this.ctx.save();\n                        this.save();\n                        if (this.baseTransform) {\n                            this.ctx.setTransform(...this.baseTransform);\n                        }\n                        if (Array.isArray(rect) && rect.length === 4) {\n                            const width = rect[2] - rect[0];\n                            const height = rect[3] - rect[1];\n                            if (hasOwnCanvas && this.annotationCanvasMap) {\n                                transform = transform.slice();\n                                transform[4] -= rect[0];\n                                transform[5] -= rect[1];\n                                rect = rect.slice();\n                                rect[0] = rect[1] = 0;\n                                rect[2] = width;\n                                rect[3] = height;\n                                const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(this.ctx));\n                                const { viewportScale } = this;\n                                const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n                                const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n                                this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n                                const { canvas, context } = this.annotationCanvas;\n                                this.annotationCanvasMap.set(id, canvas);\n                                this.annotationCanvas.savedCtx = this.ctx;\n                                this.ctx = context;\n                                this.ctx.save();\n                                this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);\n                                resetCtxToDefault(this.ctx);\n                            } else {\n                                resetCtxToDefault(this.ctx);\n                                this.ctx.rect(rect[0], rect[1], width, height);\n                                this.ctx.clip();\n                                this.endPath();\n                            }\n                        }\n                        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n                        this.transform(...transform);\n                        this.transform(...matrix);\n                    }\n                    endAnnotation() {\n                        if (this.annotationCanvas) {\n                            this.ctx.restore();\n                            this.#drawFilter();\n                            this.ctx = this.annotationCanvas.savedCtx;\n                            delete this.annotationCanvas.savedCtx;\n                            delete this.annotationCanvas;\n                        }\n                    }\n                    paintImageMaskXObject(img) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const count = img.count;\n                        img = this.getObject(img.data, img);\n                        img.count = count;\n                        const ctx = this.ctx;\n                        const glyph = this.processingType3;\n                        if (glyph) {\n                            if (glyph.compiled === undefined) {\n                                glyph.compiled = compileType3Glyph(img);\n                            }\n                            if (glyph.compiled) {\n                                glyph.compiled(ctx);\n                                return;\n                            }\n                        }\n                        const mask = this._createMaskCanvas(img);\n                        const maskCanvas = mask.canvas;\n                        ctx.save();\n                        ctx.setTransform(1, 0, 0, 1, 0, 0);\n                        ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n                        ctx.restore();\n                        this.compose();\n                    }\n                    paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        img = this.getObject(img.data, img);\n                        const ctx = this.ctx;\n                        ctx.save();\n                        const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n                        ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n                        const mask = this._createMaskCanvas(img);\n                        ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);\n                        for(let i = 0, ii = positions.length; i < ii; i += 2){\n                            const trans = _util.Util.transform(currentTransform, [\n                                scaleX,\n                                skewX,\n                                skewY,\n                                scaleY,\n                                positions[i],\n                                positions[i + 1]\n                            ]);\n                            const [x, y] = _util.Util.applyTransform([\n                                0,\n                                0\n                            ], trans);\n                            ctx.drawImage(mask.canvas, x, y);\n                        }\n                        ctx.restore();\n                        this.compose();\n                    }\n                    paintImageMaskXObjectGroup(images) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const ctx = this.ctx;\n                        const fillColor = this.current.fillColor;\n                        const isPatternFill = this.current.patternFill;\n                        for (const image of images){\n                            const { data, width, height, transform } = image;\n                            const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n                            const maskCtx = maskCanvas.context;\n                            maskCtx.save();\n                            const img = this.getObject(data, image);\n                            putBinaryImageMask(maskCtx, img);\n                            maskCtx.globalCompositeOperation = \"source-in\";\n                            maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;\n                            maskCtx.fillRect(0, 0, width, height);\n                            maskCtx.restore();\n                            ctx.save();\n                            ctx.transform(...transform);\n                            ctx.scale(1, -1);\n                            drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n                            ctx.restore();\n                        }\n                        this.compose();\n                    }\n                    paintImageXObject(objId) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const imgData = this.getObject(objId);\n                        if (!imgData) {\n                            (0, _util.warn)(\"Dependent image isn't ready yet\");\n                            return;\n                        }\n                        this.paintInlineImageXObject(imgData);\n                    }\n                    paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const imgData = this.getObject(objId);\n                        if (!imgData) {\n                            (0, _util.warn)(\"Dependent image isn't ready yet\");\n                            return;\n                        }\n                        const width = imgData.width;\n                        const height = imgData.height;\n                        const map = [];\n                        for(let i = 0, ii = positions.length; i < ii; i += 2){\n                            map.push({\n                                transform: [\n                                    scaleX,\n                                    0,\n                                    0,\n                                    scaleY,\n                                    positions[i],\n                                    positions[i + 1]\n                                ],\n                                x: 0,\n                                y: 0,\n                                w: width,\n                                h: height\n                            });\n                        }\n                        this.paintInlineImageXObjectGroup(imgData, map);\n                    }\n                    applyTransferMapsToCanvas(ctx) {\n                        if (this.current.transferMaps !== \"none\") {\n                            ctx.filter = this.current.transferMaps;\n                            ctx.drawImage(ctx.canvas, 0, 0);\n                            ctx.filter = \"none\";\n                        }\n                        return ctx.canvas;\n                    }\n                    applyTransferMapsToBitmap(imgData) {\n                        if (this.current.transferMaps === \"none\") {\n                            return imgData.bitmap;\n                        }\n                        const { bitmap, width, height } = imgData;\n                        const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n                        const tmpCtx = tmpCanvas.context;\n                        tmpCtx.filter = this.current.transferMaps;\n                        tmpCtx.drawImage(bitmap, 0, 0);\n                        tmpCtx.filter = \"none\";\n                        return tmpCanvas.canvas;\n                    }\n                    paintInlineImageXObject(imgData) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const width = imgData.width;\n                        const height = imgData.height;\n                        const ctx = this.ctx;\n                        this.save();\n                        if (!_util.isNodeJS) {\n                            const { filter } = ctx;\n                            if (filter !== \"none\" && filter !== \"\") {\n                                ctx.filter = \"none\";\n                            }\n                        }\n                        ctx.scale(1 / width, -1 / height);\n                        let imgToPaint;\n                        if (imgData.bitmap) {\n                            imgToPaint = this.applyTransferMapsToBitmap(imgData);\n                        } else if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n                            imgToPaint = imgData;\n                        } else {\n                            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n                            const tmpCtx = tmpCanvas.context;\n                            putBinaryImageData(tmpCtx, imgData);\n                            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n                        }\n                        const scaled = this._scaleImage(imgToPaint, (0, _display_utils.getCurrentTransformInverse)(ctx));\n                        ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(ctx), imgData.interpolate);\n                        drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n                        this.compose();\n                        this.restore();\n                    }\n                    paintInlineImageXObjectGroup(imgData, map) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const ctx = this.ctx;\n                        let imgToPaint;\n                        if (imgData.bitmap) {\n                            imgToPaint = imgData.bitmap;\n                        } else {\n                            const w = imgData.width;\n                            const h = imgData.height;\n                            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n                            const tmpCtx = tmpCanvas.context;\n                            putBinaryImageData(tmpCtx, imgData);\n                            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n                        }\n                        for (const entry of map){\n                            ctx.save();\n                            ctx.transform(...entry.transform);\n                            ctx.scale(1, -1);\n                            drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n                            ctx.restore();\n                        }\n                        this.compose();\n                    }\n                    paintSolidColorImageMask() {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        this.ctx.fillRect(0, 0, 1, 1);\n                        this.compose();\n                    }\n                    markPoint(tag) {}\n                    markPointProps(tag, properties) {}\n                    beginMarkedContent(tag) {\n                        this.markedContentStack.push({\n                            visible: true\n                        });\n                    }\n                    beginMarkedContentProps(tag, properties) {\n                        if (tag === \"OC\") {\n                            this.markedContentStack.push({\n                                visible: this.optionalContentConfig.isVisible(properties)\n                            });\n                        } else {\n                            this.markedContentStack.push({\n                                visible: true\n                            });\n                        }\n                        this.contentVisible = this.isContentVisible();\n                    }\n                    endMarkedContent() {\n                        this.markedContentStack.pop();\n                        this.contentVisible = this.isContentVisible();\n                    }\n                    beginCompat() {}\n                    endCompat() {}\n                    consumePath(clipBox) {\n                        const isEmpty = this.current.isEmptyClip();\n                        if (this.pendingClip) {\n                            this.current.updateClipFromPath();\n                        }\n                        if (!this.pendingClip) {\n                            this.compose(clipBox);\n                        }\n                        const ctx = this.ctx;\n                        if (this.pendingClip) {\n                            if (!isEmpty) {\n                                if (this.pendingClip === EO_CLIP) {\n                                    ctx.clip(\"evenodd\");\n                                } else {\n                                    ctx.clip();\n                                }\n                            }\n                            this.pendingClip = null;\n                        }\n                        this.current.startNewPathAndClipBox(this.current.clipBox);\n                        ctx.beginPath();\n                    }\n                    getSinglePixelWidth() {\n                        if (!this._cachedGetSinglePixelWidth) {\n                            const m = (0, _display_utils.getCurrentTransform)(this.ctx);\n                            if (m[1] === 0 && m[2] === 0) {\n                                this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n                            } else {\n                                const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n                                const normX = Math.hypot(m[0], m[2]);\n                                const normY = Math.hypot(m[1], m[3]);\n                                this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n                            }\n                        }\n                        return this._cachedGetSinglePixelWidth;\n                    }\n                    getScaleForStroking() {\n                        if (this._cachedScaleForStroking[0] === -1) {\n                            const { lineWidth } = this.current;\n                            const { a, b, c, d } = this.ctx.getTransform();\n                            let scaleX, scaleY;\n                            if (b === 0 && c === 0) {\n                                const normX = Math.abs(a);\n                                const normY = Math.abs(d);\n                                if (normX === normY) {\n                                    if (lineWidth === 0) {\n                                        scaleX = scaleY = 1 / normX;\n                                    } else {\n                                        const scaledLineWidth = normX * lineWidth;\n                                        scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;\n                                    }\n                                } else if (lineWidth === 0) {\n                                    scaleX = 1 / normX;\n                                    scaleY = 1 / normY;\n                                } else {\n                                    const scaledXLineWidth = normX * lineWidth;\n                                    const scaledYLineWidth = normY * lineWidth;\n                                    scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n                                    scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n                                }\n                            } else {\n                                const absDet = Math.abs(a * d - b * c);\n                                const normX = Math.hypot(a, b);\n                                const normY = Math.hypot(c, d);\n                                if (lineWidth === 0) {\n                                    scaleX = normY / absDet;\n                                    scaleY = normX / absDet;\n                                } else {\n                                    const baseArea = lineWidth * absDet;\n                                    scaleX = normY > baseArea ? normY / baseArea : 1;\n                                    scaleY = normX > baseArea ? normX / baseArea : 1;\n                                }\n                            }\n                            this._cachedScaleForStroking[0] = scaleX;\n                            this._cachedScaleForStroking[1] = scaleY;\n                        }\n                        return this._cachedScaleForStroking;\n                    }\n                    rescaleAndStroke(saveRestore) {\n                        const { ctx } = this;\n                        const { lineWidth } = this.current;\n                        const [scaleX, scaleY] = this.getScaleForStroking();\n                        ctx.lineWidth = lineWidth || 1;\n                        if (scaleX === 1 && scaleY === 1) {\n                            ctx.stroke();\n                            return;\n                        }\n                        const dashes = ctx.getLineDash();\n                        if (saveRestore) {\n                            ctx.save();\n                        }\n                        ctx.scale(scaleX, scaleY);\n                        if (dashes.length > 0) {\n                            const scale = Math.max(scaleX, scaleY);\n                            ctx.setLineDash(dashes.map((x)=>x / scale));\n                            ctx.lineDashOffset /= scale;\n                        }\n                        ctx.stroke();\n                        if (saveRestore) {\n                            ctx.restore();\n                        }\n                    }\n                    isContentVisible() {\n                        for(let i = this.markedContentStack.length - 1; i >= 0; i--){\n                            if (!this.markedContentStack[i].visible) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    }\n                }\n                exports1.CanvasGraphics = CanvasGraphics;\n                for(const op in _util.OPS){\n                    if (CanvasGraphics.prototype[op] !== undefined) {\n                        CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];\n                    }\n                }\n            /***/ },\n            /* 12 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.TilingPattern = exports1.PathType = void 0;\n                exports1.getShadingPattern = getShadingPattern;\n                var _util = __w_pdfjs_require__(1);\n                var _display_utils = __w_pdfjs_require__(6);\n                const PathType = {\n                    FILL: \"Fill\",\n                    STROKE: \"Stroke\",\n                    SHADING: \"Shading\"\n                };\n                exports1.PathType = PathType;\n                function applyBoundingBox(ctx, bbox) {\n                    if (!bbox) {\n                        return;\n                    }\n                    const width = bbox[2] - bbox[0];\n                    const height = bbox[3] - bbox[1];\n                    const region = new Path2D();\n                    region.rect(bbox[0], bbox[1], width, height);\n                    ctx.clip(region);\n                }\n                class BaseShadingPattern {\n                    constructor(){\n                        if (this.constructor === BaseShadingPattern) {\n                            (0, _util.unreachable)(\"Cannot initialize BaseShadingPattern.\");\n                        }\n                    }\n                    getPattern() {\n                        (0, _util.unreachable)(\"Abstract method `getPattern` called.\");\n                    }\n                }\n                class RadialAxialShadingPattern extends BaseShadingPattern {\n                    constructor(IR){\n                        super();\n                        this._type = IR[1];\n                        this._bbox = IR[2];\n                        this._colorStops = IR[3];\n                        this._p0 = IR[4];\n                        this._p1 = IR[5];\n                        this._r0 = IR[6];\n                        this._r1 = IR[7];\n                        this.matrix = null;\n                    }\n                    _createGradient(ctx) {\n                        let grad;\n                        if (this._type === \"axial\") {\n                            grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n                        } else if (this._type === \"radial\") {\n                            grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n                        }\n                        for (const colorStop of this._colorStops){\n                            grad.addColorStop(colorStop[0], colorStop[1]);\n                        }\n                        return grad;\n                    }\n                    getPattern(ctx, owner, inverse, pathType) {\n                        let pattern;\n                        if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n                            const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils.getCurrentTransform)(ctx)) || [\n                                0,\n                                0,\n                                0,\n                                0\n                            ];\n                            const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n                            const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n                            const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height, true);\n                            const tmpCtx = tmpCanvas.context;\n                            tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n                            tmpCtx.beginPath();\n                            tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n                            tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n                            inverse = _util.Util.transform(inverse, [\n                                1,\n                                0,\n                                0,\n                                1,\n                                ownerBBox[0],\n                                ownerBBox[1]\n                            ]);\n                            tmpCtx.transform(...owner.baseTransform);\n                            if (this.matrix) {\n                                tmpCtx.transform(...this.matrix);\n                            }\n                            applyBoundingBox(tmpCtx, this._bbox);\n                            tmpCtx.fillStyle = this._createGradient(tmpCtx);\n                            tmpCtx.fill();\n                            pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n                            const domMatrix = new DOMMatrix(inverse);\n                            pattern.setTransform(domMatrix);\n                        } else {\n                            applyBoundingBox(ctx, this._bbox);\n                            pattern = this._createGradient(ctx);\n                        }\n                        return pattern;\n                    }\n                }\n                function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n                    const coords = context.coords, colors = context.colors;\n                    const bytes = data.data, rowSize = data.width * 4;\n                    let tmp;\n                    if (coords[p1 + 1] > coords[p2 + 1]) {\n                        tmp = p1;\n                        p1 = p2;\n                        p2 = tmp;\n                        tmp = c1;\n                        c1 = c2;\n                        c2 = tmp;\n                    }\n                    if (coords[p2 + 1] > coords[p3 + 1]) {\n                        tmp = p2;\n                        p2 = p3;\n                        p3 = tmp;\n                        tmp = c2;\n                        c2 = c3;\n                        c3 = tmp;\n                    }\n                    if (coords[p1 + 1] > coords[p2 + 1]) {\n                        tmp = p1;\n                        p1 = p2;\n                        p2 = tmp;\n                        tmp = c1;\n                        c1 = c2;\n                        c2 = tmp;\n                    }\n                    const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n                    const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n                    const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n                    const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n                    const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n                    const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n                    if (y1 >= y3) {\n                        return;\n                    }\n                    const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];\n                    const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];\n                    const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];\n                    const minY = Math.round(y1), maxY = Math.round(y3);\n                    let xa, car, cag, cab;\n                    let xb, cbr, cbg, cbb;\n                    for(let y = minY; y <= maxY; y++){\n                        if (y < y2) {\n                            const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);\n                            xa = x1 - (x1 - x2) * k;\n                            car = c1r - (c1r - c2r) * k;\n                            cag = c1g - (c1g - c2g) * k;\n                            cab = c1b - (c1b - c2b) * k;\n                        } else {\n                            let k;\n                            if (y > y3) {\n                                k = 1;\n                            } else if (y2 === y3) {\n                                k = 0;\n                            } else {\n                                k = (y2 - y) / (y2 - y3);\n                            }\n                            xa = x2 - (x2 - x3) * k;\n                            car = c2r - (c2r - c3r) * k;\n                            cag = c2g - (c2g - c3g) * k;\n                            cab = c2b - (c2b - c3b) * k;\n                        }\n                        let k;\n                        if (y < y1) {\n                            k = 0;\n                        } else if (y > y3) {\n                            k = 1;\n                        } else {\n                            k = (y1 - y) / (y1 - y3);\n                        }\n                        xb = x1 - (x1 - x3) * k;\n                        cbr = c1r - (c1r - c3r) * k;\n                        cbg = c1g - (c1g - c3g) * k;\n                        cbb = c1b - (c1b - c3b) * k;\n                        const x1_ = Math.round(Math.min(xa, xb));\n                        const x2_ = Math.round(Math.max(xa, xb));\n                        let j = rowSize * y + x1_ * 4;\n                        for(let x = x1_; x <= x2_; x++){\n                            k = (xa - x) / (xa - xb);\n                            if (k < 0) {\n                                k = 0;\n                            } else if (k > 1) {\n                                k = 1;\n                            }\n                            bytes[j++] = car - (car - cbr) * k | 0;\n                            bytes[j++] = cag - (cag - cbg) * k | 0;\n                            bytes[j++] = cab - (cab - cbb) * k | 0;\n                            bytes[j++] = 255;\n                        }\n                    }\n                }\n                function drawFigure(data, figure, context) {\n                    const ps = figure.coords;\n                    const cs = figure.colors;\n                    let i, ii;\n                    switch(figure.type){\n                        case \"lattice\":\n                            const verticesPerRow = figure.verticesPerRow;\n                            const rows = Math.floor(ps.length / verticesPerRow) - 1;\n                            const cols = verticesPerRow - 1;\n                            for(i = 0; i < rows; i++){\n                                let q = i * verticesPerRow;\n                                for(let j = 0; j < cols; j++, q++){\n                                    drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n                                    drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n                                }\n                            }\n                            break;\n                        case \"triangles\":\n                            for(i = 0, ii = ps.length; i < ii; i += 3){\n                                drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n                            }\n                            break;\n                        default:\n                            throw new Error(\"illegal figure\");\n                    }\n                }\n                class MeshShadingPattern extends BaseShadingPattern {\n                    constructor(IR){\n                        super();\n                        this._coords = IR[2];\n                        this._colors = IR[3];\n                        this._figures = IR[4];\n                        this._bounds = IR[5];\n                        this._bbox = IR[7];\n                        this._background = IR[8];\n                        this.matrix = null;\n                    }\n                    _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n                        const EXPECTED_SCALE = 1.1;\n                        const MAX_PATTERN_SIZE = 3000;\n                        const BORDER_SIZE = 2;\n                        const offsetX = Math.floor(this._bounds[0]);\n                        const offsetY = Math.floor(this._bounds[1]);\n                        const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n                        const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n                        const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n                        const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n                        const scaleX = boundsWidth / width;\n                        const scaleY = boundsHeight / height;\n                        const context = {\n                            coords: this._coords,\n                            colors: this._colors,\n                            offsetX: -offsetX,\n                            offsetY: -offsetY,\n                            scaleX: 1 / scaleX,\n                            scaleY: 1 / scaleY\n                        };\n                        const paddedWidth = width + BORDER_SIZE * 2;\n                        const paddedHeight = height + BORDER_SIZE * 2;\n                        const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\n                        const tmpCtx = tmpCanvas.context;\n                        const data = tmpCtx.createImageData(width, height);\n                        if (backgroundColor) {\n                            const bytes = data.data;\n                            for(let i = 0, ii = bytes.length; i < ii; i += 4){\n                                bytes[i] = backgroundColor[0];\n                                bytes[i + 1] = backgroundColor[1];\n                                bytes[i + 2] = backgroundColor[2];\n                                bytes[i + 3] = 255;\n                            }\n                        }\n                        for (const figure of this._figures){\n                            drawFigure(data, figure, context);\n                        }\n                        tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n                        const canvas = tmpCanvas.canvas;\n                        return {\n                            canvas,\n                            offsetX: offsetX - BORDER_SIZE * scaleX,\n                            offsetY: offsetY - BORDER_SIZE * scaleY,\n                            scaleX,\n                            scaleY\n                        };\n                    }\n                    getPattern(ctx, owner, inverse, pathType) {\n                        applyBoundingBox(ctx, this._bbox);\n                        let scale;\n                        if (pathType === PathType.SHADING) {\n                            scale = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(ctx));\n                        } else {\n                            scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);\n                            if (this.matrix) {\n                                const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n                                scale = [\n                                    scale[0] * matrixScale[0],\n                                    scale[1] * matrixScale[1]\n                                ];\n                            }\n                        }\n                        const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n                        if (pathType !== PathType.SHADING) {\n                            ctx.setTransform(...owner.baseTransform);\n                            if (this.matrix) {\n                                ctx.transform(...this.matrix);\n                            }\n                        }\n                        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n                        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n                        return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n                    }\n                }\n                class DummyShadingPattern extends BaseShadingPattern {\n                    getPattern() {\n                        return \"hotpink\";\n                    }\n                }\n                function getShadingPattern(IR) {\n                    switch(IR[0]){\n                        case \"RadialAxial\":\n                            return new RadialAxialShadingPattern(IR);\n                        case \"Mesh\":\n                            return new MeshShadingPattern(IR);\n                        case \"Dummy\":\n                            return new DummyShadingPattern();\n                    }\n                    throw new Error(`Unknown IR type: ${IR[0]}`);\n                }\n                const PaintType = {\n                    COLORED: 1,\n                    UNCOLORED: 2\n                };\n                class TilingPattern {\n                    static{\n                        this.MAX_PATTERN_SIZE = 3000;\n                    }\n                    constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform){\n                        this.operatorList = IR[2];\n                        this.matrix = IR[3] || [\n                            1,\n                            0,\n                            0,\n                            1,\n                            0,\n                            0\n                        ];\n                        this.bbox = IR[4];\n                        this.xstep = IR[5];\n                        this.ystep = IR[6];\n                        this.paintType = IR[7];\n                        this.tilingType = IR[8];\n                        this.color = color;\n                        this.ctx = ctx;\n                        this.canvasGraphicsFactory = canvasGraphicsFactory;\n                        this.baseTransform = baseTransform;\n                    }\n                    createPatternCanvas(owner) {\n                        const operatorList = this.operatorList;\n                        const bbox = this.bbox;\n                        const xstep = this.xstep;\n                        const ystep = this.ystep;\n                        const paintType = this.paintType;\n                        const tilingType = this.tilingType;\n                        const color = this.color;\n                        const canvasGraphicsFactory = this.canvasGraphicsFactory;\n                        (0, _util.info)(\"TilingType: \" + tilingType);\n                        const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];\n                        const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n                        const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);\n                        const combinedScale = [\n                            matrixScale[0] * curMatrixScale[0],\n                            matrixScale[1] * curMatrixScale[1]\n                        ];\n                        const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);\n                        const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);\n                        const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size, true);\n                        const tmpCtx = tmpCanvas.context;\n                        const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n                        graphics.groupLevel = owner.groupLevel;\n                        this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n                        let adjustedX0 = x0;\n                        let adjustedY0 = y0;\n                        let adjustedX1 = x1;\n                        let adjustedY1 = y1;\n                        if (x0 < 0) {\n                            adjustedX0 = 0;\n                            adjustedX1 += Math.abs(x0);\n                        }\n                        if (y0 < 0) {\n                            adjustedY0 = 0;\n                            adjustedY1 += Math.abs(y0);\n                        }\n                        tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));\n                        graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n                        tmpCtx.save();\n                        this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);\n                        graphics.baseTransform = (0, _display_utils.getCurrentTransform)(graphics.ctx);\n                        graphics.executeOperatorList(operatorList);\n                        graphics.endDrawing();\n                        return {\n                            canvas: tmpCanvas.canvas,\n                            scaleX: dimx.scale,\n                            scaleY: dimy.scale,\n                            offsetX: adjustedX0,\n                            offsetY: adjustedY0\n                        };\n                    }\n                    getSizeAndScale(step, realOutputSize, scale) {\n                        step = Math.abs(step);\n                        const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n                        let size = Math.ceil(step * scale);\n                        if (size >= maxSize) {\n                            size = maxSize;\n                        } else {\n                            scale = size / step;\n                        }\n                        return {\n                            scale,\n                            size\n                        };\n                    }\n                    clipBbox(graphics, x0, y0, x1, y1) {\n                        const bboxWidth = x1 - x0;\n                        const bboxHeight = y1 - y0;\n                        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n                        graphics.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(graphics.ctx), [\n                            x0,\n                            y0,\n                            x1,\n                            y1\n                        ]);\n                        graphics.clip();\n                        graphics.endPath();\n                    }\n                    setFillAndStrokeStyleToContext(graphics, paintType, color) {\n                        const context = graphics.ctx, current = graphics.current;\n                        switch(paintType){\n                            case PaintType.COLORED:\n                                const ctx = this.ctx;\n                                context.fillStyle = ctx.fillStyle;\n                                context.strokeStyle = ctx.strokeStyle;\n                                current.fillColor = ctx.fillStyle;\n                                current.strokeColor = ctx.strokeStyle;\n                                break;\n                            case PaintType.UNCOLORED:\n                                const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);\n                                context.fillStyle = cssColor;\n                                context.strokeStyle = cssColor;\n                                current.fillColor = cssColor;\n                                current.strokeColor = cssColor;\n                                break;\n                            default:\n                                throw new _util.FormatError(`Unsupported paint type: ${paintType}`);\n                        }\n                    }\n                    getPattern(ctx, owner, inverse, pathType) {\n                        let matrix = inverse;\n                        if (pathType !== PathType.SHADING) {\n                            matrix = _util.Util.transform(matrix, owner.baseTransform);\n                            if (this.matrix) {\n                                matrix = _util.Util.transform(matrix, this.matrix);\n                            }\n                        }\n                        const temporaryPatternCanvas = this.createPatternCanvas(owner);\n                        let domMatrix = new DOMMatrix(matrix);\n                        domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n                        domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n                        const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n                        pattern.setTransform(domMatrix);\n                        return pattern;\n                    }\n                }\n                exports1.TilingPattern = TilingPattern;\n            /***/ },\n            /* 13 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.convertBlackAndWhiteToRGBA = convertBlackAndWhiteToRGBA;\n                exports1.convertToRGBA = convertToRGBA;\n                exports1.grayToRGBA = grayToRGBA;\n                var _util = __w_pdfjs_require__(1);\n                function convertToRGBA(params) {\n                    switch(params.kind){\n                        case _util.ImageKind.GRAYSCALE_1BPP:\n                            return convertBlackAndWhiteToRGBA(params);\n                        case _util.ImageKind.RGB_24BPP:\n                            return convertRGBToRGBA(params);\n                    }\n                    return null;\n                }\n                function convertBlackAndWhiteToRGBA({ src, srcPos = 0, dest, width, height, nonBlackColor = 0xffffffff, inverseDecode = false }) {\n                    const black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n                    const [zeroMapping, oneMapping] = inverseDecode ? [\n                        nonBlackColor,\n                        black\n                    ] : [\n                        black,\n                        nonBlackColor\n                    ];\n                    const widthInSource = width >> 3;\n                    const widthRemainder = width & 7;\n                    const srcLength = src.length;\n                    dest = new Uint32Array(dest.buffer);\n                    let destPos = 0;\n                    for(let i = 0; i < height; i++){\n                        for(const max = srcPos + widthInSource; srcPos < max; srcPos++){\n                            const elem = srcPos < srcLength ? src[srcPos] : 255;\n                            dest[destPos++] = elem & 128 ? oneMapping : zeroMapping;\n                            dest[destPos++] = elem & 64 ? oneMapping : zeroMapping;\n                            dest[destPos++] = elem & 32 ? oneMapping : zeroMapping;\n                            dest[destPos++] = elem & 16 ? oneMapping : zeroMapping;\n                            dest[destPos++] = elem & 8 ? oneMapping : zeroMapping;\n                            dest[destPos++] = elem & 4 ? oneMapping : zeroMapping;\n                            dest[destPos++] = elem & 2 ? oneMapping : zeroMapping;\n                            dest[destPos++] = elem & 1 ? oneMapping : zeroMapping;\n                        }\n                        if (widthRemainder === 0) {\n                            continue;\n                        }\n                        const elem = srcPos < srcLength ? src[srcPos++] : 255;\n                        for(let j = 0; j < widthRemainder; j++){\n                            dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n                        }\n                    }\n                    return {\n                        srcPos,\n                        destPos\n                    };\n                }\n                function convertRGBToRGBA({ src, srcPos = 0, dest, destPos = 0, width, height }) {\n                    let i = 0;\n                    const len32 = src.length >> 2;\n                    const src32 = new Uint32Array(src.buffer, srcPos, len32);\n                    if (_util.FeatureTest.isLittleEndian) {\n                        for(; i < len32 - 2; i += 3, destPos += 4){\n                            const s1 = src32[i];\n                            const s2 = src32[i + 1];\n                            const s3 = src32[i + 2];\n                            dest[destPos] = s1 | 0xff000000;\n                            dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;\n                            dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;\n                            dest[destPos + 3] = s3 >>> 8 | 0xff000000;\n                        }\n                        for(let j = i * 4, jj = src.length; j < jj; j += 3){\n                            dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;\n                        }\n                    } else {\n                        for(; i < len32 - 2; i += 3, destPos += 4){\n                            const s1 = src32[i];\n                            const s2 = src32[i + 1];\n                            const s3 = src32[i + 2];\n                            dest[destPos] = s1 | 0xff;\n                            dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;\n                            dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;\n                            dest[destPos + 3] = s3 << 8 | 0xff;\n                        }\n                        for(let j = i * 4, jj = src.length; j < jj; j += 3){\n                            dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;\n                        }\n                    }\n                    return {\n                        srcPos,\n                        destPos\n                    };\n                }\n                function grayToRGBA(src, dest) {\n                    if (_util.FeatureTest.isLittleEndian) {\n                        for(let i = 0, ii = src.length; i < ii; i++){\n                            dest[i] = src[i] * 0x10101 | 0xff000000;\n                        }\n                    } else {\n                        for(let i = 0, ii = src.length; i < ii; i++){\n                            dest[i] = src[i] * 0x1010100 | 0x000000ff;\n                        }\n                    }\n                }\n            /***/ },\n            /* 14 */ /***/ (__unused_webpack_module, exports1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.GlobalWorkerOptions = void 0;\n                const GlobalWorkerOptions = Object.create(null);\n                exports1.GlobalWorkerOptions = GlobalWorkerOptions;\n                GlobalWorkerOptions.workerPort = null;\n                GlobalWorkerOptions.workerSrc = \"\";\n            /***/ },\n            /* 15 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.MessageHandler = void 0;\n                var _util = __w_pdfjs_require__(1);\n                const CallbackKind = {\n                    UNKNOWN: 0,\n                    DATA: 1,\n                    ERROR: 2\n                };\n                const StreamKind = {\n                    UNKNOWN: 0,\n                    CANCEL: 1,\n                    CANCEL_COMPLETE: 2,\n                    CLOSE: 3,\n                    ENQUEUE: 4,\n                    ERROR: 5,\n                    PULL: 6,\n                    PULL_COMPLETE: 7,\n                    START_COMPLETE: 8\n                };\n                function wrapReason(reason) {\n                    if (!(reason instanceof Error || typeof reason === \"object\" && reason !== null)) {\n                        (0, _util.unreachable)('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n                    }\n                    switch(reason.name){\n                        case \"AbortException\":\n                            return new _util.AbortException(reason.message);\n                        case \"MissingPDFException\":\n                            return new _util.MissingPDFException(reason.message);\n                        case \"PasswordException\":\n                            return new _util.PasswordException(reason.message, reason.code);\n                        case \"UnexpectedResponseException\":\n                            return new _util.UnexpectedResponseException(reason.message, reason.status);\n                        case \"UnknownErrorException\":\n                            return new _util.UnknownErrorException(reason.message, reason.details);\n                        default:\n                            return new _util.UnknownErrorException(reason.message, reason.toString());\n                    }\n                }\n                class MessageHandler {\n                    constructor(sourceName, targetName, comObj){\n                        this.sourceName = sourceName;\n                        this.targetName = targetName;\n                        this.comObj = comObj;\n                        this.callbackId = 1;\n                        this.streamId = 1;\n                        this.streamSinks = Object.create(null);\n                        this.streamControllers = Object.create(null);\n                        this.callbackCapabilities = Object.create(null);\n                        this.actionHandler = Object.create(null);\n                        this._onComObjOnMessage = (event)=>{\n                            const data = event.data;\n                            if (data.targetName !== this.sourceName) {\n                                return;\n                            }\n                            if (data.stream) {\n                                this.#processStreamMessage(data);\n                                return;\n                            }\n                            if (data.callback) {\n                                const callbackId = data.callbackId;\n                                const capability = this.callbackCapabilities[callbackId];\n                                if (!capability) {\n                                    throw new Error(`Cannot resolve callback ${callbackId}`);\n                                }\n                                delete this.callbackCapabilities[callbackId];\n                                if (data.callback === CallbackKind.DATA) {\n                                    capability.resolve(data.data);\n                                } else if (data.callback === CallbackKind.ERROR) {\n                                    capability.reject(wrapReason(data.reason));\n                                } else {\n                                    throw new Error(\"Unexpected callback case\");\n                                }\n                                return;\n                            }\n                            const action = this.actionHandler[data.action];\n                            if (!action) {\n                                throw new Error(`Unknown action from worker: ${data.action}`);\n                            }\n                            if (data.callbackId) {\n                                const cbSourceName = this.sourceName;\n                                const cbTargetName = data.sourceName;\n                                new Promise(function(resolve) {\n                                    resolve(action(data.data));\n                                }).then(function(result) {\n                                    comObj.postMessage({\n                                        sourceName: cbSourceName,\n                                        targetName: cbTargetName,\n                                        callback: CallbackKind.DATA,\n                                        callbackId: data.callbackId,\n                                        data: result\n                                    });\n                                }, function(reason) {\n                                    comObj.postMessage({\n                                        sourceName: cbSourceName,\n                                        targetName: cbTargetName,\n                                        callback: CallbackKind.ERROR,\n                                        callbackId: data.callbackId,\n                                        reason: wrapReason(reason)\n                                    });\n                                });\n                                return;\n                            }\n                            if (data.streamId) {\n                                this.#createStreamSink(data);\n                                return;\n                            }\n                            action(data.data);\n                        };\n                        comObj.addEventListener(\"message\", this._onComObjOnMessage);\n                    }\n                    on(actionName, handler) {\n                        const ah = this.actionHandler;\n                        if (ah[actionName]) {\n                            throw new Error(`There is already an actionName called \"${actionName}\"`);\n                        }\n                        ah[actionName] = handler;\n                    }\n                    send(actionName, data, transfers) {\n                        this.comObj.postMessage({\n                            sourceName: this.sourceName,\n                            targetName: this.targetName,\n                            action: actionName,\n                            data\n                        }, transfers);\n                    }\n                    sendWithPromise(actionName, data, transfers) {\n                        const callbackId = this.callbackId++;\n                        const capability = new _util.PromiseCapability();\n                        this.callbackCapabilities[callbackId] = capability;\n                        try {\n                            this.comObj.postMessage({\n                                sourceName: this.sourceName,\n                                targetName: this.targetName,\n                                action: actionName,\n                                callbackId,\n                                data\n                            }, transfers);\n                        } catch (ex) {\n                            capability.reject(ex);\n                        }\n                        return capability.promise;\n                    }\n                    sendWithStream(actionName, data, queueingStrategy, transfers) {\n                        const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;\n                        return new ReadableStream({\n                            start: (controller)=>{\n                                const startCapability = new _util.PromiseCapability();\n                                this.streamControllers[streamId] = {\n                                    controller,\n                                    startCall: startCapability,\n                                    pullCall: null,\n                                    cancelCall: null,\n                                    isClosed: false\n                                };\n                                comObj.postMessage({\n                                    sourceName,\n                                    targetName,\n                                    action: actionName,\n                                    streamId,\n                                    data,\n                                    desiredSize: controller.desiredSize\n                                }, transfers);\n                                return startCapability.promise;\n                            },\n                            pull: (controller)=>{\n                                const pullCapability = new _util.PromiseCapability();\n                                this.streamControllers[streamId].pullCall = pullCapability;\n                                comObj.postMessage({\n                                    sourceName,\n                                    targetName,\n                                    stream: StreamKind.PULL,\n                                    streamId,\n                                    desiredSize: controller.desiredSize\n                                });\n                                return pullCapability.promise;\n                            },\n                            cancel: (reason)=>{\n                                (0, _util.assert)(reason instanceof Error, \"cancel must have a valid reason\");\n                                const cancelCapability = new _util.PromiseCapability();\n                                this.streamControllers[streamId].cancelCall = cancelCapability;\n                                this.streamControllers[streamId].isClosed = true;\n                                comObj.postMessage({\n                                    sourceName,\n                                    targetName,\n                                    stream: StreamKind.CANCEL,\n                                    streamId,\n                                    reason: wrapReason(reason)\n                                });\n                                return cancelCapability.promise;\n                            }\n                        }, queueingStrategy);\n                    }\n                    #createStreamSink(data) {\n                        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n                        const self = this, action = this.actionHandler[data.action];\n                        const streamSink = {\n                            enqueue (chunk, size = 1, transfers) {\n                                if (this.isCancelled) {\n                                    return;\n                                }\n                                const lastDesiredSize = this.desiredSize;\n                                this.desiredSize -= size;\n                                if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n                                    this.sinkCapability = new _util.PromiseCapability();\n                                    this.ready = this.sinkCapability.promise;\n                                }\n                                comObj.postMessage({\n                                    sourceName,\n                                    targetName,\n                                    stream: StreamKind.ENQUEUE,\n                                    streamId,\n                                    chunk\n                                }, transfers);\n                            },\n                            close () {\n                                if (this.isCancelled) {\n                                    return;\n                                }\n                                this.isCancelled = true;\n                                comObj.postMessage({\n                                    sourceName,\n                                    targetName,\n                                    stream: StreamKind.CLOSE,\n                                    streamId\n                                });\n                                delete self.streamSinks[streamId];\n                            },\n                            error (reason) {\n                                (0, _util.assert)(reason instanceof Error, \"error must have a valid reason\");\n                                if (this.isCancelled) {\n                                    return;\n                                }\n                                this.isCancelled = true;\n                                comObj.postMessage({\n                                    sourceName,\n                                    targetName,\n                                    stream: StreamKind.ERROR,\n                                    streamId,\n                                    reason: wrapReason(reason)\n                                });\n                            },\n                            sinkCapability: new _util.PromiseCapability(),\n                            onPull: null,\n                            onCancel: null,\n                            isCancelled: false,\n                            desiredSize: data.desiredSize,\n                            ready: null\n                        };\n                        streamSink.sinkCapability.resolve();\n                        streamSink.ready = streamSink.sinkCapability.promise;\n                        this.streamSinks[streamId] = streamSink;\n                        new Promise(function(resolve) {\n                            resolve(action(data.data, streamSink));\n                        }).then(function() {\n                            comObj.postMessage({\n                                sourceName,\n                                targetName,\n                                stream: StreamKind.START_COMPLETE,\n                                streamId,\n                                success: true\n                            });\n                        }, function(reason) {\n                            comObj.postMessage({\n                                sourceName,\n                                targetName,\n                                stream: StreamKind.START_COMPLETE,\n                                streamId,\n                                reason: wrapReason(reason)\n                            });\n                        });\n                    }\n                    #processStreamMessage(data) {\n                        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n                        const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];\n                        switch(data.stream){\n                            case StreamKind.START_COMPLETE:\n                                if (data.success) {\n                                    streamController.startCall.resolve();\n                                } else {\n                                    streamController.startCall.reject(wrapReason(data.reason));\n                                }\n                                break;\n                            case StreamKind.PULL_COMPLETE:\n                                if (data.success) {\n                                    streamController.pullCall.resolve();\n                                } else {\n                                    streamController.pullCall.reject(wrapReason(data.reason));\n                                }\n                                break;\n                            case StreamKind.PULL:\n                                if (!streamSink) {\n                                    comObj.postMessage({\n                                        sourceName,\n                                        targetName,\n                                        stream: StreamKind.PULL_COMPLETE,\n                                        streamId,\n                                        success: true\n                                    });\n                                    break;\n                                }\n                                if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n                                    streamSink.sinkCapability.resolve();\n                                }\n                                streamSink.desiredSize = data.desiredSize;\n                                new Promise(function(resolve) {\n                                    resolve(streamSink.onPull?.());\n                                }).then(function() {\n                                    comObj.postMessage({\n                                        sourceName,\n                                        targetName,\n                                        stream: StreamKind.PULL_COMPLETE,\n                                        streamId,\n                                        success: true\n                                    });\n                                }, function(reason) {\n                                    comObj.postMessage({\n                                        sourceName,\n                                        targetName,\n                                        stream: StreamKind.PULL_COMPLETE,\n                                        streamId,\n                                        reason: wrapReason(reason)\n                                    });\n                                });\n                                break;\n                            case StreamKind.ENQUEUE:\n                                (0, _util.assert)(streamController, \"enqueue should have stream controller\");\n                                if (streamController.isClosed) {\n                                    break;\n                                }\n                                streamController.controller.enqueue(data.chunk);\n                                break;\n                            case StreamKind.CLOSE:\n                                (0, _util.assert)(streamController, \"close should have stream controller\");\n                                if (streamController.isClosed) {\n                                    break;\n                                }\n                                streamController.isClosed = true;\n                                streamController.controller.close();\n                                this.#deleteStreamController(streamController, streamId);\n                                break;\n                            case StreamKind.ERROR:\n                                (0, _util.assert)(streamController, \"error should have stream controller\");\n                                streamController.controller.error(wrapReason(data.reason));\n                                this.#deleteStreamController(streamController, streamId);\n                                break;\n                            case StreamKind.CANCEL_COMPLETE:\n                                if (data.success) {\n                                    streamController.cancelCall.resolve();\n                                } else {\n                                    streamController.cancelCall.reject(wrapReason(data.reason));\n                                }\n                                this.#deleteStreamController(streamController, streamId);\n                                break;\n                            case StreamKind.CANCEL:\n                                if (!streamSink) {\n                                    break;\n                                }\n                                new Promise(function(resolve) {\n                                    resolve(streamSink.onCancel?.(wrapReason(data.reason)));\n                                }).then(function() {\n                                    comObj.postMessage({\n                                        sourceName,\n                                        targetName,\n                                        stream: StreamKind.CANCEL_COMPLETE,\n                                        streamId,\n                                        success: true\n                                    });\n                                }, function(reason) {\n                                    comObj.postMessage({\n                                        sourceName,\n                                        targetName,\n                                        stream: StreamKind.CANCEL_COMPLETE,\n                                        streamId,\n                                        reason: wrapReason(reason)\n                                    });\n                                });\n                                streamSink.sinkCapability.reject(wrapReason(data.reason));\n                                streamSink.isCancelled = true;\n                                delete this.streamSinks[streamId];\n                                break;\n                            default:\n                                throw new Error(\"Unexpected stream case\");\n                        }\n                    }\n                    async #deleteStreamController(streamController, streamId) {\n                        await Promise.allSettled([\n                            streamController.startCall?.promise,\n                            streamController.pullCall?.promise,\n                            streamController.cancelCall?.promise\n                        ]);\n                        delete this.streamControllers[streamId];\n                    }\n                    destroy() {\n                        this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n                    }\n                }\n                exports1.MessageHandler = MessageHandler;\n            /***/ },\n            /* 16 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.Metadata = void 0;\n                var _util = __w_pdfjs_require__(1);\n                class Metadata {\n                    #metadataMap;\n                    #data;\n                    constructor({ parsedData, rawData }){\n                        this.#metadataMap = parsedData;\n                        this.#data = rawData;\n                    }\n                    getRaw() {\n                        return this.#data;\n                    }\n                    get(name) {\n                        return this.#metadataMap.get(name) ?? null;\n                    }\n                    getAll() {\n                        return (0, _util.objectFromMap)(this.#metadataMap);\n                    }\n                    has(name) {\n                        return this.#metadataMap.has(name);\n                    }\n                }\n                exports1.Metadata = Metadata;\n            /***/ },\n            /* 17 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.OptionalContentConfig = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _murmurhash = __w_pdfjs_require__(8);\n                const INTERNAL = Symbol(\"INTERNAL\");\n                class OptionalContentGroup {\n                    #visible;\n                    constructor(name, intent){\n                        this.#visible = true;\n                        this.name = name;\n                        this.intent = intent;\n                    }\n                    get visible() {\n                        return this.#visible;\n                    }\n                    _setVisible(internal, visible) {\n                        if (internal !== INTERNAL) {\n                            (0, _util.unreachable)(\"Internal method `_setVisible` called.\");\n                        }\n                        this.#visible = visible;\n                    }\n                }\n                class OptionalContentConfig {\n                    #cachedGetHash;\n                    #groups;\n                    #initialHash;\n                    #order;\n                    constructor(data){\n                        this.#cachedGetHash = null;\n                        this.#groups = new Map();\n                        this.#initialHash = null;\n                        this.#order = null;\n                        this.name = null;\n                        this.creator = null;\n                        if (data === null) {\n                            return;\n                        }\n                        this.name = data.name;\n                        this.creator = data.creator;\n                        this.#order = data.order;\n                        for (const group of data.groups){\n                            this.#groups.set(group.id, new OptionalContentGroup(group.name, group.intent));\n                        }\n                        if (data.baseState === \"OFF\") {\n                            for (const group of this.#groups.values()){\n                                group._setVisible(INTERNAL, false);\n                            }\n                        }\n                        for (const on of data.on){\n                            this.#groups.get(on)._setVisible(INTERNAL, true);\n                        }\n                        for (const off of data.off){\n                            this.#groups.get(off)._setVisible(INTERNAL, false);\n                        }\n                        this.#initialHash = this.getHash();\n                    }\n                    #evaluateVisibilityExpression(array) {\n                        const length = array.length;\n                        if (length < 2) {\n                            return true;\n                        }\n                        const operator = array[0];\n                        for(let i = 1; i < length; i++){\n                            const element = array[i];\n                            let state;\n                            if (Array.isArray(element)) {\n                                state = this.#evaluateVisibilityExpression(element);\n                            } else if (this.#groups.has(element)) {\n                                state = this.#groups.get(element).visible;\n                            } else {\n                                (0, _util.warn)(`Optional content group not found: ${element}`);\n                                return true;\n                            }\n                            switch(operator){\n                                case \"And\":\n                                    if (!state) {\n                                        return false;\n                                    }\n                                    break;\n                                case \"Or\":\n                                    if (state) {\n                                        return true;\n                                    }\n                                    break;\n                                case \"Not\":\n                                    return !state;\n                                default:\n                                    return true;\n                            }\n                        }\n                        return operator === \"And\";\n                    }\n                    isVisible(group) {\n                        if (this.#groups.size === 0) {\n                            return true;\n                        }\n                        if (!group) {\n                            (0, _util.warn)(\"Optional content group not defined.\");\n                            return true;\n                        }\n                        if (group.type === \"OCG\") {\n                            if (!this.#groups.has(group.id)) {\n                                (0, _util.warn)(`Optional content group not found: ${group.id}`);\n                                return true;\n                            }\n                            return this.#groups.get(group.id).visible;\n                        } else if (group.type === \"OCMD\") {\n                            if (group.expression) {\n                                return this.#evaluateVisibilityExpression(group.expression);\n                            }\n                            if (!group.policy || group.policy === \"AnyOn\") {\n                                for (const id of group.ids){\n                                    if (!this.#groups.has(id)) {\n                                        (0, _util.warn)(`Optional content group not found: ${id}`);\n                                        return true;\n                                    }\n                                    if (this.#groups.get(id).visible) {\n                                        return true;\n                                    }\n                                }\n                                return false;\n                            } else if (group.policy === \"AllOn\") {\n                                for (const id of group.ids){\n                                    if (!this.#groups.has(id)) {\n                                        (0, _util.warn)(`Optional content group not found: ${id}`);\n                                        return true;\n                                    }\n                                    if (!this.#groups.get(id).visible) {\n                                        return false;\n                                    }\n                                }\n                                return true;\n                            } else if (group.policy === \"AnyOff\") {\n                                for (const id of group.ids){\n                                    if (!this.#groups.has(id)) {\n                                        (0, _util.warn)(`Optional content group not found: ${id}`);\n                                        return true;\n                                    }\n                                    if (!this.#groups.get(id).visible) {\n                                        return true;\n                                    }\n                                }\n                                return false;\n                            } else if (group.policy === \"AllOff\") {\n                                for (const id of group.ids){\n                                    if (!this.#groups.has(id)) {\n                                        (0, _util.warn)(`Optional content group not found: ${id}`);\n                                        return true;\n                                    }\n                                    if (this.#groups.get(id).visible) {\n                                        return false;\n                                    }\n                                }\n                                return true;\n                            }\n                            (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);\n                            return true;\n                        }\n                        (0, _util.warn)(`Unknown group type ${group.type}.`);\n                        return true;\n                    }\n                    setVisibility(id, visible = true) {\n                        if (!this.#groups.has(id)) {\n                            (0, _util.warn)(`Optional content group not found: ${id}`);\n                            return;\n                        }\n                        this.#groups.get(id)._setVisible(INTERNAL, !!visible);\n                        this.#cachedGetHash = null;\n                    }\n                    get hasInitialVisibility() {\n                        return this.#initialHash === null || this.getHash() === this.#initialHash;\n                    }\n                    getOrder() {\n                        if (!this.#groups.size) {\n                            return null;\n                        }\n                        if (this.#order) {\n                            return this.#order.slice();\n                        }\n                        return [\n                            ...this.#groups.keys()\n                        ];\n                    }\n                    getGroups() {\n                        return this.#groups.size > 0 ? (0, _util.objectFromMap)(this.#groups) : null;\n                    }\n                    getGroup(id) {\n                        return this.#groups.get(id) || null;\n                    }\n                    getHash() {\n                        if (this.#cachedGetHash !== null) {\n                            return this.#cachedGetHash;\n                        }\n                        const hash = new _murmurhash.MurmurHash3_64();\n                        for (const [id, group] of this.#groups){\n                            hash.update(`${id}:${group.visible}`);\n                        }\n                        return this.#cachedGetHash = hash.hexdigest();\n                    }\n                }\n                exports1.OptionalContentConfig = OptionalContentConfig;\n            /***/ },\n            /* 18 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.PDFDataTransportStream = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _display_utils = __w_pdfjs_require__(6);\n                class PDFDataTransportStream {\n                    constructor({ length, initialData, progressiveDone = false, contentDispositionFilename = null, disableRange = false, disableStream = false }, pdfDataRangeTransport){\n                        (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n                        this._queuedChunks = [];\n                        this._progressiveDone = progressiveDone;\n                        this._contentDispositionFilename = contentDispositionFilename;\n                        if (initialData?.length > 0) {\n                            const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;\n                            this._queuedChunks.push(buffer);\n                        }\n                        this._pdfDataRangeTransport = pdfDataRangeTransport;\n                        this._isStreamingSupported = !disableStream;\n                        this._isRangeSupported = !disableRange;\n                        this._contentLength = length;\n                        this._fullRequestReader = null;\n                        this._rangeReaders = [];\n                        this._pdfDataRangeTransport.addRangeListener((begin, chunk)=>{\n                            this._onReceiveData({\n                                begin,\n                                chunk\n                            });\n                        });\n                        this._pdfDataRangeTransport.addProgressListener((loaded, total)=>{\n                            this._onProgress({\n                                loaded,\n                                total\n                            });\n                        });\n                        this._pdfDataRangeTransport.addProgressiveReadListener((chunk)=>{\n                            this._onReceiveData({\n                                chunk\n                            });\n                        });\n                        this._pdfDataRangeTransport.addProgressiveDoneListener(()=>{\n                            this._onProgressiveDone();\n                        });\n                        this._pdfDataRangeTransport.transportReady();\n                    }\n                    _onReceiveData({ begin, chunk }) {\n                        const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;\n                        if (begin === undefined) {\n                            if (this._fullRequestReader) {\n                                this._fullRequestReader._enqueue(buffer);\n                            } else {\n                                this._queuedChunks.push(buffer);\n                            }\n                        } else {\n                            const found = this._rangeReaders.some(function(rangeReader) {\n                                if (rangeReader._begin !== begin) {\n                                    return false;\n                                }\n                                rangeReader._enqueue(buffer);\n                                return true;\n                            });\n                            (0, _util.assert)(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n                        }\n                    }\n                    get _progressiveDataLength() {\n                        return this._fullRequestReader?._loaded ?? 0;\n                    }\n                    _onProgress(evt) {\n                        if (evt.total === undefined) {\n                            this._rangeReaders[0]?.onProgress?.({\n                                loaded: evt.loaded\n                            });\n                        } else {\n                            this._fullRequestReader?.onProgress?.({\n                                loaded: evt.loaded,\n                                total: evt.total\n                            });\n                        }\n                    }\n                    _onProgressiveDone() {\n                        this._fullRequestReader?.progressiveDone();\n                        this._progressiveDone = true;\n                    }\n                    _removeRangeReader(reader) {\n                        const i = this._rangeReaders.indexOf(reader);\n                        if (i >= 0) {\n                            this._rangeReaders.splice(i, 1);\n                        }\n                    }\n                    getFullReader() {\n                        (0, _util.assert)(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n                        const queuedChunks = this._queuedChunks;\n                        this._queuedChunks = null;\n                        return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n                    }\n                    getRangeReader(begin, end) {\n                        if (end <= this._progressiveDataLength) {\n                            return null;\n                        }\n                        const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n                        this._pdfDataRangeTransport.requestDataRange(begin, end);\n                        this._rangeReaders.push(reader);\n                        return reader;\n                    }\n                    cancelAllRequests(reason) {\n                        this._fullRequestReader?.cancel(reason);\n                        for (const reader of this._rangeReaders.slice(0)){\n                            reader.cancel(reason);\n                        }\n                        this._pdfDataRangeTransport.abort();\n                    }\n                }\n                exports1.PDFDataTransportStream = PDFDataTransportStream;\n                class PDFDataTransportStreamReader {\n                    constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null){\n                        this._stream = stream;\n                        this._done = progressiveDone || false;\n                        this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;\n                        this._queuedChunks = queuedChunks || [];\n                        this._loaded = 0;\n                        for (const chunk of this._queuedChunks){\n                            this._loaded += chunk.byteLength;\n                        }\n                        this._requests = [];\n                        this._headersReady = Promise.resolve();\n                        stream._fullRequestReader = this;\n                        this.onProgress = null;\n                    }\n                    _enqueue(chunk) {\n                        if (this._done) {\n                            return;\n                        }\n                        if (this._requests.length > 0) {\n                            const requestCapability = this._requests.shift();\n                            requestCapability.resolve({\n                                value: chunk,\n                                done: false\n                            });\n                        } else {\n                            this._queuedChunks.push(chunk);\n                        }\n                        this._loaded += chunk.byteLength;\n                    }\n                    get headersReady() {\n                        return this._headersReady;\n                    }\n                    get filename() {\n                        return this._filename;\n                    }\n                    get isRangeSupported() {\n                        return this._stream._isRangeSupported;\n                    }\n                    get isStreamingSupported() {\n                        return this._stream._isStreamingSupported;\n                    }\n                    get contentLength() {\n                        return this._stream._contentLength;\n                    }\n                    async read() {\n                        if (this._queuedChunks.length > 0) {\n                            const chunk = this._queuedChunks.shift();\n                            return {\n                                value: chunk,\n                                done: false\n                            };\n                        }\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        const requestCapability = new _util.PromiseCapability();\n                        this._requests.push(requestCapability);\n                        return requestCapability.promise;\n                    }\n                    cancel(reason) {\n                        this._done = true;\n                        for (const requestCapability of this._requests){\n                            requestCapability.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                    }\n                    progressiveDone() {\n                        if (this._done) {\n                            return;\n                        }\n                        this._done = true;\n                    }\n                }\n                class PDFDataTransportStreamRangeReader {\n                    constructor(stream, begin, end){\n                        this._stream = stream;\n                        this._begin = begin;\n                        this._end = end;\n                        this._queuedChunk = null;\n                        this._requests = [];\n                        this._done = false;\n                        this.onProgress = null;\n                    }\n                    _enqueue(chunk) {\n                        if (this._done) {\n                            return;\n                        }\n                        if (this._requests.length === 0) {\n                            this._queuedChunk = chunk;\n                        } else {\n                            const requestsCapability = this._requests.shift();\n                            requestsCapability.resolve({\n                                value: chunk,\n                                done: false\n                            });\n                            for (const requestCapability of this._requests){\n                                requestCapability.resolve({\n                                    value: undefined,\n                                    done: true\n                                });\n                            }\n                            this._requests.length = 0;\n                        }\n                        this._done = true;\n                        this._stream._removeRangeReader(this);\n                    }\n                    get isStreamingSupported() {\n                        return false;\n                    }\n                    async read() {\n                        if (this._queuedChunk) {\n                            const chunk = this._queuedChunk;\n                            this._queuedChunk = null;\n                            return {\n                                value: chunk,\n                                done: false\n                            };\n                        }\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        const requestCapability = new _util.PromiseCapability();\n                        this._requests.push(requestCapability);\n                        return requestCapability.promise;\n                    }\n                    cancel(reason) {\n                        this._done = true;\n                        for (const requestCapability of this._requests){\n                            requestCapability.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                        this._stream._removeRangeReader(this);\n                    }\n                }\n            /***/ },\n            /* 19 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.PDFFetchStream = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _network_utils = __w_pdfjs_require__(20);\n                ;\n                function createFetchOptions(headers, withCredentials, abortController) {\n                    return {\n                        method: \"GET\",\n                        headers,\n                        signal: abortController.signal,\n                        mode: \"cors\",\n                        credentials: withCredentials ? \"include\" : \"same-origin\",\n                        redirect: \"follow\"\n                    };\n                }\n                function createHeaders(httpHeaders) {\n                    const headers = new Headers();\n                    for(const property in httpHeaders){\n                        const value = httpHeaders[property];\n                        if (value === undefined) {\n                            continue;\n                        }\n                        headers.append(property, value);\n                    }\n                    return headers;\n                }\n                function getArrayBuffer(val) {\n                    if (val instanceof Uint8Array) {\n                        return val.buffer;\n                    }\n                    if (val instanceof ArrayBuffer) {\n                        return val;\n                    }\n                    (0, _util.warn)(`getArrayBuffer - unexpected data format: ${val}`);\n                    return new Uint8Array(val).buffer;\n                }\n                class PDFFetchStream {\n                    constructor(source){\n                        this.source = source;\n                        this.isHttp = /^https?:/i.test(source.url);\n                        this.httpHeaders = this.isHttp && source.httpHeaders || {};\n                        this._fullRequestReader = null;\n                        this._rangeRequestReaders = [];\n                    }\n                    get _progressiveDataLength() {\n                        return this._fullRequestReader?._loaded ?? 0;\n                    }\n                    getFullReader() {\n                        (0, _util.assert)(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n                        this._fullRequestReader = new PDFFetchStreamReader(this);\n                        return this._fullRequestReader;\n                    }\n                    getRangeReader(begin, end) {\n                        if (end <= this._progressiveDataLength) {\n                            return null;\n                        }\n                        const reader = new PDFFetchStreamRangeReader(this, begin, end);\n                        this._rangeRequestReaders.push(reader);\n                        return reader;\n                    }\n                    cancelAllRequests(reason) {\n                        this._fullRequestReader?.cancel(reason);\n                        for (const reader of this._rangeRequestReaders.slice(0)){\n                            reader.cancel(reason);\n                        }\n                    }\n                }\n                exports1.PDFFetchStream = PDFFetchStream;\n                class PDFFetchStreamReader {\n                    constructor(stream){\n                        this._stream = stream;\n                        this._reader = null;\n                        this._loaded = 0;\n                        this._filename = null;\n                        const source = stream.source;\n                        this._withCredentials = source.withCredentials || false;\n                        this._contentLength = source.length;\n                        this._headersCapability = new _util.PromiseCapability();\n                        this._disableRange = source.disableRange || false;\n                        this._rangeChunkSize = source.rangeChunkSize;\n                        if (!this._rangeChunkSize && !this._disableRange) {\n                            this._disableRange = true;\n                        }\n                        this._abortController = new AbortController();\n                        this._isStreamingSupported = !source.disableStream;\n                        this._isRangeSupported = !source.disableRange;\n                        this._headers = createHeaders(this._stream.httpHeaders);\n                        const url = source.url;\n                        fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response)=>{\n                            if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n                                throw (0, _network_utils.createResponseStatusError)(response.status, url);\n                            }\n                            this._reader = response.body.getReader();\n                            this._headersCapability.resolve();\n                            const getResponseHeader = (name)=>{\n                                return response.headers.get(name);\n                            };\n                            const { allowRangeRequests, suggestedLength } = (0, _network_utils.validateRangeRequestCapabilities)({\n                                getResponseHeader,\n                                isHttp: this._stream.isHttp,\n                                rangeChunkSize: this._rangeChunkSize,\n                                disableRange: this._disableRange\n                            });\n                            this._isRangeSupported = allowRangeRequests;\n                            this._contentLength = suggestedLength || this._contentLength;\n                            this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n                            if (!this._isStreamingSupported && this._isRangeSupported) {\n                                this.cancel(new _util.AbortException(\"Streaming is disabled.\"));\n                            }\n                        }).catch(this._headersCapability.reject);\n                        this.onProgress = null;\n                    }\n                    get headersReady() {\n                        return this._headersCapability.promise;\n                    }\n                    get filename() {\n                        return this._filename;\n                    }\n                    get contentLength() {\n                        return this._contentLength;\n                    }\n                    get isRangeSupported() {\n                        return this._isRangeSupported;\n                    }\n                    get isStreamingSupported() {\n                        return this._isStreamingSupported;\n                    }\n                    async read() {\n                        await this._headersCapability.promise;\n                        const { value, done } = await this._reader.read();\n                        if (done) {\n                            return {\n                                value,\n                                done\n                            };\n                        }\n                        this._loaded += value.byteLength;\n                        this.onProgress?.({\n                            loaded: this._loaded,\n                            total: this._contentLength\n                        });\n                        return {\n                            value: getArrayBuffer(value),\n                            done: false\n                        };\n                    }\n                    cancel(reason) {\n                        this._reader?.cancel(reason);\n                        this._abortController.abort();\n                    }\n                }\n                class PDFFetchStreamRangeReader {\n                    constructor(stream, begin, end){\n                        this._stream = stream;\n                        this._reader = null;\n                        this._loaded = 0;\n                        const source = stream.source;\n                        this._withCredentials = source.withCredentials || false;\n                        this._readCapability = new _util.PromiseCapability();\n                        this._isStreamingSupported = !source.disableStream;\n                        this._abortController = new AbortController();\n                        this._headers = createHeaders(this._stream.httpHeaders);\n                        this._headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n                        const url = source.url;\n                        fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response)=>{\n                            if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n                                throw (0, _network_utils.createResponseStatusError)(response.status, url);\n                            }\n                            this._readCapability.resolve();\n                            this._reader = response.body.getReader();\n                        }).catch(this._readCapability.reject);\n                        this.onProgress = null;\n                    }\n                    get isStreamingSupported() {\n                        return this._isStreamingSupported;\n                    }\n                    async read() {\n                        await this._readCapability.promise;\n                        const { value, done } = await this._reader.read();\n                        if (done) {\n                            return {\n                                value,\n                                done\n                            };\n                        }\n                        this._loaded += value.byteLength;\n                        this.onProgress?.({\n                            loaded: this._loaded\n                        });\n                        return {\n                            value: getArrayBuffer(value),\n                            done: false\n                        };\n                    }\n                    cancel(reason) {\n                        this._reader?.cancel(reason);\n                        this._abortController.abort();\n                    }\n                }\n            /***/ },\n            /* 20 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.createResponseStatusError = createResponseStatusError;\n                exports1.extractFilenameFromHeader = extractFilenameFromHeader;\n                exports1.validateRangeRequestCapabilities = validateRangeRequestCapabilities;\n                exports1.validateResponseStatus = validateResponseStatus;\n                var _util = __w_pdfjs_require__(1);\n                var _content_disposition = __w_pdfjs_require__(21);\n                var _display_utils = __w_pdfjs_require__(6);\n                function validateRangeRequestCapabilities({ getResponseHeader, isHttp, rangeChunkSize, disableRange }) {\n                    const returnValues = {\n                        allowRangeRequests: false,\n                        suggestedLength: undefined\n                    };\n                    const length = parseInt(getResponseHeader(\"Content-Length\"), 10);\n                    if (!Number.isInteger(length)) {\n                        return returnValues;\n                    }\n                    returnValues.suggestedLength = length;\n                    if (length <= 2 * rangeChunkSize) {\n                        return returnValues;\n                    }\n                    if (disableRange || !isHttp) {\n                        return returnValues;\n                    }\n                    if (getResponseHeader(\"Accept-Ranges\") !== \"bytes\") {\n                        return returnValues;\n                    }\n                    const contentEncoding = getResponseHeader(\"Content-Encoding\") || \"identity\";\n                    if (contentEncoding !== \"identity\") {\n                        return returnValues;\n                    }\n                    returnValues.allowRangeRequests = true;\n                    return returnValues;\n                }\n                function extractFilenameFromHeader(getResponseHeader) {\n                    const contentDisposition = getResponseHeader(\"Content-Disposition\");\n                    if (contentDisposition) {\n                        let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);\n                        if (filename.includes(\"%\")) {\n                            try {\n                                filename = decodeURIComponent(filename);\n                            } catch  {}\n                        }\n                        if ((0, _display_utils.isPdfFile)(filename)) {\n                            return filename;\n                        }\n                    }\n                    return null;\n                }\n                function createResponseStatusError(status, url) {\n                    if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n                        return new _util.MissingPDFException('Missing PDF \"' + url + '\".');\n                    }\n                    return new _util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status);\n                }\n                function validateResponseStatus(status) {\n                    return status === 200 || status === 206;\n                }\n            /***/ },\n            /* 21 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;\n                var _util = __w_pdfjs_require__(1);\n                function getFilenameFromContentDispositionHeader(contentDisposition) {\n                    let needsEncodingFixup = true;\n                    let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n                    if (tmp) {\n                        tmp = tmp[1];\n                        let filename = rfc2616unquote(tmp);\n                        filename = unescape(filename);\n                        filename = rfc5987decode(filename);\n                        filename = rfc2047decode(filename);\n                        return fixupEncoding(filename);\n                    }\n                    tmp = rfc2231getparam(contentDisposition);\n                    if (tmp) {\n                        const filename = rfc2047decode(tmp);\n                        return fixupEncoding(filename);\n                    }\n                    tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n                    if (tmp) {\n                        tmp = tmp[1];\n                        let filename = rfc2616unquote(tmp);\n                        filename = rfc2047decode(filename);\n                        return fixupEncoding(filename);\n                    }\n                    function toParamRegExp(attributePattern, flags) {\n                        return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n                    }\n                    function textdecode(encoding, value) {\n                        if (encoding) {\n                            if (!/^[\\x00-\\xFF]+$/.test(value)) {\n                                return value;\n                            }\n                            try {\n                                const decoder = new TextDecoder(encoding, {\n                                    fatal: true\n                                });\n                                const buffer = (0, _util.stringToBytes)(value);\n                                value = decoder.decode(buffer);\n                                needsEncodingFixup = false;\n                            } catch  {}\n                        }\n                        return value;\n                    }\n                    function fixupEncoding(value) {\n                        if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n                            value = textdecode(\"utf-8\", value);\n                            if (needsEncodingFixup) {\n                                value = textdecode(\"iso-8859-1\", value);\n                            }\n                        }\n                        return value;\n                    }\n                    function rfc2231getparam(contentDispositionStr) {\n                        const matches = [];\n                        let match;\n                        const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n                        while((match = iter.exec(contentDispositionStr)) !== null){\n                            let [, n, quot, part] = match;\n                            n = parseInt(n, 10);\n                            if (n in matches) {\n                                if (n === 0) {\n                                    break;\n                                }\n                                continue;\n                            }\n                            matches[n] = [\n                                quot,\n                                part\n                            ];\n                        }\n                        const parts = [];\n                        for(let n = 0; n < matches.length; ++n){\n                            if (!(n in matches)) {\n                                break;\n                            }\n                            let [quot, part] = matches[n];\n                            part = rfc2616unquote(part);\n                            if (quot) {\n                                part = unescape(part);\n                                if (n === 0) {\n                                    part = rfc5987decode(part);\n                                }\n                            }\n                            parts.push(part);\n                        }\n                        return parts.join(\"\");\n                    }\n                    function rfc2616unquote(value) {\n                        if (value.startsWith('\"')) {\n                            const parts = value.slice(1).split('\\\\\"');\n                            for(let i = 0; i < parts.length; ++i){\n                                const quotindex = parts[i].indexOf('\"');\n                                if (quotindex !== -1) {\n                                    parts[i] = parts[i].slice(0, quotindex);\n                                    parts.length = i + 1;\n                                }\n                                parts[i] = parts[i].replaceAll(/\\\\(.)/g, \"$1\");\n                            }\n                            value = parts.join('\"');\n                        }\n                        return value;\n                    }\n                    function rfc5987decode(extvalue) {\n                        const encodingend = extvalue.indexOf(\"'\");\n                        if (encodingend === -1) {\n                            return extvalue;\n                        }\n                        const encoding = extvalue.slice(0, encodingend);\n                        const langvalue = extvalue.slice(encodingend + 1);\n                        const value = langvalue.replace(/^[^']*'/, \"\");\n                        return textdecode(encoding, value);\n                    }\n                    function rfc2047decode(value) {\n                        if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n                            return value;\n                        }\n                        return value.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function(matches, charset, encoding, text) {\n                            if (encoding === \"q\" || encoding === \"Q\") {\n                                text = text.replaceAll(\"_\", \" \");\n                                text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {\n                                    return String.fromCharCode(parseInt(hex, 16));\n                                });\n                                return textdecode(charset, text);\n                            }\n                            try {\n                                text = atob(text);\n                            } catch  {}\n                            return textdecode(charset, text);\n                        });\n                    }\n                    return \"\";\n                }\n            /***/ },\n            /* 22 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.PDFNetworkStream = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _network_utils = __w_pdfjs_require__(20);\n                ;\n                const OK_RESPONSE = 200;\n                const PARTIAL_CONTENT_RESPONSE = 206;\n                function getArrayBuffer(xhr) {\n                    const data = xhr.response;\n                    if (typeof data !== \"string\") {\n                        return data;\n                    }\n                    return (0, _util.stringToBytes)(data).buffer;\n                }\n                class NetworkManager {\n                    constructor(url, args = {}){\n                        this.url = url;\n                        this.isHttp = /^https?:/i.test(url);\n                        this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);\n                        this.withCredentials = args.withCredentials || false;\n                        this.currXhrId = 0;\n                        this.pendingRequests = Object.create(null);\n                    }\n                    requestRange(begin, end, listeners) {\n                        const args = {\n                            begin,\n                            end\n                        };\n                        for(const prop in listeners){\n                            args[prop] = listeners[prop];\n                        }\n                        return this.request(args);\n                    }\n                    requestFull(listeners) {\n                        return this.request(listeners);\n                    }\n                    request(args) {\n                        const xhr = new XMLHttpRequest();\n                        const xhrId = this.currXhrId++;\n                        const pendingRequest = this.pendingRequests[xhrId] = {\n                            xhr\n                        };\n                        xhr.open(\"GET\", this.url);\n                        xhr.withCredentials = this.withCredentials;\n                        for(const property in this.httpHeaders){\n                            const value = this.httpHeaders[property];\n                            if (value === undefined) {\n                                continue;\n                            }\n                            xhr.setRequestHeader(property, value);\n                        }\n                        if (this.isHttp && \"begin\" in args && \"end\" in args) {\n                            xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n                            pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n                        } else {\n                            pendingRequest.expectedStatus = OK_RESPONSE;\n                        }\n                        xhr.responseType = \"arraybuffer\";\n                        if (args.onError) {\n                            xhr.onerror = function(evt) {\n                                args.onError(xhr.status);\n                            };\n                        }\n                        xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n                        xhr.onprogress = this.onProgress.bind(this, xhrId);\n                        pendingRequest.onHeadersReceived = args.onHeadersReceived;\n                        pendingRequest.onDone = args.onDone;\n                        pendingRequest.onError = args.onError;\n                        pendingRequest.onProgress = args.onProgress;\n                        xhr.send(null);\n                        return xhrId;\n                    }\n                    onProgress(xhrId, evt) {\n                        const pendingRequest = this.pendingRequests[xhrId];\n                        if (!pendingRequest) {\n                            return;\n                        }\n                        pendingRequest.onProgress?.(evt);\n                    }\n                    onStateChange(xhrId, evt) {\n                        const pendingRequest = this.pendingRequests[xhrId];\n                        if (!pendingRequest) {\n                            return;\n                        }\n                        const xhr = pendingRequest.xhr;\n                        if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n                            pendingRequest.onHeadersReceived();\n                            delete pendingRequest.onHeadersReceived;\n                        }\n                        if (xhr.readyState !== 4) {\n                            return;\n                        }\n                        if (!(xhrId in this.pendingRequests)) {\n                            return;\n                        }\n                        delete this.pendingRequests[xhrId];\n                        if (xhr.status === 0 && this.isHttp) {\n                            pendingRequest.onError?.(xhr.status);\n                            return;\n                        }\n                        const xhrStatus = xhr.status || OK_RESPONSE;\n                        const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n                        if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n                            pendingRequest.onError?.(xhr.status);\n                            return;\n                        }\n                        const chunk = getArrayBuffer(xhr);\n                        if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n                            const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n                            const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n                            pendingRequest.onDone({\n                                begin: parseInt(matches[1], 10),\n                                chunk\n                            });\n                        } else if (chunk) {\n                            pendingRequest.onDone({\n                                begin: 0,\n                                chunk\n                            });\n                        } else {\n                            pendingRequest.onError?.(xhr.status);\n                        }\n                    }\n                    getRequestXhr(xhrId) {\n                        return this.pendingRequests[xhrId].xhr;\n                    }\n                    isPendingRequest(xhrId) {\n                        return xhrId in this.pendingRequests;\n                    }\n                    abortRequest(xhrId) {\n                        const xhr = this.pendingRequests[xhrId].xhr;\n                        delete this.pendingRequests[xhrId];\n                        xhr.abort();\n                    }\n                }\n                class PDFNetworkStream {\n                    constructor(source){\n                        this._source = source;\n                        this._manager = new NetworkManager(source.url, {\n                            httpHeaders: source.httpHeaders,\n                            withCredentials: source.withCredentials\n                        });\n                        this._rangeChunkSize = source.rangeChunkSize;\n                        this._fullRequestReader = null;\n                        this._rangeRequestReaders = [];\n                    }\n                    _onRangeRequestReaderClosed(reader) {\n                        const i = this._rangeRequestReaders.indexOf(reader);\n                        if (i >= 0) {\n                            this._rangeRequestReaders.splice(i, 1);\n                        }\n                    }\n                    getFullReader() {\n                        (0, _util.assert)(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n                        this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n                        return this._fullRequestReader;\n                    }\n                    getRangeReader(begin, end) {\n                        const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n                        reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n                        this._rangeRequestReaders.push(reader);\n                        return reader;\n                    }\n                    cancelAllRequests(reason) {\n                        this._fullRequestReader?.cancel(reason);\n                        for (const reader of this._rangeRequestReaders.slice(0)){\n                            reader.cancel(reason);\n                        }\n                    }\n                }\n                exports1.PDFNetworkStream = PDFNetworkStream;\n                class PDFNetworkStreamFullRequestReader {\n                    constructor(manager, source){\n                        this._manager = manager;\n                        const args = {\n                            onHeadersReceived: this._onHeadersReceived.bind(this),\n                            onDone: this._onDone.bind(this),\n                            onError: this._onError.bind(this),\n                            onProgress: this._onProgress.bind(this)\n                        };\n                        this._url = source.url;\n                        this._fullRequestId = manager.requestFull(args);\n                        this._headersReceivedCapability = new _util.PromiseCapability();\n                        this._disableRange = source.disableRange || false;\n                        this._contentLength = source.length;\n                        this._rangeChunkSize = source.rangeChunkSize;\n                        if (!this._rangeChunkSize && !this._disableRange) {\n                            this._disableRange = true;\n                        }\n                        this._isStreamingSupported = false;\n                        this._isRangeSupported = false;\n                        this._cachedChunks = [];\n                        this._requests = [];\n                        this._done = false;\n                        this._storedError = undefined;\n                        this._filename = null;\n                        this.onProgress = null;\n                    }\n                    _onHeadersReceived() {\n                        const fullRequestXhrId = this._fullRequestId;\n                        const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n                        const getResponseHeader = (name)=>{\n                            return fullRequestXhr.getResponseHeader(name);\n                        };\n                        const { allowRangeRequests, suggestedLength } = (0, _network_utils.validateRangeRequestCapabilities)({\n                            getResponseHeader,\n                            isHttp: this._manager.isHttp,\n                            rangeChunkSize: this._rangeChunkSize,\n                            disableRange: this._disableRange\n                        });\n                        if (allowRangeRequests) {\n                            this._isRangeSupported = true;\n                        }\n                        this._contentLength = suggestedLength || this._contentLength;\n                        this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n                        if (this._isRangeSupported) {\n                            this._manager.abortRequest(fullRequestXhrId);\n                        }\n                        this._headersReceivedCapability.resolve();\n                    }\n                    _onDone(data) {\n                        if (data) {\n                            if (this._requests.length > 0) {\n                                const requestCapability = this._requests.shift();\n                                requestCapability.resolve({\n                                    value: data.chunk,\n                                    done: false\n                                });\n                            } else {\n                                this._cachedChunks.push(data.chunk);\n                            }\n                        }\n                        this._done = true;\n                        if (this._cachedChunks.length > 0) {\n                            return;\n                        }\n                        for (const requestCapability of this._requests){\n                            requestCapability.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                    }\n                    _onError(status) {\n                        this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n                        this._headersReceivedCapability.reject(this._storedError);\n                        for (const requestCapability of this._requests){\n                            requestCapability.reject(this._storedError);\n                        }\n                        this._requests.length = 0;\n                        this._cachedChunks.length = 0;\n                    }\n                    _onProgress(evt) {\n                        this.onProgress?.({\n                            loaded: evt.loaded,\n                            total: evt.lengthComputable ? evt.total : this._contentLength\n                        });\n                    }\n                    get filename() {\n                        return this._filename;\n                    }\n                    get isRangeSupported() {\n                        return this._isRangeSupported;\n                    }\n                    get isStreamingSupported() {\n                        return this._isStreamingSupported;\n                    }\n                    get contentLength() {\n                        return this._contentLength;\n                    }\n                    get headersReady() {\n                        return this._headersReceivedCapability.promise;\n                    }\n                    async read() {\n                        if (this._storedError) {\n                            throw this._storedError;\n                        }\n                        if (this._cachedChunks.length > 0) {\n                            const chunk = this._cachedChunks.shift();\n                            return {\n                                value: chunk,\n                                done: false\n                            };\n                        }\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        const requestCapability = new _util.PromiseCapability();\n                        this._requests.push(requestCapability);\n                        return requestCapability.promise;\n                    }\n                    cancel(reason) {\n                        this._done = true;\n                        this._headersReceivedCapability.reject(reason);\n                        for (const requestCapability of this._requests){\n                            requestCapability.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                        if (this._manager.isPendingRequest(this._fullRequestId)) {\n                            this._manager.abortRequest(this._fullRequestId);\n                        }\n                        this._fullRequestReader = null;\n                    }\n                }\n                class PDFNetworkStreamRangeRequestReader {\n                    constructor(manager, begin, end){\n                        this._manager = manager;\n                        const args = {\n                            onDone: this._onDone.bind(this),\n                            onError: this._onError.bind(this),\n                            onProgress: this._onProgress.bind(this)\n                        };\n                        this._url = manager.url;\n                        this._requestId = manager.requestRange(begin, end, args);\n                        this._requests = [];\n                        this._queuedChunk = null;\n                        this._done = false;\n                        this._storedError = undefined;\n                        this.onProgress = null;\n                        this.onClosed = null;\n                    }\n                    _close() {\n                        this.onClosed?.(this);\n                    }\n                    _onDone(data) {\n                        const chunk = data.chunk;\n                        if (this._requests.length > 0) {\n                            const requestCapability = this._requests.shift();\n                            requestCapability.resolve({\n                                value: chunk,\n                                done: false\n                            });\n                        } else {\n                            this._queuedChunk = chunk;\n                        }\n                        this._done = true;\n                        for (const requestCapability of this._requests){\n                            requestCapability.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                        this._close();\n                    }\n                    _onError(status) {\n                        this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n                        for (const requestCapability of this._requests){\n                            requestCapability.reject(this._storedError);\n                        }\n                        this._requests.length = 0;\n                        this._queuedChunk = null;\n                    }\n                    _onProgress(evt) {\n                        if (!this.isStreamingSupported) {\n                            this.onProgress?.({\n                                loaded: evt.loaded\n                            });\n                        }\n                    }\n                    get isStreamingSupported() {\n                        return false;\n                    }\n                    async read() {\n                        if (this._storedError) {\n                            throw this._storedError;\n                        }\n                        if (this._queuedChunk !== null) {\n                            const chunk = this._queuedChunk;\n                            this._queuedChunk = null;\n                            return {\n                                value: chunk,\n                                done: false\n                            };\n                        }\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        const requestCapability = new _util.PromiseCapability();\n                        this._requests.push(requestCapability);\n                        return requestCapability.promise;\n                    }\n                    cancel(reason) {\n                        this._done = true;\n                        for (const requestCapability of this._requests){\n                            requestCapability.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                        if (this._manager.isPendingRequest(this._requestId)) {\n                            this._manager.abortRequest(this._requestId);\n                        }\n                        this._close();\n                    }\n                }\n            /***/ },\n            /* 23 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.PDFNodeStream = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _network_utils = __w_pdfjs_require__(20);\n                ;\n                const fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\n                function parseUrl(sourceUrl) {\n                    const url = __webpack_require__(/*! url */ \"url\");\n                    const parsedUrl = url.parse(sourceUrl);\n                    if (parsedUrl.protocol === \"file:\" || parsedUrl.host) {\n                        return parsedUrl;\n                    }\n                    if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\n                        return url.parse(`file:///${sourceUrl}`);\n                    }\n                    if (!parsedUrl.host) {\n                        parsedUrl.protocol = \"file:\";\n                    }\n                    return parsedUrl;\n                }\n                class PDFNodeStream {\n                    constructor(source){\n                        this.source = source;\n                        this.url = parseUrl(source.url);\n                        this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n                        this.isFsUrl = this.url.protocol === \"file:\";\n                        this.httpHeaders = this.isHttp && source.httpHeaders || {};\n                        this._fullRequestReader = null;\n                        this._rangeRequestReaders = [];\n                    }\n                    get _progressiveDataLength() {\n                        return this._fullRequestReader?._loaded ?? 0;\n                    }\n                    getFullReader() {\n                        (0, _util.assert)(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n                        this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\n                        return this._fullRequestReader;\n                    }\n                    getRangeReader(start, end) {\n                        if (end <= this._progressiveDataLength) {\n                            return null;\n                        }\n                        const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\n                        this._rangeRequestReaders.push(rangeReader);\n                        return rangeReader;\n                    }\n                    cancelAllRequests(reason) {\n                        this._fullRequestReader?.cancel(reason);\n                        for (const reader of this._rangeRequestReaders.slice(0)){\n                            reader.cancel(reason);\n                        }\n                    }\n                }\n                exports1.PDFNodeStream = PDFNodeStream;\n                class BaseFullReader {\n                    constructor(stream){\n                        this._url = stream.url;\n                        this._done = false;\n                        this._storedError = null;\n                        this.onProgress = null;\n                        const source = stream.source;\n                        this._contentLength = source.length;\n                        this._loaded = 0;\n                        this._filename = null;\n                        this._disableRange = source.disableRange || false;\n                        this._rangeChunkSize = source.rangeChunkSize;\n                        if (!this._rangeChunkSize && !this._disableRange) {\n                            this._disableRange = true;\n                        }\n                        this._isStreamingSupported = !source.disableStream;\n                        this._isRangeSupported = !source.disableRange;\n                        this._readableStream = null;\n                        this._readCapability = new _util.PromiseCapability();\n                        this._headersCapability = new _util.PromiseCapability();\n                    }\n                    get headersReady() {\n                        return this._headersCapability.promise;\n                    }\n                    get filename() {\n                        return this._filename;\n                    }\n                    get contentLength() {\n                        return this._contentLength;\n                    }\n                    get isRangeSupported() {\n                        return this._isRangeSupported;\n                    }\n                    get isStreamingSupported() {\n                        return this._isStreamingSupported;\n                    }\n                    async read() {\n                        await this._readCapability.promise;\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        if (this._storedError) {\n                            throw this._storedError;\n                        }\n                        const chunk = this._readableStream.read();\n                        if (chunk === null) {\n                            this._readCapability = new _util.PromiseCapability();\n                            return this.read();\n                        }\n                        this._loaded += chunk.length;\n                        this.onProgress?.({\n                            loaded: this._loaded,\n                            total: this._contentLength\n                        });\n                        const buffer = new Uint8Array(chunk).buffer;\n                        return {\n                            value: buffer,\n                            done: false\n                        };\n                    }\n                    cancel(reason) {\n                        if (!this._readableStream) {\n                            this._error(reason);\n                            return;\n                        }\n                        this._readableStream.destroy(reason);\n                    }\n                    _error(reason) {\n                        this._storedError = reason;\n                        this._readCapability.resolve();\n                    }\n                    _setReadableStream(readableStream) {\n                        this._readableStream = readableStream;\n                        readableStream.on(\"readable\", ()=>{\n                            this._readCapability.resolve();\n                        });\n                        readableStream.on(\"end\", ()=>{\n                            readableStream.destroy();\n                            this._done = true;\n                            this._readCapability.resolve();\n                        });\n                        readableStream.on(\"error\", (reason)=>{\n                            this._error(reason);\n                        });\n                        if (!this._isStreamingSupported && this._isRangeSupported) {\n                            this._error(new _util.AbortException(\"streaming is disabled\"));\n                        }\n                        if (this._storedError) {\n                            this._readableStream.destroy(this._storedError);\n                        }\n                    }\n                }\n                class BaseRangeReader {\n                    constructor(stream){\n                        this._url = stream.url;\n                        this._done = false;\n                        this._storedError = null;\n                        this.onProgress = null;\n                        this._loaded = 0;\n                        this._readableStream = null;\n                        this._readCapability = new _util.PromiseCapability();\n                        const source = stream.source;\n                        this._isStreamingSupported = !source.disableStream;\n                    }\n                    get isStreamingSupported() {\n                        return this._isStreamingSupported;\n                    }\n                    async read() {\n                        await this._readCapability.promise;\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        if (this._storedError) {\n                            throw this._storedError;\n                        }\n                        const chunk = this._readableStream.read();\n                        if (chunk === null) {\n                            this._readCapability = new _util.PromiseCapability();\n                            return this.read();\n                        }\n                        this._loaded += chunk.length;\n                        this.onProgress?.({\n                            loaded: this._loaded\n                        });\n                        const buffer = new Uint8Array(chunk).buffer;\n                        return {\n                            value: buffer,\n                            done: false\n                        };\n                    }\n                    cancel(reason) {\n                        if (!this._readableStream) {\n                            this._error(reason);\n                            return;\n                        }\n                        this._readableStream.destroy(reason);\n                    }\n                    _error(reason) {\n                        this._storedError = reason;\n                        this._readCapability.resolve();\n                    }\n                    _setReadableStream(readableStream) {\n                        this._readableStream = readableStream;\n                        readableStream.on(\"readable\", ()=>{\n                            this._readCapability.resolve();\n                        });\n                        readableStream.on(\"end\", ()=>{\n                            readableStream.destroy();\n                            this._done = true;\n                            this._readCapability.resolve();\n                        });\n                        readableStream.on(\"error\", (reason)=>{\n                            this._error(reason);\n                        });\n                        if (this._storedError) {\n                            this._readableStream.destroy(this._storedError);\n                        }\n                    }\n                }\n                function createRequestOptions(parsedUrl, headers) {\n                    return {\n                        protocol: parsedUrl.protocol,\n                        auth: parsedUrl.auth,\n                        host: parsedUrl.hostname,\n                        port: parsedUrl.port,\n                        path: parsedUrl.path,\n                        method: \"GET\",\n                        headers\n                    };\n                }\n                class PDFNodeStreamFullReader extends BaseFullReader {\n                    constructor(stream){\n                        super(stream);\n                        const handleResponse = (response)=>{\n                            if (response.statusCode === 404) {\n                                const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n                                this._storedError = error;\n                                this._headersCapability.reject(error);\n                                return;\n                            }\n                            this._headersCapability.resolve();\n                            this._setReadableStream(response);\n                            const getResponseHeader = (name)=>{\n                                return this._readableStream.headers[name.toLowerCase()];\n                            };\n                            const { allowRangeRequests, suggestedLength } = (0, _network_utils.validateRangeRequestCapabilities)({\n                                getResponseHeader,\n                                isHttp: stream.isHttp,\n                                rangeChunkSize: this._rangeChunkSize,\n                                disableRange: this._disableRange\n                            });\n                            this._isRangeSupported = allowRangeRequests;\n                            this._contentLength = suggestedLength || this._contentLength;\n                            this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n                        };\n                        this._request = null;\n                        if (this._url.protocol === \"http:\") {\n                            const http = __webpack_require__(/*! http */ \"http\");\n                            this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n                        } else {\n                            const https = __webpack_require__(/*! https */ \"https\");\n                            this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n                        }\n                        this._request.on(\"error\", (reason)=>{\n                            this._storedError = reason;\n                            this._headersCapability.reject(reason);\n                        });\n                        this._request.end();\n                    }\n                }\n                class PDFNodeStreamRangeReader extends BaseRangeReader {\n                    constructor(stream, start, end){\n                        super(stream);\n                        this._httpHeaders = {};\n                        for(const property in stream.httpHeaders){\n                            const value = stream.httpHeaders[property];\n                            if (value === undefined) {\n                                continue;\n                            }\n                            this._httpHeaders[property] = value;\n                        }\n                        this._httpHeaders.Range = `bytes=${start}-${end - 1}`;\n                        const handleResponse = (response)=>{\n                            if (response.statusCode === 404) {\n                                const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n                                this._storedError = error;\n                                return;\n                            }\n                            this._setReadableStream(response);\n                        };\n                        this._request = null;\n                        if (this._url.protocol === \"http:\") {\n                            const http = __webpack_require__(/*! http */ \"http\");\n                            this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n                        } else {\n                            const https = __webpack_require__(/*! https */ \"https\");\n                            this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n                        }\n                        this._request.on(\"error\", (reason)=>{\n                            this._storedError = reason;\n                        });\n                        this._request.end();\n                    }\n                }\n                class PDFNodeStreamFsFullReader extends BaseFullReader {\n                    constructor(stream){\n                        super(stream);\n                        let path = decodeURIComponent(this._url.path);\n                        if (fileUriRegex.test(this._url.href)) {\n                            path = path.replace(/^\\//, \"\");\n                        }\n                        const fs = __webpack_require__(/*! fs */ \"fs\");\n                        fs.lstat(path, (error, stat)=>{\n                            if (error) {\n                                if (error.code === \"ENOENT\") {\n                                    error = new _util.MissingPDFException(`Missing PDF \"${path}\".`);\n                                }\n                                this._storedError = error;\n                                this._headersCapability.reject(error);\n                                return;\n                            }\n                            this._contentLength = stat.size;\n                            this._setReadableStream(fs.createReadStream(path));\n                            this._headersCapability.resolve();\n                        });\n                    }\n                }\n                class PDFNodeStreamFsRangeReader extends BaseRangeReader {\n                    constructor(stream, start, end){\n                        super(stream);\n                        let path = decodeURIComponent(this._url.path);\n                        if (fileUriRegex.test(this._url.href)) {\n                            path = path.replace(/^\\//, \"\");\n                        }\n                        const fs = __webpack_require__(/*! fs */ \"fs\");\n                        this._setReadableStream(fs.createReadStream(path, {\n                            start,\n                            end: end - 1\n                        }));\n                    }\n                }\n            /***/ },\n            /* 24 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.SVGGraphics = void 0;\n                var _display_utils = __w_pdfjs_require__(6);\n                var _util = __w_pdfjs_require__(1);\n                ;\n                const SVG_DEFAULTS = {\n                    fontStyle: \"normal\",\n                    fontWeight: \"normal\",\n                    fillColor: \"#000000\"\n                };\n                const XML_NS = \"http://www.w3.org/XML/1998/namespace\";\n                const XLINK_NS = \"http://www.w3.org/1999/xlink\";\n                const LINE_CAP_STYLES = [\n                    \"butt\",\n                    \"round\",\n                    \"square\"\n                ];\n                const LINE_JOIN_STYLES = [\n                    \"miter\",\n                    \"round\",\n                    \"bevel\"\n                ];\n                const createObjectURL = function(data, contentType = \"\", forceDataSchema = false) {\n                    if (URL.createObjectURL && typeof Blob !== \"undefined\" && !forceDataSchema) {\n                        return URL.createObjectURL(new Blob([\n                            data\n                        ], {\n                            type: contentType\n                        }));\n                    }\n                    const digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n                    let buffer = `data:${contentType};base64,`;\n                    for(let i = 0, ii = data.length; i < ii; i += 3){\n                        const b1 = data[i] & 0xff;\n                        const b2 = data[i + 1] & 0xff;\n                        const b3 = data[i + 2] & 0xff;\n                        const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;\n                        const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;\n                        const d4 = i + 2 < ii ? b3 & 0x3f : 64;\n                        buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n                    }\n                    return buffer;\n                };\n                const convertImgDataToPng = function() {\n                    const PNG_HEADER = new Uint8Array([\n                        0x89,\n                        0x50,\n                        0x4e,\n                        0x47,\n                        0x0d,\n                        0x0a,\n                        0x1a,\n                        0x0a\n                    ]);\n                    const CHUNK_WRAPPER_SIZE = 12;\n                    const crcTable = new Int32Array(256);\n                    for(let i = 0; i < 256; i++){\n                        let c = i;\n                        for(let h = 0; h < 8; h++){\n                            c = c & 1 ? 0xedb88320 ^ c >> 1 & 0x7fffffff : c >> 1 & 0x7fffffff;\n                        }\n                        crcTable[i] = c;\n                    }\n                    function crc32(data, start, end) {\n                        let crc = -1;\n                        for(let i = start; i < end; i++){\n                            const a = (crc ^ data[i]) & 0xff;\n                            const b = crcTable[a];\n                            crc = crc >>> 8 ^ b;\n                        }\n                        return crc ^ -1;\n                    }\n                    function writePngChunk(type, body, data, offset) {\n                        let p = offset;\n                        const len = body.length;\n                        data[p] = len >> 24 & 0xff;\n                        data[p + 1] = len >> 16 & 0xff;\n                        data[p + 2] = len >> 8 & 0xff;\n                        data[p + 3] = len & 0xff;\n                        p += 4;\n                        data[p] = type.charCodeAt(0) & 0xff;\n                        data[p + 1] = type.charCodeAt(1) & 0xff;\n                        data[p + 2] = type.charCodeAt(2) & 0xff;\n                        data[p + 3] = type.charCodeAt(3) & 0xff;\n                        p += 4;\n                        data.set(body, p);\n                        p += body.length;\n                        const crc = crc32(data, offset + 4, p);\n                        data[p] = crc >> 24 & 0xff;\n                        data[p + 1] = crc >> 16 & 0xff;\n                        data[p + 2] = crc >> 8 & 0xff;\n                        data[p + 3] = crc & 0xff;\n                    }\n                    function adler32(data, start, end) {\n                        let a = 1;\n                        let b = 0;\n                        for(let i = start; i < end; ++i){\n                            a = (a + (data[i] & 0xff)) % 65521;\n                            b = (b + a) % 65521;\n                        }\n                        return b << 16 | a;\n                    }\n                    function deflateSync(literals) {\n                        if (!_util.isNodeJS) {\n                            return deflateSyncUncompressed(literals);\n                        }\n                        try {\n                            const input = parseInt(process.versions.node) >= 8 ? literals : Buffer.from(literals);\n                            const output = (__webpack_require__(/*! zlib */ \"zlib\").deflateSync)(input, {\n                                level: 9\n                            });\n                            return output instanceof Uint8Array ? output : new Uint8Array(output);\n                        } catch (e) {\n                            (0, _util.warn)(\"Not compressing PNG because zlib.deflateSync is unavailable: \" + e);\n                        }\n                        return deflateSyncUncompressed(literals);\n                    }\n                    function deflateSyncUncompressed(literals) {\n                        let len = literals.length;\n                        const maxBlockLength = 0xffff;\n                        const deflateBlocks = Math.ceil(len / maxBlockLength);\n                        const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\n                        let pi = 0;\n                        idat[pi++] = 0x78;\n                        idat[pi++] = 0x9c;\n                        let pos = 0;\n                        while(len > maxBlockLength){\n                            idat[pi++] = 0x00;\n                            idat[pi++] = 0xff;\n                            idat[pi++] = 0xff;\n                            idat[pi++] = 0x00;\n                            idat[pi++] = 0x00;\n                            idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\n                            pi += maxBlockLength;\n                            pos += maxBlockLength;\n                            len -= maxBlockLength;\n                        }\n                        idat[pi++] = 0x01;\n                        idat[pi++] = len & 0xff;\n                        idat[pi++] = len >> 8 & 0xff;\n                        idat[pi++] = ~len & 0xffff & 0xff;\n                        idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\n                        idat.set(literals.subarray(pos), pi);\n                        pi += literals.length - pos;\n                        const adler = adler32(literals, 0, literals.length);\n                        idat[pi++] = adler >> 24 & 0xff;\n                        idat[pi++] = adler >> 16 & 0xff;\n                        idat[pi++] = adler >> 8 & 0xff;\n                        idat[pi++] = adler & 0xff;\n                        return idat;\n                    }\n                    function encode(imgData, kind, forceDataSchema, isMask) {\n                        const width = imgData.width;\n                        const height = imgData.height;\n                        let bitDepth, colorType, lineSize;\n                        const bytes = imgData.data;\n                        switch(kind){\n                            case _util.ImageKind.GRAYSCALE_1BPP:\n                                colorType = 0;\n                                bitDepth = 1;\n                                lineSize = width + 7 >> 3;\n                                break;\n                            case _util.ImageKind.RGB_24BPP:\n                                colorType = 2;\n                                bitDepth = 8;\n                                lineSize = width * 3;\n                                break;\n                            case _util.ImageKind.RGBA_32BPP:\n                                colorType = 6;\n                                bitDepth = 8;\n                                lineSize = width * 4;\n                                break;\n                            default:\n                                throw new Error(\"invalid format\");\n                        }\n                        const literals = new Uint8Array((1 + lineSize) * height);\n                        let offsetLiterals = 0, offsetBytes = 0;\n                        for(let y = 0; y < height; ++y){\n                            literals[offsetLiterals++] = 0;\n                            literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);\n                            offsetBytes += lineSize;\n                            offsetLiterals += lineSize;\n                        }\n                        if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {\n                            offsetLiterals = 0;\n                            for(let y = 0; y < height; y++){\n                                offsetLiterals++;\n                                for(let i = 0; i < lineSize; i++){\n                                    literals[offsetLiterals++] ^= 0xff;\n                                }\n                            }\n                        }\n                        const ihdr = new Uint8Array([\n                            width >> 24 & 0xff,\n                            width >> 16 & 0xff,\n                            width >> 8 & 0xff,\n                            width & 0xff,\n                            height >> 24 & 0xff,\n                            height >> 16 & 0xff,\n                            height >> 8 & 0xff,\n                            height & 0xff,\n                            bitDepth,\n                            colorType,\n                            0x00,\n                            0x00,\n                            0x00\n                        ]);\n                        const idat = deflateSync(literals);\n                        const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\n                        const data = new Uint8Array(pngLength);\n                        let offset = 0;\n                        data.set(PNG_HEADER, offset);\n                        offset += PNG_HEADER.length;\n                        writePngChunk(\"IHDR\", ihdr, data, offset);\n                        offset += CHUNK_WRAPPER_SIZE + ihdr.length;\n                        writePngChunk(\"IDATA\", idat, data, offset);\n                        offset += CHUNK_WRAPPER_SIZE + idat.length;\n                        writePngChunk(\"IEND\", new Uint8Array(0), data, offset);\n                        return createObjectURL(data, \"image/png\", forceDataSchema);\n                    }\n                    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {\n                        const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;\n                        return encode(imgData, kind, forceDataSchema, isMask);\n                    };\n                }();\n                class SVGExtraState {\n                    constructor(){\n                        this.fontSizeScale = 1;\n                        this.fontWeight = SVG_DEFAULTS.fontWeight;\n                        this.fontSize = 0;\n                        this.textMatrix = _util.IDENTITY_MATRIX;\n                        this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n                        this.leading = 0;\n                        this.textRenderingMode = _util.TextRenderingMode.FILL;\n                        this.textMatrixScale = 1;\n                        this.x = 0;\n                        this.y = 0;\n                        this.lineX = 0;\n                        this.lineY = 0;\n                        this.charSpacing = 0;\n                        this.wordSpacing = 0;\n                        this.textHScale = 1;\n                        this.textRise = 0;\n                        this.fillColor = SVG_DEFAULTS.fillColor;\n                        this.strokeColor = \"#000000\";\n                        this.fillAlpha = 1;\n                        this.strokeAlpha = 1;\n                        this.lineWidth = 1;\n                        this.lineJoin = \"\";\n                        this.lineCap = \"\";\n                        this.miterLimit = 0;\n                        this.dashArray = [];\n                        this.dashPhase = 0;\n                        this.dependencies = [];\n                        this.activeClipUrl = null;\n                        this.clipGroup = null;\n                        this.maskId = \"\";\n                    }\n                    clone() {\n                        return Object.create(this);\n                    }\n                    setCurrentPoint(x, y) {\n                        this.x = x;\n                        this.y = y;\n                    }\n                }\n                function opListToTree(opList) {\n                    let opTree = [];\n                    const tmp = [];\n                    for (const opListElement of opList){\n                        if (opListElement.fn === \"save\") {\n                            opTree.push({\n                                fnId: 92,\n                                fn: \"group\",\n                                items: []\n                            });\n                            tmp.push(opTree);\n                            opTree = opTree.at(-1).items;\n                            continue;\n                        }\n                        if (opListElement.fn === \"restore\") {\n                            opTree = tmp.pop();\n                        } else {\n                            opTree.push(opListElement);\n                        }\n                    }\n                    return opTree;\n                }\n                function pf(value) {\n                    if (Number.isInteger(value)) {\n                        return value.toString();\n                    }\n                    const s = value.toFixed(10);\n                    let i = s.length - 1;\n                    if (s[i] !== \"0\") {\n                        return s;\n                    }\n                    do {\n                        i--;\n                    }while (s[i] === \"0\");\n                    return s.substring(0, s[i] === \".\" ? i : i + 1);\n                }\n                function pm(m) {\n                    if (m[4] === 0 && m[5] === 0) {\n                        if (m[1] === 0 && m[2] === 0) {\n                            if (m[0] === 1 && m[3] === 1) {\n                                return \"\";\n                            }\n                            return `scale(${pf(m[0])} ${pf(m[3])})`;\n                        }\n                        if (m[0] === m[3] && m[1] === -m[2]) {\n                            const a = Math.acos(m[0]) * 180 / Math.PI;\n                            return `rotate(${pf(a)})`;\n                        }\n                    } else if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\n                        return `translate(${pf(m[4])} ${pf(m[5])})`;\n                    }\n                    return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;\n                }\n                let clipCount = 0;\n                let maskCount = 0;\n                let shadingCount = 0;\n                class SVGGraphics {\n                    constructor(commonObjs, objs, forceDataSchema = false){\n                        (0, _display_utils.deprecated)(\"The SVG back-end is no longer maintained and *may* be removed in the future.\");\n                        this.svgFactory = new _display_utils.DOMSVGFactory();\n                        this.current = new SVGExtraState();\n                        this.transformMatrix = _util.IDENTITY_MATRIX;\n                        this.transformStack = [];\n                        this.extraStack = [];\n                        this.commonObjs = commonObjs;\n                        this.objs = objs;\n                        this.pendingClip = null;\n                        this.pendingEOFill = false;\n                        this.embedFonts = false;\n                        this.embeddedFonts = Object.create(null);\n                        this.cssStyle = null;\n                        this.forceDataSchema = !!forceDataSchema;\n                        this._operatorIdMapping = [];\n                        for(const op in _util.OPS){\n                            this._operatorIdMapping[_util.OPS[op]] = op;\n                        }\n                    }\n                    getObject(data, fallback = null) {\n                        if (typeof data === \"string\") {\n                            return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n                        }\n                        return fallback;\n                    }\n                    save() {\n                        this.transformStack.push(this.transformMatrix);\n                        const old = this.current;\n                        this.extraStack.push(old);\n                        this.current = old.clone();\n                    }\n                    restore() {\n                        this.transformMatrix = this.transformStack.pop();\n                        this.current = this.extraStack.pop();\n                        this.pendingClip = null;\n                        this.tgrp = null;\n                    }\n                    group(items) {\n                        this.save();\n                        this.executeOpTree(items);\n                        this.restore();\n                    }\n                    loadDependencies(operatorList) {\n                        const fnArray = operatorList.fnArray;\n                        const argsArray = operatorList.argsArray;\n                        for(let i = 0, ii = fnArray.length; i < ii; i++){\n                            if (fnArray[i] !== _util.OPS.dependency) {\n                                continue;\n                            }\n                            for (const obj of argsArray[i]){\n                                const objsPool = obj.startsWith(\"g_\") ? this.commonObjs : this.objs;\n                                const promise = new Promise((resolve)=>{\n                                    objsPool.get(obj, resolve);\n                                });\n                                this.current.dependencies.push(promise);\n                            }\n                        }\n                        return Promise.all(this.current.dependencies);\n                    }\n                    transform(a, b, c, d, e, f) {\n                        const transformMatrix = [\n                            a,\n                            b,\n                            c,\n                            d,\n                            e,\n                            f\n                        ];\n                        this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);\n                        this.tgrp = null;\n                    }\n                    getSVG(operatorList, viewport) {\n                        this.viewport = viewport;\n                        const svgElement = this._initialize(viewport);\n                        return this.loadDependencies(operatorList).then(()=>{\n                            this.transformMatrix = _util.IDENTITY_MATRIX;\n                            this.executeOpTree(this.convertOpList(operatorList));\n                            return svgElement;\n                        });\n                    }\n                    convertOpList(operatorList) {\n                        const operatorIdMapping = this._operatorIdMapping;\n                        const argsArray = operatorList.argsArray;\n                        const fnArray = operatorList.fnArray;\n                        const opList = [];\n                        for(let i = 0, ii = fnArray.length; i < ii; i++){\n                            const fnId = fnArray[i];\n                            opList.push({\n                                fnId,\n                                fn: operatorIdMapping[fnId],\n                                args: argsArray[i]\n                            });\n                        }\n                        return opListToTree(opList);\n                    }\n                    executeOpTree(opTree) {\n                        for (const opTreeElement of opTree){\n                            const fn = opTreeElement.fn;\n                            const fnId = opTreeElement.fnId;\n                            const args = opTreeElement.args;\n                            switch(fnId | 0){\n                                case _util.OPS.beginText:\n                                    this.beginText();\n                                    break;\n                                case _util.OPS.dependency:\n                                    break;\n                                case _util.OPS.setLeading:\n                                    this.setLeading(args);\n                                    break;\n                                case _util.OPS.setLeadingMoveText:\n                                    this.setLeadingMoveText(args[0], args[1]);\n                                    break;\n                                case _util.OPS.setFont:\n                                    this.setFont(args);\n                                    break;\n                                case _util.OPS.showText:\n                                    this.showText(args[0]);\n                                    break;\n                                case _util.OPS.showSpacedText:\n                                    this.showText(args[0]);\n                                    break;\n                                case _util.OPS.endText:\n                                    this.endText();\n                                    break;\n                                case _util.OPS.moveText:\n                                    this.moveText(args[0], args[1]);\n                                    break;\n                                case _util.OPS.setCharSpacing:\n                                    this.setCharSpacing(args[0]);\n                                    break;\n                                case _util.OPS.setWordSpacing:\n                                    this.setWordSpacing(args[0]);\n                                    break;\n                                case _util.OPS.setHScale:\n                                    this.setHScale(args[0]);\n                                    break;\n                                case _util.OPS.setTextMatrix:\n                                    this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\n                                    break;\n                                case _util.OPS.setTextRise:\n                                    this.setTextRise(args[0]);\n                                    break;\n                                case _util.OPS.setTextRenderingMode:\n                                    this.setTextRenderingMode(args[0]);\n                                    break;\n                                case _util.OPS.setLineWidth:\n                                    this.setLineWidth(args[0]);\n                                    break;\n                                case _util.OPS.setLineJoin:\n                                    this.setLineJoin(args[0]);\n                                    break;\n                                case _util.OPS.setLineCap:\n                                    this.setLineCap(args[0]);\n                                    break;\n                                case _util.OPS.setMiterLimit:\n                                    this.setMiterLimit(args[0]);\n                                    break;\n                                case _util.OPS.setFillRGBColor:\n                                    this.setFillRGBColor(args[0], args[1], args[2]);\n                                    break;\n                                case _util.OPS.setStrokeRGBColor:\n                                    this.setStrokeRGBColor(args[0], args[1], args[2]);\n                                    break;\n                                case _util.OPS.setStrokeColorN:\n                                    this.setStrokeColorN(args);\n                                    break;\n                                case _util.OPS.setFillColorN:\n                                    this.setFillColorN(args);\n                                    break;\n                                case _util.OPS.shadingFill:\n                                    this.shadingFill(args[0]);\n                                    break;\n                                case _util.OPS.setDash:\n                                    this.setDash(args[0], args[1]);\n                                    break;\n                                case _util.OPS.setRenderingIntent:\n                                    this.setRenderingIntent(args[0]);\n                                    break;\n                                case _util.OPS.setFlatness:\n                                    this.setFlatness(args[0]);\n                                    break;\n                                case _util.OPS.setGState:\n                                    this.setGState(args[0]);\n                                    break;\n                                case _util.OPS.fill:\n                                    this.fill();\n                                    break;\n                                case _util.OPS.eoFill:\n                                    this.eoFill();\n                                    break;\n                                case _util.OPS.stroke:\n                                    this.stroke();\n                                    break;\n                                case _util.OPS.fillStroke:\n                                    this.fillStroke();\n                                    break;\n                                case _util.OPS.eoFillStroke:\n                                    this.eoFillStroke();\n                                    break;\n                                case _util.OPS.clip:\n                                    this.clip(\"nonzero\");\n                                    break;\n                                case _util.OPS.eoClip:\n                                    this.clip(\"evenodd\");\n                                    break;\n                                case _util.OPS.paintSolidColorImageMask:\n                                    this.paintSolidColorImageMask();\n                                    break;\n                                case _util.OPS.paintImageXObject:\n                                    this.paintImageXObject(args[0]);\n                                    break;\n                                case _util.OPS.paintInlineImageXObject:\n                                    this.paintInlineImageXObject(args[0]);\n                                    break;\n                                case _util.OPS.paintImageMaskXObject:\n                                    this.paintImageMaskXObject(args[0]);\n                                    break;\n                                case _util.OPS.paintFormXObjectBegin:\n                                    this.paintFormXObjectBegin(args[0], args[1]);\n                                    break;\n                                case _util.OPS.paintFormXObjectEnd:\n                                    this.paintFormXObjectEnd();\n                                    break;\n                                case _util.OPS.closePath:\n                                    this.closePath();\n                                    break;\n                                case _util.OPS.closeStroke:\n                                    this.closeStroke();\n                                    break;\n                                case _util.OPS.closeFillStroke:\n                                    this.closeFillStroke();\n                                    break;\n                                case _util.OPS.closeEOFillStroke:\n                                    this.closeEOFillStroke();\n                                    break;\n                                case _util.OPS.nextLine:\n                                    this.nextLine();\n                                    break;\n                                case _util.OPS.transform:\n                                    this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);\n                                    break;\n                                case _util.OPS.constructPath:\n                                    this.constructPath(args[0], args[1]);\n                                    break;\n                                case _util.OPS.endPath:\n                                    this.endPath();\n                                    break;\n                                case 92:\n                                    this.group(opTreeElement.items);\n                                    break;\n                                default:\n                                    (0, _util.warn)(`Unimplemented operator ${fn}`);\n                                    break;\n                            }\n                        }\n                    }\n                    setWordSpacing(wordSpacing) {\n                        this.current.wordSpacing = wordSpacing;\n                    }\n                    setCharSpacing(charSpacing) {\n                        this.current.charSpacing = charSpacing;\n                    }\n                    nextLine() {\n                        this.moveText(0, this.current.leading);\n                    }\n                    setTextMatrix(a, b, c, d, e, f) {\n                        const current = this.current;\n                        current.textMatrix = current.lineMatrix = [\n                            a,\n                            b,\n                            c,\n                            d,\n                            e,\n                            f\n                        ];\n                        current.textMatrixScale = Math.hypot(a, b);\n                        current.x = current.lineX = 0;\n                        current.y = current.lineY = 0;\n                        current.xcoords = [];\n                        current.ycoords = [];\n                        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                        current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n                        current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n                        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n                        current.txtElement = this.svgFactory.createElement(\"svg:text\");\n                        current.txtElement.append(current.tspan);\n                    }\n                    beginText() {\n                        const current = this.current;\n                        current.x = current.lineX = 0;\n                        current.y = current.lineY = 0;\n                        current.textMatrix = _util.IDENTITY_MATRIX;\n                        current.lineMatrix = _util.IDENTITY_MATRIX;\n                        current.textMatrixScale = 1;\n                        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                        current.txtElement = this.svgFactory.createElement(\"svg:text\");\n                        current.txtgrp = this.svgFactory.createElement(\"svg:g\");\n                        current.xcoords = [];\n                        current.ycoords = [];\n                    }\n                    moveText(x, y) {\n                        const current = this.current;\n                        current.x = current.lineX += x;\n                        current.y = current.lineY += y;\n                        current.xcoords = [];\n                        current.ycoords = [];\n                        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                        current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n                        current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n                        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n                    }\n                    showText(glyphs) {\n                        const current = this.current;\n                        const font = current.font;\n                        const fontSize = current.fontSize;\n                        if (fontSize === 0) {\n                            return;\n                        }\n                        const fontSizeScale = current.fontSizeScale;\n                        const charSpacing = current.charSpacing;\n                        const wordSpacing = current.wordSpacing;\n                        const fontDirection = current.fontDirection;\n                        const textHScale = current.textHScale * fontDirection;\n                        const vertical = font.vertical;\n                        const spacingDir = vertical ? 1 : -1;\n                        const defaultVMetrics = font.defaultVMetrics;\n                        const widthAdvanceScale = fontSize * current.fontMatrix[0];\n                        let x = 0;\n                        for (const glyph of glyphs){\n                            if (glyph === null) {\n                                x += fontDirection * wordSpacing;\n                                continue;\n                            } else if (typeof glyph === \"number\") {\n                                x += spacingDir * glyph * fontSize / 1000;\n                                continue;\n                            }\n                            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n                            const character = glyph.fontChar;\n                            let scaledX, scaledY;\n                            let width = glyph.width;\n                            if (vertical) {\n                                let vx;\n                                const vmetric = glyph.vmetric || defaultVMetrics;\n                                vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n                                vx = -vx * widthAdvanceScale;\n                                const vy = vmetric[2] * widthAdvanceScale;\n                                width = vmetric ? -vmetric[0] : width;\n                                scaledX = vx / fontSizeScale;\n                                scaledY = (x + vy) / fontSizeScale;\n                            } else {\n                                scaledX = x / fontSizeScale;\n                                scaledY = 0;\n                            }\n                            if (glyph.isInFont || font.missingFile) {\n                                current.xcoords.push(current.x + scaledX);\n                                if (vertical) {\n                                    current.ycoords.push(-current.y + scaledY);\n                                }\n                                current.tspan.textContent += character;\n                            } else {}\n                            const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n                            x += charWidth;\n                        }\n                        current.tspan.setAttributeNS(null, \"x\", current.xcoords.map(pf).join(\" \"));\n                        if (vertical) {\n                            current.tspan.setAttributeNS(null, \"y\", current.ycoords.map(pf).join(\" \"));\n                        } else {\n                            current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n                        }\n                        if (vertical) {\n                            current.y -= x;\n                        } else {\n                            current.x += x * textHScale;\n                        }\n                        current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n                        current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n                        if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\n                            current.tspan.setAttributeNS(null, \"font-style\", current.fontStyle);\n                        }\n                        if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\n                            current.tspan.setAttributeNS(null, \"font-weight\", current.fontWeight);\n                        }\n                        const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n                        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                            if (current.fillColor !== SVG_DEFAULTS.fillColor) {\n                                current.tspan.setAttributeNS(null, \"fill\", current.fillColor);\n                            }\n                            if (current.fillAlpha < 1) {\n                                current.tspan.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n                            }\n                        } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {\n                            current.tspan.setAttributeNS(null, \"fill\", \"transparent\");\n                        } else {\n                            current.tspan.setAttributeNS(null, \"fill\", \"none\");\n                        }\n                        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                            const lineWidthScale = 1 / (current.textMatrixScale || 1);\n                            this._setStrokeAttributes(current.tspan, lineWidthScale);\n                        }\n                        let textMatrix = current.textMatrix;\n                        if (current.textRise !== 0) {\n                            textMatrix = textMatrix.slice();\n                            textMatrix[5] += current.textRise;\n                        }\n                        current.txtElement.setAttributeNS(null, \"transform\", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);\n                        current.txtElement.setAttributeNS(XML_NS, \"xml:space\", \"preserve\");\n                        current.txtElement.append(current.tspan);\n                        current.txtgrp.append(current.txtElement);\n                        this._ensureTransformGroup().append(current.txtElement);\n                    }\n                    setLeadingMoveText(x, y) {\n                        this.setLeading(-y);\n                        this.moveText(x, y);\n                    }\n                    addFontStyle(fontObj) {\n                        if (!fontObj.data) {\n                            throw new Error(\"addFontStyle: No font data available, \" + 'ensure that the \"fontExtraProperties\" API parameter is set.');\n                        }\n                        if (!this.cssStyle) {\n                            this.cssStyle = this.svgFactory.createElement(\"svg:style\");\n                            this.cssStyle.setAttributeNS(null, \"type\", \"text/css\");\n                            this.defs.append(this.cssStyle);\n                        }\n                        const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);\n                        this.cssStyle.textContent += `@font-face { font-family: \"${fontObj.loadedName}\";` + ` src: url(${url}); }\\n`;\n                    }\n                    setFont(details) {\n                        const current = this.current;\n                        const fontObj = this.commonObjs.get(details[0]);\n                        let size = details[1];\n                        current.font = fontObj;\n                        if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {\n                            this.addFontStyle(fontObj);\n                            this.embeddedFonts[fontObj.loadedName] = fontObj;\n                        }\n                        current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n                        let bold = \"normal\";\n                        if (fontObj.black) {\n                            bold = \"900\";\n                        } else if (fontObj.bold) {\n                            bold = \"bold\";\n                        }\n                        const italic = fontObj.italic ? \"italic\" : \"normal\";\n                        if (size < 0) {\n                            size = -size;\n                            current.fontDirection = -1;\n                        } else {\n                            current.fontDirection = 1;\n                        }\n                        current.fontSize = size;\n                        current.fontFamily = fontObj.loadedName;\n                        current.fontWeight = bold;\n                        current.fontStyle = italic;\n                        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n                        current.xcoords = [];\n                        current.ycoords = [];\n                    }\n                    endText() {\n                        const current = this.current;\n                        if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {\n                            current.element = current.txtElement;\n                            this.clip(\"nonzero\");\n                            this.endPath();\n                        }\n                    }\n                    setLineWidth(width) {\n                        if (width > 0) {\n                            this.current.lineWidth = width;\n                        }\n                    }\n                    setLineCap(style) {\n                        this.current.lineCap = LINE_CAP_STYLES[style];\n                    }\n                    setLineJoin(style) {\n                        this.current.lineJoin = LINE_JOIN_STYLES[style];\n                    }\n                    setMiterLimit(limit) {\n                        this.current.miterLimit = limit;\n                    }\n                    setStrokeAlpha(strokeAlpha) {\n                        this.current.strokeAlpha = strokeAlpha;\n                    }\n                    setStrokeRGBColor(r, g, b) {\n                        this.current.strokeColor = _util.Util.makeHexColor(r, g, b);\n                    }\n                    setFillAlpha(fillAlpha) {\n                        this.current.fillAlpha = fillAlpha;\n                    }\n                    setFillRGBColor(r, g, b) {\n                        this.current.fillColor = _util.Util.makeHexColor(r, g, b);\n                        this.current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                        this.current.xcoords = [];\n                        this.current.ycoords = [];\n                    }\n                    setStrokeColorN(args) {\n                        this.current.strokeColor = this._makeColorN_Pattern(args);\n                    }\n                    setFillColorN(args) {\n                        this.current.fillColor = this._makeColorN_Pattern(args);\n                    }\n                    shadingFill(args) {\n                        const { width, height } = this.viewport;\n                        const inv = _util.Util.inverseTransform(this.transformMatrix);\n                        const [x0, y0, x1, y1] = _util.Util.getAxialAlignedBoundingBox([\n                            0,\n                            0,\n                            width,\n                            height\n                        ], inv);\n                        const rect = this.svgFactory.createElement(\"svg:rect\");\n                        rect.setAttributeNS(null, \"x\", x0);\n                        rect.setAttributeNS(null, \"y\", y0);\n                        rect.setAttributeNS(null, \"width\", x1 - x0);\n                        rect.setAttributeNS(null, \"height\", y1 - y0);\n                        rect.setAttributeNS(null, \"fill\", this._makeShadingPattern(args));\n                        if (this.current.fillAlpha < 1) {\n                            rect.setAttributeNS(null, \"fill-opacity\", this.current.fillAlpha);\n                        }\n                        this._ensureTransformGroup().append(rect);\n                    }\n                    _makeColorN_Pattern(args) {\n                        if (args[0] === \"TilingPattern\") {\n                            return this._makeTilingPattern(args);\n                        }\n                        return this._makeShadingPattern(args);\n                    }\n                    _makeTilingPattern(args) {\n                        const color = args[1];\n                        const operatorList = args[2];\n                        const matrix = args[3] || _util.IDENTITY_MATRIX;\n                        const [x0, y0, x1, y1] = args[4];\n                        const xstep = args[5];\n                        const ystep = args[6];\n                        const paintType = args[7];\n                        const tilingId = `shading${shadingCount++}`;\n                        const [tx0, ty0, tx1, ty1] = _util.Util.normalizeRect([\n                            ..._util.Util.applyTransform([\n                                x0,\n                                y0\n                            ], matrix),\n                            ..._util.Util.applyTransform([\n                                x1,\n                                y1\n                            ], matrix)\n                        ]);\n                        const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);\n                        const txstep = xstep * xscale;\n                        const tystep = ystep * yscale;\n                        const tiling = this.svgFactory.createElement(\"svg:pattern\");\n                        tiling.setAttributeNS(null, \"id\", tilingId);\n                        tiling.setAttributeNS(null, \"patternUnits\", \"userSpaceOnUse\");\n                        tiling.setAttributeNS(null, \"width\", txstep);\n                        tiling.setAttributeNS(null, \"height\", tystep);\n                        tiling.setAttributeNS(null, \"x\", `${tx0}`);\n                        tiling.setAttributeNS(null, \"y\", `${ty0}`);\n                        const svg = this.svg;\n                        const transformMatrix = this.transformMatrix;\n                        const fillColor = this.current.fillColor;\n                        const strokeColor = this.current.strokeColor;\n                        const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);\n                        this.svg = bbox;\n                        this.transformMatrix = matrix;\n                        if (paintType === 2) {\n                            const cssColor = _util.Util.makeHexColor(...color);\n                            this.current.fillColor = cssColor;\n                            this.current.strokeColor = cssColor;\n                        }\n                        this.executeOpTree(this.convertOpList(operatorList));\n                        this.svg = svg;\n                        this.transformMatrix = transformMatrix;\n                        this.current.fillColor = fillColor;\n                        this.current.strokeColor = strokeColor;\n                        tiling.append(bbox.childNodes[0]);\n                        this.defs.append(tiling);\n                        return `url(#${tilingId})`;\n                    }\n                    _makeShadingPattern(args) {\n                        if (typeof args === \"string\") {\n                            args = this.objs.get(args);\n                        }\n                        switch(args[0]){\n                            case \"RadialAxial\":\n                                const shadingId = `shading${shadingCount++}`;\n                                const colorStops = args[3];\n                                let gradient;\n                                switch(args[1]){\n                                    case \"axial\":\n                                        const point0 = args[4];\n                                        const point1 = args[5];\n                                        gradient = this.svgFactory.createElement(\"svg:linearGradient\");\n                                        gradient.setAttributeNS(null, \"id\", shadingId);\n                                        gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n                                        gradient.setAttributeNS(null, \"x1\", point0[0]);\n                                        gradient.setAttributeNS(null, \"y1\", point0[1]);\n                                        gradient.setAttributeNS(null, \"x2\", point1[0]);\n                                        gradient.setAttributeNS(null, \"y2\", point1[1]);\n                                        break;\n                                    case \"radial\":\n                                        const focalPoint = args[4];\n                                        const circlePoint = args[5];\n                                        const focalRadius = args[6];\n                                        const circleRadius = args[7];\n                                        gradient = this.svgFactory.createElement(\"svg:radialGradient\");\n                                        gradient.setAttributeNS(null, \"id\", shadingId);\n                                        gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n                                        gradient.setAttributeNS(null, \"cx\", circlePoint[0]);\n                                        gradient.setAttributeNS(null, \"cy\", circlePoint[1]);\n                                        gradient.setAttributeNS(null, \"r\", circleRadius);\n                                        gradient.setAttributeNS(null, \"fx\", focalPoint[0]);\n                                        gradient.setAttributeNS(null, \"fy\", focalPoint[1]);\n                                        gradient.setAttributeNS(null, \"fr\", focalRadius);\n                                        break;\n                                    default:\n                                        throw new Error(`Unknown RadialAxial type: ${args[1]}`);\n                                }\n                                for (const colorStop of colorStops){\n                                    const stop = this.svgFactory.createElement(\"svg:stop\");\n                                    stop.setAttributeNS(null, \"offset\", colorStop[0]);\n                                    stop.setAttributeNS(null, \"stop-color\", colorStop[1]);\n                                    gradient.append(stop);\n                                }\n                                this.defs.append(gradient);\n                                return `url(#${shadingId})`;\n                            case \"Mesh\":\n                                (0, _util.warn)(\"Unimplemented pattern Mesh\");\n                                return null;\n                            case \"Dummy\":\n                                return \"hotpink\";\n                            default:\n                                throw new Error(`Unknown IR type: ${args[0]}`);\n                        }\n                    }\n                    setDash(dashArray, dashPhase) {\n                        this.current.dashArray = dashArray;\n                        this.current.dashPhase = dashPhase;\n                    }\n                    constructPath(ops, args) {\n                        const current = this.current;\n                        let x = current.x, y = current.y;\n                        let d = [];\n                        let j = 0;\n                        for (const op of ops){\n                            switch(op | 0){\n                                case _util.OPS.rectangle:\n                                    x = args[j++];\n                                    y = args[j++];\n                                    const width = args[j++];\n                                    const height = args[j++];\n                                    const xw = x + width;\n                                    const yh = y + height;\n                                    d.push(\"M\", pf(x), pf(y), \"L\", pf(xw), pf(y), \"L\", pf(xw), pf(yh), \"L\", pf(x), pf(yh), \"Z\");\n                                    break;\n                                case _util.OPS.moveTo:\n                                    x = args[j++];\n                                    y = args[j++];\n                                    d.push(\"M\", pf(x), pf(y));\n                                    break;\n                                case _util.OPS.lineTo:\n                                    x = args[j++];\n                                    y = args[j++];\n                                    d.push(\"L\", pf(x), pf(y));\n                                    break;\n                                case _util.OPS.curveTo:\n                                    x = args[j + 4];\n                                    y = args[j + 5];\n                                    d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));\n                                    j += 6;\n                                    break;\n                                case _util.OPS.curveTo2:\n                                    d.push(\"C\", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));\n                                    x = args[j + 2];\n                                    y = args[j + 3];\n                                    j += 4;\n                                    break;\n                                case _util.OPS.curveTo3:\n                                    x = args[j + 2];\n                                    y = args[j + 3];\n                                    d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));\n                                    j += 4;\n                                    break;\n                                case _util.OPS.closePath:\n                                    d.push(\"Z\");\n                                    break;\n                            }\n                        }\n                        d = d.join(\" \");\n                        if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {\n                            d = current.path.getAttributeNS(null, \"d\") + d;\n                        } else {\n                            current.path = this.svgFactory.createElement(\"svg:path\");\n                            this._ensureTransformGroup().append(current.path);\n                        }\n                        current.path.setAttributeNS(null, \"d\", d);\n                        current.path.setAttributeNS(null, \"fill\", \"none\");\n                        current.element = current.path;\n                        current.setCurrentPoint(x, y);\n                    }\n                    endPath() {\n                        const current = this.current;\n                        current.path = null;\n                        if (!this.pendingClip) {\n                            return;\n                        }\n                        if (!current.element) {\n                            this.pendingClip = null;\n                            return;\n                        }\n                        const clipId = `clippath${clipCount++}`;\n                        const clipPath = this.svgFactory.createElement(\"svg:clipPath\");\n                        clipPath.setAttributeNS(null, \"id\", clipId);\n                        clipPath.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n                        const clipElement = current.element.cloneNode(true);\n                        if (this.pendingClip === \"evenodd\") {\n                            clipElement.setAttributeNS(null, \"clip-rule\", \"evenodd\");\n                        } else {\n                            clipElement.setAttributeNS(null, \"clip-rule\", \"nonzero\");\n                        }\n                        this.pendingClip = null;\n                        clipPath.append(clipElement);\n                        this.defs.append(clipPath);\n                        if (current.activeClipUrl) {\n                            current.clipGroup = null;\n                            for (const prev of this.extraStack){\n                                prev.clipGroup = null;\n                            }\n                            clipPath.setAttributeNS(null, \"clip-path\", current.activeClipUrl);\n                        }\n                        current.activeClipUrl = `url(#${clipId})`;\n                        this.tgrp = null;\n                    }\n                    clip(type) {\n                        this.pendingClip = type;\n                    }\n                    closePath() {\n                        const current = this.current;\n                        if (current.path) {\n                            const d = `${current.path.getAttributeNS(null, \"d\")}Z`;\n                            current.path.setAttributeNS(null, \"d\", d);\n                        }\n                    }\n                    setLeading(leading) {\n                        this.current.leading = -leading;\n                    }\n                    setTextRise(textRise) {\n                        this.current.textRise = textRise;\n                    }\n                    setTextRenderingMode(textRenderingMode) {\n                        this.current.textRenderingMode = textRenderingMode;\n                    }\n                    setHScale(scale) {\n                        this.current.textHScale = scale / 100;\n                    }\n                    setRenderingIntent(intent) {}\n                    setFlatness(flatness) {}\n                    setGState(states) {\n                        for (const [key, value] of states){\n                            switch(key){\n                                case \"LW\":\n                                    this.setLineWidth(value);\n                                    break;\n                                case \"LC\":\n                                    this.setLineCap(value);\n                                    break;\n                                case \"LJ\":\n                                    this.setLineJoin(value);\n                                    break;\n                                case \"ML\":\n                                    this.setMiterLimit(value);\n                                    break;\n                                case \"D\":\n                                    this.setDash(value[0], value[1]);\n                                    break;\n                                case \"RI\":\n                                    this.setRenderingIntent(value);\n                                    break;\n                                case \"FL\":\n                                    this.setFlatness(value);\n                                    break;\n                                case \"Font\":\n                                    this.setFont(value);\n                                    break;\n                                case \"CA\":\n                                    this.setStrokeAlpha(value);\n                                    break;\n                                case \"ca\":\n                                    this.setFillAlpha(value);\n                                    break;\n                                default:\n                                    (0, _util.warn)(`Unimplemented graphic state operator ${key}`);\n                                    break;\n                            }\n                        }\n                    }\n                    fill() {\n                        const current = this.current;\n                        if (current.element) {\n                            current.element.setAttributeNS(null, \"fill\", current.fillColor);\n                            current.element.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n                            this.endPath();\n                        }\n                    }\n                    stroke() {\n                        const current = this.current;\n                        if (current.element) {\n                            this._setStrokeAttributes(current.element);\n                            current.element.setAttributeNS(null, \"fill\", \"none\");\n                            this.endPath();\n                        }\n                    }\n                    _setStrokeAttributes(element, lineWidthScale = 1) {\n                        const current = this.current;\n                        let dashArray = current.dashArray;\n                        if (lineWidthScale !== 1 && dashArray.length > 0) {\n                            dashArray = dashArray.map(function(value) {\n                                return lineWidthScale * value;\n                            });\n                        }\n                        element.setAttributeNS(null, \"stroke\", current.strokeColor);\n                        element.setAttributeNS(null, \"stroke-opacity\", current.strokeAlpha);\n                        element.setAttributeNS(null, \"stroke-miterlimit\", pf(current.miterLimit));\n                        element.setAttributeNS(null, \"stroke-linecap\", current.lineCap);\n                        element.setAttributeNS(null, \"stroke-linejoin\", current.lineJoin);\n                        element.setAttributeNS(null, \"stroke-width\", pf(lineWidthScale * current.lineWidth) + \"px\");\n                        element.setAttributeNS(null, \"stroke-dasharray\", dashArray.map(pf).join(\" \"));\n                        element.setAttributeNS(null, \"stroke-dashoffset\", pf(lineWidthScale * current.dashPhase) + \"px\");\n                    }\n                    eoFill() {\n                        this.current.element?.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n                        this.fill();\n                    }\n                    fillStroke() {\n                        this.stroke();\n                        this.fill();\n                    }\n                    eoFillStroke() {\n                        this.current.element?.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n                        this.fillStroke();\n                    }\n                    closeStroke() {\n                        this.closePath();\n                        this.stroke();\n                    }\n                    closeFillStroke() {\n                        this.closePath();\n                        this.fillStroke();\n                    }\n                    closeEOFillStroke() {\n                        this.closePath();\n                        this.eoFillStroke();\n                    }\n                    paintSolidColorImageMask() {\n                        const rect = this.svgFactory.createElement(\"svg:rect\");\n                        rect.setAttributeNS(null, \"x\", \"0\");\n                        rect.setAttributeNS(null, \"y\", \"0\");\n                        rect.setAttributeNS(null, \"width\", \"1px\");\n                        rect.setAttributeNS(null, \"height\", \"1px\");\n                        rect.setAttributeNS(null, \"fill\", this.current.fillColor);\n                        this._ensureTransformGroup().append(rect);\n                    }\n                    paintImageXObject(objId) {\n                        const imgData = this.getObject(objId);\n                        if (!imgData) {\n                            (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);\n                            return;\n                        }\n                        this.paintInlineImageXObject(imgData);\n                    }\n                    paintInlineImageXObject(imgData, mask) {\n                        const width = imgData.width;\n                        const height = imgData.height;\n                        const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);\n                        const cliprect = this.svgFactory.createElement(\"svg:rect\");\n                        cliprect.setAttributeNS(null, \"x\", \"0\");\n                        cliprect.setAttributeNS(null, \"y\", \"0\");\n                        cliprect.setAttributeNS(null, \"width\", pf(width));\n                        cliprect.setAttributeNS(null, \"height\", pf(height));\n                        this.current.element = cliprect;\n                        this.clip(\"nonzero\");\n                        const imgEl = this.svgFactory.createElement(\"svg:image\");\n                        imgEl.setAttributeNS(XLINK_NS, \"xlink:href\", imgSrc);\n                        imgEl.setAttributeNS(null, \"x\", \"0\");\n                        imgEl.setAttributeNS(null, \"y\", pf(-height));\n                        imgEl.setAttributeNS(null, \"width\", pf(width) + \"px\");\n                        imgEl.setAttributeNS(null, \"height\", pf(height) + \"px\");\n                        imgEl.setAttributeNS(null, \"transform\", `scale(${pf(1 / width)} ${pf(-1 / height)})`);\n                        if (mask) {\n                            mask.append(imgEl);\n                        } else {\n                            this._ensureTransformGroup().append(imgEl);\n                        }\n                    }\n                    paintImageMaskXObject(img) {\n                        const imgData = this.getObject(img.data, img);\n                        if (imgData.bitmap) {\n                            (0, _util.warn)(\"paintImageMaskXObject: ImageBitmap support is not implemented, \" + \"ensure that the `isOffscreenCanvasSupported` API parameter is disabled.\");\n                            return;\n                        }\n                        const current = this.current;\n                        const width = imgData.width;\n                        const height = imgData.height;\n                        const fillColor = current.fillColor;\n                        current.maskId = `mask${maskCount++}`;\n                        const mask = this.svgFactory.createElement(\"svg:mask\");\n                        mask.setAttributeNS(null, \"id\", current.maskId);\n                        const rect = this.svgFactory.createElement(\"svg:rect\");\n                        rect.setAttributeNS(null, \"x\", \"0\");\n                        rect.setAttributeNS(null, \"y\", \"0\");\n                        rect.setAttributeNS(null, \"width\", pf(width));\n                        rect.setAttributeNS(null, \"height\", pf(height));\n                        rect.setAttributeNS(null, \"fill\", fillColor);\n                        rect.setAttributeNS(null, \"mask\", `url(#${current.maskId})`);\n                        this.defs.append(mask);\n                        this._ensureTransformGroup().append(rect);\n                        this.paintInlineImageXObject(imgData, mask);\n                    }\n                    paintFormXObjectBegin(matrix, bbox) {\n                        if (Array.isArray(matrix) && matrix.length === 6) {\n                            this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n                        }\n                        if (bbox) {\n                            const width = bbox[2] - bbox[0];\n                            const height = bbox[3] - bbox[1];\n                            const cliprect = this.svgFactory.createElement(\"svg:rect\");\n                            cliprect.setAttributeNS(null, \"x\", bbox[0]);\n                            cliprect.setAttributeNS(null, \"y\", bbox[1]);\n                            cliprect.setAttributeNS(null, \"width\", pf(width));\n                            cliprect.setAttributeNS(null, \"height\", pf(height));\n                            this.current.element = cliprect;\n                            this.clip(\"nonzero\");\n                            this.endPath();\n                        }\n                    }\n                    paintFormXObjectEnd() {}\n                    _initialize(viewport) {\n                        const svg = this.svgFactory.create(viewport.width, viewport.height);\n                        const definitions = this.svgFactory.createElement(\"svg:defs\");\n                        svg.append(definitions);\n                        this.defs = definitions;\n                        const rootGroup = this.svgFactory.createElement(\"svg:g\");\n                        rootGroup.setAttributeNS(null, \"transform\", pm(viewport.transform));\n                        svg.append(rootGroup);\n                        this.svg = rootGroup;\n                        return svg;\n                    }\n                    _ensureClipGroup() {\n                        if (!this.current.clipGroup) {\n                            const clipGroup = this.svgFactory.createElement(\"svg:g\");\n                            clipGroup.setAttributeNS(null, \"clip-path\", this.current.activeClipUrl);\n                            this.svg.append(clipGroup);\n                            this.current.clipGroup = clipGroup;\n                        }\n                        return this.current.clipGroup;\n                    }\n                    _ensureTransformGroup() {\n                        if (!this.tgrp) {\n                            this.tgrp = this.svgFactory.createElement(\"svg:g\");\n                            this.tgrp.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n                            if (this.current.activeClipUrl) {\n                                this._ensureClipGroup().append(this.tgrp);\n                            } else {\n                                this.svg.append(this.tgrp);\n                            }\n                        }\n                        return this.tgrp;\n                    }\n                }\n                exports1.SVGGraphics = SVGGraphics;\n            /***/ },\n            /* 25 */ /***/ (__unused_webpack_module, exports1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.XfaText = void 0;\n                class XfaText {\n                    static textContent(xfa) {\n                        const items = [];\n                        const output = {\n                            items,\n                            styles: Object.create(null)\n                        };\n                        function walk(node) {\n                            if (!node) {\n                                return;\n                            }\n                            let str = null;\n                            const name = node.name;\n                            if (name === \"#text\") {\n                                str = node.value;\n                            } else if (!XfaText.shouldBuildText(name)) {\n                                return;\n                            } else if (node?.attributes?.textContent) {\n                                str = node.attributes.textContent;\n                            } else if (node.value) {\n                                str = node.value;\n                            }\n                            if (str !== null) {\n                                items.push({\n                                    str\n                                });\n                            }\n                            if (!node.children) {\n                                return;\n                            }\n                            for (const child of node.children){\n                                walk(child);\n                            }\n                        }\n                        walk(xfa);\n                        return output;\n                    }\n                    static shouldBuildText(name) {\n                        return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n                    }\n                }\n                exports1.XfaText = XfaText;\n            /***/ },\n            /* 26 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.TextLayerRenderTask = void 0;\n                exports1.renderTextLayer = renderTextLayer;\n                exports1.updateTextLayer = updateTextLayer;\n                var _util = __w_pdfjs_require__(1);\n                var _display_utils = __w_pdfjs_require__(6);\n                const MAX_TEXT_DIVS_TO_RENDER = 100000;\n                const DEFAULT_FONT_SIZE = 30;\n                const DEFAULT_FONT_ASCENT = 0.8;\n                const ascentCache = new Map();\n                function getCtx(size, isOffscreenCanvasSupported) {\n                    let ctx;\n                    if (isOffscreenCanvasSupported && _util.FeatureTest.isOffscreenCanvasSupported) {\n                        ctx = new OffscreenCanvas(size, size).getContext(\"2d\", {\n                            alpha: false\n                        });\n                    } else {\n                        const canvas = document.createElement(\"canvas\");\n                        canvas.width = canvas.height = size;\n                        ctx = canvas.getContext(\"2d\", {\n                            alpha: false\n                        });\n                    }\n                    return ctx;\n                }\n                function getAscent(fontFamily, isOffscreenCanvasSupported) {\n                    const cachedAscent = ascentCache.get(fontFamily);\n                    if (cachedAscent) {\n                        return cachedAscent;\n                    }\n                    const ctx = getCtx(DEFAULT_FONT_SIZE, isOffscreenCanvasSupported);\n                    ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;\n                    const metrics = ctx.measureText(\"\");\n                    let ascent = metrics.fontBoundingBoxAscent;\n                    let descent = Math.abs(metrics.fontBoundingBoxDescent);\n                    if (ascent) {\n                        const ratio = ascent / (ascent + descent);\n                        ascentCache.set(fontFamily, ratio);\n                        ctx.canvas.width = ctx.canvas.height = 0;\n                        return ratio;\n                    }\n                    ctx.strokeStyle = \"red\";\n                    ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n                    ctx.strokeText(\"g\", 0, 0);\n                    let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n                    descent = 0;\n                    for(let i = pixels.length - 1 - 3; i >= 0; i -= 4){\n                        if (pixels[i] > 0) {\n                            descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);\n                            break;\n                        }\n                    }\n                    ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n                    ctx.strokeText(\"A\", 0, DEFAULT_FONT_SIZE);\n                    pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n                    ascent = 0;\n                    for(let i = 0, ii = pixels.length; i < ii; i += 4){\n                        if (pixels[i] > 0) {\n                            ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);\n                            break;\n                        }\n                    }\n                    ctx.canvas.width = ctx.canvas.height = 0;\n                    if (ascent) {\n                        const ratio = ascent / (ascent + descent);\n                        ascentCache.set(fontFamily, ratio);\n                        return ratio;\n                    }\n                    ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);\n                    return DEFAULT_FONT_ASCENT;\n                }\n                function appendText(task, geom, styles) {\n                    const textDiv = document.createElement(\"span\");\n                    const textDivProperties = {\n                        angle: 0,\n                        canvasWidth: 0,\n                        hasText: geom.str !== \"\",\n                        hasEOL: geom.hasEOL,\n                        fontSize: 0\n                    };\n                    task._textDivs.push(textDiv);\n                    const tx = _util.Util.transform(task._transform, geom.transform);\n                    let angle = Math.atan2(tx[1], tx[0]);\n                    const style = styles[geom.fontName];\n                    if (style.vertical) {\n                        angle += Math.PI / 2;\n                    }\n                    const fontHeight = Math.hypot(tx[2], tx[3]);\n                    const fontAscent = fontHeight * getAscent(style.fontFamily, task._isOffscreenCanvasSupported);\n                    let left, top;\n                    if (angle === 0) {\n                        left = tx[4];\n                        top = tx[5] - fontAscent;\n                    } else {\n                        left = tx[4] + fontAscent * Math.sin(angle);\n                        top = tx[5] - fontAscent * Math.cos(angle);\n                    }\n                    const scaleFactorStr = \"calc(var(--scale-factor)*\";\n                    const divStyle = textDiv.style;\n                    if (task._container === task._rootContainer) {\n                        divStyle.left = `${(100 * left / task._pageWidth).toFixed(2)}%`;\n                        divStyle.top = `${(100 * top / task._pageHeight).toFixed(2)}%`;\n                    } else {\n                        divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;\n                        divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;\n                    }\n                    divStyle.fontSize = `${scaleFactorStr}${fontHeight.toFixed(2)}px)`;\n                    divStyle.fontFamily = style.fontFamily;\n                    textDivProperties.fontSize = fontHeight;\n                    textDiv.setAttribute(\"role\", \"presentation\");\n                    textDiv.textContent = geom.str;\n                    textDiv.dir = geom.dir;\n                    if (task._fontInspectorEnabled) {\n                        textDiv.dataset.fontName = geom.fontName;\n                    }\n                    if (angle !== 0) {\n                        textDivProperties.angle = angle * (180 / Math.PI);\n                    }\n                    let shouldScaleText = false;\n                    if (geom.str.length > 1) {\n                        shouldScaleText = true;\n                    } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n                        const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);\n                        if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n                            shouldScaleText = true;\n                        }\n                    }\n                    if (shouldScaleText) {\n                        textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;\n                    }\n                    task._textDivProperties.set(textDiv, textDivProperties);\n                    if (task._isReadableStream) {\n                        task._layoutText(textDiv);\n                    }\n                }\n                function layout(params) {\n                    const { div, scale, properties, ctx, prevFontSize, prevFontFamily } = params;\n                    const { style } = div;\n                    let transform = \"\";\n                    if (properties.canvasWidth !== 0 && properties.hasText) {\n                        const { fontFamily } = style;\n                        const { canvasWidth, fontSize } = properties;\n                        if (prevFontSize !== fontSize || prevFontFamily !== fontFamily) {\n                            ctx.font = `${fontSize * scale}px ${fontFamily}`;\n                            params.prevFontSize = fontSize;\n                            params.prevFontFamily = fontFamily;\n                        }\n                        const { width } = ctx.measureText(div.textContent);\n                        if (width > 0) {\n                            transform = `scaleX(${canvasWidth * scale / width})`;\n                        }\n                    }\n                    if (properties.angle !== 0) {\n                        transform = `rotate(${properties.angle}deg) ${transform}`;\n                    }\n                    if (transform.length > 0) {\n                        style.transform = transform;\n                    }\n                }\n                function render(task) {\n                    if (task._canceled) {\n                        return;\n                    }\n                    const textDivs = task._textDivs;\n                    const capability = task._capability;\n                    const textDivsLength = textDivs.length;\n                    if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n                        capability.resolve();\n                        return;\n                    }\n                    if (!task._isReadableStream) {\n                        for (const textDiv of textDivs){\n                            task._layoutText(textDiv);\n                        }\n                    }\n                    capability.resolve();\n                }\n                class TextLayerRenderTask {\n                    constructor({ textContentSource, container, viewport, textDivs, textDivProperties, textContentItemsStr, isOffscreenCanvasSupported }){\n                        this._textContentSource = textContentSource;\n                        this._isReadableStream = textContentSource instanceof ReadableStream;\n                        this._container = this._rootContainer = container;\n                        this._textDivs = textDivs || [];\n                        this._textContentItemsStr = textContentItemsStr || [];\n                        this._isOffscreenCanvasSupported = isOffscreenCanvasSupported;\n                        this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n                        this._reader = null;\n                        this._textDivProperties = textDivProperties || new WeakMap();\n                        this._canceled = false;\n                        this._capability = new _util.PromiseCapability();\n                        this._layoutTextParams = {\n                            prevFontSize: null,\n                            prevFontFamily: null,\n                            div: null,\n                            scale: viewport.scale * (globalThis.devicePixelRatio || 1),\n                            properties: null,\n                            ctx: getCtx(0, isOffscreenCanvasSupported)\n                        };\n                        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n                        this._transform = [\n                            1,\n                            0,\n                            0,\n                            -1,\n                            -pageX,\n                            pageY + pageHeight\n                        ];\n                        this._pageWidth = pageWidth;\n                        this._pageHeight = pageHeight;\n                        (0, _display_utils.setLayerDimensions)(container, viewport);\n                        this._capability.promise.finally(()=>{\n                            this._layoutTextParams = null;\n                        }).catch(()=>{});\n                    }\n                    get promise() {\n                        return this._capability.promise;\n                    }\n                    cancel() {\n                        this._canceled = true;\n                        if (this._reader) {\n                            this._reader.cancel(new _util.AbortException(\"TextLayer task cancelled.\")).catch(()=>{});\n                            this._reader = null;\n                        }\n                        this._capability.reject(new _util.AbortException(\"TextLayer task cancelled.\"));\n                    }\n                    _processItems(items, styleCache) {\n                        for (const item of items){\n                            if (item.str === undefined) {\n                                if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") {\n                                    const parent = this._container;\n                                    this._container = document.createElement(\"span\");\n                                    this._container.classList.add(\"markedContent\");\n                                    if (item.id !== null) {\n                                        this._container.setAttribute(\"id\", `${item.id}`);\n                                    }\n                                    parent.append(this._container);\n                                } else if (item.type === \"endMarkedContent\") {\n                                    this._container = this._container.parentNode;\n                                }\n                                continue;\n                            }\n                            this._textContentItemsStr.push(item.str);\n                            appendText(this, item, styleCache);\n                        }\n                    }\n                    _layoutText(textDiv) {\n                        const textDivProperties = this._layoutTextParams.properties = this._textDivProperties.get(textDiv);\n                        this._layoutTextParams.div = textDiv;\n                        layout(this._layoutTextParams);\n                        if (textDivProperties.hasText) {\n                            this._container.append(textDiv);\n                        }\n                        if (textDivProperties.hasEOL) {\n                            const br = document.createElement(\"br\");\n                            br.setAttribute(\"role\", \"presentation\");\n                            this._container.append(br);\n                        }\n                    }\n                    _render() {\n                        const capability = new _util.PromiseCapability();\n                        let styleCache = Object.create(null);\n                        if (this._isReadableStream) {\n                            const pump = ()=>{\n                                this._reader.read().then(({ value, done })=>{\n                                    if (done) {\n                                        capability.resolve();\n                                        return;\n                                    }\n                                    Object.assign(styleCache, value.styles);\n                                    this._processItems(value.items, styleCache);\n                                    pump();\n                                }, capability.reject);\n                            };\n                            this._reader = this._textContentSource.getReader();\n                            pump();\n                        } else if (this._textContentSource) {\n                            const { items, styles } = this._textContentSource;\n                            this._processItems(items, styles);\n                            capability.resolve();\n                        } else {\n                            throw new Error('No \"textContentSource\" parameter specified.');\n                        }\n                        capability.promise.then(()=>{\n                            styleCache = null;\n                            render(this);\n                        }, this._capability.reject);\n                    }\n                }\n                exports1.TextLayerRenderTask = TextLayerRenderTask;\n                function renderTextLayer(params) {\n                    if (!params.textContentSource && (params.textContent || params.textContentStream)) {\n                        (0, _display_utils.deprecated)(\"The TextLayerRender `textContent`/`textContentStream` parameters \" + \"will be removed in the future, please use `textContentSource` instead.\");\n                        params.textContentSource = params.textContent || params.textContentStream;\n                    }\n                    const { container, viewport } = params;\n                    const style = getComputedStyle(container);\n                    const visibility = style.getPropertyValue(\"visibility\");\n                    const scaleFactor = parseFloat(style.getPropertyValue(\"--scale-factor\"));\n                    if (visibility === \"visible\" && (!scaleFactor || Math.abs(scaleFactor - viewport.scale) > 1e-5)) {\n                        console.error(\"The `--scale-factor` CSS-variable must be set, \" + \"to the same value as `viewport.scale`, \" + \"either on the `container`-element itself or higher up in the DOM.\");\n                    }\n                    const task = new TextLayerRenderTask(params);\n                    task._render();\n                    return task;\n                }\n                function updateTextLayer({ container, viewport, textDivs, textDivProperties, isOffscreenCanvasSupported, mustRotate = true, mustRescale = true }) {\n                    if (mustRotate) {\n                        (0, _display_utils.setLayerDimensions)(container, {\n                            rotation: viewport.rotation\n                        });\n                    }\n                    if (mustRescale) {\n                        const ctx = getCtx(0, isOffscreenCanvasSupported);\n                        const scale = viewport.scale * (globalThis.devicePixelRatio || 1);\n                        const params = {\n                            prevFontSize: null,\n                            prevFontFamily: null,\n                            div: null,\n                            scale,\n                            properties: null,\n                            ctx\n                        };\n                        for (const div of textDivs){\n                            params.properties = textDivProperties.get(div);\n                            params.div = div;\n                            layout(params);\n                        }\n                    }\n                }\n            /***/ },\n            /* 27 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.AnnotationEditorLayer = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _editor = __w_pdfjs_require__(4);\n                var _freetext = __w_pdfjs_require__(28);\n                var _ink = __w_pdfjs_require__(33);\n                var _display_utils = __w_pdfjs_require__(6);\n                var _stamp = __w_pdfjs_require__(34);\n                class AnnotationEditorLayer {\n                    #accessibilityManager;\n                    #allowClick;\n                    #annotationLayer;\n                    #boundPointerup;\n                    #boundPointerdown;\n                    #editors;\n                    #hadPointerDown;\n                    #isCleaningUp;\n                    #isDisabling;\n                    #uiManager;\n                    static{\n                        this._initialized = false;\n                    }\n                    constructor({ uiManager, pageIndex, div, accessibilityManager, annotationLayer, viewport, l10n }){\n                        this.#allowClick = false;\n                        this.#annotationLayer = null;\n                        this.#boundPointerup = this.pointerup.bind(this);\n                        this.#boundPointerdown = this.pointerdown.bind(this);\n                        this.#editors = new Map();\n                        this.#hadPointerDown = false;\n                        this.#isCleaningUp = false;\n                        this.#isDisabling = false;\n                        const editorTypes = [\n                            _freetext.FreeTextEditor,\n                            _ink.InkEditor,\n                            _stamp.StampEditor\n                        ];\n                        if (!AnnotationEditorLayer._initialized) {\n                            AnnotationEditorLayer._initialized = true;\n                            for (const editorType of editorTypes){\n                                editorType.initialize(l10n);\n                            }\n                        }\n                        uiManager.registerEditorTypes(editorTypes);\n                        this.#uiManager = uiManager;\n                        this.pageIndex = pageIndex;\n                        this.div = div;\n                        this.#accessibilityManager = accessibilityManager;\n                        this.#annotationLayer = annotationLayer;\n                        this.viewport = viewport;\n                        this.#uiManager.addLayer(this);\n                    }\n                    get isEmpty() {\n                        return this.#editors.size === 0;\n                    }\n                    updateToolbar(mode) {\n                        this.#uiManager.updateToolbar(mode);\n                    }\n                    updateMode(mode = this.#uiManager.getMode()) {\n                        this.#cleanup();\n                        if (mode === _util.AnnotationEditorType.INK) {\n                            this.addInkEditorIfNeeded(false);\n                            this.disableClick();\n                        } else {\n                            this.enableClick();\n                        }\n                        if (mode !== _util.AnnotationEditorType.NONE) {\n                            this.div.classList.toggle(\"freeTextEditing\", mode === _util.AnnotationEditorType.FREETEXT);\n                            this.div.classList.toggle(\"inkEditing\", mode === _util.AnnotationEditorType.INK);\n                            this.div.classList.toggle(\"stampEditing\", mode === _util.AnnotationEditorType.STAMP);\n                            this.div.hidden = false;\n                        }\n                    }\n                    addInkEditorIfNeeded(isCommitting) {\n                        if (!isCommitting && this.#uiManager.getMode() !== _util.AnnotationEditorType.INK) {\n                            return;\n                        }\n                        if (!isCommitting) {\n                            for (const editor of this.#editors.values()){\n                                if (editor.isEmpty()) {\n                                    editor.setInBackground();\n                                    return;\n                                }\n                            }\n                        }\n                        const editor = this.#createAndAddNewEditor({\n                            offsetX: 0,\n                            offsetY: 0\n                        }, false);\n                        editor.setInBackground();\n                    }\n                    setEditingState(isEditing) {\n                        this.#uiManager.setEditingState(isEditing);\n                    }\n                    addCommands(params) {\n                        this.#uiManager.addCommands(params);\n                    }\n                    enable() {\n                        this.div.style.pointerEvents = \"auto\";\n                        const annotationElementIds = new Set();\n                        for (const editor of this.#editors.values()){\n                            editor.enableEditing();\n                            if (editor.annotationElementId) {\n                                annotationElementIds.add(editor.annotationElementId);\n                            }\n                        }\n                        if (!this.#annotationLayer) {\n                            return;\n                        }\n                        const editables = this.#annotationLayer.getEditableAnnotations();\n                        for (const editable of editables){\n                            editable.hide();\n                            if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {\n                                continue;\n                            }\n                            if (annotationElementIds.has(editable.data.id)) {\n                                continue;\n                            }\n                            const editor = this.deserialize(editable);\n                            if (!editor) {\n                                continue;\n                            }\n                            this.addOrRebuild(editor);\n                            editor.enableEditing();\n                        }\n                    }\n                    disable() {\n                        this.#isDisabling = true;\n                        this.div.style.pointerEvents = \"none\";\n                        const hiddenAnnotationIds = new Set();\n                        for (const editor of this.#editors.values()){\n                            editor.disableEditing();\n                            if (!editor.annotationElementId || editor.serialize() !== null) {\n                                hiddenAnnotationIds.add(editor.annotationElementId);\n                                continue;\n                            }\n                            this.getEditableAnnotation(editor.annotationElementId)?.show();\n                            editor.remove();\n                        }\n                        if (this.#annotationLayer) {\n                            const editables = this.#annotationLayer.getEditableAnnotations();\n                            for (const editable of editables){\n                                const { id } = editable.data;\n                                if (hiddenAnnotationIds.has(id) || this.#uiManager.isDeletedAnnotationElement(id)) {\n                                    continue;\n                                }\n                                editable.show();\n                            }\n                        }\n                        this.#cleanup();\n                        if (this.isEmpty) {\n                            this.div.hidden = true;\n                        }\n                        this.#isDisabling = false;\n                    }\n                    getEditableAnnotation(id) {\n                        return this.#annotationLayer?.getEditableAnnotation(id) || null;\n                    }\n                    setActiveEditor(editor) {\n                        const currentActive = this.#uiManager.getActive();\n                        if (currentActive === editor) {\n                            return;\n                        }\n                        this.#uiManager.setActiveEditor(editor);\n                    }\n                    enableClick() {\n                        this.div.addEventListener(\"pointerdown\", this.#boundPointerdown);\n                        this.div.addEventListener(\"pointerup\", this.#boundPointerup);\n                    }\n                    disableClick() {\n                        this.div.removeEventListener(\"pointerdown\", this.#boundPointerdown);\n                        this.div.removeEventListener(\"pointerup\", this.#boundPointerup);\n                    }\n                    attach(editor) {\n                        this.#editors.set(editor.id, editor);\n                        const { annotationElementId } = editor;\n                        if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {\n                            this.#uiManager.removeDeletedAnnotationElement(editor);\n                        }\n                    }\n                    detach(editor) {\n                        this.#editors.delete(editor.id);\n                        this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n                        if (!this.#isDisabling && editor.annotationElementId) {\n                            this.#uiManager.addDeletedAnnotationElement(editor);\n                        }\n                    }\n                    remove(editor) {\n                        this.detach(editor);\n                        this.#uiManager.removeEditor(editor);\n                        if (editor.div.contains(document.activeElement)) {\n                            setTimeout(()=>{\n                                this.#uiManager.focusMainContainer();\n                            }, 0);\n                        }\n                        editor.div.remove();\n                        editor.isAttachedToDOM = false;\n                        if (!this.#isCleaningUp) {\n                            this.addInkEditorIfNeeded(false);\n                        }\n                    }\n                    changeParent(editor) {\n                        if (editor.parent === this) {\n                            return;\n                        }\n                        if (editor.annotationElementId) {\n                            this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);\n                            _editor.AnnotationEditor.deleteAnnotationElement(editor);\n                            editor.annotationElementId = null;\n                        }\n                        this.attach(editor);\n                        editor.parent?.detach(editor);\n                        editor.setParent(this);\n                        if (editor.div && editor.isAttachedToDOM) {\n                            editor.div.remove();\n                            this.div.append(editor.div);\n                        }\n                    }\n                    add(editor) {\n                        this.changeParent(editor);\n                        this.#uiManager.addEditor(editor);\n                        this.attach(editor);\n                        if (!editor.isAttachedToDOM) {\n                            const div = editor.render();\n                            this.div.append(div);\n                            editor.isAttachedToDOM = true;\n                        }\n                        editor.fixAndSetPosition();\n                        editor.onceAdded();\n                        this.#uiManager.addToAnnotationStorage(editor);\n                    }\n                    moveEditorInDOM(editor) {\n                        if (!editor.isAttachedToDOM) {\n                            return;\n                        }\n                        const { activeElement } = document;\n                        if (editor.div.contains(activeElement)) {\n                            editor._focusEventsAllowed = false;\n                            setTimeout(()=>{\n                                if (!editor.div.contains(document.activeElement)) {\n                                    editor.div.addEventListener(\"focusin\", ()=>{\n                                        editor._focusEventsAllowed = true;\n                                    }, {\n                                        once: true\n                                    });\n                                    activeElement.focus();\n                                } else {\n                                    editor._focusEventsAllowed = true;\n                                }\n                            }, 0);\n                        }\n                        editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n                    }\n                    addOrRebuild(editor) {\n                        if (editor.needsToBeRebuilt()) {\n                            editor.rebuild();\n                        } else {\n                            this.add(editor);\n                        }\n                    }\n                    addUndoableEditor(editor) {\n                        const cmd = ()=>editor._uiManager.rebuild(editor);\n                        const undo = ()=>{\n                            editor.remove();\n                        };\n                        this.addCommands({\n                            cmd,\n                            undo,\n                            mustExec: false\n                        });\n                    }\n                    getNextId() {\n                        return this.#uiManager.getId();\n                    }\n                    #createNewEditor(params) {\n                        switch(this.#uiManager.getMode()){\n                            case _util.AnnotationEditorType.FREETEXT:\n                                return new _freetext.FreeTextEditor(params);\n                            case _util.AnnotationEditorType.INK:\n                                return new _ink.InkEditor(params);\n                            case _util.AnnotationEditorType.STAMP:\n                                return new _stamp.StampEditor(params);\n                        }\n                        return null;\n                    }\n                    pasteEditor(mode, params) {\n                        this.#uiManager.updateToolbar(mode);\n                        this.#uiManager.updateMode(mode);\n                        const { offsetX, offsetY } = this.#getCenterPoint();\n                        const id = this.getNextId();\n                        const editor = this.#createNewEditor({\n                            parent: this,\n                            id,\n                            x: offsetX,\n                            y: offsetY,\n                            uiManager: this.#uiManager,\n                            isCentered: true,\n                            ...params\n                        });\n                        if (editor) {\n                            this.add(editor);\n                        }\n                    }\n                    deserialize(data) {\n                        switch(data.annotationType ?? data.annotationEditorType){\n                            case _util.AnnotationEditorType.FREETEXT:\n                                return _freetext.FreeTextEditor.deserialize(data, this, this.#uiManager);\n                            case _util.AnnotationEditorType.INK:\n                                return _ink.InkEditor.deserialize(data, this, this.#uiManager);\n                            case _util.AnnotationEditorType.STAMP:\n                                return _stamp.StampEditor.deserialize(data, this, this.#uiManager);\n                        }\n                        return null;\n                    }\n                    #createAndAddNewEditor(event, isCentered) {\n                        const id = this.getNextId();\n                        const editor = this.#createNewEditor({\n                            parent: this,\n                            id,\n                            x: event.offsetX,\n                            y: event.offsetY,\n                            uiManager: this.#uiManager,\n                            isCentered\n                        });\n                        if (editor) {\n                            this.add(editor);\n                        }\n                        return editor;\n                    }\n                    #getCenterPoint() {\n                        const { x, y, width, height } = this.div.getBoundingClientRect();\n                        const tlX = Math.max(0, x);\n                        const tlY = Math.max(0, y);\n                        const brX = Math.min(window.innerWidth, x + width);\n                        const brY = Math.min(window.innerHeight, y + height);\n                        const centerX = (tlX + brX) / 2 - x;\n                        const centerY = (tlY + brY) / 2 - y;\n                        const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [\n                            centerX,\n                            centerY\n                        ] : [\n                            centerY,\n                            centerX\n                        ];\n                        return {\n                            offsetX,\n                            offsetY\n                        };\n                    }\n                    addNewEditor() {\n                        this.#createAndAddNewEditor(this.#getCenterPoint(), true);\n                    }\n                    setSelected(editor) {\n                        this.#uiManager.setSelected(editor);\n                    }\n                    toggleSelected(editor) {\n                        this.#uiManager.toggleSelected(editor);\n                    }\n                    isSelected(editor) {\n                        return this.#uiManager.isSelected(editor);\n                    }\n                    unselect(editor) {\n                        this.#uiManager.unselect(editor);\n                    }\n                    pointerup(event) {\n                        const { isMac } = _util.FeatureTest.platform;\n                        if (event.button !== 0 || event.ctrlKey && isMac) {\n                            return;\n                        }\n                        if (event.target !== this.div) {\n                            return;\n                        }\n                        if (!this.#hadPointerDown) {\n                            return;\n                        }\n                        this.#hadPointerDown = false;\n                        if (!this.#allowClick) {\n                            this.#allowClick = true;\n                            return;\n                        }\n                        if (this.#uiManager.getMode() === _util.AnnotationEditorType.STAMP) {\n                            this.#uiManager.unselectAll();\n                            return;\n                        }\n                        this.#createAndAddNewEditor(event, false);\n                    }\n                    pointerdown(event) {\n                        if (this.#hadPointerDown) {\n                            this.#hadPointerDown = false;\n                            return;\n                        }\n                        const { isMac } = _util.FeatureTest.platform;\n                        if (event.button !== 0 || event.ctrlKey && isMac) {\n                            return;\n                        }\n                        if (event.target !== this.div) {\n                            return;\n                        }\n                        this.#hadPointerDown = true;\n                        const editor = this.#uiManager.getActive();\n                        this.#allowClick = !editor || editor.isEmpty();\n                    }\n                    findNewParent(editor, x, y) {\n                        const layer = this.#uiManager.findParent(x, y);\n                        if (layer === null || layer === this) {\n                            return false;\n                        }\n                        layer.changeParent(editor);\n                        return true;\n                    }\n                    destroy() {\n                        if (this.#uiManager.getActive()?.parent === this) {\n                            this.#uiManager.commitOrRemove();\n                            this.#uiManager.setActiveEditor(null);\n                        }\n                        for (const editor of this.#editors.values()){\n                            this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n                            editor.setParent(null);\n                            editor.isAttachedToDOM = false;\n                            editor.div.remove();\n                        }\n                        this.div = null;\n                        this.#editors.clear();\n                        this.#uiManager.removeLayer(this);\n                    }\n                    #cleanup() {\n                        this.#isCleaningUp = true;\n                        for (const editor of this.#editors.values()){\n                            if (editor.isEmpty()) {\n                                editor.remove();\n                            }\n                        }\n                        this.#isCleaningUp = false;\n                    }\n                    render({ viewport }) {\n                        this.viewport = viewport;\n                        (0, _display_utils.setLayerDimensions)(this.div, viewport);\n                        for (const editor of this.#uiManager.getEditors(this.pageIndex)){\n                            this.add(editor);\n                        }\n                        this.updateMode();\n                    }\n                    update({ viewport }) {\n                        this.#uiManager.commitOrRemove();\n                        this.viewport = viewport;\n                        (0, _display_utils.setLayerDimensions)(this.div, {\n                            rotation: viewport.rotation\n                        });\n                        this.updateMode();\n                    }\n                    get pageDimensions() {\n                        const { pageWidth, pageHeight } = this.viewport.rawDims;\n                        return [\n                            pageWidth,\n                            pageHeight\n                        ];\n                    }\n                }\n                exports1.AnnotationEditorLayer = AnnotationEditorLayer;\n            /***/ },\n            /* 28 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.FreeTextEditor = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _tools = __w_pdfjs_require__(5);\n                var _editor = __w_pdfjs_require__(4);\n                var _annotation_layer = __w_pdfjs_require__(29);\n                class FreeTextEditor extends _editor.AnnotationEditor {\n                    #boundEditorDivBlur;\n                    #boundEditorDivFocus;\n                    #boundEditorDivInput;\n                    #boundEditorDivKeydown;\n                    #color;\n                    #content;\n                    #editorDivId;\n                    #fontSize;\n                    #initialData;\n                    static{\n                        this._freeTextDefaultContent = \"\";\n                    }\n                    static{\n                        this._internalPadding = 0;\n                    }\n                    static{\n                        this._defaultColor = null;\n                    }\n                    static{\n                        this._defaultFontSize = 10;\n                    }\n                    static get _keyboardManager() {\n                        const proto = FreeTextEditor.prototype;\n                        const arrowChecker = (self)=>self.isEmpty();\n                        const small = _tools.AnnotationEditorUIManager.TRANSLATE_SMALL;\n                        const big = _tools.AnnotationEditorUIManager.TRANSLATE_BIG;\n                        return (0, _util.shadow)(this, \"_keyboardManager\", new _tools.KeyboardManager([\n                            [\n                                [\n                                    \"ctrl+s\",\n                                    \"mac+meta+s\",\n                                    \"ctrl+p\",\n                                    \"mac+meta+p\"\n                                ],\n                                proto.commitOrRemove,\n                                {\n                                    bubbles: true\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+Enter\",\n                                    \"mac+meta+Enter\",\n                                    \"Escape\",\n                                    \"mac+Escape\"\n                                ],\n                                proto.commitOrRemove\n                            ],\n                            [\n                                [\n                                    \"ArrowLeft\",\n                                    \"mac+ArrowLeft\"\n                                ],\n                                proto._translateEmpty,\n                                {\n                                    args: [\n                                        -small,\n                                        0\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowLeft\",\n                                    \"mac+shift+ArrowLeft\"\n                                ],\n                                proto._translateEmpty,\n                                {\n                                    args: [\n                                        -big,\n                                        0\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowRight\",\n                                    \"mac+ArrowRight\"\n                                ],\n                                proto._translateEmpty,\n                                {\n                                    args: [\n                                        small,\n                                        0\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowRight\",\n                                    \"mac+shift+ArrowRight\"\n                                ],\n                                proto._translateEmpty,\n                                {\n                                    args: [\n                                        big,\n                                        0\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowUp\",\n                                    \"mac+ArrowUp\"\n                                ],\n                                proto._translateEmpty,\n                                {\n                                    args: [\n                                        0,\n                                        -small\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowUp\",\n                                    \"mac+shift+ArrowUp\"\n                                ],\n                                proto._translateEmpty,\n                                {\n                                    args: [\n                                        0,\n                                        -big\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowDown\",\n                                    \"mac+ArrowDown\"\n                                ],\n                                proto._translateEmpty,\n                                {\n                                    args: [\n                                        0,\n                                        small\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowDown\",\n                                    \"mac+shift+ArrowDown\"\n                                ],\n                                proto._translateEmpty,\n                                {\n                                    args: [\n                                        0,\n                                        big\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ]\n                        ]));\n                    }\n                    static{\n                        this._type = \"freetext\";\n                    }\n                    constructor(params){\n                        super({\n                            ...params,\n                            name: \"freeTextEditor\"\n                        });\n                        this.#boundEditorDivBlur = this.editorDivBlur.bind(this);\n                        this.#boundEditorDivFocus = this.editorDivFocus.bind(this);\n                        this.#boundEditorDivInput = this.editorDivInput.bind(this);\n                        this.#boundEditorDivKeydown = this.editorDivKeydown.bind(this);\n                        this.#content = \"\";\n                        this.#editorDivId = `${this.id}-editor`;\n                        this.#initialData = null;\n                        this.#color = params.color || FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;\n                        this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n                    }\n                    static initialize(l10n) {\n                        _editor.AnnotationEditor.initialize(l10n, {\n                            strings: [\n                                \"free_text2_default_content\",\n                                \"editor_free_text2_aria_label\"\n                            ]\n                        });\n                        const style = getComputedStyle(document.documentElement);\n                        this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n                    }\n                    static updateDefaultParams(type, value) {\n                        switch(type){\n                            case _util.AnnotationEditorParamsType.FREETEXT_SIZE:\n                                FreeTextEditor._defaultFontSize = value;\n                                break;\n                            case _util.AnnotationEditorParamsType.FREETEXT_COLOR:\n                                FreeTextEditor._defaultColor = value;\n                                break;\n                        }\n                    }\n                    updateParams(type, value) {\n                        switch(type){\n                            case _util.AnnotationEditorParamsType.FREETEXT_SIZE:\n                                this.#updateFontSize(value);\n                                break;\n                            case _util.AnnotationEditorParamsType.FREETEXT_COLOR:\n                                this.#updateColor(value);\n                                break;\n                        }\n                    }\n                    static get defaultPropertiesToUpdate() {\n                        return [\n                            [\n                                _util.AnnotationEditorParamsType.FREETEXT_SIZE,\n                                FreeTextEditor._defaultFontSize\n                            ],\n                            [\n                                _util.AnnotationEditorParamsType.FREETEXT_COLOR,\n                                FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor\n                            ]\n                        ];\n                    }\n                    get propertiesToUpdate() {\n                        return [\n                            [\n                                _util.AnnotationEditorParamsType.FREETEXT_SIZE,\n                                this.#fontSize\n                            ],\n                            [\n                                _util.AnnotationEditorParamsType.FREETEXT_COLOR,\n                                this.#color\n                            ]\n                        ];\n                    }\n                    #updateFontSize(fontSize) {\n                        const setFontsize = (size)=>{\n                            this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;\n                            this.translate(0, -(size - this.#fontSize) * this.parentScale);\n                            this.#fontSize = size;\n                            this.#setEditorDimensions();\n                        };\n                        const savedFontsize = this.#fontSize;\n                        this.addCommands({\n                            cmd: ()=>{\n                                setFontsize(fontSize);\n                            },\n                            undo: ()=>{\n                                setFontsize(savedFontsize);\n                            },\n                            mustExec: true,\n                            type: _util.AnnotationEditorParamsType.FREETEXT_SIZE,\n                            overwriteIfSameType: true,\n                            keepUndo: true\n                        });\n                    }\n                    #updateColor(color) {\n                        const savedColor = this.#color;\n                        this.addCommands({\n                            cmd: ()=>{\n                                this.#color = this.editorDiv.style.color = color;\n                            },\n                            undo: ()=>{\n                                this.#color = this.editorDiv.style.color = savedColor;\n                            },\n                            mustExec: true,\n                            type: _util.AnnotationEditorParamsType.FREETEXT_COLOR,\n                            overwriteIfSameType: true,\n                            keepUndo: true\n                        });\n                    }\n                    _translateEmpty(x, y) {\n                        this._uiManager.translateSelectedEditors(x, y, true);\n                    }\n                    getInitialTranslation() {\n                        const scale = this.parentScale;\n                        return [\n                            -FreeTextEditor._internalPadding * scale,\n                            -(FreeTextEditor._internalPadding + this.#fontSize) * scale\n                        ];\n                    }\n                    rebuild() {\n                        if (!this.parent) {\n                            return;\n                        }\n                        super.rebuild();\n                        if (this.div === null) {\n                            return;\n                        }\n                        if (!this.isAttachedToDOM) {\n                            this.parent.add(this);\n                        }\n                    }\n                    enableEditMode() {\n                        if (this.isInEditMode()) {\n                            return;\n                        }\n                        this.parent.setEditingState(false);\n                        this.parent.updateToolbar(_util.AnnotationEditorType.FREETEXT);\n                        super.enableEditMode();\n                        this.overlayDiv.classList.remove(\"enabled\");\n                        this.editorDiv.contentEditable = true;\n                        this._isDraggable = false;\n                        this.div.removeAttribute(\"aria-activedescendant\");\n                        this.editorDiv.addEventListener(\"keydown\", this.#boundEditorDivKeydown);\n                        this.editorDiv.addEventListener(\"focus\", this.#boundEditorDivFocus);\n                        this.editorDiv.addEventListener(\"blur\", this.#boundEditorDivBlur);\n                        this.editorDiv.addEventListener(\"input\", this.#boundEditorDivInput);\n                    }\n                    disableEditMode() {\n                        if (!this.isInEditMode()) {\n                            return;\n                        }\n                        this.parent.setEditingState(true);\n                        super.disableEditMode();\n                        this.overlayDiv.classList.add(\"enabled\");\n                        this.editorDiv.contentEditable = false;\n                        this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId);\n                        this._isDraggable = true;\n                        this.editorDiv.removeEventListener(\"keydown\", this.#boundEditorDivKeydown);\n                        this.editorDiv.removeEventListener(\"focus\", this.#boundEditorDivFocus);\n                        this.editorDiv.removeEventListener(\"blur\", this.#boundEditorDivBlur);\n                        this.editorDiv.removeEventListener(\"input\", this.#boundEditorDivInput);\n                        this.div.focus({\n                            preventScroll: true\n                        });\n                        this.isEditing = false;\n                        this.parent.div.classList.add(\"freeTextEditing\");\n                    }\n                    focusin(event) {\n                        if (!this._focusEventsAllowed) {\n                            return;\n                        }\n                        super.focusin(event);\n                        if (event.target !== this.editorDiv) {\n                            this.editorDiv.focus();\n                        }\n                    }\n                    onceAdded() {\n                        if (this.width) {\n                            this.#cheatInitialRect();\n                            return;\n                        }\n                        this.enableEditMode();\n                        this.editorDiv.focus();\n                        if (this._initialOptions?.isCentered) {\n                            this.center();\n                        }\n                        this._initialOptions = null;\n                    }\n                    isEmpty() {\n                        return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n                    }\n                    remove() {\n                        this.isEditing = false;\n                        if (this.parent) {\n                            this.parent.setEditingState(true);\n                            this.parent.div.classList.add(\"freeTextEditing\");\n                        }\n                        super.remove();\n                    }\n                    #extractText() {\n                        const divs = this.editorDiv.getElementsByTagName(\"div\");\n                        if (divs.length === 0) {\n                            return this.editorDiv.innerText;\n                        }\n                        const buffer = [];\n                        for (const div of divs){\n                            buffer.push(div.innerText.replace(/\\r\\n?|\\n/, \"\"));\n                        }\n                        return buffer.join(\"\\n\");\n                    }\n                    #setEditorDimensions() {\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        let rect;\n                        if (this.isAttachedToDOM) {\n                            rect = this.div.getBoundingClientRect();\n                        } else {\n                            const { currentLayer, div } = this;\n                            const savedDisplay = div.style.display;\n                            div.style.display = \"hidden\";\n                            currentLayer.div.append(this.div);\n                            rect = div.getBoundingClientRect();\n                            div.remove();\n                            div.style.display = savedDisplay;\n                        }\n                        if (this.rotation % 180 === this.parentRotation % 180) {\n                            this.width = rect.width / parentWidth;\n                            this.height = rect.height / parentHeight;\n                        } else {\n                            this.width = rect.height / parentWidth;\n                            this.height = rect.width / parentHeight;\n                        }\n                        this.fixAndSetPosition();\n                    }\n                    commit() {\n                        if (!this.isInEditMode()) {\n                            return;\n                        }\n                        super.commit();\n                        this.disableEditMode();\n                        const savedText = this.#content;\n                        const newText = this.#content = this.#extractText().trimEnd();\n                        if (savedText === newText) {\n                            return;\n                        }\n                        const setText = (text)=>{\n                            this.#content = text;\n                            if (!text) {\n                                this.remove();\n                                return;\n                            }\n                            this.#setContent();\n                            this._uiManager.rebuild(this);\n                            this.#setEditorDimensions();\n                        };\n                        this.addCommands({\n                            cmd: ()=>{\n                                setText(newText);\n                            },\n                            undo: ()=>{\n                                setText(savedText);\n                            },\n                            mustExec: false\n                        });\n                        this.#setEditorDimensions();\n                    }\n                    shouldGetKeyboardEvents() {\n                        return this.isInEditMode();\n                    }\n                    enterInEditMode() {\n                        this.enableEditMode();\n                        this.editorDiv.focus();\n                    }\n                    dblclick(event) {\n                        this.enterInEditMode();\n                    }\n                    keydown(event) {\n                        if (event.target === this.div && event.key === \"Enter\") {\n                            this.enterInEditMode();\n                            event.preventDefault();\n                        }\n                    }\n                    editorDivKeydown(event) {\n                        FreeTextEditor._keyboardManager.exec(this, event);\n                    }\n                    editorDivFocus(event) {\n                        this.isEditing = true;\n                    }\n                    editorDivBlur(event) {\n                        this.isEditing = false;\n                    }\n                    editorDivInput(event) {\n                        this.parent.div.classList.toggle(\"freeTextEditing\", this.isEmpty());\n                    }\n                    disableEditing() {\n                        this.editorDiv.setAttribute(\"role\", \"comment\");\n                        this.editorDiv.removeAttribute(\"aria-multiline\");\n                    }\n                    enableEditing() {\n                        this.editorDiv.setAttribute(\"role\", \"textbox\");\n                        this.editorDiv.setAttribute(\"aria-multiline\", true);\n                    }\n                    render() {\n                        if (this.div) {\n                            return this.div;\n                        }\n                        let baseX, baseY;\n                        if (this.width) {\n                            baseX = this.x;\n                            baseY = this.y;\n                        }\n                        super.render();\n                        this.editorDiv = document.createElement(\"div\");\n                        this.editorDiv.className = \"internal\";\n                        this.editorDiv.setAttribute(\"id\", this.#editorDivId);\n                        this.enableEditing();\n                        _editor.AnnotationEditor._l10nPromise.get(\"editor_free_text2_aria_label\").then((msg)=>this.editorDiv?.setAttribute(\"aria-label\", msg));\n                        _editor.AnnotationEditor._l10nPromise.get(\"free_text2_default_content\").then((msg)=>this.editorDiv?.setAttribute(\"default-content\", msg));\n                        this.editorDiv.contentEditable = true;\n                        const { style } = this.editorDiv;\n                        style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;\n                        style.color = this.#color;\n                        this.div.append(this.editorDiv);\n                        this.overlayDiv = document.createElement(\"div\");\n                        this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n                        this.div.append(this.overlayDiv);\n                        (0, _tools.bindEvents)(this, this.div, [\n                            \"dblclick\",\n                            \"keydown\"\n                        ]);\n                        if (this.width) {\n                            const [parentWidth, parentHeight] = this.parentDimensions;\n                            if (this.annotationElementId) {\n                                const { position } = this.#initialData;\n                                let [tx, ty] = this.getInitialTranslation();\n                                [tx, ty] = this.pageTranslationToScreen(tx, ty);\n                                const [pageWidth, pageHeight] = this.pageDimensions;\n                                const [pageX, pageY] = this.pageTranslation;\n                                let posX, posY;\n                                switch(this.rotation){\n                                    case 0:\n                                        posX = baseX + (position[0] - pageX) / pageWidth;\n                                        posY = baseY + this.height - (position[1] - pageY) / pageHeight;\n                                        break;\n                                    case 90:\n                                        posX = baseX + (position[0] - pageX) / pageWidth;\n                                        posY = baseY - (position[1] - pageY) / pageHeight;\n                                        [tx, ty] = [\n                                            ty,\n                                            -tx\n                                        ];\n                                        break;\n                                    case 180:\n                                        posX = baseX - this.width + (position[0] - pageX) / pageWidth;\n                                        posY = baseY - (position[1] - pageY) / pageHeight;\n                                        [tx, ty] = [\n                                            -tx,\n                                            -ty\n                                        ];\n                                        break;\n                                    case 270:\n                                        posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;\n                                        posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;\n                                        [tx, ty] = [\n                                            -ty,\n                                            tx\n                                        ];\n                                        break;\n                                }\n                                this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);\n                            } else {\n                                this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n                            }\n                            this.#setContent();\n                            this._isDraggable = true;\n                            this.editorDiv.contentEditable = false;\n                        } else {\n                            this._isDraggable = false;\n                            this.editorDiv.contentEditable = true;\n                        }\n                        return this.div;\n                    }\n                    #setContent() {\n                        this.editorDiv.replaceChildren();\n                        if (!this.#content) {\n                            return;\n                        }\n                        for (const line of this.#content.split(\"\\n\")){\n                            const div = document.createElement(\"div\");\n                            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n                            this.editorDiv.append(div);\n                        }\n                    }\n                    get contentDiv() {\n                        return this.editorDiv;\n                    }\n                    static deserialize(data, parent, uiManager) {\n                        let initialData = null;\n                        if (data instanceof _annotation_layer.FreeTextAnnotationElement) {\n                            const { data: { defaultAppearanceData: { fontSize, fontColor }, rect, rotation, id }, textContent, textPosition, parent: { page: { pageNumber } } } = data;\n                            if (!textContent || textContent.length === 0) {\n                                return null;\n                            }\n                            initialData = data = {\n                                annotationType: _util.AnnotationEditorType.FREETEXT,\n                                color: Array.from(fontColor),\n                                fontSize,\n                                value: textContent.join(\"\\n\"),\n                                position: textPosition,\n                                pageIndex: pageNumber - 1,\n                                rect,\n                                rotation,\n                                id,\n                                deleted: false\n                            };\n                        }\n                        const editor = super.deserialize(data, parent, uiManager);\n                        editor.#fontSize = data.fontSize;\n                        editor.#color = _util.Util.makeHexColor(...data.color);\n                        editor.#content = data.value;\n                        editor.annotationElementId = data.id || null;\n                        editor.#initialData = initialData;\n                        return editor;\n                    }\n                    serialize(isForCopying = false) {\n                        if (this.isEmpty()) {\n                            return null;\n                        }\n                        if (this.deleted) {\n                            return {\n                                pageIndex: this.pageIndex,\n                                id: this.annotationElementId,\n                                deleted: true\n                            };\n                        }\n                        const padding = FreeTextEditor._internalPadding * this.parentScale;\n                        const rect = this.getRect(padding, padding);\n                        const color = _editor.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);\n                        const serialized = {\n                            annotationType: _util.AnnotationEditorType.FREETEXT,\n                            color,\n                            fontSize: this.#fontSize,\n                            value: this.#content,\n                            pageIndex: this.pageIndex,\n                            rect,\n                            rotation: this.rotation,\n                            structTreeParentId: this._structTreeParentId\n                        };\n                        if (isForCopying) {\n                            return serialized;\n                        }\n                        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n                            return null;\n                        }\n                        serialized.id = this.annotationElementId;\n                        return serialized;\n                    }\n                    #hasElementChanged(serialized) {\n                        const { value, fontSize, color, rect, pageIndex } = this.#initialData;\n                        return serialized.value !== value || serialized.fontSize !== fontSize || serialized.rect.some((x, i)=>Math.abs(x - rect[i]) >= 1) || serialized.color.some((c, i)=>c !== color[i]) || serialized.pageIndex !== pageIndex;\n                    }\n                    #cheatInitialRect(delayed = false) {\n                        if (!this.annotationElementId) {\n                            return;\n                        }\n                        this.#setEditorDimensions();\n                        if (!delayed && (this.width === 0 || this.height === 0)) {\n                            setTimeout(()=>this.#cheatInitialRect(true), 0);\n                            return;\n                        }\n                        const padding = FreeTextEditor._internalPadding * this.parentScale;\n                        this.#initialData.rect = this.getRect(padding, padding);\n                    }\n                }\n                exports1.FreeTextEditor = FreeTextEditor;\n            /***/ },\n            /* 29 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.StampAnnotationElement = exports1.InkAnnotationElement = exports1.FreeTextAnnotationElement = exports1.AnnotationLayer = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _display_utils = __w_pdfjs_require__(6);\n                var _annotation_storage = __w_pdfjs_require__(3);\n                var _scripting_utils = __w_pdfjs_require__(30);\n                var _displayL10n_utils = __w_pdfjs_require__(31);\n                var _xfa_layer = __w_pdfjs_require__(32);\n                const DEFAULT_TAB_INDEX = 1000;\n                const DEFAULT_FONT_SIZE = 9;\n                const GetElementsByNameSet = new WeakSet();\n                function getRectDims(rect) {\n                    return {\n                        width: rect[2] - rect[0],\n                        height: rect[3] - rect[1]\n                    };\n                }\n                class AnnotationElementFactory {\n                    static create(parameters) {\n                        const subtype = parameters.data.annotationType;\n                        switch(subtype){\n                            case _util.AnnotationType.LINK:\n                                return new LinkAnnotationElement(parameters);\n                            case _util.AnnotationType.TEXT:\n                                return new TextAnnotationElement(parameters);\n                            case _util.AnnotationType.WIDGET:\n                                const fieldType = parameters.data.fieldType;\n                                switch(fieldType){\n                                    case \"Tx\":\n                                        return new TextWidgetAnnotationElement(parameters);\n                                    case \"Btn\":\n                                        if (parameters.data.radioButton) {\n                                            return new RadioButtonWidgetAnnotationElement(parameters);\n                                        } else if (parameters.data.checkBox) {\n                                            return new CheckboxWidgetAnnotationElement(parameters);\n                                        }\n                                        return new PushButtonWidgetAnnotationElement(parameters);\n                                    case \"Ch\":\n                                        return new ChoiceWidgetAnnotationElement(parameters);\n                                    case \"Sig\":\n                                        return new SignatureWidgetAnnotationElement(parameters);\n                                }\n                                return new WidgetAnnotationElement(parameters);\n                            case _util.AnnotationType.POPUP:\n                                return new PopupAnnotationElement(parameters);\n                            case _util.AnnotationType.FREETEXT:\n                                return new FreeTextAnnotationElement(parameters);\n                            case _util.AnnotationType.LINE:\n                                return new LineAnnotationElement(parameters);\n                            case _util.AnnotationType.SQUARE:\n                                return new SquareAnnotationElement(parameters);\n                            case _util.AnnotationType.CIRCLE:\n                                return new CircleAnnotationElement(parameters);\n                            case _util.AnnotationType.POLYLINE:\n                                return new PolylineAnnotationElement(parameters);\n                            case _util.AnnotationType.CARET:\n                                return new CaretAnnotationElement(parameters);\n                            case _util.AnnotationType.INK:\n                                return new InkAnnotationElement(parameters);\n                            case _util.AnnotationType.POLYGON:\n                                return new PolygonAnnotationElement(parameters);\n                            case _util.AnnotationType.HIGHLIGHT:\n                                return new HighlightAnnotationElement(parameters);\n                            case _util.AnnotationType.UNDERLINE:\n                                return new UnderlineAnnotationElement(parameters);\n                            case _util.AnnotationType.SQUIGGLY:\n                                return new SquigglyAnnotationElement(parameters);\n                            case _util.AnnotationType.STRIKEOUT:\n                                return new StrikeOutAnnotationElement(parameters);\n                            case _util.AnnotationType.STAMP:\n                                return new StampAnnotationElement(parameters);\n                            case _util.AnnotationType.FILEATTACHMENT:\n                                return new FileAttachmentAnnotationElement(parameters);\n                            default:\n                                return new AnnotationElement(parameters);\n                        }\n                    }\n                }\n                class AnnotationElement {\n                    #hasBorder;\n                    constructor(parameters, { isRenderable = false, ignoreBorder = false, createQuadrilaterals = false } = {}){\n                        this.#hasBorder = false;\n                        this.isRenderable = isRenderable;\n                        this.data = parameters.data;\n                        this.layer = parameters.layer;\n                        this.linkService = parameters.linkService;\n                        this.downloadManager = parameters.downloadManager;\n                        this.imageResourcesPath = parameters.imageResourcesPath;\n                        this.renderForms = parameters.renderForms;\n                        this.svgFactory = parameters.svgFactory;\n                        this.annotationStorage = parameters.annotationStorage;\n                        this.enableScripting = parameters.enableScripting;\n                        this.hasJSActions = parameters.hasJSActions;\n                        this._fieldObjects = parameters.fieldObjects;\n                        this.parent = parameters.parent;\n                        if (isRenderable) {\n                            this.container = this._createContainer(ignoreBorder);\n                        }\n                        if (createQuadrilaterals) {\n                            this._createQuadrilaterals();\n                        }\n                    }\n                    static _hasPopupData({ titleObj, contentsObj, richText }) {\n                        return !!(titleObj?.str || contentsObj?.str || richText?.str);\n                    }\n                    get hasPopupData() {\n                        return AnnotationElement._hasPopupData(this.data);\n                    }\n                    _createContainer(ignoreBorder) {\n                        const { data, parent: { page, viewport } } = this;\n                        const container = document.createElement(\"section\");\n                        container.setAttribute(\"data-annotation-id\", data.id);\n                        if (!(this instanceof WidgetAnnotationElement)) {\n                            container.tabIndex = DEFAULT_TAB_INDEX;\n                        }\n                        container.style.zIndex = this.parent.zIndex++;\n                        if (this.data.popupRef) {\n                            container.setAttribute(\"aria-haspopup\", \"dialog\");\n                        }\n                        if (data.noRotate) {\n                            container.classList.add(\"norotate\");\n                        }\n                        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n                        if (!data.rect || this instanceof PopupAnnotationElement) {\n                            const { rotation } = data;\n                            if (!data.hasOwnCanvas && rotation !== 0) {\n                                this.setRotation(rotation, container);\n                            }\n                            return container;\n                        }\n                        const { width, height } = getRectDims(data.rect);\n                        const rect = _util.Util.normalizeRect([\n                            data.rect[0],\n                            page.view[3] - data.rect[1] + page.view[1],\n                            data.rect[2],\n                            page.view[3] - data.rect[3] + page.view[1]\n                        ]);\n                        if (!ignoreBorder && data.borderStyle.width > 0) {\n                            container.style.borderWidth = `${data.borderStyle.width}px`;\n                            const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n                            const verticalRadius = data.borderStyle.verticalCornerRadius;\n                            if (horizontalRadius > 0 || verticalRadius > 0) {\n                                const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;\n                                container.style.borderRadius = radius;\n                            } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n                                const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;\n                                container.style.borderRadius = radius;\n                            }\n                            switch(data.borderStyle.style){\n                                case _util.AnnotationBorderStyleType.SOLID:\n                                    container.style.borderStyle = \"solid\";\n                                    break;\n                                case _util.AnnotationBorderStyleType.DASHED:\n                                    container.style.borderStyle = \"dashed\";\n                                    break;\n                                case _util.AnnotationBorderStyleType.BEVELED:\n                                    (0, _util.warn)(\"Unimplemented border style: beveled\");\n                                    break;\n                                case _util.AnnotationBorderStyleType.INSET:\n                                    (0, _util.warn)(\"Unimplemented border style: inset\");\n                                    break;\n                                case _util.AnnotationBorderStyleType.UNDERLINE:\n                                    container.style.borderBottomStyle = \"solid\";\n                                    break;\n                                default:\n                                    break;\n                            }\n                            const borderColor = data.borderColor || null;\n                            if (borderColor) {\n                                this.#hasBorder = true;\n                                container.style.borderColor = _util.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n                            } else {\n                                container.style.borderWidth = 0;\n                            }\n                        }\n                        container.style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n                        container.style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;\n                        const { rotation } = data;\n                        if (data.hasOwnCanvas || rotation === 0) {\n                            container.style.width = `${100 * width / pageWidth}%`;\n                            container.style.height = `${100 * height / pageHeight}%`;\n                        } else {\n                            this.setRotation(rotation, container);\n                        }\n                        return container;\n                    }\n                    setRotation(angle, container = this.container) {\n                        if (!this.data.rect) {\n                            return;\n                        }\n                        const { pageWidth, pageHeight } = this.parent.viewport.rawDims;\n                        const { width, height } = getRectDims(this.data.rect);\n                        let elementWidth, elementHeight;\n                        if (angle % 180 === 0) {\n                            elementWidth = 100 * width / pageWidth;\n                            elementHeight = 100 * height / pageHeight;\n                        } else {\n                            elementWidth = 100 * height / pageWidth;\n                            elementHeight = 100 * width / pageHeight;\n                        }\n                        container.style.width = `${elementWidth}%`;\n                        container.style.height = `${elementHeight}%`;\n                        container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n                    }\n                    get _commonActions() {\n                        const setColor = (jsName, styleName, event)=>{\n                            const color = event.detail[jsName];\n                            const colorType = color[0];\n                            const colorArray = color.slice(1);\n                            event.target.style[styleName] = _scripting_utils.ColorConverters[`${colorType}_HTML`](colorArray);\n                            this.annotationStorage.setValue(this.data.id, {\n                                [styleName]: _scripting_utils.ColorConverters[`${colorType}_rgb`](colorArray)\n                            });\n                        };\n                        return (0, _util.shadow)(this, \"_commonActions\", {\n                            display: (event)=>{\n                                const { display } = event.detail;\n                                const hidden = display % 2 === 1;\n                                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                                this.annotationStorage.setValue(this.data.id, {\n                                    noView: hidden,\n                                    noPrint: display === 1 || display === 2\n                                });\n                            },\n                            print: (event)=>{\n                                this.annotationStorage.setValue(this.data.id, {\n                                    noPrint: !event.detail.print\n                                });\n                            },\n                            hidden: (event)=>{\n                                const { hidden } = event.detail;\n                                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                                this.annotationStorage.setValue(this.data.id, {\n                                    noPrint: hidden,\n                                    noView: hidden\n                                });\n                            },\n                            focus: (event)=>{\n                                setTimeout(()=>event.target.focus({\n                                        preventScroll: false\n                                    }), 0);\n                            },\n                            userName: (event)=>{\n                                event.target.title = event.detail.userName;\n                            },\n                            readonly: (event)=>{\n                                event.target.disabled = event.detail.readonly;\n                            },\n                            required: (event)=>{\n                                this._setRequired(event.target, event.detail.required);\n                            },\n                            bgColor: (event)=>{\n                                setColor(\"bgColor\", \"backgroundColor\", event);\n                            },\n                            fillColor: (event)=>{\n                                setColor(\"fillColor\", \"backgroundColor\", event);\n                            },\n                            fgColor: (event)=>{\n                                setColor(\"fgColor\", \"color\", event);\n                            },\n                            textColor: (event)=>{\n                                setColor(\"textColor\", \"color\", event);\n                            },\n                            borderColor: (event)=>{\n                                setColor(\"borderColor\", \"borderColor\", event);\n                            },\n                            strokeColor: (event)=>{\n                                setColor(\"strokeColor\", \"borderColor\", event);\n                            },\n                            rotation: (event)=>{\n                                const angle = event.detail.rotation;\n                                this.setRotation(angle);\n                                this.annotationStorage.setValue(this.data.id, {\n                                    rotation: angle\n                                });\n                            }\n                        });\n                    }\n                    _dispatchEventFromSandbox(actions, jsEvent) {\n                        const commonActions = this._commonActions;\n                        for (const name of Object.keys(jsEvent.detail)){\n                            const action = actions[name] || commonActions[name];\n                            action?.(jsEvent);\n                        }\n                    }\n                    _setDefaultPropertiesFromJS(element) {\n                        if (!this.enableScripting) {\n                            return;\n                        }\n                        const storedData = this.annotationStorage.getRawValue(this.data.id);\n                        if (!storedData) {\n                            return;\n                        }\n                        const commonActions = this._commonActions;\n                        for (const [actionName, detail] of Object.entries(storedData)){\n                            const action = commonActions[actionName];\n                            if (action) {\n                                const eventProxy = {\n                                    detail: {\n                                        [actionName]: detail\n                                    },\n                                    target: element\n                                };\n                                action(eventProxy);\n                                delete storedData[actionName];\n                            }\n                        }\n                    }\n                    _createQuadrilaterals() {\n                        if (!this.container) {\n                            return;\n                        }\n                        const { quadPoints } = this.data;\n                        if (!quadPoints) {\n                            return;\n                        }\n                        const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect;\n                        if (quadPoints.length === 1) {\n                            const [, { x: trX, y: trY }, { x: blX, y: blY }] = quadPoints[0];\n                            if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {\n                                return;\n                            }\n                        }\n                        const { style } = this.container;\n                        let svgBuffer;\n                        if (this.#hasBorder) {\n                            const { borderColor, borderWidth } = style;\n                            style.borderWidth = 0;\n                            svgBuffer = [\n                                \"url('data:image/svg+xml;utf8,\",\n                                `<svg xmlns=\"http://www.w3.org/2000/svg\"`,\n                                ` preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">`,\n                                `<g fill=\"transparent\" stroke=\"${borderColor}\" stroke-width=\"${borderWidth}\">`\n                            ];\n                            this.container.classList.add(\"hasBorder\");\n                        }\n                        const width = rectTrX - rectBlX;\n                        const height = rectTrY - rectBlY;\n                        const { svgFactory } = this;\n                        const svg = svgFactory.createElement(\"svg\");\n                        svg.classList.add(\"quadrilateralsContainer\");\n                        svg.setAttribute(\"width\", 0);\n                        svg.setAttribute(\"height\", 0);\n                        const defs = svgFactory.createElement(\"defs\");\n                        svg.append(defs);\n                        const clipPath = svgFactory.createElement(\"clipPath\");\n                        const id = `clippath_${this.data.id}`;\n                        clipPath.setAttribute(\"id\", id);\n                        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n                        defs.append(clipPath);\n                        for (const [, { x: trX, y: trY }, { x: blX, y: blY }] of quadPoints){\n                            const rect = svgFactory.createElement(\"rect\");\n                            const x = (blX - rectBlX) / width;\n                            const y = (rectTrY - trY) / height;\n                            const rectWidth = (trX - blX) / width;\n                            const rectHeight = (trY - blY) / height;\n                            rect.setAttribute(\"x\", x);\n                            rect.setAttribute(\"y\", y);\n                            rect.setAttribute(\"width\", rectWidth);\n                            rect.setAttribute(\"height\", rectHeight);\n                            clipPath.append(rect);\n                            svgBuffer?.push(`<rect vector-effect=\"non-scaling-stroke\" x=\"${x}\" y=\"${y}\" width=\"${rectWidth}\" height=\"${rectHeight}\"/>`);\n                        }\n                        if (this.#hasBorder) {\n                            svgBuffer.push(`</g></svg>')`);\n                            style.backgroundImage = svgBuffer.join(\"\");\n                        }\n                        this.container.append(svg);\n                        this.container.style.clipPath = `url(#${id})`;\n                    }\n                    _createPopup() {\n                        const { container, data } = this;\n                        container.setAttribute(\"aria-haspopup\", \"dialog\");\n                        const popup = new PopupAnnotationElement({\n                            data: {\n                                color: data.color,\n                                titleObj: data.titleObj,\n                                modificationDate: data.modificationDate,\n                                contentsObj: data.contentsObj,\n                                richText: data.richText,\n                                parentRect: data.rect,\n                                borderStyle: 0,\n                                id: `popup_${data.id}`,\n                                rotation: data.rotation\n                            },\n                            parent: this.parent,\n                            elements: [\n                                this\n                            ]\n                        });\n                        this.parent.div.append(popup.render());\n                    }\n                    render() {\n                        (0, _util.unreachable)(\"Abstract method `AnnotationElement.render` called\");\n                    }\n                    _getElementsByName(name, skipId = null) {\n                        const fields = [];\n                        if (this._fieldObjects) {\n                            const fieldObj = this._fieldObjects[name];\n                            if (fieldObj) {\n                                for (const { page, id, exportValues } of fieldObj){\n                                    if (page === -1) {\n                                        continue;\n                                    }\n                                    if (id === skipId) {\n                                        continue;\n                                    }\n                                    const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n                                    const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                                    if (domElement && !GetElementsByNameSet.has(domElement)) {\n                                        (0, _util.warn)(`_getElementsByName - element not allowed: ${id}`);\n                                        continue;\n                                    }\n                                    fields.push({\n                                        id,\n                                        exportValue,\n                                        domElement\n                                    });\n                                }\n                            }\n                            return fields;\n                        }\n                        for (const domElement of document.getElementsByName(name)){\n                            const { exportValue } = domElement;\n                            const id = domElement.getAttribute(\"data-element-id\");\n                            if (id === skipId) {\n                                continue;\n                            }\n                            if (!GetElementsByNameSet.has(domElement)) {\n                                continue;\n                            }\n                            fields.push({\n                                id,\n                                exportValue,\n                                domElement\n                            });\n                        }\n                        return fields;\n                    }\n                    show() {\n                        if (this.container) {\n                            this.container.hidden = false;\n                        }\n                        this.popup?.maybeShow();\n                    }\n                    hide() {\n                        if (this.container) {\n                            this.container.hidden = true;\n                        }\n                        this.popup?.forceHide();\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.container;\n                    }\n                    addHighlightArea() {\n                        const triggers = this.getElementsToTriggerPopup();\n                        if (Array.isArray(triggers)) {\n                            for (const element of triggers){\n                                element.classList.add(\"highlightArea\");\n                            }\n                        } else {\n                            triggers.classList.add(\"highlightArea\");\n                        }\n                    }\n                    _editOnDoubleClick() {\n                        const { annotationEditorType: mode, data: { id: editId } } = this;\n                        this.container.addEventListener(\"dblclick\", ()=>{\n                            this.linkService.eventBus?.dispatch(\"switchannotationeditormode\", {\n                                source: this,\n                                mode,\n                                editId\n                            });\n                        });\n                    }\n                }\n                class LinkAnnotationElement extends AnnotationElement {\n                    constructor(parameters, options = null){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: !!options?.ignoreBorder,\n                            createQuadrilaterals: true\n                        });\n                        this.isTooltipOnly = parameters.data.isTooltipOnly;\n                    }\n                    render() {\n                        const { data, linkService } = this;\n                        const link = document.createElement(\"a\");\n                        link.setAttribute(\"data-element-id\", data.id);\n                        let isBound = false;\n                        if (data.url) {\n                            linkService.addLinkAttributes(link, data.url, data.newWindow);\n                            isBound = true;\n                        } else if (data.action) {\n                            this._bindNamedAction(link, data.action);\n                            isBound = true;\n                        } else if (data.attachment) {\n                            this._bindAttachment(link, data.attachment);\n                            isBound = true;\n                        } else if (data.setOCGState) {\n                            this.#bindSetOCGState(link, data.setOCGState);\n                            isBound = true;\n                        } else if (data.dest) {\n                            this._bindLink(link, data.dest);\n                            isBound = true;\n                        } else {\n                            if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n                                this._bindJSAction(link, data);\n                                isBound = true;\n                            }\n                            if (data.resetForm) {\n                                this._bindResetFormAction(link, data.resetForm);\n                                isBound = true;\n                            } else if (this.isTooltipOnly && !isBound) {\n                                this._bindLink(link, \"\");\n                                isBound = true;\n                            }\n                        }\n                        this.container.classList.add(\"linkAnnotation\");\n                        if (isBound) {\n                            this.container.append(link);\n                        }\n                        return this.container;\n                    }\n                    #setInternalLink() {\n                        this.container.setAttribute(\"data-internal-link\", \"\");\n                    }\n                    _bindLink(link, destination) {\n                        link.href = this.linkService.getDestinationHash(destination);\n                        link.onclick = ()=>{\n                            if (destination) {\n                                this.linkService.goToDestination(destination);\n                            }\n                            return false;\n                        };\n                        if (destination || destination === \"\") {\n                            this.#setInternalLink();\n                        }\n                    }\n                    _bindNamedAction(link, action) {\n                        link.href = this.linkService.getAnchorUrl(\"\");\n                        link.onclick = ()=>{\n                            this.linkService.executeNamedAction(action);\n                            return false;\n                        };\n                        this.#setInternalLink();\n                    }\n                    _bindAttachment(link, attachment) {\n                        link.href = this.linkService.getAnchorUrl(\"\");\n                        link.onclick = ()=>{\n                            this.downloadManager?.openOrDownloadData(this.container, attachment.content, attachment.filename);\n                            return false;\n                        };\n                        this.#setInternalLink();\n                    }\n                    #bindSetOCGState(link, action) {\n                        link.href = this.linkService.getAnchorUrl(\"\");\n                        link.onclick = ()=>{\n                            this.linkService.executeSetOCGState(action);\n                            return false;\n                        };\n                        this.#setInternalLink();\n                    }\n                    _bindJSAction(link, data) {\n                        link.href = this.linkService.getAnchorUrl(\"\");\n                        const map = new Map([\n                            [\n                                \"Action\",\n                                \"onclick\"\n                            ],\n                            [\n                                \"Mouse Up\",\n                                \"onmouseup\"\n                            ],\n                            [\n                                \"Mouse Down\",\n                                \"onmousedown\"\n                            ]\n                        ]);\n                        for (const name of Object.keys(data.actions)){\n                            const jsName = map.get(name);\n                            if (!jsName) {\n                                continue;\n                            }\n                            link[jsName] = ()=>{\n                                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                    source: this,\n                                    detail: {\n                                        id: data.id,\n                                        name\n                                    }\n                                });\n                                return false;\n                            };\n                        }\n                        if (!link.onclick) {\n                            link.onclick = ()=>false;\n                        }\n                        this.#setInternalLink();\n                    }\n                    _bindResetFormAction(link, resetForm) {\n                        const otherClickAction = link.onclick;\n                        if (!otherClickAction) {\n                            link.href = this.linkService.getAnchorUrl(\"\");\n                        }\n                        this.#setInternalLink();\n                        if (!this._fieldObjects) {\n                            (0, _util.warn)(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n                            if (!otherClickAction) {\n                                link.onclick = ()=>false;\n                            }\n                            return;\n                        }\n                        link.onclick = ()=>{\n                            otherClickAction?.();\n                            const { fields: resetFormFields, refs: resetFormRefs, include } = resetForm;\n                            const allFields = [];\n                            if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n                                const fieldIds = new Set(resetFormRefs);\n                                for (const fieldName of resetFormFields){\n                                    const fields = this._fieldObjects[fieldName] || [];\n                                    for (const { id } of fields){\n                                        fieldIds.add(id);\n                                    }\n                                }\n                                for (const fields of Object.values(this._fieldObjects)){\n                                    for (const field of fields){\n                                        if (fieldIds.has(field.id) === include) {\n                                            allFields.push(field);\n                                        }\n                                    }\n                                }\n                            } else {\n                                for (const fields of Object.values(this._fieldObjects)){\n                                    allFields.push(...fields);\n                                }\n                            }\n                            const storage = this.annotationStorage;\n                            const allIds = [];\n                            for (const field of allFields){\n                                const { id } = field;\n                                allIds.push(id);\n                                switch(field.type){\n                                    case \"text\":\n                                        {\n                                            const value = field.defaultValue || \"\";\n                                            storage.setValue(id, {\n                                                value\n                                            });\n                                            break;\n                                        }\n                                    case \"checkbox\":\n                                    case \"radiobutton\":\n                                        {\n                                            const value = field.defaultValue === field.exportValues;\n                                            storage.setValue(id, {\n                                                value\n                                            });\n                                            break;\n                                        }\n                                    case \"combobox\":\n                                    case \"listbox\":\n                                        {\n                                            const value = field.defaultValue || \"\";\n                                            storage.setValue(id, {\n                                                value\n                                            });\n                                            break;\n                                        }\n                                    default:\n                                        continue;\n                                }\n                                const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                                if (!domElement) {\n                                    continue;\n                                } else if (!GetElementsByNameSet.has(domElement)) {\n                                    (0, _util.warn)(`_bindResetFormAction - element not allowed: ${id}`);\n                                    continue;\n                                }\n                                domElement.dispatchEvent(new Event(\"resetform\"));\n                            }\n                            if (this.enableScripting) {\n                                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                    source: this,\n                                    detail: {\n                                        id: \"app\",\n                                        ids: allIds,\n                                        name: \"ResetForm\"\n                                    }\n                                });\n                            }\n                            return false;\n                        };\n                    }\n                }\n                class TextAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"textAnnotation\");\n                        const image = document.createElement(\"img\");\n                        image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n                        image.alt = \"[{{type}} Annotation]\";\n                        image.dataset.l10nId = \"text_annotation_type\";\n                        image.dataset.l10nArgs = JSON.stringify({\n                            type: this.data.name\n                        });\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this.container.append(image);\n                        return this.container;\n                    }\n                }\n                class WidgetAnnotationElement extends AnnotationElement {\n                    render() {\n                        if (this.data.alternativeText) {\n                            this.container.title = this.data.alternativeText;\n                        }\n                        return this.container;\n                    }\n                    showElementAndHideCanvas(element) {\n                        if (this.data.hasOwnCanvas) {\n                            if (element.previousSibling?.nodeName === \"CANVAS\") {\n                                element.previousSibling.hidden = true;\n                            }\n                            element.hidden = false;\n                        }\n                    }\n                    _getKeyModifier(event) {\n                        const { isWin, isMac } = _util.FeatureTest.platform;\n                        return isWin && event.ctrlKey || isMac && event.metaKey;\n                    }\n                    _setEventListener(element, elementData, baseName, eventName, valueGetter) {\n                        if (baseName.includes(\"mouse\")) {\n                            element.addEventListener(baseName, (event)=>{\n                                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                    source: this,\n                                    detail: {\n                                        id: this.data.id,\n                                        name: eventName,\n                                        value: valueGetter(event),\n                                        shift: event.shiftKey,\n                                        modifier: this._getKeyModifier(event)\n                                    }\n                                });\n                            });\n                        } else {\n                            element.addEventListener(baseName, (event)=>{\n                                if (baseName === \"blur\") {\n                                    if (!elementData.focused || !event.relatedTarget) {\n                                        return;\n                                    }\n                                    elementData.focused = false;\n                                } else if (baseName === \"focus\") {\n                                    if (elementData.focused) {\n                                        return;\n                                    }\n                                    elementData.focused = true;\n                                }\n                                if (!valueGetter) {\n                                    return;\n                                }\n                                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                    source: this,\n                                    detail: {\n                                        id: this.data.id,\n                                        name: eventName,\n                                        value: valueGetter(event)\n                                    }\n                                });\n                            });\n                        }\n                    }\n                    _setEventListeners(element, elementData, names, getter) {\n                        for (const [baseName, eventName] of names){\n                            if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n                                if (eventName === \"Focus\" || eventName === \"Blur\") {\n                                    elementData ||= {\n                                        focused: false\n                                    };\n                                }\n                                this._setEventListener(element, elementData, baseName, eventName, getter);\n                                if (eventName === \"Focus\" && !this.data.actions?.Blur) {\n                                    this._setEventListener(element, elementData, \"blur\", \"Blur\", null);\n                                } else if (eventName === \"Blur\" && !this.data.actions?.Focus) {\n                                    this._setEventListener(element, elementData, \"focus\", \"Focus\", null);\n                                }\n                            }\n                        }\n                    }\n                    _setBackgroundColor(element) {\n                        const color = this.data.backgroundColor || null;\n                        element.style.backgroundColor = color === null ? \"transparent\" : _util.Util.makeHexColor(color[0], color[1], color[2]);\n                    }\n                    _setTextStyle(element) {\n                        const TEXT_ALIGNMENT = [\n                            \"left\",\n                            \"center\",\n                            \"right\"\n                        ];\n                        const { fontColor } = this.data.defaultAppearanceData;\n                        const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;\n                        const style = element.style;\n                        let computedFontSize;\n                        const BORDER_SIZE = 2;\n                        const roundToOneDecimal = (x)=>Math.round(10 * x) / 10;\n                        if (this.data.multiLine) {\n                            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n                            const numberOfLines = Math.round(height / (_util.LINE_FACTOR * fontSize)) || 1;\n                            const lineHeight = height / numberOfLines;\n                            computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / _util.LINE_FACTOR));\n                        } else {\n                            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n                            computedFontSize = Math.min(fontSize, roundToOneDecimal(height / _util.LINE_FACTOR));\n                        }\n                        style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;\n                        style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n                        if (this.data.textAlignment !== null) {\n                            style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n                        }\n                    }\n                    _setRequired(element, isRequired) {\n                        if (isRequired) {\n                            element.setAttribute(\"required\", true);\n                        } else {\n                            element.removeAttribute(\"required\");\n                        }\n                        element.setAttribute(\"aria-required\", isRequired);\n                    }\n                }\n                class TextWidgetAnnotationElement extends WidgetAnnotationElement {\n                    constructor(parameters){\n                        const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n                        super(parameters, {\n                            isRenderable\n                        });\n                    }\n                    setPropertyOnSiblings(base, key, value, keyInStorage) {\n                        const storage = this.annotationStorage;\n                        for (const element of this._getElementsByName(base.name, base.id)){\n                            if (element.domElement) {\n                                element.domElement[key] = value;\n                            }\n                            storage.setValue(element.id, {\n                                [keyInStorage]: value\n                            });\n                        }\n                    }\n                    render() {\n                        const storage = this.annotationStorage;\n                        const id = this.data.id;\n                        this.container.classList.add(\"textWidgetAnnotation\");\n                        let element = null;\n                        if (this.renderForms) {\n                            const storedData = storage.getValue(id, {\n                                value: this.data.fieldValue\n                            });\n                            let textContent = storedData.value || \"\";\n                            const maxLen = storage.getValue(id, {\n                                charLimit: this.data.maxLen\n                            }).charLimit;\n                            if (maxLen && textContent.length > maxLen) {\n                                textContent = textContent.slice(0, maxLen);\n                            }\n                            let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join(\"\\n\") || null;\n                            if (fieldFormattedValues && this.data.comb) {\n                                fieldFormattedValues = fieldFormattedValues.replaceAll(/\\s+/g, \"\");\n                            }\n                            const elementData = {\n                                userValue: textContent,\n                                formattedValue: fieldFormattedValues,\n                                lastCommittedValue: null,\n                                commitKey: 1,\n                                focused: false\n                            };\n                            if (this.data.multiLine) {\n                                element = document.createElement(\"textarea\");\n                                element.textContent = fieldFormattedValues ?? textContent;\n                                if (this.data.doNotScroll) {\n                                    element.style.overflowY = \"hidden\";\n                                }\n                            } else {\n                                element = document.createElement(\"input\");\n                                element.type = \"text\";\n                                element.setAttribute(\"value\", fieldFormattedValues ?? textContent);\n                                if (this.data.doNotScroll) {\n                                    element.style.overflowX = \"hidden\";\n                                }\n                            }\n                            if (this.data.hasOwnCanvas) {\n                                element.hidden = true;\n                            }\n                            GetElementsByNameSet.add(element);\n                            element.setAttribute(\"data-element-id\", id);\n                            element.disabled = this.data.readOnly;\n                            element.name = this.data.fieldName;\n                            element.tabIndex = DEFAULT_TAB_INDEX;\n                            this._setRequired(element, this.data.required);\n                            if (maxLen) {\n                                element.maxLength = maxLen;\n                            }\n                            element.addEventListener(\"input\", (event)=>{\n                                storage.setValue(id, {\n                                    value: event.target.value\n                                });\n                                this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n                                elementData.formattedValue = null;\n                            });\n                            element.addEventListener(\"resetform\", (event)=>{\n                                const defaultValue = this.data.defaultFieldValue ?? \"\";\n                                element.value = elementData.userValue = defaultValue;\n                                elementData.formattedValue = null;\n                            });\n                            let blurListener = (event)=>{\n                                const { formattedValue } = elementData;\n                                if (formattedValue !== null && formattedValue !== undefined) {\n                                    event.target.value = formattedValue;\n                                }\n                                event.target.scrollLeft = 0;\n                            };\n                            if (this.enableScripting && this.hasJSActions) {\n                                element.addEventListener(\"focus\", (event)=>{\n                                    if (elementData.focused) {\n                                        return;\n                                    }\n                                    const { target } = event;\n                                    if (elementData.userValue) {\n                                        target.value = elementData.userValue;\n                                    }\n                                    elementData.lastCommittedValue = target.value;\n                                    elementData.commitKey = 1;\n                                    elementData.focused = true;\n                                });\n                                element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                                    this.showElementAndHideCanvas(jsEvent.target);\n                                    const actions = {\n                                        value (event) {\n                                            elementData.userValue = event.detail.value ?? \"\";\n                                            storage.setValue(id, {\n                                                value: elementData.userValue.toString()\n                                            });\n                                            event.target.value = elementData.userValue;\n                                        },\n                                        formattedValue (event) {\n                                            const { formattedValue } = event.detail;\n                                            elementData.formattedValue = formattedValue;\n                                            if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                                                event.target.value = formattedValue;\n                                            }\n                                            storage.setValue(id, {\n                                                formattedValue\n                                            });\n                                        },\n                                        selRange (event) {\n                                            event.target.setSelectionRange(...event.detail.selRange);\n                                        },\n                                        charLimit: (event)=>{\n                                            const { charLimit } = event.detail;\n                                            const { target } = event;\n                                            if (charLimit === 0) {\n                                                target.removeAttribute(\"maxLength\");\n                                                return;\n                                            }\n                                            target.setAttribute(\"maxLength\", charLimit);\n                                            let value = elementData.userValue;\n                                            if (!value || value.length <= charLimit) {\n                                                return;\n                                            }\n                                            value = value.slice(0, charLimit);\n                                            target.value = elementData.userValue = value;\n                                            storage.setValue(id, {\n                                                value\n                                            });\n                                            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                                source: this,\n                                                detail: {\n                                                    id,\n                                                    name: \"Keystroke\",\n                                                    value,\n                                                    willCommit: true,\n                                                    commitKey: 1,\n                                                    selStart: target.selectionStart,\n                                                    selEnd: target.selectionEnd\n                                                }\n                                            });\n                                        }\n                                    };\n                                    this._dispatchEventFromSandbox(actions, jsEvent);\n                                });\n                                element.addEventListener(\"keydown\", (event)=>{\n                                    elementData.commitKey = 1;\n                                    let commitKey = -1;\n                                    if (event.key === \"Escape\") {\n                                        commitKey = 0;\n                                    } else if (event.key === \"Enter\" && !this.data.multiLine) {\n                                        commitKey = 2;\n                                    } else if (event.key === \"Tab\") {\n                                        elementData.commitKey = 3;\n                                    }\n                                    if (commitKey === -1) {\n                                        return;\n                                    }\n                                    const { value } = event.target;\n                                    if (elementData.lastCommittedValue === value) {\n                                        return;\n                                    }\n                                    elementData.lastCommittedValue = value;\n                                    elementData.userValue = value;\n                                    this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                        source: this,\n                                        detail: {\n                                            id,\n                                            name: \"Keystroke\",\n                                            value,\n                                            willCommit: true,\n                                            commitKey,\n                                            selStart: event.target.selectionStart,\n                                            selEnd: event.target.selectionEnd\n                                        }\n                                    });\n                                });\n                                const _blurListener = blurListener;\n                                blurListener = null;\n                                element.addEventListener(\"blur\", (event)=>{\n                                    if (!elementData.focused || !event.relatedTarget) {\n                                        return;\n                                    }\n                                    elementData.focused = false;\n                                    const { value } = event.target;\n                                    elementData.userValue = value;\n                                    if (elementData.lastCommittedValue !== value) {\n                                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                            source: this,\n                                            detail: {\n                                                id,\n                                                name: \"Keystroke\",\n                                                value,\n                                                willCommit: true,\n                                                commitKey: elementData.commitKey,\n                                                selStart: event.target.selectionStart,\n                                                selEnd: event.target.selectionEnd\n                                            }\n                                        });\n                                    }\n                                    _blurListener(event);\n                                });\n                                if (this.data.actions?.Keystroke) {\n                                    element.addEventListener(\"beforeinput\", (event)=>{\n                                        elementData.lastCommittedValue = null;\n                                        const { data, target } = event;\n                                        const { value, selectionStart, selectionEnd } = target;\n                                        let selStart = selectionStart, selEnd = selectionEnd;\n                                        switch(event.inputType){\n                                            case \"deleteWordBackward\":\n                                                {\n                                                    const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n                                                    if (match) {\n                                                        selStart -= match[0].length;\n                                                    }\n                                                    break;\n                                                }\n                                            case \"deleteWordForward\":\n                                                {\n                                                    const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n                                                    if (match) {\n                                                        selEnd += match[0].length;\n                                                    }\n                                                    break;\n                                                }\n                                            case \"deleteContentBackward\":\n                                                if (selectionStart === selectionEnd) {\n                                                    selStart -= 1;\n                                                }\n                                                break;\n                                            case \"deleteContentForward\":\n                                                if (selectionStart === selectionEnd) {\n                                                    selEnd += 1;\n                                                }\n                                                break;\n                                        }\n                                        event.preventDefault();\n                                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                            source: this,\n                                            detail: {\n                                                id,\n                                                name: \"Keystroke\",\n                                                value,\n                                                change: data || \"\",\n                                                willCommit: false,\n                                                selStart,\n                                                selEnd\n                                            }\n                                        });\n                                    });\n                                }\n                                this._setEventListeners(element, elementData, [\n                                    [\n                                        \"focus\",\n                                        \"Focus\"\n                                    ],\n                                    [\n                                        \"blur\",\n                                        \"Blur\"\n                                    ],\n                                    [\n                                        \"mousedown\",\n                                        \"Mouse Down\"\n                                    ],\n                                    [\n                                        \"mouseenter\",\n                                        \"Mouse Enter\"\n                                    ],\n                                    [\n                                        \"mouseleave\",\n                                        \"Mouse Exit\"\n                                    ],\n                                    [\n                                        \"mouseup\",\n                                        \"Mouse Up\"\n                                    ]\n                                ], (event)=>event.target.value);\n                            }\n                            if (blurListener) {\n                                element.addEventListener(\"blur\", blurListener);\n                            }\n                            if (this.data.comb) {\n                                const fieldWidth = this.data.rect[2] - this.data.rect[0];\n                                const combWidth = fieldWidth / maxLen;\n                                element.classList.add(\"comb\");\n                                element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;\n                            }\n                        } else {\n                            element = document.createElement(\"div\");\n                            element.textContent = this.data.fieldValue;\n                            element.style.verticalAlign = \"middle\";\n                            element.style.display = \"table-cell\";\n                        }\n                        this._setTextStyle(element);\n                        this._setBackgroundColor(element);\n                        this._setDefaultPropertiesFromJS(element);\n                        this.container.append(element);\n                        return this.container;\n                    }\n                }\n                class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: !!parameters.data.hasOwnCanvas\n                        });\n                    }\n                }\n                class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: parameters.renderForms\n                        });\n                    }\n                    render() {\n                        const storage = this.annotationStorage;\n                        const data = this.data;\n                        const id = data.id;\n                        let value = storage.getValue(id, {\n                            value: data.exportValue === data.fieldValue\n                        }).value;\n                        if (typeof value === \"string\") {\n                            value = value !== \"Off\";\n                            storage.setValue(id, {\n                                value\n                            });\n                        }\n                        this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n                        const element = document.createElement(\"input\");\n                        GetElementsByNameSet.add(element);\n                        element.setAttribute(\"data-element-id\", id);\n                        element.disabled = data.readOnly;\n                        this._setRequired(element, this.data.required);\n                        element.type = \"checkbox\";\n                        element.name = data.fieldName;\n                        if (value) {\n                            element.setAttribute(\"checked\", true);\n                        }\n                        element.setAttribute(\"exportValue\", data.exportValue);\n                        element.tabIndex = DEFAULT_TAB_INDEX;\n                        element.addEventListener(\"change\", (event)=>{\n                            const { name, checked } = event.target;\n                            for (const checkbox of this._getElementsByName(name, id)){\n                                const curChecked = checked && checkbox.exportValue === data.exportValue;\n                                if (checkbox.domElement) {\n                                    checkbox.domElement.checked = curChecked;\n                                }\n                                storage.setValue(checkbox.id, {\n                                    value: curChecked\n                                });\n                            }\n                            storage.setValue(id, {\n                                value: checked\n                            });\n                        });\n                        element.addEventListener(\"resetform\", (event)=>{\n                            const defaultValue = data.defaultFieldValue || \"Off\";\n                            event.target.checked = defaultValue === data.exportValue;\n                        });\n                        if (this.enableScripting && this.hasJSActions) {\n                            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                                const actions = {\n                                    value (event) {\n                                        event.target.checked = event.detail.value !== \"Off\";\n                                        storage.setValue(id, {\n                                            value: event.target.checked\n                                        });\n                                    }\n                                };\n                                this._dispatchEventFromSandbox(actions, jsEvent);\n                            });\n                            this._setEventListeners(element, null, [\n                                [\n                                    \"change\",\n                                    \"Validate\"\n                                ],\n                                [\n                                    \"change\",\n                                    \"Action\"\n                                ],\n                                [\n                                    \"focus\",\n                                    \"Focus\"\n                                ],\n                                [\n                                    \"blur\",\n                                    \"Blur\"\n                                ],\n                                [\n                                    \"mousedown\",\n                                    \"Mouse Down\"\n                                ],\n                                [\n                                    \"mouseenter\",\n                                    \"Mouse Enter\"\n                                ],\n                                [\n                                    \"mouseleave\",\n                                    \"Mouse Exit\"\n                                ],\n                                [\n                                    \"mouseup\",\n                                    \"Mouse Up\"\n                                ]\n                            ], (event)=>event.target.checked);\n                        }\n                        this._setBackgroundColor(element);\n                        this._setDefaultPropertiesFromJS(element);\n                        this.container.append(element);\n                        return this.container;\n                    }\n                }\n                class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: parameters.renderForms\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n                        const storage = this.annotationStorage;\n                        const data = this.data;\n                        const id = data.id;\n                        let value = storage.getValue(id, {\n                            value: data.fieldValue === data.buttonValue\n                        }).value;\n                        if (typeof value === \"string\") {\n                            value = value !== data.buttonValue;\n                            storage.setValue(id, {\n                                value\n                            });\n                        }\n                        const element = document.createElement(\"input\");\n                        GetElementsByNameSet.add(element);\n                        element.setAttribute(\"data-element-id\", id);\n                        element.disabled = data.readOnly;\n                        this._setRequired(element, this.data.required);\n                        element.type = \"radio\";\n                        element.name = data.fieldName;\n                        if (value) {\n                            element.setAttribute(\"checked\", true);\n                        }\n                        element.tabIndex = DEFAULT_TAB_INDEX;\n                        element.addEventListener(\"change\", (event)=>{\n                            const { name, checked } = event.target;\n                            for (const radio of this._getElementsByName(name, id)){\n                                storage.setValue(radio.id, {\n                                    value: false\n                                });\n                            }\n                            storage.setValue(id, {\n                                value: checked\n                            });\n                        });\n                        element.addEventListener(\"resetform\", (event)=>{\n                            const defaultValue = data.defaultFieldValue;\n                            event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n                        });\n                        if (this.enableScripting && this.hasJSActions) {\n                            const pdfButtonValue = data.buttonValue;\n                            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                                const actions = {\n                                    value: (event)=>{\n                                        const checked = pdfButtonValue === event.detail.value;\n                                        for (const radio of this._getElementsByName(event.target.name)){\n                                            const curChecked = checked && radio.id === id;\n                                            if (radio.domElement) {\n                                                radio.domElement.checked = curChecked;\n                                            }\n                                            storage.setValue(radio.id, {\n                                                value: curChecked\n                                            });\n                                        }\n                                    }\n                                };\n                                this._dispatchEventFromSandbox(actions, jsEvent);\n                            });\n                            this._setEventListeners(element, null, [\n                                [\n                                    \"change\",\n                                    \"Validate\"\n                                ],\n                                [\n                                    \"change\",\n                                    \"Action\"\n                                ],\n                                [\n                                    \"focus\",\n                                    \"Focus\"\n                                ],\n                                [\n                                    \"blur\",\n                                    \"Blur\"\n                                ],\n                                [\n                                    \"mousedown\",\n                                    \"Mouse Down\"\n                                ],\n                                [\n                                    \"mouseenter\",\n                                    \"Mouse Enter\"\n                                ],\n                                [\n                                    \"mouseleave\",\n                                    \"Mouse Exit\"\n                                ],\n                                [\n                                    \"mouseup\",\n                                    \"Mouse Up\"\n                                ]\n                            ], (event)=>event.target.checked);\n                        }\n                        this._setBackgroundColor(element);\n                        this._setDefaultPropertiesFromJS(element);\n                        this.container.append(element);\n                        return this.container;\n                    }\n                }\n                class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            ignoreBorder: parameters.data.hasAppearance\n                        });\n                    }\n                    render() {\n                        const container = super.render();\n                        container.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n                        if (this.data.alternativeText) {\n                            container.title = this.data.alternativeText;\n                        }\n                        const linkElement = container.lastChild;\n                        if (this.enableScripting && this.hasJSActions && linkElement) {\n                            this._setDefaultPropertiesFromJS(linkElement);\n                            linkElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                                this._dispatchEventFromSandbox({}, jsEvent);\n                            });\n                        }\n                        return container;\n                    }\n                }\n                class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: parameters.renderForms\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"choiceWidgetAnnotation\");\n                        const storage = this.annotationStorage;\n                        const id = this.data.id;\n                        const storedData = storage.getValue(id, {\n                            value: this.data.fieldValue\n                        });\n                        const selectElement = document.createElement(\"select\");\n                        GetElementsByNameSet.add(selectElement);\n                        selectElement.setAttribute(\"data-element-id\", id);\n                        selectElement.disabled = this.data.readOnly;\n                        this._setRequired(selectElement, this.data.required);\n                        selectElement.name = this.data.fieldName;\n                        selectElement.tabIndex = DEFAULT_TAB_INDEX;\n                        let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n                        if (!this.data.combo) {\n                            selectElement.size = this.data.options.length;\n                            if (this.data.multiSelect) {\n                                selectElement.multiple = true;\n                            }\n                        }\n                        selectElement.addEventListener(\"resetform\", (event)=>{\n                            const defaultValue = this.data.defaultFieldValue;\n                            for (const option of selectElement.options){\n                                option.selected = option.value === defaultValue;\n                            }\n                        });\n                        for (const option of this.data.options){\n                            const optionElement = document.createElement(\"option\");\n                            optionElement.textContent = option.displayValue;\n                            optionElement.value = option.exportValue;\n                            if (storedData.value.includes(option.exportValue)) {\n                                optionElement.setAttribute(\"selected\", true);\n                                addAnEmptyEntry = false;\n                            }\n                            selectElement.append(optionElement);\n                        }\n                        let removeEmptyEntry = null;\n                        if (addAnEmptyEntry) {\n                            const noneOptionElement = document.createElement(\"option\");\n                            noneOptionElement.value = \" \";\n                            noneOptionElement.setAttribute(\"hidden\", true);\n                            noneOptionElement.setAttribute(\"selected\", true);\n                            selectElement.prepend(noneOptionElement);\n                            removeEmptyEntry = ()=>{\n                                noneOptionElement.remove();\n                                selectElement.removeEventListener(\"input\", removeEmptyEntry);\n                                removeEmptyEntry = null;\n                            };\n                            selectElement.addEventListener(\"input\", removeEmptyEntry);\n                        }\n                        const getValue = (isExport)=>{\n                            const name = isExport ? \"value\" : \"textContent\";\n                            const { options, multiple } = selectElement;\n                            if (!multiple) {\n                                return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n                            }\n                            return Array.prototype.filter.call(options, (option)=>option.selected).map((option)=>option[name]);\n                        };\n                        let selectedValues = getValue(false);\n                        const getItems = (event)=>{\n                            const options = event.target.options;\n                            return Array.prototype.map.call(options, (option)=>{\n                                return {\n                                    displayValue: option.textContent,\n                                    exportValue: option.value\n                                };\n                            });\n                        };\n                        if (this.enableScripting && this.hasJSActions) {\n                            selectElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                                const actions = {\n                                    value (event) {\n                                        removeEmptyEntry?.();\n                                        const value = event.detail.value;\n                                        const values = new Set(Array.isArray(value) ? value : [\n                                            value\n                                        ]);\n                                        for (const option of selectElement.options){\n                                            option.selected = values.has(option.value);\n                                        }\n                                        storage.setValue(id, {\n                                            value: getValue(true)\n                                        });\n                                        selectedValues = getValue(false);\n                                    },\n                                    multipleSelection (event) {\n                                        selectElement.multiple = true;\n                                    },\n                                    remove (event) {\n                                        const options = selectElement.options;\n                                        const index = event.detail.remove;\n                                        options[index].selected = false;\n                                        selectElement.remove(index);\n                                        if (options.length > 0) {\n                                            const i = Array.prototype.findIndex.call(options, (option)=>option.selected);\n                                            if (i === -1) {\n                                                options[0].selected = true;\n                                            }\n                                        }\n                                        storage.setValue(id, {\n                                            value: getValue(true),\n                                            items: getItems(event)\n                                        });\n                                        selectedValues = getValue(false);\n                                    },\n                                    clear (event) {\n                                        while(selectElement.length !== 0){\n                                            selectElement.remove(0);\n                                        }\n                                        storage.setValue(id, {\n                                            value: null,\n                                            items: []\n                                        });\n                                        selectedValues = getValue(false);\n                                    },\n                                    insert (event) {\n                                        const { index, displayValue, exportValue } = event.detail.insert;\n                                        const selectChild = selectElement.children[index];\n                                        const optionElement = document.createElement(\"option\");\n                                        optionElement.textContent = displayValue;\n                                        optionElement.value = exportValue;\n                                        if (selectChild) {\n                                            selectChild.before(optionElement);\n                                        } else {\n                                            selectElement.append(optionElement);\n                                        }\n                                        storage.setValue(id, {\n                                            value: getValue(true),\n                                            items: getItems(event)\n                                        });\n                                        selectedValues = getValue(false);\n                                    },\n                                    items (event) {\n                                        const { items } = event.detail;\n                                        while(selectElement.length !== 0){\n                                            selectElement.remove(0);\n                                        }\n                                        for (const item of items){\n                                            const { displayValue, exportValue } = item;\n                                            const optionElement = document.createElement(\"option\");\n                                            optionElement.textContent = displayValue;\n                                            optionElement.value = exportValue;\n                                            selectElement.append(optionElement);\n                                        }\n                                        if (selectElement.options.length > 0) {\n                                            selectElement.options[0].selected = true;\n                                        }\n                                        storage.setValue(id, {\n                                            value: getValue(true),\n                                            items: getItems(event)\n                                        });\n                                        selectedValues = getValue(false);\n                                    },\n                                    indices (event) {\n                                        const indices = new Set(event.detail.indices);\n                                        for (const option of event.target.options){\n                                            option.selected = indices.has(option.index);\n                                        }\n                                        storage.setValue(id, {\n                                            value: getValue(true)\n                                        });\n                                        selectedValues = getValue(false);\n                                    },\n                                    editable (event) {\n                                        event.target.disabled = !event.detail.editable;\n                                    }\n                                };\n                                this._dispatchEventFromSandbox(actions, jsEvent);\n                            });\n                            selectElement.addEventListener(\"input\", (event)=>{\n                                const exportValue = getValue(true);\n                                storage.setValue(id, {\n                                    value: exportValue\n                                });\n                                event.preventDefault();\n                                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                    source: this,\n                                    detail: {\n                                        id,\n                                        name: \"Keystroke\",\n                                        value: selectedValues,\n                                        changeEx: exportValue,\n                                        willCommit: false,\n                                        commitKey: 1,\n                                        keyDown: false\n                                    }\n                                });\n                            });\n                            this._setEventListeners(selectElement, null, [\n                                [\n                                    \"focus\",\n                                    \"Focus\"\n                                ],\n                                [\n                                    \"blur\",\n                                    \"Blur\"\n                                ],\n                                [\n                                    \"mousedown\",\n                                    \"Mouse Down\"\n                                ],\n                                [\n                                    \"mouseenter\",\n                                    \"Mouse Enter\"\n                                ],\n                                [\n                                    \"mouseleave\",\n                                    \"Mouse Exit\"\n                                ],\n                                [\n                                    \"mouseup\",\n                                    \"Mouse Up\"\n                                ],\n                                [\n                                    \"input\",\n                                    \"Action\"\n                                ],\n                                [\n                                    \"input\",\n                                    \"Validate\"\n                                ]\n                            ], (event)=>event.target.value);\n                        } else {\n                            selectElement.addEventListener(\"input\", function(event) {\n                                storage.setValue(id, {\n                                    value: getValue(true)\n                                });\n                            });\n                        }\n                        if (this.data.combo) {\n                            this._setTextStyle(selectElement);\n                        } else {}\n                        this._setBackgroundColor(selectElement);\n                        this._setDefaultPropertiesFromJS(selectElement);\n                        this.container.append(selectElement);\n                        return this.container;\n                    }\n                }\n                class PopupAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        const { data, elements } = parameters;\n                        super(parameters, {\n                            isRenderable: AnnotationElement._hasPopupData(data)\n                        });\n                        this.elements = elements;\n                    }\n                    render() {\n                        this.container.classList.add(\"popupAnnotation\");\n                        const popup = new PopupElement({\n                            container: this.container,\n                            color: this.data.color,\n                            titleObj: this.data.titleObj,\n                            modificationDate: this.data.modificationDate,\n                            contentsObj: this.data.contentsObj,\n                            richText: this.data.richText,\n                            rect: this.data.rect,\n                            parentRect: this.data.parentRect || null,\n                            parent: this.parent,\n                            elements: this.elements,\n                            open: this.data.open\n                        });\n                        const elementIds = [];\n                        for (const element of this.elements){\n                            element.popup = popup;\n                            elementIds.push(element.data.id);\n                            element.addHighlightArea();\n                        }\n                        this.container.setAttribute(\"aria-controls\", elementIds.map((id)=>`${_util.AnnotationPrefix}${id}`).join(\",\"));\n                        return this.container;\n                    }\n                }\n                class PopupElement {\n                    #dateTimePromise;\n                    #boundKeyDown;\n                    #boundHide;\n                    #boundShow;\n                    #boundToggle;\n                    #color;\n                    #container;\n                    #contentsObj;\n                    #elements;\n                    #parent;\n                    #parentRect;\n                    #pinned;\n                    #popup;\n                    #rect;\n                    #richText;\n                    #titleObj;\n                    #wasVisible;\n                    constructor({ container, color, elements, titleObj, modificationDate, contentsObj, richText, parent, rect, parentRect, open }){\n                        this.#dateTimePromise = null;\n                        this.#boundKeyDown = this.#keyDown.bind(this);\n                        this.#boundHide = this.#hide.bind(this);\n                        this.#boundShow = this.#show.bind(this);\n                        this.#boundToggle = this.#toggle.bind(this);\n                        this.#color = null;\n                        this.#container = null;\n                        this.#contentsObj = null;\n                        this.#elements = null;\n                        this.#parent = null;\n                        this.#parentRect = null;\n                        this.#pinned = false;\n                        this.#popup = null;\n                        this.#rect = null;\n                        this.#richText = null;\n                        this.#titleObj = null;\n                        this.#wasVisible = false;\n                        this.#container = container;\n                        this.#titleObj = titleObj;\n                        this.#contentsObj = contentsObj;\n                        this.#richText = richText;\n                        this.#parent = parent;\n                        this.#color = color;\n                        this.#rect = rect;\n                        this.#parentRect = parentRect;\n                        this.#elements = elements;\n                        const dateObject = _display_utils.PDFDateString.toDateObject(modificationDate);\n                        if (dateObject) {\n                            this.#dateTimePromise = parent.l10n.get(\"annotation_date_string\", {\n                                date: dateObject.toLocaleDateString(),\n                                time: dateObject.toLocaleTimeString()\n                            });\n                        }\n                        this.trigger = elements.flatMap((e)=>e.getElementsToTriggerPopup());\n                        for (const element of this.trigger){\n                            element.addEventListener(\"click\", this.#boundToggle);\n                            element.addEventListener(\"mouseenter\", this.#boundShow);\n                            element.addEventListener(\"mouseleave\", this.#boundHide);\n                            element.classList.add(\"popupTriggerArea\");\n                        }\n                        for (const element of elements){\n                            element.container?.addEventListener(\"keydown\", this.#boundKeyDown);\n                        }\n                        this.#container.hidden = true;\n                        if (open) {\n                            this.#toggle();\n                        }\n                    }\n                    render() {\n                        if (this.#popup) {\n                            return;\n                        }\n                        const { page: { view }, viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } = this.#parent;\n                        const popup = this.#popup = document.createElement(\"div\");\n                        popup.className = \"popup\";\n                        if (this.#color) {\n                            const baseColor = popup.style.outlineColor = _util.Util.makeHexColor(...this.#color);\n                            if (CSS.supports(\"background-color\", \"color-mix(in srgb, red 30%, white)\")) {\n                                popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;\n                            } else {\n                                const BACKGROUND_ENLIGHT = 0.7;\n                                popup.style.backgroundColor = _util.Util.makeHexColor(...this.#color.map((c)=>Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)));\n                            }\n                        }\n                        const header = document.createElement(\"span\");\n                        header.className = \"header\";\n                        const title = document.createElement(\"h1\");\n                        header.append(title);\n                        ({ dir: title.dir, str: title.textContent } = this.#titleObj);\n                        popup.append(header);\n                        if (this.#dateTimePromise) {\n                            const modificationDate = document.createElement(\"span\");\n                            modificationDate.classList.add(\"popupDate\");\n                            this.#dateTimePromise.then((localized)=>{\n                                modificationDate.textContent = localized;\n                            });\n                            header.append(modificationDate);\n                        }\n                        const contentsObj = this.#contentsObj;\n                        const richText = this.#richText;\n                        if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {\n                            _xfa_layer.XfaLayer.render({\n                                xfaHtml: richText.html,\n                                intent: \"richText\",\n                                div: popup\n                            });\n                            popup.lastChild.classList.add(\"richText\", \"popupContent\");\n                        } else {\n                            const contents = this._formatContents(contentsObj);\n                            popup.append(contents);\n                        }\n                        let useParentRect = !!this.#parentRect;\n                        let rect = useParentRect ? this.#parentRect : this.#rect;\n                        for (const element of this.#elements){\n                            if (!rect || _util.Util.intersect(element.data.rect, rect) !== null) {\n                                rect = element.data.rect;\n                                useParentRect = true;\n                                break;\n                            }\n                        }\n                        const normalizedRect = _util.Util.normalizeRect([\n                            rect[0],\n                            view[3] - rect[1] + view[1],\n                            rect[2],\n                            view[3] - rect[3] + view[1]\n                        ]);\n                        const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;\n                        const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;\n                        const popupLeft = normalizedRect[0] + parentWidth;\n                        const popupTop = normalizedRect[1];\n                        const { style } = this.#container;\n                        style.left = `${100 * (popupLeft - pageX) / pageWidth}%`;\n                        style.top = `${100 * (popupTop - pageY) / pageHeight}%`;\n                        this.#container.append(popup);\n                    }\n                    _formatContents({ str, dir }) {\n                        const p = document.createElement(\"p\");\n                        p.classList.add(\"popupContent\");\n                        p.dir = dir;\n                        const lines = str.split(/(?:\\r\\n?|\\n)/);\n                        for(let i = 0, ii = lines.length; i < ii; ++i){\n                            const line = lines[i];\n                            p.append(document.createTextNode(line));\n                            if (i < ii - 1) {\n                                p.append(document.createElement(\"br\"));\n                            }\n                        }\n                        return p;\n                    }\n                    #keyDown(event) {\n                        if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {\n                            return;\n                        }\n                        if (event.key === \"Enter\" || event.key === \"Escape\" && this.#pinned) {\n                            this.#toggle();\n                        }\n                    }\n                    #toggle() {\n                        this.#pinned = !this.#pinned;\n                        if (this.#pinned) {\n                            this.#show();\n                            this.#container.addEventListener(\"click\", this.#boundToggle);\n                            this.#container.addEventListener(\"keydown\", this.#boundKeyDown);\n                        } else {\n                            this.#hide();\n                            this.#container.removeEventListener(\"click\", this.#boundToggle);\n                            this.#container.removeEventListener(\"keydown\", this.#boundKeyDown);\n                        }\n                    }\n                    #show() {\n                        if (!this.#popup) {\n                            this.render();\n                        }\n                        if (!this.isVisible) {\n                            this.#container.hidden = false;\n                            this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;\n                        } else if (this.#pinned) {\n                            this.#container.classList.add(\"focused\");\n                        }\n                    }\n                    #hide() {\n                        this.#container.classList.remove(\"focused\");\n                        if (this.#pinned || !this.isVisible) {\n                            return;\n                        }\n                        this.#container.hidden = true;\n                        this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;\n                    }\n                    forceHide() {\n                        this.#wasVisible = this.isVisible;\n                        if (!this.#wasVisible) {\n                            return;\n                        }\n                        this.#container.hidden = true;\n                    }\n                    maybeShow() {\n                        if (!this.#wasVisible) {\n                            return;\n                        }\n                        this.#wasVisible = false;\n                        this.#container.hidden = false;\n                    }\n                    get isVisible() {\n                        return this.#container.hidden === false;\n                    }\n                }\n                class FreeTextAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.textContent = parameters.data.textContent;\n                        this.textPosition = parameters.data.textPosition;\n                        this.annotationEditorType = _util.AnnotationEditorType.FREETEXT;\n                    }\n                    render() {\n                        this.container.classList.add(\"freeTextAnnotation\");\n                        if (this.textContent) {\n                            const content = document.createElement(\"div\");\n                            content.classList.add(\"annotationTextContent\");\n                            content.setAttribute(\"role\", \"comment\");\n                            for (const line of this.textContent){\n                                const lineSpan = document.createElement(\"span\");\n                                lineSpan.textContent = line;\n                                content.append(lineSpan);\n                            }\n                            this.container.append(content);\n                        }\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this._editOnDoubleClick();\n                        return this.container;\n                    }\n                }\n                exports1.FreeTextAnnotationElement = FreeTextAnnotationElement;\n                class LineAnnotationElement extends AnnotationElement {\n                    #line;\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.#line = null;\n                    }\n                    render() {\n                        this.container.classList.add(\"lineAnnotation\");\n                        const data = this.data;\n                        const { width, height } = getRectDims(data.rect);\n                        const svg = this.svgFactory.create(width, height, true);\n                        const line = this.#line = this.svgFactory.createElement(\"svg:line\");\n                        line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n                        line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n                        line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n                        line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n                        line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n                        line.setAttribute(\"stroke\", \"transparent\");\n                        line.setAttribute(\"fill\", \"transparent\");\n                        svg.append(line);\n                        this.container.append(svg);\n                        if (!data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#line;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                }\n                class SquareAnnotationElement extends AnnotationElement {\n                    #square;\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.#square = null;\n                    }\n                    render() {\n                        this.container.classList.add(\"squareAnnotation\");\n                        const data = this.data;\n                        const { width, height } = getRectDims(data.rect);\n                        const svg = this.svgFactory.create(width, height, true);\n                        const borderWidth = data.borderStyle.width;\n                        const square = this.#square = this.svgFactory.createElement(\"svg:rect\");\n                        square.setAttribute(\"x\", borderWidth / 2);\n                        square.setAttribute(\"y\", borderWidth / 2);\n                        square.setAttribute(\"width\", width - borderWidth);\n                        square.setAttribute(\"height\", height - borderWidth);\n                        square.setAttribute(\"stroke-width\", borderWidth || 1);\n                        square.setAttribute(\"stroke\", \"transparent\");\n                        square.setAttribute(\"fill\", \"transparent\");\n                        svg.append(square);\n                        this.container.append(svg);\n                        if (!data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#square;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                }\n                class CircleAnnotationElement extends AnnotationElement {\n                    #circle;\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.#circle = null;\n                    }\n                    render() {\n                        this.container.classList.add(\"circleAnnotation\");\n                        const data = this.data;\n                        const { width, height } = getRectDims(data.rect);\n                        const svg = this.svgFactory.create(width, height, true);\n                        const borderWidth = data.borderStyle.width;\n                        const circle = this.#circle = this.svgFactory.createElement(\"svg:ellipse\");\n                        circle.setAttribute(\"cx\", width / 2);\n                        circle.setAttribute(\"cy\", height / 2);\n                        circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n                        circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n                        circle.setAttribute(\"stroke-width\", borderWidth || 1);\n                        circle.setAttribute(\"stroke\", \"transparent\");\n                        circle.setAttribute(\"fill\", \"transparent\");\n                        svg.append(circle);\n                        this.container.append(svg);\n                        if (!data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#circle;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                }\n                class PolylineAnnotationElement extends AnnotationElement {\n                    #polyline;\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.#polyline = null;\n                        this.containerClassName = \"polylineAnnotation\";\n                        this.svgElementName = \"svg:polyline\";\n                    }\n                    render() {\n                        this.container.classList.add(this.containerClassName);\n                        const data = this.data;\n                        const { width, height } = getRectDims(data.rect);\n                        const svg = this.svgFactory.create(width, height, true);\n                        let points = [];\n                        for (const coordinate of data.vertices){\n                            const x = coordinate.x - data.rect[0];\n                            const y = data.rect[3] - coordinate.y;\n                            points.push(x + \",\" + y);\n                        }\n                        points = points.join(\" \");\n                        const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);\n                        polyline.setAttribute(\"points\", points);\n                        polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n                        polyline.setAttribute(\"stroke\", \"transparent\");\n                        polyline.setAttribute(\"fill\", \"transparent\");\n                        svg.append(polyline);\n                        this.container.append(svg);\n                        if (!data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#polyline;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                }\n                class PolygonAnnotationElement extends PolylineAnnotationElement {\n                    constructor(parameters){\n                        super(parameters);\n                        this.containerClassName = \"polygonAnnotation\";\n                        this.svgElementName = \"svg:polygon\";\n                    }\n                }\n                class CaretAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"caretAnnotation\");\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                }\n                class InkAnnotationElement extends AnnotationElement {\n                    #polylines;\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.#polylines = [];\n                        this.containerClassName = \"inkAnnotation\";\n                        this.svgElementName = \"svg:polyline\";\n                        this.annotationEditorType = _util.AnnotationEditorType.INK;\n                    }\n                    render() {\n                        this.container.classList.add(this.containerClassName);\n                        const data = this.data;\n                        const { width, height } = getRectDims(data.rect);\n                        const svg = this.svgFactory.create(width, height, true);\n                        for (const inkList of data.inkLists){\n                            let points = [];\n                            for (const coordinate of inkList){\n                                const x = coordinate.x - data.rect[0];\n                                const y = data.rect[3] - coordinate.y;\n                                points.push(`${x},${y}`);\n                            }\n                            points = points.join(\" \");\n                            const polyline = this.svgFactory.createElement(this.svgElementName);\n                            this.#polylines.push(polyline);\n                            polyline.setAttribute(\"points\", points);\n                            polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n                            polyline.setAttribute(\"stroke\", \"transparent\");\n                            polyline.setAttribute(\"fill\", \"transparent\");\n                            if (!data.popupRef && this.hasPopupData) {\n                                this._createPopup();\n                            }\n                            svg.append(polyline);\n                        }\n                        this.container.append(svg);\n                        return this.container;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#polylines;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                }\n                exports1.InkAnnotationElement = InkAnnotationElement;\n                class HighlightAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true,\n                            createQuadrilaterals: true\n                        });\n                    }\n                    render() {\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this.container.classList.add(\"highlightAnnotation\");\n                        return this.container;\n                    }\n                }\n                class UnderlineAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true,\n                            createQuadrilaterals: true\n                        });\n                    }\n                    render() {\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this.container.classList.add(\"underlineAnnotation\");\n                        return this.container;\n                    }\n                }\n                class SquigglyAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true,\n                            createQuadrilaterals: true\n                        });\n                    }\n                    render() {\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this.container.classList.add(\"squigglyAnnotation\");\n                        return this.container;\n                    }\n                }\n                class StrikeOutAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true,\n                            createQuadrilaterals: true\n                        });\n                    }\n                    render() {\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this.container.classList.add(\"strikeoutAnnotation\");\n                        return this.container;\n                    }\n                }\n                class StampAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"stampAnnotation\");\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                }\n                exports1.StampAnnotationElement = StampAnnotationElement;\n                class FileAttachmentAnnotationElement extends AnnotationElement {\n                    #trigger;\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true\n                        });\n                        this.#trigger = null;\n                        const { filename, content } = this.data.file;\n                        this.filename = (0, _display_utils.getFilenameFromUrl)(filename, true);\n                        this.content = content;\n                        this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n                            source: this,\n                            filename,\n                            content\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"fileAttachmentAnnotation\");\n                        const { container, data } = this;\n                        let trigger;\n                        if (data.hasAppearance || data.fillAlpha === 0) {\n                            trigger = document.createElement(\"div\");\n                        } else {\n                            trigger = document.createElement(\"img\");\n                            trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? \"paperclip\" : \"pushpin\"}.svg`;\n                            if (data.fillAlpha && data.fillAlpha < 1) {\n                                trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;\n                            }\n                        }\n                        trigger.addEventListener(\"dblclick\", this.#download.bind(this));\n                        this.#trigger = trigger;\n                        const { isMac } = _util.FeatureTest.platform;\n                        container.addEventListener(\"keydown\", (evt)=>{\n                            if (evt.key === \"Enter\" && (isMac ? evt.metaKey : evt.ctrlKey)) {\n                                this.#download();\n                            }\n                        });\n                        if (!data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        } else {\n                            trigger.classList.add(\"popupTriggerArea\");\n                        }\n                        container.append(trigger);\n                        return container;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#trigger;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                    #download() {\n                        this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);\n                    }\n                }\n                class AnnotationLayer {\n                    #accessibilityManager;\n                    #annotationCanvasMap;\n                    #editableAnnotations;\n                    constructor({ div, accessibilityManager, annotationCanvasMap, l10n, page, viewport }){\n                        this.#accessibilityManager = null;\n                        this.#annotationCanvasMap = null;\n                        this.#editableAnnotations = new Map();\n                        this.div = div;\n                        this.#accessibilityManager = accessibilityManager;\n                        this.#annotationCanvasMap = annotationCanvasMap;\n                        this.l10n = l10n;\n                        this.page = page;\n                        this.viewport = viewport;\n                        this.zIndex = 0;\n                        this.l10n ||= _displayL10n_utils.NullL10n;\n                    }\n                    #appendElement(element, id) {\n                        const contentElement = element.firstChild || element;\n                        contentElement.id = `${_util.AnnotationPrefix}${id}`;\n                        this.div.append(element);\n                        this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);\n                    }\n                    async render(params) {\n                        const { annotations } = params;\n                        const layer = this.div;\n                        (0, _display_utils.setLayerDimensions)(layer, this.viewport);\n                        const popupToElements = new Map();\n                        const elementParams = {\n                            data: null,\n                            layer,\n                            linkService: params.linkService,\n                            downloadManager: params.downloadManager,\n                            imageResourcesPath: params.imageResourcesPath || \"\",\n                            renderForms: params.renderForms !== false,\n                            svgFactory: new _display_utils.DOMSVGFactory(),\n                            annotationStorage: params.annotationStorage || new _annotation_storage.AnnotationStorage(),\n                            enableScripting: params.enableScripting === true,\n                            hasJSActions: params.hasJSActions,\n                            fieldObjects: params.fieldObjects,\n                            parent: this,\n                            elements: null\n                        };\n                        for (const data of annotations){\n                            if (data.noHTML) {\n                                continue;\n                            }\n                            const isPopupAnnotation = data.annotationType === _util.AnnotationType.POPUP;\n                            if (!isPopupAnnotation) {\n                                const { width, height } = getRectDims(data.rect);\n                                if (width <= 0 || height <= 0) {\n                                    continue;\n                                }\n                            } else {\n                                const elements = popupToElements.get(data.id);\n                                if (!elements) {\n                                    continue;\n                                }\n                                elementParams.elements = elements;\n                            }\n                            elementParams.data = data;\n                            const element = AnnotationElementFactory.create(elementParams);\n                            if (!element.isRenderable) {\n                                continue;\n                            }\n                            if (!isPopupAnnotation && data.popupRef) {\n                                const elements = popupToElements.get(data.popupRef);\n                                if (!elements) {\n                                    popupToElements.set(data.popupRef, [\n                                        element\n                                    ]);\n                                } else {\n                                    elements.push(element);\n                                }\n                            }\n                            if (element.annotationEditorType > 0) {\n                                this.#editableAnnotations.set(element.data.id, element);\n                            }\n                            const rendered = element.render();\n                            if (data.hidden) {\n                                rendered.style.visibility = \"hidden\";\n                            }\n                            this.#appendElement(rendered, data.id);\n                        }\n                        this.#setAnnotationCanvasMap();\n                        await this.l10n.translate(layer);\n                    }\n                    update({ viewport }) {\n                        const layer = this.div;\n                        this.viewport = viewport;\n                        (0, _display_utils.setLayerDimensions)(layer, {\n                            rotation: viewport.rotation\n                        });\n                        this.#setAnnotationCanvasMap();\n                        layer.hidden = false;\n                    }\n                    #setAnnotationCanvasMap() {\n                        if (!this.#annotationCanvasMap) {\n                            return;\n                        }\n                        const layer = this.div;\n                        for (const [id, canvas] of this.#annotationCanvasMap){\n                            const element = layer.querySelector(`[data-annotation-id=\"${id}\"]`);\n                            if (!element) {\n                                continue;\n                            }\n                            const { firstChild } = element;\n                            if (!firstChild) {\n                                element.append(canvas);\n                            } else if (firstChild.nodeName === \"CANVAS\") {\n                                firstChild.replaceWith(canvas);\n                            } else {\n                                firstChild.before(canvas);\n                            }\n                        }\n                        this.#annotationCanvasMap.clear();\n                    }\n                    getEditableAnnotations() {\n                        return Array.from(this.#editableAnnotations.values());\n                    }\n                    getEditableAnnotation(id) {\n                        return this.#editableAnnotations.get(id);\n                    }\n                }\n                exports1.AnnotationLayer = AnnotationLayer;\n            /***/ },\n            /* 30 */ /***/ (__unused_webpack_module, exports1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.ColorConverters = void 0;\n                function makeColorComp(n) {\n                    return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n                }\n                function scaleAndClamp(x) {\n                    return Math.max(0, Math.min(255, 255 * x));\n                }\n                class ColorConverters {\n                    static CMYK_G([c, y, m, k]) {\n                        return [\n                            \"G\",\n                            1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)\n                        ];\n                    }\n                    static G_CMYK([g]) {\n                        return [\n                            \"CMYK\",\n                            0,\n                            0,\n                            0,\n                            1 - g\n                        ];\n                    }\n                    static G_RGB([g]) {\n                        return [\n                            \"RGB\",\n                            g,\n                            g,\n                            g\n                        ];\n                    }\n                    static G_rgb([g]) {\n                        g = scaleAndClamp(g);\n                        return [\n                            g,\n                            g,\n                            g\n                        ];\n                    }\n                    static G_HTML([g]) {\n                        const G = makeColorComp(g);\n                        return `#${G}${G}${G}`;\n                    }\n                    static RGB_G([r, g, b]) {\n                        return [\n                            \"G\",\n                            0.3 * r + 0.59 * g + 0.11 * b\n                        ];\n                    }\n                    static RGB_rgb(color) {\n                        return color.map(scaleAndClamp);\n                    }\n                    static RGB_HTML(color) {\n                        return `#${color.map(makeColorComp).join(\"\")}`;\n                    }\n                    static T_HTML() {\n                        return \"#00000000\";\n                    }\n                    static T_rgb() {\n                        return [\n                            null\n                        ];\n                    }\n                    static CMYK_RGB([c, y, m, k]) {\n                        return [\n                            \"RGB\",\n                            1 - Math.min(1, c + k),\n                            1 - Math.min(1, m + k),\n                            1 - Math.min(1, y + k)\n                        ];\n                    }\n                    static CMYK_rgb([c, y, m, k]) {\n                        return [\n                            scaleAndClamp(1 - Math.min(1, c + k)),\n                            scaleAndClamp(1 - Math.min(1, m + k)),\n                            scaleAndClamp(1 - Math.min(1, y + k))\n                        ];\n                    }\n                    static CMYK_HTML(components) {\n                        const rgb = this.CMYK_RGB(components).slice(1);\n                        return this.RGB_HTML(rgb);\n                    }\n                    static RGB_CMYK([r, g, b]) {\n                        const c = 1 - r;\n                        const m = 1 - g;\n                        const y = 1 - b;\n                        const k = Math.min(c, m, y);\n                        return [\n                            \"CMYK\",\n                            c,\n                            m,\n                            y,\n                            k\n                        ];\n                    }\n                }\n                exports1.ColorConverters = ColorConverters;\n            /***/ },\n            /* 31 */ /***/ (__unused_webpack_module, exports1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.NullL10n = void 0;\n                exports1.getL10nFallback = getL10nFallback;\n                const DEFAULT_L10N_STRINGS = {\n                    of_pages: \"of {{pagesCount}}\",\n                    page_of_pages: \"({{pageNumber}} of {{pagesCount}})\",\n                    document_properties_kb: \"{{size_kb}} KB ({{size_b}} bytes)\",\n                    document_properties_mb: \"{{size_mb}} MB ({{size_b}} bytes)\",\n                    document_properties_date_string: \"{{date}}, {{time}}\",\n                    document_properties_page_size_unit_inches: \"in\",\n                    document_properties_page_size_unit_millimeters: \"mm\",\n                    document_properties_page_size_orientation_portrait: \"portrait\",\n                    document_properties_page_size_orientation_landscape: \"landscape\",\n                    document_properties_page_size_name_a3: \"A3\",\n                    document_properties_page_size_name_a4: \"A4\",\n                    document_properties_page_size_name_letter: \"Letter\",\n                    document_properties_page_size_name_legal: \"Legal\",\n                    document_properties_page_size_dimension_string: \"{{width}} \\xd7 {{height}} {{unit}} ({{orientation}})\",\n                    document_properties_page_size_dimension_name_string: \"{{width}} \\xd7 {{height}} {{unit}} ({{name}}, {{orientation}})\",\n                    document_properties_linearized_yes: \"Yes\",\n                    document_properties_linearized_no: \"No\",\n                    additional_layers: \"Additional Layers\",\n                    page_landmark: \"Page {{page}}\",\n                    thumb_page_title: \"Page {{page}}\",\n                    thumb_page_canvas: \"Thumbnail of Page {{page}}\",\n                    find_reached_top: \"Reached top of document, continued from bottom\",\n                    find_reached_bottom: \"Reached end of document, continued from top\",\n                    \"find_match_count[one]\": \"{{current}} of {{total}} match\",\n                    \"find_match_count[other]\": \"{{current}} of {{total}} matches\",\n                    \"find_match_count_limit[one]\": \"More than {{limit}} match\",\n                    \"find_match_count_limit[other]\": \"More than {{limit}} matches\",\n                    find_not_found: \"Phrase not found\",\n                    page_scale_width: \"Page Width\",\n                    page_scale_fit: \"Page Fit\",\n                    page_scale_auto: \"Automatic Zoom\",\n                    page_scale_actual: \"Actual Size\",\n                    page_scale_percent: \"{{scale}}%\",\n                    loading_error: \"An error occurred while loading the PDF.\",\n                    invalid_file_error: \"Invalid or corrupted PDF file.\",\n                    missing_file_error: \"Missing PDF file.\",\n                    unexpected_response_error: \"Unexpected server response.\",\n                    rendering_error: \"An error occurred while rendering the page.\",\n                    annotation_date_string: \"{{date}}, {{time}}\",\n                    printing_not_supported: \"Warning: Printing is not fully supported by this browser.\",\n                    printing_not_ready: \"Warning: The PDF is not fully loaded for printing.\",\n                    web_fonts_disabled: \"Web fonts are disabled: unable to use embedded PDF fonts.\",\n                    free_text2_default_content: \"Start typing…\",\n                    editor_free_text2_aria_label: \"Text Editor\",\n                    editor_ink2_aria_label: \"Draw Editor\",\n                    editor_ink_canvas_aria_label: \"User-created image\",\n                    editor_alt_text_button_label: \"Alt text\",\n                    editor_alt_text_edit_button_label: \"Edit alt text\",\n                    editor_alt_text_decorative_tooltip: \"Marked as decorative\"\n                };\n                {\n                    DEFAULT_L10N_STRINGS.print_progress_percent = \"{{progress}}%\";\n                }\n                function getL10nFallback(key, args) {\n                    switch(key){\n                        case \"find_match_count\":\n                            key = `find_match_count[${args.total === 1 ? \"one\" : \"other\"}]`;\n                            break;\n                        case \"find_match_count_limit\":\n                            key = `find_match_count_limit[${args.limit === 1 ? \"one\" : \"other\"}]`;\n                            break;\n                    }\n                    return DEFAULT_L10N_STRINGS[key] || \"\";\n                }\n                function formatL10nValue(text, args) {\n                    if (!args) {\n                        return text;\n                    }\n                    return text.replaceAll(/\\{\\{\\s*(\\w+)\\s*\\}\\}/g, (all, name)=>{\n                        return name in args ? args[name] : \"{{\" + name + \"}}\";\n                    });\n                }\n                const NullL10n = {\n                    async getLanguage () {\n                        return \"en-us\";\n                    },\n                    async getDirection () {\n                        return \"ltr\";\n                    },\n                    async get (key, args = null, fallback = getL10nFallback(key, args)) {\n                        return formatL10nValue(fallback, args);\n                    },\n                    async translate (element) {}\n                };\n                exports1.NullL10n = NullL10n;\n            /***/ },\n            /* 32 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.XfaLayer = void 0;\n                var _xfa_text = __w_pdfjs_require__(25);\n                class XfaLayer {\n                    static setupStorage(html, id, element, storage, intent) {\n                        const storedData = storage.getValue(id, {\n                            value: null\n                        });\n                        switch(element.name){\n                            case \"textarea\":\n                                if (storedData.value !== null) {\n                                    html.textContent = storedData.value;\n                                }\n                                if (intent === \"print\") {\n                                    break;\n                                }\n                                html.addEventListener(\"input\", (event)=>{\n                                    storage.setValue(id, {\n                                        value: event.target.value\n                                    });\n                                });\n                                break;\n                            case \"input\":\n                                if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n                                    if (storedData.value === element.attributes.xfaOn) {\n                                        html.setAttribute(\"checked\", true);\n                                    } else if (storedData.value === element.attributes.xfaOff) {\n                                        html.removeAttribute(\"checked\");\n                                    }\n                                    if (intent === \"print\") {\n                                        break;\n                                    }\n                                    html.addEventListener(\"change\", (event)=>{\n                                        storage.setValue(id, {\n                                            value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n                                        });\n                                    });\n                                } else {\n                                    if (storedData.value !== null) {\n                                        html.setAttribute(\"value\", storedData.value);\n                                    }\n                                    if (intent === \"print\") {\n                                        break;\n                                    }\n                                    html.addEventListener(\"input\", (event)=>{\n                                        storage.setValue(id, {\n                                            value: event.target.value\n                                        });\n                                    });\n                                }\n                                break;\n                            case \"select\":\n                                if (storedData.value !== null) {\n                                    html.setAttribute(\"value\", storedData.value);\n                                    for (const option of element.children){\n                                        if (option.attributes.value === storedData.value) {\n                                            option.attributes.selected = true;\n                                        } else if (option.attributes.hasOwnProperty(\"selected\")) {\n                                            delete option.attributes.selected;\n                                        }\n                                    }\n                                }\n                                html.addEventListener(\"input\", (event)=>{\n                                    const options = event.target.options;\n                                    const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n                                    storage.setValue(id, {\n                                        value\n                                    });\n                                });\n                                break;\n                        }\n                    }\n                    static setAttributes({ html, element, storage = null, intent, linkService }) {\n                        const { attributes } = element;\n                        const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n                        if (attributes.type === \"radio\") {\n                            attributes.name = `${attributes.name}-${intent}`;\n                        }\n                        for (const [key, value] of Object.entries(attributes)){\n                            if (value === null || value === undefined) {\n                                continue;\n                            }\n                            switch(key){\n                                case \"class\":\n                                    if (value.length) {\n                                        html.setAttribute(key, value.join(\" \"));\n                                    }\n                                    break;\n                                case \"dataId\":\n                                    break;\n                                case \"id\":\n                                    html.setAttribute(\"data-element-id\", value);\n                                    break;\n                                case \"style\":\n                                    Object.assign(html.style, value);\n                                    break;\n                                case \"textContent\":\n                                    html.textContent = value;\n                                    break;\n                                default:\n                                    if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n                                        html.setAttribute(key, value);\n                                    }\n                            }\n                        }\n                        if (isHTMLAnchorElement) {\n                            linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n                        }\n                        if (storage && attributes.dataId) {\n                            this.setupStorage(html, attributes.dataId, element, storage);\n                        }\n                    }\n                    static render(parameters) {\n                        const storage = parameters.annotationStorage;\n                        const linkService = parameters.linkService;\n                        const root = parameters.xfaHtml;\n                        const intent = parameters.intent || \"display\";\n                        const rootHtml = document.createElement(root.name);\n                        if (root.attributes) {\n                            this.setAttributes({\n                                html: rootHtml,\n                                element: root,\n                                intent,\n                                linkService\n                            });\n                        }\n                        const stack = [\n                            [\n                                root,\n                                -1,\n                                rootHtml\n                            ]\n                        ];\n                        const rootDiv = parameters.div;\n                        rootDiv.append(rootHtml);\n                        if (parameters.viewport) {\n                            const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n                            rootDiv.style.transform = transform;\n                        }\n                        if (intent !== \"richText\") {\n                            rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n                        }\n                        const textDivs = [];\n                        while(stack.length > 0){\n                            const [parent, i, html] = stack.at(-1);\n                            if (i + 1 === parent.children.length) {\n                                stack.pop();\n                                continue;\n                            }\n                            const child = parent.children[++stack.at(-1)[1]];\n                            if (child === null) {\n                                continue;\n                            }\n                            const { name } = child;\n                            if (name === \"#text\") {\n                                const node = document.createTextNode(child.value);\n                                textDivs.push(node);\n                                html.append(node);\n                                continue;\n                            }\n                            const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);\n                            html.append(childHtml);\n                            if (child.attributes) {\n                                this.setAttributes({\n                                    html: childHtml,\n                                    element: child,\n                                    storage,\n                                    intent,\n                                    linkService\n                                });\n                            }\n                            if (child.children && child.children.length > 0) {\n                                stack.push([\n                                    child,\n                                    -1,\n                                    childHtml\n                                ]);\n                            } else if (child.value) {\n                                const node = document.createTextNode(child.value);\n                                if (_xfa_text.XfaText.shouldBuildText(name)) {\n                                    textDivs.push(node);\n                                }\n                                childHtml.append(node);\n                            }\n                        }\n                        for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")){\n                            el.setAttribute(\"readOnly\", true);\n                        }\n                        return {\n                            textDivs\n                        };\n                    }\n                    static update(parameters) {\n                        const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n                        parameters.div.style.transform = transform;\n                        parameters.div.hidden = false;\n                    }\n                }\n                exports1.XfaLayer = XfaLayer;\n            /***/ },\n            /* 33 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.InkEditor = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _editor = __w_pdfjs_require__(4);\n                var _annotation_layer = __w_pdfjs_require__(29);\n                var _display_utils = __w_pdfjs_require__(6);\n                var _tools = __w_pdfjs_require__(5);\n                class InkEditor extends _editor.AnnotationEditor {\n                    #baseHeight;\n                    #baseWidth;\n                    #boundCanvasPointermove;\n                    #boundCanvasPointerleave;\n                    #boundCanvasPointerup;\n                    #boundCanvasPointerdown;\n                    #currentPath2D;\n                    #disableEditing;\n                    #hasSomethingToDraw;\n                    #isCanvasInitialized;\n                    #observer;\n                    #realWidth;\n                    #realHeight;\n                    #requestFrameCallback;\n                    static{\n                        this._defaultColor = null;\n                    }\n                    static{\n                        this._defaultOpacity = 1;\n                    }\n                    static{\n                        this._defaultThickness = 1;\n                    }\n                    static{\n                        this._type = \"ink\";\n                    }\n                    constructor(params){\n                        super({\n                            ...params,\n                            name: \"inkEditor\"\n                        });\n                        this.#baseHeight = 0;\n                        this.#baseWidth = 0;\n                        this.#boundCanvasPointermove = this.canvasPointermove.bind(this);\n                        this.#boundCanvasPointerleave = this.canvasPointerleave.bind(this);\n                        this.#boundCanvasPointerup = this.canvasPointerup.bind(this);\n                        this.#boundCanvasPointerdown = this.canvasPointerdown.bind(this);\n                        this.#currentPath2D = new Path2D();\n                        this.#disableEditing = false;\n                        this.#hasSomethingToDraw = false;\n                        this.#isCanvasInitialized = false;\n                        this.#observer = null;\n                        this.#realWidth = 0;\n                        this.#realHeight = 0;\n                        this.#requestFrameCallback = null;\n                        this.color = params.color || null;\n                        this.thickness = params.thickness || null;\n                        this.opacity = params.opacity || null;\n                        this.paths = [];\n                        this.bezierPath2D = [];\n                        this.allRawPaths = [];\n                        this.currentPath = [];\n                        this.scaleFactor = 1;\n                        this.translationX = this.translationY = 0;\n                        this.x = 0;\n                        this.y = 0;\n                        this._willKeepAspectRatio = true;\n                    }\n                    static initialize(l10n) {\n                        _editor.AnnotationEditor.initialize(l10n, {\n                            strings: [\n                                \"editor_ink_canvas_aria_label\",\n                                \"editor_ink2_aria_label\"\n                            ]\n                        });\n                    }\n                    static updateDefaultParams(type, value) {\n                        switch(type){\n                            case _util.AnnotationEditorParamsType.INK_THICKNESS:\n                                InkEditor._defaultThickness = value;\n                                break;\n                            case _util.AnnotationEditorParamsType.INK_COLOR:\n                                InkEditor._defaultColor = value;\n                                break;\n                            case _util.AnnotationEditorParamsType.INK_OPACITY:\n                                InkEditor._defaultOpacity = value / 100;\n                                break;\n                        }\n                    }\n                    updateParams(type, value) {\n                        switch(type){\n                            case _util.AnnotationEditorParamsType.INK_THICKNESS:\n                                this.#updateThickness(value);\n                                break;\n                            case _util.AnnotationEditorParamsType.INK_COLOR:\n                                this.#updateColor(value);\n                                break;\n                            case _util.AnnotationEditorParamsType.INK_OPACITY:\n                                this.#updateOpacity(value);\n                                break;\n                        }\n                    }\n                    static get defaultPropertiesToUpdate() {\n                        return [\n                            [\n                                _util.AnnotationEditorParamsType.INK_THICKNESS,\n                                InkEditor._defaultThickness\n                            ],\n                            [\n                                _util.AnnotationEditorParamsType.INK_COLOR,\n                                InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor\n                            ],\n                            [\n                                _util.AnnotationEditorParamsType.INK_OPACITY,\n                                Math.round(InkEditor._defaultOpacity * 100)\n                            ]\n                        ];\n                    }\n                    get propertiesToUpdate() {\n                        return [\n                            [\n                                _util.AnnotationEditorParamsType.INK_THICKNESS,\n                                this.thickness || InkEditor._defaultThickness\n                            ],\n                            [\n                                _util.AnnotationEditorParamsType.INK_COLOR,\n                                this.color || InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor\n                            ],\n                            [\n                                _util.AnnotationEditorParamsType.INK_OPACITY,\n                                Math.round(100 * (this.opacity ?? InkEditor._defaultOpacity))\n                            ]\n                        ];\n                    }\n                    #updateThickness(thickness) {\n                        const savedThickness = this.thickness;\n                        this.addCommands({\n                            cmd: ()=>{\n                                this.thickness = thickness;\n                                this.#fitToContent();\n                            },\n                            undo: ()=>{\n                                this.thickness = savedThickness;\n                                this.#fitToContent();\n                            },\n                            mustExec: true,\n                            type: _util.AnnotationEditorParamsType.INK_THICKNESS,\n                            overwriteIfSameType: true,\n                            keepUndo: true\n                        });\n                    }\n                    #updateColor(color) {\n                        const savedColor = this.color;\n                        this.addCommands({\n                            cmd: ()=>{\n                                this.color = color;\n                                this.#redraw();\n                            },\n                            undo: ()=>{\n                                this.color = savedColor;\n                                this.#redraw();\n                            },\n                            mustExec: true,\n                            type: _util.AnnotationEditorParamsType.INK_COLOR,\n                            overwriteIfSameType: true,\n                            keepUndo: true\n                        });\n                    }\n                    #updateOpacity(opacity) {\n                        opacity /= 100;\n                        const savedOpacity = this.opacity;\n                        this.addCommands({\n                            cmd: ()=>{\n                                this.opacity = opacity;\n                                this.#redraw();\n                            },\n                            undo: ()=>{\n                                this.opacity = savedOpacity;\n                                this.#redraw();\n                            },\n                            mustExec: true,\n                            type: _util.AnnotationEditorParamsType.INK_OPACITY,\n                            overwriteIfSameType: true,\n                            keepUndo: true\n                        });\n                    }\n                    rebuild() {\n                        if (!this.parent) {\n                            return;\n                        }\n                        super.rebuild();\n                        if (this.div === null) {\n                            return;\n                        }\n                        if (!this.canvas) {\n                            this.#createCanvas();\n                            this.#createObserver();\n                        }\n                        if (!this.isAttachedToDOM) {\n                            this.parent.add(this);\n                            this.#setCanvasDims();\n                        }\n                        this.#fitToContent();\n                    }\n                    remove() {\n                        if (this.canvas === null) {\n                            return;\n                        }\n                        if (!this.isEmpty()) {\n                            this.commit();\n                        }\n                        this.canvas.width = this.canvas.height = 0;\n                        this.canvas.remove();\n                        this.canvas = null;\n                        this.#observer.disconnect();\n                        this.#observer = null;\n                        super.remove();\n                    }\n                    setParent(parent) {\n                        if (!this.parent && parent) {\n                            this._uiManager.removeShouldRescale(this);\n                        } else if (this.parent && parent === null) {\n                            this._uiManager.addShouldRescale(this);\n                        }\n                        super.setParent(parent);\n                    }\n                    onScaleChanging() {\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        const width = this.width * parentWidth;\n                        const height = this.height * parentHeight;\n                        this.setDimensions(width, height);\n                    }\n                    enableEditMode() {\n                        if (this.#disableEditing || this.canvas === null) {\n                            return;\n                        }\n                        super.enableEditMode();\n                        this._isDraggable = false;\n                        this.canvas.addEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n                    }\n                    disableEditMode() {\n                        if (!this.isInEditMode() || this.canvas === null) {\n                            return;\n                        }\n                        super.disableEditMode();\n                        this._isDraggable = !this.isEmpty();\n                        this.div.classList.remove(\"editing\");\n                        this.canvas.removeEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n                    }\n                    onceAdded() {\n                        this._isDraggable = !this.isEmpty();\n                    }\n                    isEmpty() {\n                        return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;\n                    }\n                    #getInitialBBox() {\n                        const { parentRotation, parentDimensions: [width, height] } = this;\n                        switch(parentRotation){\n                            case 90:\n                                return [\n                                    0,\n                                    height,\n                                    height,\n                                    width\n                                ];\n                            case 180:\n                                return [\n                                    width,\n                                    height,\n                                    width,\n                                    height\n                                ];\n                            case 270:\n                                return [\n                                    width,\n                                    0,\n                                    height,\n                                    width\n                                ];\n                            default:\n                                return [\n                                    0,\n                                    0,\n                                    width,\n                                    height\n                                ];\n                        }\n                    }\n                    #setStroke() {\n                        const { ctx, color, opacity, thickness, parentScale, scaleFactor } = this;\n                        ctx.lineWidth = thickness * parentScale / scaleFactor;\n                        ctx.lineCap = \"round\";\n                        ctx.lineJoin = \"round\";\n                        ctx.miterLimit = 10;\n                        ctx.strokeStyle = `${color}${(0, _tools.opacityToHex)(opacity)}`;\n                    }\n                    #startDrawing(x, y) {\n                        this.canvas.addEventListener(\"contextmenu\", _display_utils.noContextMenu);\n                        this.canvas.addEventListener(\"pointerleave\", this.#boundCanvasPointerleave);\n                        this.canvas.addEventListener(\"pointermove\", this.#boundCanvasPointermove);\n                        this.canvas.addEventListener(\"pointerup\", this.#boundCanvasPointerup);\n                        this.canvas.removeEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n                        this.isEditing = true;\n                        if (!this.#isCanvasInitialized) {\n                            this.#isCanvasInitialized = true;\n                            this.#setCanvasDims();\n                            this.thickness ||= InkEditor._defaultThickness;\n                            this.color ||= InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;\n                            this.opacity ??= InkEditor._defaultOpacity;\n                        }\n                        this.currentPath.push([\n                            x,\n                            y\n                        ]);\n                        this.#hasSomethingToDraw = false;\n                        this.#setStroke();\n                        this.#requestFrameCallback = ()=>{\n                            this.#drawPoints();\n                            if (this.#requestFrameCallback) {\n                                window.requestAnimationFrame(this.#requestFrameCallback);\n                            }\n                        };\n                        window.requestAnimationFrame(this.#requestFrameCallback);\n                    }\n                    #draw(x, y) {\n                        const [lastX, lastY] = this.currentPath.at(-1);\n                        if (this.currentPath.length > 1 && x === lastX && y === lastY) {\n                            return;\n                        }\n                        const currentPath = this.currentPath;\n                        let path2D = this.#currentPath2D;\n                        currentPath.push([\n                            x,\n                            y\n                        ]);\n                        this.#hasSomethingToDraw = true;\n                        if (currentPath.length <= 2) {\n                            path2D.moveTo(...currentPath[0]);\n                            path2D.lineTo(x, y);\n                            return;\n                        }\n                        if (currentPath.length === 3) {\n                            this.#currentPath2D = path2D = new Path2D();\n                            path2D.moveTo(...currentPath[0]);\n                        }\n                        this.#makeBezierCurve(path2D, ...currentPath.at(-3), ...currentPath.at(-2), x, y);\n                    }\n                    #endPath() {\n                        if (this.currentPath.length === 0) {\n                            return;\n                        }\n                        const lastPoint = this.currentPath.at(-1);\n                        this.#currentPath2D.lineTo(...lastPoint);\n                    }\n                    #stopDrawing(x, y) {\n                        this.#requestFrameCallback = null;\n                        x = Math.min(Math.max(x, 0), this.canvas.width);\n                        y = Math.min(Math.max(y, 0), this.canvas.height);\n                        this.#draw(x, y);\n                        this.#endPath();\n                        let bezier;\n                        if (this.currentPath.length !== 1) {\n                            bezier = this.#generateBezierPoints();\n                        } else {\n                            const xy = [\n                                x,\n                                y\n                            ];\n                            bezier = [\n                                [\n                                    xy,\n                                    xy.slice(),\n                                    xy.slice(),\n                                    xy\n                                ]\n                            ];\n                        }\n                        const path2D = this.#currentPath2D;\n                        const currentPath = this.currentPath;\n                        this.currentPath = [];\n                        this.#currentPath2D = new Path2D();\n                        const cmd = ()=>{\n                            this.allRawPaths.push(currentPath);\n                            this.paths.push(bezier);\n                            this.bezierPath2D.push(path2D);\n                            this.rebuild();\n                        };\n                        const undo = ()=>{\n                            this.allRawPaths.pop();\n                            this.paths.pop();\n                            this.bezierPath2D.pop();\n                            if (this.paths.length === 0) {\n                                this.remove();\n                            } else {\n                                if (!this.canvas) {\n                                    this.#createCanvas();\n                                    this.#createObserver();\n                                }\n                                this.#fitToContent();\n                            }\n                        };\n                        this.addCommands({\n                            cmd,\n                            undo,\n                            mustExec: true\n                        });\n                    }\n                    #drawPoints() {\n                        if (!this.#hasSomethingToDraw) {\n                            return;\n                        }\n                        this.#hasSomethingToDraw = false;\n                        const thickness = Math.ceil(this.thickness * this.parentScale);\n                        const lastPoints = this.currentPath.slice(-3);\n                        const x = lastPoints.map((xy)=>xy[0]);\n                        const y = lastPoints.map((xy)=>xy[1]);\n                        const xMin = Math.min(...x) - thickness;\n                        const xMax = Math.max(...x) + thickness;\n                        const yMin = Math.min(...y) - thickness;\n                        const yMax = Math.max(...y) + thickness;\n                        const { ctx } = this;\n                        ctx.save();\n                        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                        for (const path of this.bezierPath2D){\n                            ctx.stroke(path);\n                        }\n                        ctx.stroke(this.#currentPath2D);\n                        ctx.restore();\n                    }\n                    #makeBezierCurve(path2D, x0, y0, x1, y1, x2, y2) {\n                        const prevX = (x0 + x1) / 2;\n                        const prevY = (y0 + y1) / 2;\n                        const x3 = (x1 + x2) / 2;\n                        const y3 = (y1 + y2) / 2;\n                        path2D.bezierCurveTo(prevX + 2 * (x1 - prevX) / 3, prevY + 2 * (y1 - prevY) / 3, x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3, x3, y3);\n                    }\n                    #generateBezierPoints() {\n                        const path = this.currentPath;\n                        if (path.length <= 2) {\n                            return [\n                                [\n                                    path[0],\n                                    path[0],\n                                    path.at(-1),\n                                    path.at(-1)\n                                ]\n                            ];\n                        }\n                        const bezierPoints = [];\n                        let i;\n                        let [x0, y0] = path[0];\n                        for(i = 1; i < path.length - 2; i++){\n                            const [x1, y1] = path[i];\n                            const [x2, y2] = path[i + 1];\n                            const x3 = (x1 + x2) / 2;\n                            const y3 = (y1 + y2) / 2;\n                            const control1 = [\n                                x0 + 2 * (x1 - x0) / 3,\n                                y0 + 2 * (y1 - y0) / 3\n                            ];\n                            const control2 = [\n                                x3 + 2 * (x1 - x3) / 3,\n                                y3 + 2 * (y1 - y3) / 3\n                            ];\n                            bezierPoints.push([\n                                [\n                                    x0,\n                                    y0\n                                ],\n                                control1,\n                                control2,\n                                [\n                                    x3,\n                                    y3\n                                ]\n                            ]);\n                            [x0, y0] = [\n                                x3,\n                                y3\n                            ];\n                        }\n                        const [x1, y1] = path[i];\n                        const [x2, y2] = path[i + 1];\n                        const control1 = [\n                            x0 + 2 * (x1 - x0) / 3,\n                            y0 + 2 * (y1 - y0) / 3\n                        ];\n                        const control2 = [\n                            x2 + 2 * (x1 - x2) / 3,\n                            y2 + 2 * (y1 - y2) / 3\n                        ];\n                        bezierPoints.push([\n                            [\n                                x0,\n                                y0\n                            ],\n                            control1,\n                            control2,\n                            [\n                                x2,\n                                y2\n                            ]\n                        ]);\n                        return bezierPoints;\n                    }\n                    #redraw() {\n                        if (this.isEmpty()) {\n                            this.#updateTransform();\n                            return;\n                        }\n                        this.#setStroke();\n                        const { canvas, ctx } = this;\n                        ctx.setTransform(1, 0, 0, 1, 0, 0);\n                        ctx.clearRect(0, 0, canvas.width, canvas.height);\n                        this.#updateTransform();\n                        for (const path of this.bezierPath2D){\n                            ctx.stroke(path);\n                        }\n                    }\n                    commit() {\n                        if (this.#disableEditing) {\n                            return;\n                        }\n                        super.commit();\n                        this.isEditing = false;\n                        this.disableEditMode();\n                        this.setInForeground();\n                        this.#disableEditing = true;\n                        this.div.classList.add(\"disabled\");\n                        this.#fitToContent(true);\n                        this.makeResizable();\n                        this.parent.addInkEditorIfNeeded(true);\n                        this.moveInDOM();\n                        this.div.focus({\n                            preventScroll: true\n                        });\n                    }\n                    focusin(event) {\n                        if (!this._focusEventsAllowed) {\n                            return;\n                        }\n                        super.focusin(event);\n                        this.enableEditMode();\n                    }\n                    canvasPointerdown(event) {\n                        if (event.button !== 0 || !this.isInEditMode() || this.#disableEditing) {\n                            return;\n                        }\n                        this.setInForeground();\n                        event.preventDefault();\n                        if (event.type !== \"mouse\") {\n                            this.div.focus();\n                        }\n                        this.#startDrawing(event.offsetX, event.offsetY);\n                    }\n                    canvasPointermove(event) {\n                        event.preventDefault();\n                        this.#draw(event.offsetX, event.offsetY);\n                    }\n                    canvasPointerup(event) {\n                        event.preventDefault();\n                        this.#endDrawing(event);\n                    }\n                    canvasPointerleave(event) {\n                        this.#endDrawing(event);\n                    }\n                    #endDrawing(event) {\n                        this.canvas.removeEventListener(\"pointerleave\", this.#boundCanvasPointerleave);\n                        this.canvas.removeEventListener(\"pointermove\", this.#boundCanvasPointermove);\n                        this.canvas.removeEventListener(\"pointerup\", this.#boundCanvasPointerup);\n                        this.canvas.addEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n                        setTimeout(()=>{\n                            this.canvas.removeEventListener(\"contextmenu\", _display_utils.noContextMenu);\n                        }, 10);\n                        this.#stopDrawing(event.offsetX, event.offsetY);\n                        this.addToAnnotationStorage();\n                        this.setInBackground();\n                    }\n                    #createCanvas() {\n                        this.canvas = document.createElement(\"canvas\");\n                        this.canvas.width = this.canvas.height = 0;\n                        this.canvas.className = \"inkEditorCanvas\";\n                        _editor.AnnotationEditor._l10nPromise.get(\"editor_ink_canvas_aria_label\").then((msg)=>this.canvas?.setAttribute(\"aria-label\", msg));\n                        this.div.append(this.canvas);\n                        this.ctx = this.canvas.getContext(\"2d\");\n                    }\n                    #createObserver() {\n                        this.#observer = new ResizeObserver((entries)=>{\n                            const rect = entries[0].contentRect;\n                            if (rect.width && rect.height) {\n                                this.setDimensions(rect.width, rect.height);\n                            }\n                        });\n                        this.#observer.observe(this.div);\n                    }\n                    get isResizable() {\n                        return !this.isEmpty() && this.#disableEditing;\n                    }\n                    render() {\n                        if (this.div) {\n                            return this.div;\n                        }\n                        let baseX, baseY;\n                        if (this.width) {\n                            baseX = this.x;\n                            baseY = this.y;\n                        }\n                        super.render();\n                        _editor.AnnotationEditor._l10nPromise.get(\"editor_ink2_aria_label\").then((msg)=>this.div?.setAttribute(\"aria-label\", msg));\n                        const [x, y, w, h] = this.#getInitialBBox();\n                        this.setAt(x, y, 0, 0);\n                        this.setDims(w, h);\n                        this.#createCanvas();\n                        if (this.width) {\n                            const [parentWidth, parentHeight] = this.parentDimensions;\n                            this.setAspectRatio(this.width * parentWidth, this.height * parentHeight);\n                            this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n                            this.#isCanvasInitialized = true;\n                            this.#setCanvasDims();\n                            this.setDims(this.width * parentWidth, this.height * parentHeight);\n                            this.#redraw();\n                            this.div.classList.add(\"disabled\");\n                        } else {\n                            this.div.classList.add(\"editing\");\n                            this.enableEditMode();\n                        }\n                        this.#createObserver();\n                        return this.div;\n                    }\n                    #setCanvasDims() {\n                        if (!this.#isCanvasInitialized) {\n                            return;\n                        }\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        this.canvas.width = Math.ceil(this.width * parentWidth);\n                        this.canvas.height = Math.ceil(this.height * parentHeight);\n                        this.#updateTransform();\n                    }\n                    setDimensions(width, height) {\n                        const roundedWidth = Math.round(width);\n                        const roundedHeight = Math.round(height);\n                        if (this.#realWidth === roundedWidth && this.#realHeight === roundedHeight) {\n                            return;\n                        }\n                        this.#realWidth = roundedWidth;\n                        this.#realHeight = roundedHeight;\n                        this.canvas.style.visibility = \"hidden\";\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        this.width = width / parentWidth;\n                        this.height = height / parentHeight;\n                        this.fixAndSetPosition();\n                        if (this.#disableEditing) {\n                            this.#setScaleFactor(width, height);\n                        }\n                        this.#setCanvasDims();\n                        this.#redraw();\n                        this.canvas.style.visibility = \"visible\";\n                        this.fixDims();\n                    }\n                    #setScaleFactor(width, height) {\n                        const padding = this.#getPadding();\n                        const scaleFactorW = (width - padding) / this.#baseWidth;\n                        const scaleFactorH = (height - padding) / this.#baseHeight;\n                        this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);\n                    }\n                    #updateTransform() {\n                        const padding = this.#getPadding() / 2;\n                        this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);\n                    }\n                    static #buildPath2D(bezier) {\n                        const path2D = new Path2D();\n                        for(let i = 0, ii = bezier.length; i < ii; i++){\n                            const [first, control1, control2, second] = bezier[i];\n                            if (i === 0) {\n                                path2D.moveTo(...first);\n                            }\n                            path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);\n                        }\n                        return path2D;\n                    }\n                    static #toPDFCoordinates(points, rect, rotation) {\n                        const [blX, blY, trX, trY] = rect;\n                        switch(rotation){\n                            case 0:\n                                for(let i = 0, ii = points.length; i < ii; i += 2){\n                                    points[i] += blX;\n                                    points[i + 1] = trY - points[i + 1];\n                                }\n                                break;\n                            case 90:\n                                for(let i = 0, ii = points.length; i < ii; i += 2){\n                                    const x = points[i];\n                                    points[i] = points[i + 1] + blX;\n                                    points[i + 1] = x + blY;\n                                }\n                                break;\n                            case 180:\n                                for(let i = 0, ii = points.length; i < ii; i += 2){\n                                    points[i] = trX - points[i];\n                                    points[i + 1] += blY;\n                                }\n                                break;\n                            case 270:\n                                for(let i = 0, ii = points.length; i < ii; i += 2){\n                                    const x = points[i];\n                                    points[i] = trX - points[i + 1];\n                                    points[i + 1] = trY - x;\n                                }\n                                break;\n                            default:\n                                throw new Error(\"Invalid rotation\");\n                        }\n                        return points;\n                    }\n                    static #fromPDFCoordinates(points, rect, rotation) {\n                        const [blX, blY, trX, trY] = rect;\n                        switch(rotation){\n                            case 0:\n                                for(let i = 0, ii = points.length; i < ii; i += 2){\n                                    points[i] -= blX;\n                                    points[i + 1] = trY - points[i + 1];\n                                }\n                                break;\n                            case 90:\n                                for(let i = 0, ii = points.length; i < ii; i += 2){\n                                    const x = points[i];\n                                    points[i] = points[i + 1] - blY;\n                                    points[i + 1] = x - blX;\n                                }\n                                break;\n                            case 180:\n                                for(let i = 0, ii = points.length; i < ii; i += 2){\n                                    points[i] = trX - points[i];\n                                    points[i + 1] -= blY;\n                                }\n                                break;\n                            case 270:\n                                for(let i = 0, ii = points.length; i < ii; i += 2){\n                                    const x = points[i];\n                                    points[i] = trY - points[i + 1];\n                                    points[i + 1] = trX - x;\n                                }\n                                break;\n                            default:\n                                throw new Error(\"Invalid rotation\");\n                        }\n                        return points;\n                    }\n                    #serializePaths(s, tx, ty, rect) {\n                        const paths = [];\n                        const padding = this.thickness / 2;\n                        const shiftX = s * tx + padding;\n                        const shiftY = s * ty + padding;\n                        for (const bezier of this.paths){\n                            const buffer = [];\n                            const points = [];\n                            for(let j = 0, jj = bezier.length; j < jj; j++){\n                                const [first, control1, control2, second] = bezier[j];\n                                const p10 = s * first[0] + shiftX;\n                                const p11 = s * first[1] + shiftY;\n                                const p20 = s * control1[0] + shiftX;\n                                const p21 = s * control1[1] + shiftY;\n                                const p30 = s * control2[0] + shiftX;\n                                const p31 = s * control2[1] + shiftY;\n                                const p40 = s * second[0] + shiftX;\n                                const p41 = s * second[1] + shiftY;\n                                if (j === 0) {\n                                    buffer.push(p10, p11);\n                                    points.push(p10, p11);\n                                }\n                                buffer.push(p20, p21, p30, p31, p40, p41);\n                                points.push(p20, p21);\n                                if (j === jj - 1) {\n                                    points.push(p40, p41);\n                                }\n                            }\n                            paths.push({\n                                bezier: InkEditor.#toPDFCoordinates(buffer, rect, this.rotation),\n                                points: InkEditor.#toPDFCoordinates(points, rect, this.rotation)\n                            });\n                        }\n                        return paths;\n                    }\n                    #getBbox() {\n                        let xMin = Infinity;\n                        let xMax = -Infinity;\n                        let yMin = Infinity;\n                        let yMax = -Infinity;\n                        for (const path of this.paths){\n                            for (const [first, control1, control2, second] of path){\n                                const bbox = _util.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);\n                                xMin = Math.min(xMin, bbox[0]);\n                                yMin = Math.min(yMin, bbox[1]);\n                                xMax = Math.max(xMax, bbox[2]);\n                                yMax = Math.max(yMax, bbox[3]);\n                            }\n                        }\n                        return [\n                            xMin,\n                            yMin,\n                            xMax,\n                            yMax\n                        ];\n                    }\n                    #getPadding() {\n                        return this.#disableEditing ? Math.ceil(this.thickness * this.parentScale) : 0;\n                    }\n                    #fitToContent(firstTime = false) {\n                        if (this.isEmpty()) {\n                            return;\n                        }\n                        if (!this.#disableEditing) {\n                            this.#redraw();\n                            return;\n                        }\n                        const bbox = this.#getBbox();\n                        const padding = this.#getPadding();\n                        this.#baseWidth = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);\n                        this.#baseHeight = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);\n                        const width = Math.ceil(padding + this.#baseWidth * this.scaleFactor);\n                        const height = Math.ceil(padding + this.#baseHeight * this.scaleFactor);\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        this.width = width / parentWidth;\n                        this.height = height / parentHeight;\n                        this.setAspectRatio(width, height);\n                        const prevTranslationX = this.translationX;\n                        const prevTranslationY = this.translationY;\n                        this.translationX = -bbox[0];\n                        this.translationY = -bbox[1];\n                        this.#setCanvasDims();\n                        this.#redraw();\n                        this.#realWidth = width;\n                        this.#realHeight = height;\n                        this.setDims(width, height);\n                        const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;\n                        this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);\n                    }\n                    static deserialize(data, parent, uiManager) {\n                        if (data instanceof _annotation_layer.InkAnnotationElement) {\n                            return null;\n                        }\n                        const editor = super.deserialize(data, parent, uiManager);\n                        editor.thickness = data.thickness;\n                        editor.color = _util.Util.makeHexColor(...data.color);\n                        editor.opacity = data.opacity;\n                        const [pageWidth, pageHeight] = editor.pageDimensions;\n                        const width = editor.width * pageWidth;\n                        const height = editor.height * pageHeight;\n                        const scaleFactor = editor.parentScale;\n                        const padding = data.thickness / 2;\n                        editor.#disableEditing = true;\n                        editor.#realWidth = Math.round(width);\n                        editor.#realHeight = Math.round(height);\n                        const { paths, rect, rotation } = data;\n                        for (let { bezier } of paths){\n                            bezier = InkEditor.#fromPDFCoordinates(bezier, rect, rotation);\n                            const path = [];\n                            editor.paths.push(path);\n                            let p0 = scaleFactor * (bezier[0] - padding);\n                            let p1 = scaleFactor * (bezier[1] - padding);\n                            for(let i = 2, ii = bezier.length; i < ii; i += 6){\n                                const p10 = scaleFactor * (bezier[i] - padding);\n                                const p11 = scaleFactor * (bezier[i + 1] - padding);\n                                const p20 = scaleFactor * (bezier[i + 2] - padding);\n                                const p21 = scaleFactor * (bezier[i + 3] - padding);\n                                const p30 = scaleFactor * (bezier[i + 4] - padding);\n                                const p31 = scaleFactor * (bezier[i + 5] - padding);\n                                path.push([\n                                    [\n                                        p0,\n                                        p1\n                                    ],\n                                    [\n                                        p10,\n                                        p11\n                                    ],\n                                    [\n                                        p20,\n                                        p21\n                                    ],\n                                    [\n                                        p30,\n                                        p31\n                                    ]\n                                ]);\n                                p0 = p30;\n                                p1 = p31;\n                            }\n                            const path2D = this.#buildPath2D(path);\n                            editor.bezierPath2D.push(path2D);\n                        }\n                        const bbox = editor.#getBbox();\n                        editor.#baseWidth = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);\n                        editor.#baseHeight = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);\n                        editor.#setScaleFactor(width, height);\n                        return editor;\n                    }\n                    serialize() {\n                        if (this.isEmpty()) {\n                            return null;\n                        }\n                        const rect = this.getRect(0, 0);\n                        const color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);\n                        return {\n                            annotationType: _util.AnnotationEditorType.INK,\n                            color,\n                            thickness: this.thickness,\n                            opacity: this.opacity,\n                            paths: this.#serializePaths(this.scaleFactor / this.parentScale, this.translationX, this.translationY, rect),\n                            pageIndex: this.pageIndex,\n                            rect,\n                            rotation: this.rotation,\n                            structTreeParentId: this._structTreeParentId\n                        };\n                    }\n                }\n                exports1.InkEditor = InkEditor;\n            /***/ },\n            /* 34 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.StampEditor = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _editor = __w_pdfjs_require__(4);\n                var _display_utils = __w_pdfjs_require__(6);\n                var _annotation_layer = __w_pdfjs_require__(29);\n                class StampEditor extends _editor.AnnotationEditor {\n                    #bitmap;\n                    #bitmapId;\n                    #bitmapPromise;\n                    #bitmapUrl;\n                    #bitmapFile;\n                    #canvas;\n                    #observer;\n                    #resizeTimeoutId;\n                    #isSvg;\n                    #hasBeenAddedInUndoStack;\n                    static{\n                        this._type = \"stamp\";\n                    }\n                    constructor(params){\n                        super({\n                            ...params,\n                            name: \"stampEditor\"\n                        });\n                        this.#bitmap = null;\n                        this.#bitmapId = null;\n                        this.#bitmapPromise = null;\n                        this.#bitmapUrl = null;\n                        this.#bitmapFile = null;\n                        this.#canvas = null;\n                        this.#observer = null;\n                        this.#resizeTimeoutId = null;\n                        this.#isSvg = false;\n                        this.#hasBeenAddedInUndoStack = false;\n                        this.#bitmapUrl = params.bitmapUrl;\n                        this.#bitmapFile = params.bitmapFile;\n                    }\n                    static initialize(l10n) {\n                        _editor.AnnotationEditor.initialize(l10n);\n                    }\n                    static get supportedTypes() {\n                        const types = [\n                            \"apng\",\n                            \"avif\",\n                            \"bmp\",\n                            \"gif\",\n                            \"jpeg\",\n                            \"png\",\n                            \"svg+xml\",\n                            \"webp\",\n                            \"x-icon\"\n                        ];\n                        return (0, _util.shadow)(this, \"supportedTypes\", types.map((type)=>`image/${type}`));\n                    }\n                    static get supportedTypesStr() {\n                        return (0, _util.shadow)(this, \"supportedTypesStr\", this.supportedTypes.join(\",\"));\n                    }\n                    static isHandlingMimeForPasting(mime) {\n                        return this.supportedTypes.includes(mime);\n                    }\n                    static paste(item, parent) {\n                        parent.pasteEditor(_util.AnnotationEditorType.STAMP, {\n                            bitmapFile: item.getAsFile()\n                        });\n                    }\n                    #getBitmapFetched(data, fromId = false) {\n                        if (!data) {\n                            this.remove();\n                            return;\n                        }\n                        this.#bitmap = data.bitmap;\n                        if (!fromId) {\n                            this.#bitmapId = data.id;\n                            this.#isSvg = data.isSvg;\n                        }\n                        this.#createCanvas();\n                    }\n                    #getBitmapDone() {\n                        this.#bitmapPromise = null;\n                        this._uiManager.enableWaiting(false);\n                        if (this.#canvas) {\n                            this.div.focus();\n                        }\n                    }\n                    #getBitmap() {\n                        if (this.#bitmapId) {\n                            this._uiManager.enableWaiting(true);\n                            this._uiManager.imageManager.getFromId(this.#bitmapId).then((data)=>this.#getBitmapFetched(data, true)).finally(()=>this.#getBitmapDone());\n                            return;\n                        }\n                        if (this.#bitmapUrl) {\n                            const url = this.#bitmapUrl;\n                            this.#bitmapUrl = null;\n                            this._uiManager.enableWaiting(true);\n                            this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n                            return;\n                        }\n                        if (this.#bitmapFile) {\n                            const file = this.#bitmapFile;\n                            this.#bitmapFile = null;\n                            this._uiManager.enableWaiting(true);\n                            this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n                            return;\n                        }\n                        const input = document.createElement(\"input\");\n                        input.type = \"file\";\n                        input.accept = StampEditor.supportedTypesStr;\n                        this.#bitmapPromise = new Promise((resolve)=>{\n                            input.addEventListener(\"change\", async ()=>{\n                                if (!input.files || input.files.length === 0) {\n                                    this.remove();\n                                } else {\n                                    this._uiManager.enableWaiting(true);\n                                    const data = await this._uiManager.imageManager.getFromFile(input.files[0]);\n                                    this.#getBitmapFetched(data);\n                                }\n                                resolve();\n                            });\n                            input.addEventListener(\"cancel\", ()=>{\n                                this.remove();\n                                resolve();\n                            });\n                        }).finally(()=>this.#getBitmapDone());\n                        input.click();\n                    }\n                    remove() {\n                        if (this.#bitmapId) {\n                            this.#bitmap = null;\n                            this._uiManager.imageManager.deleteId(this.#bitmapId);\n                            this.#canvas?.remove();\n                            this.#canvas = null;\n                            this.#observer?.disconnect();\n                            this.#observer = null;\n                        }\n                        super.remove();\n                    }\n                    rebuild() {\n                        if (!this.parent) {\n                            if (this.#bitmapId) {\n                                this.#getBitmap();\n                            }\n                            return;\n                        }\n                        super.rebuild();\n                        if (this.div === null) {\n                            return;\n                        }\n                        if (this.#bitmapId) {\n                            this.#getBitmap();\n                        }\n                        if (!this.isAttachedToDOM) {\n                            this.parent.add(this);\n                        }\n                    }\n                    onceAdded() {\n                        this._isDraggable = true;\n                        this.div.focus();\n                    }\n                    isEmpty() {\n                        return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile);\n                    }\n                    get isResizable() {\n                        return true;\n                    }\n                    render() {\n                        if (this.div) {\n                            return this.div;\n                        }\n                        let baseX, baseY;\n                        if (this.width) {\n                            baseX = this.x;\n                            baseY = this.y;\n                        }\n                        super.render();\n                        this.div.hidden = true;\n                        if (this.#bitmap) {\n                            this.#createCanvas();\n                        } else {\n                            this.#getBitmap();\n                        }\n                        if (this.width) {\n                            const [parentWidth, parentHeight] = this.parentDimensions;\n                            this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n                        }\n                        return this.div;\n                    }\n                    #createCanvas() {\n                        const { div } = this;\n                        let { width, height } = this.#bitmap;\n                        const [pageWidth, pageHeight] = this.pageDimensions;\n                        const MAX_RATIO = 0.75;\n                        if (this.width) {\n                            width = this.width * pageWidth;\n                            height = this.height * pageHeight;\n                        } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {\n                            const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);\n                            width *= factor;\n                            height *= factor;\n                        }\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);\n                        this._uiManager.enableWaiting(false);\n                        const canvas = this.#canvas = document.createElement(\"canvas\");\n                        div.append(canvas);\n                        div.hidden = false;\n                        this.#drawBitmap(width, height);\n                        this.#createObserver();\n                        if (!this.#hasBeenAddedInUndoStack) {\n                            this.parent.addUndoableEditor(this);\n                            this.#hasBeenAddedInUndoStack = true;\n                        }\n                        this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n                            source: this,\n                            details: {\n                                type: \"editing\",\n                                subtype: this.editorType,\n                                data: {\n                                    action: \"inserted_image\"\n                                }\n                            }\n                        });\n                        this.addAltTextButton();\n                    }\n                    #setDimensions(width, height) {\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        this.width = width / parentWidth;\n                        this.height = height / parentHeight;\n                        this.setDims(width, height);\n                        if (this._initialOptions?.isCentered) {\n                            this.center();\n                        } else {\n                            this.fixAndSetPosition();\n                        }\n                        this._initialOptions = null;\n                        if (this.#resizeTimeoutId !== null) {\n                            clearTimeout(this.#resizeTimeoutId);\n                        }\n                        const TIME_TO_WAIT = 200;\n                        this.#resizeTimeoutId = setTimeout(()=>{\n                            this.#resizeTimeoutId = null;\n                            this.#drawBitmap(width, height);\n                        }, TIME_TO_WAIT);\n                    }\n                    #scaleBitmap(width, height) {\n                        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n                        let newWidth = bitmapWidth;\n                        let newHeight = bitmapHeight;\n                        let bitmap = this.#bitmap;\n                        while(newWidth > 2 * width || newHeight > 2 * height){\n                            const prevWidth = newWidth;\n                            const prevHeight = newHeight;\n                            if (newWidth > 2 * width) {\n                                newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);\n                            }\n                            if (newHeight > 2 * height) {\n                                newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);\n                            }\n                            const offscreen = new OffscreenCanvas(newWidth, newHeight);\n                            const ctx = offscreen.getContext(\"2d\");\n                            ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n                            bitmap = offscreen.transferToImageBitmap();\n                        }\n                        return bitmap;\n                    }\n                    #drawBitmap(width, height) {\n                        width = Math.ceil(width);\n                        height = Math.ceil(height);\n                        const canvas = this.#canvas;\n                        if (!canvas || canvas.width === width && canvas.height === height) {\n                            return;\n                        }\n                        canvas.width = width;\n                        canvas.height = height;\n                        const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(width, height);\n                        const ctx = canvas.getContext(\"2d\");\n                        ctx.filter = this._uiManager.hcmFilter;\n                        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, width, height);\n                    }\n                    #serializeBitmap(toUrl) {\n                        if (toUrl) {\n                            if (this.#isSvg) {\n                                const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);\n                                if (url) {\n                                    return url;\n                                }\n                            }\n                            const canvas = document.createElement(\"canvas\");\n                            ({ width: canvas.width, height: canvas.height } = this.#bitmap);\n                            const ctx = canvas.getContext(\"2d\");\n                            ctx.drawImage(this.#bitmap, 0, 0);\n                            return canvas.toDataURL();\n                        }\n                        if (this.#isSvg) {\n                            const [pageWidth, pageHeight] = this.pageDimensions;\n                            const width = Math.round(this.width * pageWidth * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n                            const height = Math.round(this.height * pageHeight * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n                            const offscreen = new OffscreenCanvas(width, height);\n                            const ctx = offscreen.getContext(\"2d\");\n                            ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);\n                            return offscreen.transferToImageBitmap();\n                        }\n                        return structuredClone(this.#bitmap);\n                    }\n                    #createObserver() {\n                        this.#observer = new ResizeObserver((entries)=>{\n                            const rect = entries[0].contentRect;\n                            if (rect.width && rect.height) {\n                                this.#setDimensions(rect.width, rect.height);\n                            }\n                        });\n                        this.#observer.observe(this.div);\n                    }\n                    static deserialize(data, parent, uiManager) {\n                        if (data instanceof _annotation_layer.StampAnnotationElement) {\n                            return null;\n                        }\n                        const editor = super.deserialize(data, parent, uiManager);\n                        const { rect, bitmapUrl, bitmapId, isSvg, accessibilityData } = data;\n                        if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {\n                            editor.#bitmapId = bitmapId;\n                        } else {\n                            editor.#bitmapUrl = bitmapUrl;\n                        }\n                        editor.#isSvg = isSvg;\n                        const [parentWidth, parentHeight] = editor.pageDimensions;\n                        editor.width = (rect[2] - rect[0]) / parentWidth;\n                        editor.height = (rect[3] - rect[1]) / parentHeight;\n                        if (accessibilityData) {\n                            editor.altTextData = accessibilityData;\n                        }\n                        return editor;\n                    }\n                    serialize(isForCopying = false, context = null) {\n                        if (this.isEmpty()) {\n                            return null;\n                        }\n                        const serialized = {\n                            annotationType: _util.AnnotationEditorType.STAMP,\n                            bitmapId: this.#bitmapId,\n                            pageIndex: this.pageIndex,\n                            rect: this.getRect(0, 0),\n                            rotation: this.rotation,\n                            isSvg: this.#isSvg,\n                            structTreeParentId: this._structTreeParentId\n                        };\n                        if (isForCopying) {\n                            serialized.bitmapUrl = this.#serializeBitmap(true);\n                            serialized.accessibilityData = this.altTextData;\n                            return serialized;\n                        }\n                        const { decorative, altText } = this.altTextData;\n                        if (!decorative && altText) {\n                            serialized.accessibilityData = {\n                                type: \"Figure\",\n                                alt: altText\n                            };\n                        }\n                        if (context === null) {\n                            return serialized;\n                        }\n                        context.stamps ||= new Map();\n                        const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;\n                        if (!context.stamps.has(this.#bitmapId)) {\n                            context.stamps.set(this.#bitmapId, {\n                                area,\n                                serialized\n                            });\n                            serialized.bitmap = this.#serializeBitmap(false);\n                        } else if (this.#isSvg) {\n                            const prevData = context.stamps.get(this.#bitmapId);\n                            if (area > prevData.area) {\n                                prevData.area = area;\n                                prevData.serialized.bitmap.close();\n                                prevData.serialized.bitmap = this.#serializeBitmap(false);\n                            }\n                        }\n                        return serialized;\n                    }\n                }\n                exports1.StampEditor = StampEditor;\n            /***/ }\n        ];\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __w_pdfjs_require__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module1, module1.exports, __w_pdfjs_require__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /************************************************************************/ var __nested_webpack_exports__ = {};\n        // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n        (()=>{\n            var exports1 = __nested_webpack_exports__;\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            Object.defineProperty(exports1, \"AbortException\", {\n                enumerable: true,\n                get: function() {\n                    return _util.AbortException;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationEditorLayer\", {\n                enumerable: true,\n                get: function() {\n                    return _annotation_editor_layer.AnnotationEditorLayer;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationEditorParamsType\", {\n                enumerable: true,\n                get: function() {\n                    return _util.AnnotationEditorParamsType;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationEditorType\", {\n                enumerable: true,\n                get: function() {\n                    return _util.AnnotationEditorType;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationEditorUIManager\", {\n                enumerable: true,\n                get: function() {\n                    return _tools.AnnotationEditorUIManager;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationLayer\", {\n                enumerable: true,\n                get: function() {\n                    return _annotation_layer.AnnotationLayer;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationMode\", {\n                enumerable: true,\n                get: function() {\n                    return _util.AnnotationMode;\n                }\n            });\n            Object.defineProperty(exports1, \"CMapCompressionType\", {\n                enumerable: true,\n                get: function() {\n                    return _util.CMapCompressionType;\n                }\n            });\n            Object.defineProperty(exports1, \"DOMSVGFactory\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.DOMSVGFactory;\n                }\n            });\n            Object.defineProperty(exports1, \"FeatureTest\", {\n                enumerable: true,\n                get: function() {\n                    return _util.FeatureTest;\n                }\n            });\n            Object.defineProperty(exports1, \"GlobalWorkerOptions\", {\n                enumerable: true,\n                get: function() {\n                    return _worker_options.GlobalWorkerOptions;\n                }\n            });\n            Object.defineProperty(exports1, \"ImageKind\", {\n                enumerable: true,\n                get: function() {\n                    return _util.ImageKind;\n                }\n            });\n            Object.defineProperty(exports1, \"InvalidPDFException\", {\n                enumerable: true,\n                get: function() {\n                    return _util.InvalidPDFException;\n                }\n            });\n            Object.defineProperty(exports1, \"MissingPDFException\", {\n                enumerable: true,\n                get: function() {\n                    return _util.MissingPDFException;\n                }\n            });\n            Object.defineProperty(exports1, \"OPS\", {\n                enumerable: true,\n                get: function() {\n                    return _util.OPS;\n                }\n            });\n            Object.defineProperty(exports1, \"PDFDataRangeTransport\", {\n                enumerable: true,\n                get: function() {\n                    return _api.PDFDataRangeTransport;\n                }\n            });\n            Object.defineProperty(exports1, \"PDFDateString\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.PDFDateString;\n                }\n            });\n            Object.defineProperty(exports1, \"PDFWorker\", {\n                enumerable: true,\n                get: function() {\n                    return _api.PDFWorker;\n                }\n            });\n            Object.defineProperty(exports1, \"PasswordResponses\", {\n                enumerable: true,\n                get: function() {\n                    return _util.PasswordResponses;\n                }\n            });\n            Object.defineProperty(exports1, \"PermissionFlag\", {\n                enumerable: true,\n                get: function() {\n                    return _util.PermissionFlag;\n                }\n            });\n            Object.defineProperty(exports1, \"PixelsPerInch\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.PixelsPerInch;\n                }\n            });\n            Object.defineProperty(exports1, \"PromiseCapability\", {\n                enumerable: true,\n                get: function() {\n                    return _util.PromiseCapability;\n                }\n            });\n            Object.defineProperty(exports1, \"RenderingCancelledException\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.RenderingCancelledException;\n                }\n            });\n            Object.defineProperty(exports1, \"SVGGraphics\", {\n                enumerable: true,\n                get: function() {\n                    return _api.SVGGraphics;\n                }\n            });\n            Object.defineProperty(exports1, \"UnexpectedResponseException\", {\n                enumerable: true,\n                get: function() {\n                    return _util.UnexpectedResponseException;\n                }\n            });\n            Object.defineProperty(exports1, \"Util\", {\n                enumerable: true,\n                get: function() {\n                    return _util.Util;\n                }\n            });\n            Object.defineProperty(exports1, \"VerbosityLevel\", {\n                enumerable: true,\n                get: function() {\n                    return _util.VerbosityLevel;\n                }\n            });\n            Object.defineProperty(exports1, \"XfaLayer\", {\n                enumerable: true,\n                get: function() {\n                    return _xfa_layer.XfaLayer;\n                }\n            });\n            Object.defineProperty(exports1, \"build\", {\n                enumerable: true,\n                get: function() {\n                    return _api.build;\n                }\n            });\n            Object.defineProperty(exports1, \"createValidAbsoluteUrl\", {\n                enumerable: true,\n                get: function() {\n                    return _util.createValidAbsoluteUrl;\n                }\n            });\n            Object.defineProperty(exports1, \"getDocument\", {\n                enumerable: true,\n                get: function() {\n                    return _api.getDocument;\n                }\n            });\n            Object.defineProperty(exports1, \"getFilenameFromUrl\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.getFilenameFromUrl;\n                }\n            });\n            Object.defineProperty(exports1, \"getPdfFilenameFromUrl\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.getPdfFilenameFromUrl;\n                }\n            });\n            Object.defineProperty(exports1, \"getXfaPageViewport\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.getXfaPageViewport;\n                }\n            });\n            Object.defineProperty(exports1, \"isDataScheme\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.isDataScheme;\n                }\n            });\n            Object.defineProperty(exports1, \"isPdfFile\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.isPdfFile;\n                }\n            });\n            Object.defineProperty(exports1, \"loadScript\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.loadScript;\n                }\n            });\n            Object.defineProperty(exports1, \"noContextMenu\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.noContextMenu;\n                }\n            });\n            Object.defineProperty(exports1, \"normalizeUnicode\", {\n                enumerable: true,\n                get: function() {\n                    return _util.normalizeUnicode;\n                }\n            });\n            Object.defineProperty(exports1, \"renderTextLayer\", {\n                enumerable: true,\n                get: function() {\n                    return _text_layer.renderTextLayer;\n                }\n            });\n            Object.defineProperty(exports1, \"setLayerDimensions\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.setLayerDimensions;\n                }\n            });\n            Object.defineProperty(exports1, \"shadow\", {\n                enumerable: true,\n                get: function() {\n                    return _util.shadow;\n                }\n            });\n            Object.defineProperty(exports1, \"updateTextLayer\", {\n                enumerable: true,\n                get: function() {\n                    return _text_layer.updateTextLayer;\n                }\n            });\n            Object.defineProperty(exports1, \"version\", {\n                enumerable: true,\n                get: function() {\n                    return _api.version;\n                }\n            });\n            var _util = __w_pdfjs_require__(1);\n            var _api = __w_pdfjs_require__(2);\n            var _display_utils = __w_pdfjs_require__(6);\n            var _text_layer = __w_pdfjs_require__(26);\n            var _annotation_editor_layer = __w_pdfjs_require__(27);\n            var _tools = __w_pdfjs_require__(5);\n            var _annotation_layer = __w_pdfjs_require__(29);\n            var _worker_options = __w_pdfjs_require__(14);\n            var _xfa_layer = __w_pdfjs_require__(32);\n            const pdfjsVersion = \"3.11.174\";\n            const pdfjsBuild = \"ce8716743\";\n        })();\n        /******/ return __nested_webpack_exports__;\n    /******/ })();\n}); //# sourceMappingURL=pdf.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC9idWlsZC9wZGYuanMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUVBLFVBQVNBLGlDQUFpQ0MsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZELElBQUcsSUFBaUQsRUFDbkRFLE9BQU9ELE9BQU8sR0FBR0YsS0FBS0ksUUFBUSxHQUFHSDtTQUM3QixFQUtxREE7QUFDM0QsR0FBR00sWUFBWTtJQUNmLE9BQWdCLE1BQUgsR0FBSTtRQUNqQixNQUFNLEdBQUk7UUFDVixNQUFNLEdBQUksSUFBSUMsc0JBQXVCOztZQUVyQyxLQUFLLEdBQ0wsR0FBRyxHQUFJLENBQUNDLHlCQUF5QlA7Z0JBSWpDUSxPQUFPQyxjQUFjLENBQUNULFVBQVMsY0FBZTtvQkFDNUNVLE9BQU87Z0JBQ1Q7Z0JBQ0FWLFNBQVFXLGNBQWMsR0FBR1gsU0FBUVksSUFBSSxHQUFHWixTQUFRYSxxQkFBcUIsR0FBR2IsU0FBUWMsMkJBQTJCLEdBQUdkLFNBQVFlLGlCQUFpQixHQUFHZixTQUFRZ0IsbUJBQW1CLEdBQUdoQixTQUFRaUIsaUJBQWlCLEdBQUdqQixTQUFRa0IsY0FBYyxHQUFHbEIsU0FBUW1CLGlCQUFpQixHQUFHbkIsU0FBUW9CLGlCQUFpQixHQUFHcEIsU0FBUXFCLG1CQUFtQixHQUFHckIsU0FBUXNCLEdBQUcsR0FBR3RCLFNBQVF1QixtQkFBbUIsR0FBR3ZCLFNBQVF3Qix1QkFBdUIsR0FBR3hCLFNBQVF5QixXQUFXLEdBQUd6QixTQUFRMEIsbUJBQW1CLEdBQUcxQixTQUFRMkIsbUJBQW1CLEdBQUczQixTQUFRNEIsU0FBUyxHQUFHNUIsU0FBUTZCLGVBQWUsR0FBRzdCLFNBQVE4QixXQUFXLEdBQUc5QixTQUFRK0IsV0FBVyxHQUFHL0IsU0FBUWdDLG9CQUFvQixHQUFHaEMsU0FBUWlDLHVCQUF1QixHQUFHakMsU0FBUWtDLG1CQUFtQixHQUFHbEMsU0FBUW1DLGFBQWEsR0FBR25DLFNBQVFv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QUNBLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N5bmNjaGF0Ly4vbm9kZV9tb2R1bGVzL3BkZmpzLWRpc3QvYnVpbGQvcGRmLmpzPzdhYTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljc3RhcnQgVGhlIGZvbGxvd2luZyBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGVcbiAqIEphdmFTY3JpcHQgY29kZSBpbiB0aGlzIHBhZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMyBNb3ppbGxhIEZvdW5kYXRpb25cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQGxpY2VuZCBUaGUgYWJvdmUgaXMgdGhlIGVudGlyZSBsaWNlbnNlIG5vdGljZSBmb3IgdGhlXG4gKiBKYXZhU2NyaXB0IGNvZGUgaW4gdGhpcyBwYWdlXG4gKi9cblxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gcm9vdC5wZGZqc0xpYiA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwicGRmanMtZGlzdC9idWlsZC9wZGZcIiwgW10sICgpID0+IHsgcmV0dXJuIChyb290LnBkZmpzTGliID0gZmFjdG9yeSgpKTsgfSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJwZGZqcy1kaXN0L2J1aWxkL3BkZlwiXSA9IHJvb3QucGRmanNMaWIgPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wicGRmanMtZGlzdC9idWlsZC9wZGZcIl0gPSByb290LnBkZmpzTGliID0gZmFjdG9yeSgpO1xufSkoZ2xvYmFsVGhpcywgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKFtcbi8qIDAgKi8sXG4vKiAxICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlZlcmJvc2l0eUxldmVsID0gZXhwb3J0cy5VdGlsID0gZXhwb3J0cy5Vbmtub3duRXJyb3JFeGNlcHRpb24gPSBleHBvcnRzLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiA9IGV4cG9ydHMuVGV4dFJlbmRlcmluZ01vZGUgPSBleHBvcnRzLlJlbmRlcmluZ0ludGVudEZsYWcgPSBleHBvcnRzLlByb21pc2VDYXBhYmlsaXR5ID0gZXhwb3J0cy5QZXJtaXNzaW9uRmxhZyA9IGV4cG9ydHMuUGFzc3dvcmRSZXNwb25zZXMgPSBleHBvcnRzLlBhc3N3b3JkRXhjZXB0aW9uID0gZXhwb3J0cy5QYWdlQWN0aW9uRXZlbnRUeXBlID0gZXhwb3J0cy5PUFMgPSBleHBvcnRzLk1pc3NpbmdQREZFeGNlcHRpb24gPSBleHBvcnRzLk1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFID0gZXhwb3J0cy5MSU5FX0ZBQ1RPUiA9IGV4cG9ydHMuTElORV9ERVNDRU5UX0ZBQ1RPUiA9IGV4cG9ydHMuSW52YWxpZFBERkV4Y2VwdGlvbiA9IGV4cG9ydHMuSW1hZ2VLaW5kID0gZXhwb3J0cy5JREVOVElUWV9NQVRSSVggPSBleHBvcnRzLkZvcm1hdEVycm9yID0gZXhwb3J0cy5GZWF0dXJlVGVzdCA9IGV4cG9ydHMuRk9OVF9JREVOVElUWV9NQVRSSVggPSBleHBvcnRzLkRvY3VtZW50QWN0aW9uRXZlbnRUeXBlID0gZXhwb3J0cy5DTWFwQ29tcHJlc3Npb25UeXBlID0gZXhwb3J0cy5CYXNlRXhjZXB0aW9uID0gZXhwb3J0cy5CQVNFTElORV9GQUNUT1IgPSBleHBvcnRzLkFubm90YXRpb25UeXBlID0gZXhwb3J0cy5Bbm5vdGF0aW9uUmVwbHlUeXBlID0gZXhwb3J0cy5Bbm5vdGF0aW9uUHJlZml4ID0gZXhwb3J0cy5Bbm5vdGF0aW9uTW9kZSA9IGV4cG9ydHMuQW5ub3RhdGlvbkZsYWcgPSBleHBvcnRzLkFubm90YXRpb25GaWVsZEZsYWcgPSBleHBvcnRzLkFubm90YXRpb25FZGl0b3JUeXBlID0gZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yUHJlZml4ID0gZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSA9IGV4cG9ydHMuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSA9IGV4cG9ydHMuQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSA9IGV4cG9ydHMuQWJvcnRFeGNlcHRpb24gPSB2b2lkIDA7XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbmV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGJ5dGVzVG9TdHJpbmc7XG5leHBvcnRzLmNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwgPSBjcmVhdGVWYWxpZEFic29sdXRlVXJsO1xuZXhwb3J0cy5nZXRNb2RpZmljYXRpb25EYXRlID0gZ2V0TW9kaWZpY2F0aW9uRGF0ZTtcbmV4cG9ydHMuZ2V0VXVpZCA9IGdldFV1aWQ7XG5leHBvcnRzLmdldFZlcmJvc2l0eUxldmVsID0gZ2V0VmVyYm9zaXR5TGV2ZWw7XG5leHBvcnRzLmluZm8gPSBpbmZvO1xuZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcbmV4cG9ydHMuaXNBcnJheUVxdWFsID0gaXNBcnJheUVxdWFsO1xuZXhwb3J0cy5pc05vZGVKUyA9IHZvaWQgMDtcbmV4cG9ydHMubm9ybWFsaXplVW5pY29kZSA9IG5vcm1hbGl6ZVVuaWNvZGU7XG5leHBvcnRzLm9iamVjdEZyb21NYXAgPSBvYmplY3RGcm9tTWFwO1xuZXhwb3J0cy5vYmplY3RTaXplID0gb2JqZWN0U2l6ZTtcbmV4cG9ydHMuc2V0VmVyYm9zaXR5TGV2ZWwgPSBzZXRWZXJib3NpdHlMZXZlbDtcbmV4cG9ydHMuc2hhZG93ID0gc2hhZG93O1xuZXhwb3J0cy5zdHJpbmczMiA9IHN0cmluZzMyO1xuZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gc3RyaW5nVG9CeXRlcztcbmV4cG9ydHMuc3RyaW5nVG9QREZTdHJpbmcgPSBzdHJpbmdUb1BERlN0cmluZztcbmV4cG9ydHMuc3RyaW5nVG9VVEY4U3RyaW5nID0gc3RyaW5nVG9VVEY4U3RyaW5nO1xuZXhwb3J0cy51bnJlYWNoYWJsZSA9IHVucmVhY2hhYmxlO1xuZXhwb3J0cy51dGY4U3RyaW5nVG9TdHJpbmcgPSB1dGY4U3RyaW5nVG9TdHJpbmc7XG5leHBvcnRzLndhcm4gPSB3YXJuO1xuY29uc3QgaXNOb2RlSlMgPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICsgXCJcIiA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgJiYgIXByb2Nlc3MudmVyc2lvbnMubncgJiYgIShwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uICYmIHByb2Nlc3MudHlwZSAmJiBwcm9jZXNzLnR5cGUgIT09IFwiYnJvd3NlclwiKTtcbmV4cG9ydHMuaXNOb2RlSlMgPSBpc05vZGVKUztcbmNvbnN0IElERU5USVRZX01BVFJJWCA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbmV4cG9ydHMuSURFTlRJVFlfTUFUUklYID0gSURFTlRJVFlfTUFUUklYO1xuY29uc3QgRk9OVF9JREVOVElUWV9NQVRSSVggPSBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXTtcbmV4cG9ydHMuRk9OVF9JREVOVElUWV9NQVRSSVggPSBGT05UX0lERU5USVRZX01BVFJJWDtcbmNvbnN0IE1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFID0gMTBlNjtcbmV4cG9ydHMuTUFYX0lNQUdFX1NJWkVfVE9fQ0FDSEUgPSBNQVhfSU1BR0VfU0laRV9UT19DQUNIRTtcbmNvbnN0IExJTkVfRkFDVE9SID0gMS4zNTtcbmV4cG9ydHMuTElORV9GQUNUT1IgPSBMSU5FX0ZBQ1RPUjtcbmNvbnN0IExJTkVfREVTQ0VOVF9GQUNUT1IgPSAwLjM1O1xuZXhwb3J0cy5MSU5FX0RFU0NFTlRfRkFDVE9SID0gTElORV9ERVNDRU5UX0ZBQ1RPUjtcbmNvbnN0IEJBU0VMSU5FX0ZBQ1RPUiA9IExJTkVfREVTQ0VOVF9GQUNUT1IgLyBMSU5FX0ZBQ1RPUjtcbmV4cG9ydHMuQkFTRUxJTkVfRkFDVE9SID0gQkFTRUxJTkVfRkFDVE9SO1xuY29uc3QgUmVuZGVyaW5nSW50ZW50RmxhZyA9IHtcbiAgQU5ZOiAweDAxLFxuICBESVNQTEFZOiAweDAyLFxuICBQUklOVDogMHgwNCxcbiAgU0FWRTogMHgwOCxcbiAgQU5OT1RBVElPTlNfRk9STVM6IDB4MTAsXG4gIEFOTk9UQVRJT05TX1NUT1JBR0U6IDB4MjAsXG4gIEFOTk9UQVRJT05TX0RJU0FCTEU6IDB4NDAsXG4gIE9QTElTVDogMHgxMDBcbn07XG5leHBvcnRzLlJlbmRlcmluZ0ludGVudEZsYWcgPSBSZW5kZXJpbmdJbnRlbnRGbGFnO1xuY29uc3QgQW5ub3RhdGlvbk1vZGUgPSB7XG4gIERJU0FCTEU6IDAsXG4gIEVOQUJMRTogMSxcbiAgRU5BQkxFX0ZPUk1TOiAyLFxuICBFTkFCTEVfU1RPUkFHRTogM1xufTtcbmV4cG9ydHMuQW5ub3RhdGlvbk1vZGUgPSBBbm5vdGF0aW9uTW9kZTtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JQcmVmaXggPSBcInBkZmpzX2ludGVybmFsX2VkaXRvcl9cIjtcbmV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvclByZWZpeCA9IEFubm90YXRpb25FZGl0b3JQcmVmaXg7XG5jb25zdCBBbm5vdGF0aW9uRWRpdG9yVHlwZSA9IHtcbiAgRElTQUJMRTogLTEsXG4gIE5PTkU6IDAsXG4gIEZSRUVURVhUOiAzLFxuICBTVEFNUDogMTMsXG4gIElOSzogMTVcbn07XG5leHBvcnRzLkFubm90YXRpb25FZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGU7XG5jb25zdCBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSA9IHtcbiAgUkVTSVpFOiAxLFxuICBDUkVBVEU6IDIsXG4gIEZSRUVURVhUX1NJWkU6IDExLFxuICBGUkVFVEVYVF9DT0xPUjogMTIsXG4gIEZSRUVURVhUX09QQUNJVFk6IDEzLFxuICBJTktfQ09MT1I6IDIxLFxuICBJTktfVEhJQ0tORVNTOiAyMixcbiAgSU5LX09QQUNJVFk6IDIzXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSA9IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlO1xuY29uc3QgUGVybWlzc2lvbkZsYWcgPSB7XG4gIFBSSU5UOiAweDA0LFxuICBNT0RJRllfQ09OVEVOVFM6IDB4MDgsXG4gIENPUFk6IDB4MTAsXG4gIE1PRElGWV9BTk5PVEFUSU9OUzogMHgyMCxcbiAgRklMTF9JTlRFUkFDVElWRV9GT1JNUzogMHgxMDAsXG4gIENPUFlfRk9SX0FDQ0VTU0lCSUxJVFk6IDB4MjAwLFxuICBBU1NFTUJMRTogMHg0MDAsXG4gIFBSSU5UX0hJR0hfUVVBTElUWTogMHg4MDBcbn07XG5leHBvcnRzLlBlcm1pc3Npb25GbGFnID0gUGVybWlzc2lvbkZsYWc7XG5jb25zdCBUZXh0UmVuZGVyaW5nTW9kZSA9IHtcbiAgRklMTDogMCxcbiAgU1RST0tFOiAxLFxuICBGSUxMX1NUUk9LRTogMixcbiAgSU5WSVNJQkxFOiAzLFxuICBGSUxMX0FERF9UT19QQVRIOiA0LFxuICBTVFJPS0VfQUREX1RPX1BBVEg6IDUsXG4gIEZJTExfU1RST0tFX0FERF9UT19QQVRIOiA2LFxuICBBRERfVE9fUEFUSDogNyxcbiAgRklMTF9TVFJPS0VfTUFTSzogMyxcbiAgQUREX1RPX1BBVEhfRkxBRzogNFxufTtcbmV4cG9ydHMuVGV4dFJlbmRlcmluZ01vZGUgPSBUZXh0UmVuZGVyaW5nTW9kZTtcbmNvbnN0IEltYWdlS2luZCA9IHtcbiAgR1JBWVNDQUxFXzFCUFA6IDEsXG4gIFJHQl8yNEJQUDogMixcbiAgUkdCQV8zMkJQUDogM1xufTtcbmV4cG9ydHMuSW1hZ2VLaW5kID0gSW1hZ2VLaW5kO1xuY29uc3QgQW5ub3RhdGlvblR5cGUgPSB7XG4gIFRFWFQ6IDEsXG4gIExJTks6IDIsXG4gIEZSRUVURVhUOiAzLFxuICBMSU5FOiA0LFxuICBTUVVBUkU6IDUsXG4gIENJUkNMRTogNixcbiAgUE9MWUdPTjogNyxcbiAgUE9MWUxJTkU6IDgsXG4gIEhJR0hMSUdIVDogOSxcbiAgVU5ERVJMSU5FOiAxMCxcbiAgU1FVSUdHTFk6IDExLFxuICBTVFJJS0VPVVQ6IDEyLFxuICBTVEFNUDogMTMsXG4gIENBUkVUOiAxNCxcbiAgSU5LOiAxNSxcbiAgUE9QVVA6IDE2LFxuICBGSUxFQVRUQUNITUVOVDogMTcsXG4gIFNPVU5EOiAxOCxcbiAgTU9WSUU6IDE5LFxuICBXSURHRVQ6IDIwLFxuICBTQ1JFRU46IDIxLFxuICBQUklOVEVSTUFSSzogMjIsXG4gIFRSQVBORVQ6IDIzLFxuICBXQVRFUk1BUks6IDI0LFxuICBUSFJFRUQ6IDI1LFxuICBSRURBQ1Q6IDI2XG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZSA9IEFubm90YXRpb25UeXBlO1xuY29uc3QgQW5ub3RhdGlvblJlcGx5VHlwZSA9IHtcbiAgR1JPVVA6IFwiR3JvdXBcIixcbiAgUkVQTFk6IFwiUlwiXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uUmVwbHlUeXBlID0gQW5ub3RhdGlvblJlcGx5VHlwZTtcbmNvbnN0IEFubm90YXRpb25GbGFnID0ge1xuICBJTlZJU0lCTEU6IDB4MDEsXG4gIEhJRERFTjogMHgwMixcbiAgUFJJTlQ6IDB4MDQsXG4gIE5PWk9PTTogMHgwOCxcbiAgTk9ST1RBVEU6IDB4MTAsXG4gIE5PVklFVzogMHgyMCxcbiAgUkVBRE9OTFk6IDB4NDAsXG4gIExPQ0tFRDogMHg4MCxcbiAgVE9HR0xFTk9WSUVXOiAweDEwMCxcbiAgTE9DS0VEQ09OVEVOVFM6IDB4MjAwXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uRmxhZyA9IEFubm90YXRpb25GbGFnO1xuY29uc3QgQW5ub3RhdGlvbkZpZWxkRmxhZyA9IHtcbiAgUkVBRE9OTFk6IDB4MDAwMDAwMSxcbiAgUkVRVUlSRUQ6IDB4MDAwMDAwMixcbiAgTk9FWFBPUlQ6IDB4MDAwMDAwNCxcbiAgTVVMVElMSU5FOiAweDAwMDEwMDAsXG4gIFBBU1NXT1JEOiAweDAwMDIwMDAsXG4gIE5PVE9HR0xFVE9PRkY6IDB4MDAwNDAwMCxcbiAgUkFESU86IDB4MDAwODAwMCxcbiAgUFVTSEJVVFRPTjogMHgwMDEwMDAwLFxuICBDT01CTzogMHgwMDIwMDAwLFxuICBFRElUOiAweDAwNDAwMDAsXG4gIFNPUlQ6IDB4MDA4MDAwMCxcbiAgRklMRVNFTEVDVDogMHgwMTAwMDAwLFxuICBNVUxUSVNFTEVDVDogMHgwMjAwMDAwLFxuICBET05PVFNQRUxMQ0hFQ0s6IDB4MDQwMDAwMCxcbiAgRE9OT1RTQ1JPTEw6IDB4MDgwMDAwMCxcbiAgQ09NQjogMHgxMDAwMDAwLFxuICBSSUNIVEVYVDogMHgyMDAwMDAwLFxuICBSQURJT1NJTlVOSVNPTjogMHgyMDAwMDAwLFxuICBDT01NSVRPTlNFTENIQU5HRTogMHg0MDAwMDAwXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uRmllbGRGbGFnID0gQW5ub3RhdGlvbkZpZWxkRmxhZztcbmNvbnN0IEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUgPSB7XG4gIFNPTElEOiAxLFxuICBEQVNIRUQ6IDIsXG4gIEJFVkVMRUQ6IDMsXG4gIElOU0VUOiA0LFxuICBVTkRFUkxJTkU6IDVcbn07XG5leHBvcnRzLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUgPSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlO1xuY29uc3QgQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgRTogXCJNb3VzZSBFbnRlclwiLFxuICBYOiBcIk1vdXNlIEV4aXRcIixcbiAgRDogXCJNb3VzZSBEb3duXCIsXG4gIFU6IFwiTW91c2UgVXBcIixcbiAgRm86IFwiRm9jdXNcIixcbiAgQmw6IFwiQmx1clwiLFxuICBQTzogXCJQYWdlT3BlblwiLFxuICBQQzogXCJQYWdlQ2xvc2VcIixcbiAgUFY6IFwiUGFnZVZpc2libGVcIixcbiAgUEk6IFwiUGFnZUludmlzaWJsZVwiLFxuICBLOiBcIktleXN0cm9rZVwiLFxuICBGOiBcIkZvcm1hdFwiLFxuICBWOiBcIlZhbGlkYXRlXCIsXG4gIEM6IFwiQ2FsY3VsYXRlXCJcbn07XG5leHBvcnRzLkFubm90YXRpb25BY3Rpb25FdmVudFR5cGUgPSBBbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlO1xuY29uc3QgRG9jdW1lbnRBY3Rpb25FdmVudFR5cGUgPSB7XG4gIFdDOiBcIldpbGxDbG9zZVwiLFxuICBXUzogXCJXaWxsU2F2ZVwiLFxuICBEUzogXCJEaWRTYXZlXCIsXG4gIFdQOiBcIldpbGxQcmludFwiLFxuICBEUDogXCJEaWRQcmludFwiXG59O1xuZXhwb3J0cy5Eb2N1bWVudEFjdGlvbkV2ZW50VHlwZSA9IERvY3VtZW50QWN0aW9uRXZlbnRUeXBlO1xuY29uc3QgUGFnZUFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgTzogXCJQYWdlT3BlblwiLFxuICBDOiBcIlBhZ2VDbG9zZVwiXG59O1xuZXhwb3J0cy5QYWdlQWN0aW9uRXZlbnRUeXBlID0gUGFnZUFjdGlvbkV2ZW50VHlwZTtcbmNvbnN0IFZlcmJvc2l0eUxldmVsID0ge1xuICBFUlJPUlM6IDAsXG4gIFdBUk5JTkdTOiAxLFxuICBJTkZPUzogNVxufTtcbmV4cG9ydHMuVmVyYm9zaXR5TGV2ZWwgPSBWZXJib3NpdHlMZXZlbDtcbmNvbnN0IENNYXBDb21wcmVzc2lvblR5cGUgPSB7XG4gIE5PTkU6IDAsXG4gIEJJTkFSWTogMVxufTtcbmV4cG9ydHMuQ01hcENvbXByZXNzaW9uVHlwZSA9IENNYXBDb21wcmVzc2lvblR5cGU7XG5jb25zdCBPUFMgPSB7XG4gIGRlcGVuZGVuY3k6IDEsXG4gIHNldExpbmVXaWR0aDogMixcbiAgc2V0TGluZUNhcDogMyxcbiAgc2V0TGluZUpvaW46IDQsXG4gIHNldE1pdGVyTGltaXQ6IDUsXG4gIHNldERhc2g6IDYsXG4gIHNldFJlbmRlcmluZ0ludGVudDogNyxcbiAgc2V0RmxhdG5lc3M6IDgsXG4gIHNldEdTdGF0ZTogOSxcbiAgc2F2ZTogMTAsXG4gIHJlc3RvcmU6IDExLFxuICB0cmFuc2Zvcm06IDEyLFxuICBtb3ZlVG86IDEzLFxuICBsaW5lVG86IDE0LFxuICBjdXJ2ZVRvOiAxNSxcbiAgY3VydmVUbzI6IDE2LFxuICBjdXJ2ZVRvMzogMTcsXG4gIGNsb3NlUGF0aDogMTgsXG4gIHJlY3RhbmdsZTogMTksXG4gIHN0cm9rZTogMjAsXG4gIGNsb3NlU3Ryb2tlOiAyMSxcbiAgZmlsbDogMjIsXG4gIGVvRmlsbDogMjMsXG4gIGZpbGxTdHJva2U6IDI0LFxuICBlb0ZpbGxTdHJva2U6IDI1LFxuICBjbG9zZUZpbGxTdHJva2U6IDI2LFxuICBjbG9zZUVPRmlsbFN0cm9rZTogMjcsXG4gIGVuZFBhdGg6IDI4LFxuICBjbGlwOiAyOSxcbiAgZW9DbGlwOiAzMCxcbiAgYmVnaW5UZXh0OiAzMSxcbiAgZW5kVGV4dDogMzIsXG4gIHNldENoYXJTcGFjaW5nOiAzMyxcbiAgc2V0V29yZFNwYWNpbmc6IDM0LFxuICBzZXRIU2NhbGU6IDM1LFxuICBzZXRMZWFkaW5nOiAzNixcbiAgc2V0Rm9udDogMzcsXG4gIHNldFRleHRSZW5kZXJpbmdNb2RlOiAzOCxcbiAgc2V0VGV4dFJpc2U6IDM5LFxuICBtb3ZlVGV4dDogNDAsXG4gIHNldExlYWRpbmdNb3ZlVGV4dDogNDEsXG4gIHNldFRleHRNYXRyaXg6IDQyLFxuICBuZXh0TGluZTogNDMsXG4gIHNob3dUZXh0OiA0NCxcbiAgc2hvd1NwYWNlZFRleHQ6IDQ1LFxuICBuZXh0TGluZVNob3dUZXh0OiA0NixcbiAgbmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQ6IDQ3LFxuICBzZXRDaGFyV2lkdGg6IDQ4LFxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHM6IDQ5LFxuICBzZXRTdHJva2VDb2xvclNwYWNlOiA1MCxcbiAgc2V0RmlsbENvbG9yU3BhY2U6IDUxLFxuICBzZXRTdHJva2VDb2xvcjogNTIsXG4gIHNldFN0cm9rZUNvbG9yTjogNTMsXG4gIHNldEZpbGxDb2xvcjogNTQsXG4gIHNldEZpbGxDb2xvck46IDU1LFxuICBzZXRTdHJva2VHcmF5OiA1NixcbiAgc2V0RmlsbEdyYXk6IDU3LFxuICBzZXRTdHJva2VSR0JDb2xvcjogNTgsXG4gIHNldEZpbGxSR0JDb2xvcjogNTksXG4gIHNldFN0cm9rZUNNWUtDb2xvcjogNjAsXG4gIHNldEZpbGxDTVlLQ29sb3I6IDYxLFxuICBzaGFkaW5nRmlsbDogNjIsXG4gIGJlZ2luSW5saW5lSW1hZ2U6IDYzLFxuICBiZWdpbkltYWdlRGF0YTogNjQsXG4gIGVuZElubGluZUltYWdlOiA2NSxcbiAgcGFpbnRYT2JqZWN0OiA2NixcbiAgbWFya1BvaW50OiA2NyxcbiAgbWFya1BvaW50UHJvcHM6IDY4LFxuICBiZWdpbk1hcmtlZENvbnRlbnQ6IDY5LFxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wczogNzAsXG4gIGVuZE1hcmtlZENvbnRlbnQ6IDcxLFxuICBiZWdpbkNvbXBhdDogNzIsXG4gIGVuZENvbXBhdDogNzMsXG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbjogNzQsXG4gIHBhaW50Rm9ybVhPYmplY3RFbmQ6IDc1LFxuICBiZWdpbkdyb3VwOiA3NixcbiAgZW5kR3JvdXA6IDc3LFxuICBiZWdpbkFubm90YXRpb246IDgwLFxuICBlbmRBbm5vdGF0aW9uOiA4MSxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0OiA4MyxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXA6IDg0LFxuICBwYWludEltYWdlWE9iamVjdDogODUsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0OiA4NixcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cDogODcsXG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0OiA4OCxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0OiA4OSxcbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrOiA5MCxcbiAgY29uc3RydWN0UGF0aDogOTFcbn07XG5leHBvcnRzLk9QUyA9IE9QUztcbmNvbnN0IFBhc3N3b3JkUmVzcG9uc2VzID0ge1xuICBORUVEX1BBU1NXT1JEOiAxLFxuICBJTkNPUlJFQ1RfUEFTU1dPUkQ6IDJcbn07XG5leHBvcnRzLlBhc3N3b3JkUmVzcG9uc2VzID0gUGFzc3dvcmRSZXNwb25zZXM7XG5sZXQgdmVyYm9zaXR5ID0gVmVyYm9zaXR5TGV2ZWwuV0FSTklOR1M7XG5mdW5jdGlvbiBzZXRWZXJib3NpdHlMZXZlbChsZXZlbCkge1xuICBpZiAoTnVtYmVyLmlzSW50ZWdlcihsZXZlbCkpIHtcbiAgICB2ZXJib3NpdHkgPSBsZXZlbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmVyYm9zaXR5TGV2ZWwoKSB7XG4gIHJldHVybiB2ZXJib3NpdHk7XG59XG5mdW5jdGlvbiBpbmZvKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLklORk9TKSB7XG4gICAgY29uc29sZS5sb2coYEluZm86ICR7bXNnfWApO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLldBUk5JTkdTKSB7XG4gICAgY29uc29sZS5sb2coYFdhcm5pbmc6ICR7bXNnfWApO1xuICB9XG59XG5mdW5jdGlvbiB1bnJlYWNoYWJsZShtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG59XG5mdW5jdGlvbiBhc3NlcnQoY29uZCwgbXNnKSB7XG4gIGlmICghY29uZCkge1xuICAgIHVucmVhY2hhYmxlKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9pc1ZhbGlkUHJvdG9jb2wodXJsKSB7XG4gIHN3aXRjaCAodXJsPy5wcm90b2NvbCkge1xuICAgIGNhc2UgXCJodHRwOlwiOlxuICAgIGNhc2UgXCJodHRwczpcIjpcbiAgICBjYXNlIFwiZnRwOlwiOlxuICAgIGNhc2UgXCJtYWlsdG86XCI6XG4gICAgY2FzZSBcInRlbDpcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwodXJsLCBiYXNlVXJsID0gbnVsbCwgb3B0aW9ucyA9IG51bGwpIHtcbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChvcHRpb25zLmFkZERlZmF1bHRQcm90b2NvbCAmJiB1cmwuc3RhcnRzV2l0aChcInd3dy5cIikpIHtcbiAgICAgICAgY29uc3QgZG90cyA9IHVybC5tYXRjaCgvXFwuL2cpO1xuICAgICAgICBpZiAoZG90cz8ubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICB1cmwgPSBgaHR0cDovLyR7dXJsfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnRyeUNvbnZlcnRFbmNvZGluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVybCA9IHN0cmluZ1RvVVRGOFN0cmluZyh1cmwpO1xuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFic29sdXRlVXJsID0gYmFzZVVybCA/IG5ldyBVUkwodXJsLCBiYXNlVXJsKSA6IG5ldyBVUkwodXJsKTtcbiAgICBpZiAoX2lzVmFsaWRQcm90b2NvbChhYnNvbHV0ZVVybCkpIHtcbiAgICAgIHJldHVybiBhYnNvbHV0ZVVybDtcbiAgICB9XG4gIH0gY2F0Y2gge31cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzaGFkb3cob2JqLCBwcm9wLCB2YWx1ZSwgbm9uU2VyaWFsaXphYmxlID0gZmFsc2UpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgIHZhbHVlLFxuICAgIGVudW1lcmFibGU6ICFub25TZXJpYWxpemFibGUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgQmFzZUV4Y2VwdGlvbiA9IGZ1bmN0aW9uIEJhc2VFeGNlcHRpb25DbG9zdXJlKCkge1xuICBmdW5jdGlvbiBCYXNlRXhjZXB0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZUV4Y2VwdGlvbikge1xuICAgICAgdW5yZWFjaGFibGUoXCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlRXhjZXB0aW9uLlwiKTtcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG4gIEJhc2VFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIEJhc2VFeGNlcHRpb24uY29uc3RydWN0b3IgPSBCYXNlRXhjZXB0aW9uO1xuICByZXR1cm4gQmFzZUV4Y2VwdGlvbjtcbn0oKTtcbmV4cG9ydHMuQmFzZUV4Y2VwdGlvbiA9IEJhc2VFeGNlcHRpb247XG5jbGFzcyBQYXNzd29yZEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGNvZGUpIHtcbiAgICBzdXBlcihtc2csIFwiUGFzc3dvcmRFeGNlcHRpb25cIik7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufVxuZXhwb3J0cy5QYXNzd29yZEV4Y2VwdGlvbiA9IFBhc3N3b3JkRXhjZXB0aW9uO1xuY2xhc3MgVW5rbm93bkVycm9yRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgZGV0YWlscykge1xuICAgIHN1cGVyKG1zZywgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIik7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufVxuZXhwb3J0cy5Vbmtub3duRXJyb3JFeGNlcHRpb24gPSBVbmtub3duRXJyb3JFeGNlcHRpb247XG5jbGFzcyBJbnZhbGlkUERGRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJJbnZhbGlkUERGRXhjZXB0aW9uXCIpO1xuICB9XG59XG5leHBvcnRzLkludmFsaWRQREZFeGNlcHRpb24gPSBJbnZhbGlkUERGRXhjZXB0aW9uO1xuY2xhc3MgTWlzc2luZ1BERkV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiKTtcbiAgfVxufVxuZXhwb3J0cy5NaXNzaW5nUERGRXhjZXB0aW9uID0gTWlzc2luZ1BERkV4Y2VwdGlvbjtcbmNsYXNzIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIHN0YXR1cykge1xuICAgIHN1cGVyKG1zZywgXCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25cIik7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gIH1cbn1cbmV4cG9ydHMuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uID0gVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uO1xuY2xhc3MgRm9ybWF0RXJyb3IgZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkZvcm1hdEVycm9yXCIpO1xuICB9XG59XG5leHBvcnRzLkZvcm1hdEVycm9yID0gRm9ybWF0RXJyb3I7XG5jbGFzcyBBYm9ydEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiQWJvcnRFeGNlcHRpb25cIik7XG4gIH1cbn1cbmV4cG9ydHMuQWJvcnRFeGNlcHRpb24gPSBBYm9ydEV4Y2VwdGlvbjtcbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgaWYgKHR5cGVvZiBieXRlcyAhPT0gXCJvYmplY3RcIiB8fCBieXRlcz8ubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICB1bnJlYWNoYWJsZShcIkludmFsaWQgYXJndW1lbnQgZm9yIGJ5dGVzVG9TdHJpbmdcIik7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICBjb25zdCBNQVhfQVJHVU1FTlRfQ09VTlQgPSA4MTkyO1xuICBpZiAobGVuZ3RoIDwgTUFYX0FSR1VNRU5UX0NPVU5UKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMpO1xuICB9XG4gIGNvbnN0IHN0ckJ1ZiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBNQVhfQVJHVU1FTlRfQ09VTlQpIHtcbiAgICBjb25zdCBjaHVua0VuZCA9IE1hdGgubWluKGkgKyBNQVhfQVJHVU1FTlRfQ09VTlQsIGxlbmd0aCk7XG4gICAgY29uc3QgY2h1bmsgPSBieXRlcy5zdWJhcnJheShpLCBjaHVua0VuZCk7XG4gICAgc3RyQnVmLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjaHVuaykpO1xuICB9XG4gIHJldHVybiBzdHJCdWYuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdW5yZWFjaGFibGUoXCJJbnZhbGlkIGFyZ3VtZW50IGZvciBzdHJpbmdUb0J5dGVzXCIpO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzW2ldID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIHN0cmluZzMyKHZhbHVlKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlID4+IDI0ICYgMHhmZiwgdmFsdWUgPj4gMTYgJiAweGZmLCB2YWx1ZSA+PiA4ICYgMHhmZiwgdmFsdWUgJiAweGZmKTtcbn1cbmZ1bmN0aW9uIG9iamVjdFNpemUob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIG9iamVjdEZyb21NYXAobWFwKSB7XG4gIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcCkge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIGlzTGl0dGxlRW5kaWFuKCkge1xuICBjb25zdCBidWZmZXI4ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIGJ1ZmZlcjhbMF0gPSAxO1xuICBjb25zdCB2aWV3MzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyOC5idWZmZXIsIDAsIDEpO1xuICByZXR1cm4gdmlldzMyWzBdID09PSAxO1xufVxuZnVuY3Rpb24gaXNFdmFsU3VwcG9ydGVkKCkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbihcIlwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jbGFzcyBGZWF0dXJlVGVzdCB7XG4gIHN0YXRpYyBnZXQgaXNMaXR0bGVFbmRpYW4oKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzTGl0dGxlRW5kaWFuXCIsIGlzTGl0dGxlRW5kaWFuKCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNFdmFsU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0V2YWxTdXBwb3J0ZWRcIiwgaXNFdmFsU3VwcG9ydGVkKCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkXCIsIHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgcGxhdGZvcm0oKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBzaGFkb3codGhpcywgXCJwbGF0Zm9ybVwiLCB7XG4gICAgICAgIGlzV2luOiBmYWxzZSxcbiAgICAgICAgaXNNYWM6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInBsYXRmb3JtXCIsIHtcbiAgICAgIGlzV2luOiBuYXZpZ2F0b3IucGxhdGZvcm0uaW5jbHVkZXMoXCJXaW5cIiksXG4gICAgICBpc01hYzogbmF2aWdhdG9yLnBsYXRmb3JtLmluY2x1ZGVzKFwiTWFjXCIpXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc0NTU1JvdW5kU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0NTU1JvdW5kU3VwcG9ydGVkXCIsIGdsb2JhbFRoaXMuQ1NTPy5zdXBwb3J0cz8uKFwid2lkdGg6IHJvdW5kKDEuNXB4LCAxcHgpXCIpKTtcbiAgfVxufVxuZXhwb3J0cy5GZWF0dXJlVGVzdCA9IEZlYXR1cmVUZXN0O1xuY29uc3QgaGV4TnVtYmVycyA9IFsuLi5BcnJheSgyNTYpLmtleXMoKV0ubWFwKG4gPT4gbi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKTtcbmNsYXNzIFV0aWwge1xuICBzdGF0aWMgbWFrZUhleENvbG9yKHIsIGcsIGIpIHtcbiAgICByZXR1cm4gYCMke2hleE51bWJlcnNbcl19JHtoZXhOdW1iZXJzW2ddfSR7aGV4TnVtYmVyc1tiXX1gO1xuICB9XG4gIHN0YXRpYyBzY2FsZU1pbk1heCh0cmFuc2Zvcm0sIG1pbk1heCkge1xuICAgIGxldCB0ZW1wO1xuICAgIGlmICh0cmFuc2Zvcm1bMF0pIHtcbiAgICAgIGlmICh0cmFuc2Zvcm1bMF0gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICAgIG1pbk1heFswXSA9IG1pbk1heFsxXTtcbiAgICAgICAgbWluTWF4WzFdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFswXSAqPSB0cmFuc2Zvcm1bMF07XG4gICAgICBtaW5NYXhbMV0gKj0gdHJhbnNmb3JtWzBdO1xuICAgICAgaWYgKHRyYW5zZm9ybVszXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFsyXTtcbiAgICAgICAgbWluTWF4WzJdID0gbWluTWF4WzNdO1xuICAgICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzJdICo9IHRyYW5zZm9ybVszXTtcbiAgICAgIG1pbk1heFszXSAqPSB0cmFuc2Zvcm1bM107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMl07XG4gICAgICBtaW5NYXhbMl0gPSB0ZW1wO1xuICAgICAgdGVtcCA9IG1pbk1heFsxXTtcbiAgICAgIG1pbk1heFsxXSA9IG1pbk1heFszXTtcbiAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICBpZiAodHJhbnNmb3JtWzFdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzJdO1xuICAgICAgICBtaW5NYXhbMl0gPSBtaW5NYXhbM107XG4gICAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMl0gKj0gdHJhbnNmb3JtWzFdO1xuICAgICAgbWluTWF4WzNdICo9IHRyYW5zZm9ybVsxXTtcbiAgICAgIGlmICh0cmFuc2Zvcm1bMl0gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICAgIG1pbk1heFswXSA9IG1pbk1heFsxXTtcbiAgICAgICAgbWluTWF4WzFdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFswXSAqPSB0cmFuc2Zvcm1bMl07XG4gICAgICBtaW5NYXhbMV0gKj0gdHJhbnNmb3JtWzJdO1xuICAgIH1cbiAgICBtaW5NYXhbMF0gKz0gdHJhbnNmb3JtWzRdO1xuICAgIG1pbk1heFsxXSArPSB0cmFuc2Zvcm1bNF07XG4gICAgbWluTWF4WzJdICs9IHRyYW5zZm9ybVs1XTtcbiAgICBtaW5NYXhbM10gKz0gdHJhbnNmb3JtWzVdO1xuICB9XG4gIHN0YXRpYyB0cmFuc2Zvcm0obTEsIG0yKSB7XG4gICAgcmV0dXJuIFttMVswXSAqIG0yWzBdICsgbTFbMl0gKiBtMlsxXSwgbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV0sIG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdLCBtMVsxXSAqIG0yWzJdICsgbTFbM10gKiBtMlszXSwgbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XSwgbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XV07XG4gIH1cbiAgc3RhdGljIGFwcGx5VHJhbnNmb3JtKHAsIG0pIHtcbiAgICBjb25zdCB4dCA9IHBbMF0gKiBtWzBdICsgcFsxXSAqIG1bMl0gKyBtWzRdO1xuICAgIGNvbnN0IHl0ID0gcFswXSAqIG1bMV0gKyBwWzFdICogbVszXSArIG1bNV07XG4gICAgcmV0dXJuIFt4dCwgeXRdO1xuICB9XG4gIHN0YXRpYyBhcHBseUludmVyc2VUcmFuc2Zvcm0ocCwgbSkge1xuICAgIGNvbnN0IGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgIGNvbnN0IHh0ID0gKHBbMF0gKiBtWzNdIC0gcFsxXSAqIG1bMl0gKyBtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQ7XG4gICAgY29uc3QgeXQgPSAoLXBbMF0gKiBtWzFdICsgcFsxXSAqIG1bMF0gKyBtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGQ7XG4gICAgcmV0dXJuIFt4dCwgeXRdO1xuICB9XG4gIHN0YXRpYyBnZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChyLCBtKSB7XG4gICAgY29uc3QgcDEgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKHIsIG0pO1xuICAgIGNvbnN0IHAyID0gdGhpcy5hcHBseVRyYW5zZm9ybShyLnNsaWNlKDIsIDQpLCBtKTtcbiAgICBjb25zdCBwMyA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0oW3JbMF0sIHJbM11dLCBtKTtcbiAgICBjb25zdCBwNCA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0oW3JbMl0sIHJbMV1dLCBtKTtcbiAgICByZXR1cm4gW01hdGgubWluKHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKSwgTWF0aC5taW4ocDFbMV0sIHAyWzFdLCBwM1sxXSwgcDRbMV0pLCBNYXRoLm1heChwMVswXSwgcDJbMF0sIHAzWzBdLCBwNFswXSksIE1hdGgubWF4KHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKV07XG4gIH1cbiAgc3RhdGljIGludmVyc2VUcmFuc2Zvcm0obSkge1xuICAgIGNvbnN0IGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgIHJldHVybiBbbVszXSAvIGQsIC1tWzFdIC8gZCwgLW1bMl0gLyBkLCBtWzBdIC8gZCwgKG1bMl0gKiBtWzVdIC0gbVs0XSAqIG1bM10pIC8gZCwgKG1bNF0gKiBtWzFdIC0gbVs1XSAqIG1bMF0pIC8gZF07XG4gIH1cbiAgc3RhdGljIHNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG0pIHtcbiAgICBjb25zdCB0cmFuc3Bvc2UgPSBbbVswXSwgbVsyXSwgbVsxXSwgbVszXV07XG4gICAgY29uc3QgYSA9IG1bMF0gKiB0cmFuc3Bvc2VbMF0gKyBtWzFdICogdHJhbnNwb3NlWzJdO1xuICAgIGNvbnN0IGIgPSBtWzBdICogdHJhbnNwb3NlWzFdICsgbVsxXSAqIHRyYW5zcG9zZVszXTtcbiAgICBjb25zdCBjID0gbVsyXSAqIHRyYW5zcG9zZVswXSArIG1bM10gKiB0cmFuc3Bvc2VbMl07XG4gICAgY29uc3QgZCA9IG1bMl0gKiB0cmFuc3Bvc2VbMV0gKyBtWzNdICogdHJhbnNwb3NlWzNdO1xuICAgIGNvbnN0IGZpcnN0ID0gKGEgKyBkKSAvIDI7XG4gICAgY29uc3Qgc2Vjb25kID0gTWF0aC5zcXJ0KChhICsgZCkgKiogMiAtIDQgKiAoYSAqIGQgLSBjICogYikpIC8gMjtcbiAgICBjb25zdCBzeCA9IGZpcnN0ICsgc2Vjb25kIHx8IDE7XG4gICAgY29uc3Qgc3kgPSBmaXJzdCAtIHNlY29uZCB8fCAxO1xuICAgIHJldHVybiBbTWF0aC5zcXJ0KHN4KSwgTWF0aC5zcXJ0KHN5KV07XG4gIH1cbiAgc3RhdGljIG5vcm1hbGl6ZVJlY3QocmVjdCkge1xuICAgIGNvbnN0IHIgPSByZWN0LnNsaWNlKDApO1xuICAgIGlmIChyZWN0WzBdID4gcmVjdFsyXSkge1xuICAgICAgclswXSA9IHJlY3RbMl07XG4gICAgICByWzJdID0gcmVjdFswXTtcbiAgICB9XG4gICAgaWYgKHJlY3RbMV0gPiByZWN0WzNdKSB7XG4gICAgICByWzFdID0gcmVjdFszXTtcbiAgICAgIHJbM10gPSByZWN0WzFdO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICBzdGF0aWMgaW50ZXJzZWN0KHJlY3QxLCByZWN0Mikge1xuICAgIGNvbnN0IHhMb3cgPSBNYXRoLm1heChNYXRoLm1pbihyZWN0MVswXSwgcmVjdDFbMl0pLCBNYXRoLm1pbihyZWN0MlswXSwgcmVjdDJbMl0pKTtcbiAgICBjb25zdCB4SGlnaCA9IE1hdGgubWluKE1hdGgubWF4KHJlY3QxWzBdLCByZWN0MVsyXSksIE1hdGgubWF4KHJlY3QyWzBdLCByZWN0MlsyXSkpO1xuICAgIGlmICh4TG93ID4geEhpZ2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB5TG93ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVjdDFbMV0sIHJlY3QxWzNdKSwgTWF0aC5taW4ocmVjdDJbMV0sIHJlY3QyWzNdKSk7XG4gICAgY29uc3QgeUhpZ2ggPSBNYXRoLm1pbihNYXRoLm1heChyZWN0MVsxXSwgcmVjdDFbM10pLCBNYXRoLm1heChyZWN0MlsxXSwgcmVjdDJbM10pKTtcbiAgICBpZiAoeUxvdyA+IHlIaWdoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFt4TG93LCB5TG93LCB4SGlnaCwgeUhpZ2hdO1xuICB9XG4gIHN0YXRpYyBiZXppZXJCb3VuZGluZ0JveCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICBjb25zdCB0dmFsdWVzID0gW10sXG4gICAgICBib3VuZHMgPSBbW10sIFtdXTtcbiAgICBsZXQgYSwgYiwgYywgdCwgdDEsIHQyLCBiMmFjLCBzcXJ0YjJhYztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgYiA9IDYgKiB4MCAtIDEyICogeDEgKyA2ICogeDI7XG4gICAgICAgIGEgPSAtMyAqIHgwICsgOSAqIHgxIC0gOSAqIHgyICsgMyAqIHgzO1xuICAgICAgICBjID0gMyAqIHgxIC0gMyAqIHgwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYiA9IDYgKiB5MCAtIDEyICogeTEgKyA2ICogeTI7XG4gICAgICAgIGEgPSAtMyAqIHkwICsgOSAqIHkxIC0gOSAqIHkyICsgMyAqIHkzO1xuICAgICAgICBjID0gMyAqIHkxIC0gMyAqIHkwO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKGEpIDwgMWUtMTIpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGIpIDwgMWUtMTIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ID0gLWMgLyBiO1xuICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgICB0dmFsdWVzLnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XG4gICAgICBzcXJ0YjJhYyA9IE1hdGguc3FydChiMmFjKTtcbiAgICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHQxID0gKC1iICsgc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgIGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XG4gICAgICAgIHR2YWx1ZXMucHVzaCh0MSk7XG4gICAgICB9XG4gICAgICB0MiA9ICgtYiAtIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuICAgICAgICB0dmFsdWVzLnB1c2godDIpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaiA9IHR2YWx1ZXMubGVuZ3RoLFxuICAgICAgbXQ7XG4gICAgY29uc3QgamxlbiA9IGo7XG4gICAgd2hpbGUgKGotLSkge1xuICAgICAgdCA9IHR2YWx1ZXNbal07XG4gICAgICBtdCA9IDEgLSB0O1xuICAgICAgYm91bmRzWzBdW2pdID0gbXQgKiBtdCAqIG10ICogeDAgKyAzICogbXQgKiBtdCAqIHQgKiB4MSArIDMgKiBtdCAqIHQgKiB0ICogeDIgKyB0ICogdCAqIHQgKiB4MztcbiAgICAgIGJvdW5kc1sxXVtqXSA9IG10ICogbXQgKiBtdCAqIHkwICsgMyAqIG10ICogbXQgKiB0ICogeTEgKyAzICogbXQgKiB0ICogdCAqIHkyICsgdCAqIHQgKiB0ICogeTM7XG4gICAgfVxuICAgIGJvdW5kc1swXVtqbGVuXSA9IHgwO1xuICAgIGJvdW5kc1sxXVtqbGVuXSA9IHkwO1xuICAgIGJvdW5kc1swXVtqbGVuICsgMV0gPSB4MztcbiAgICBib3VuZHNbMV1bamxlbiArIDFdID0geTM7XG4gICAgYm91bmRzWzBdLmxlbmd0aCA9IGJvdW5kc1sxXS5sZW5ndGggPSBqbGVuICsgMjtcbiAgICByZXR1cm4gW01hdGgubWluKC4uLmJvdW5kc1swXSksIE1hdGgubWluKC4uLmJvdW5kc1sxXSksIE1hdGgubWF4KC4uLmJvdW5kc1swXSksIE1hdGgubWF4KC4uLmJvdW5kc1sxXSldO1xuICB9XG59XG5leHBvcnRzLlV0aWwgPSBVdGlsO1xuY29uc3QgUERGU3RyaW5nVHJhbnNsYXRlVGFibGUgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgyZDgsIDB4MmM3LCAweDJjNiwgMHgyZDksIDB4MmRkLCAweDJkYiwgMHgyZGEsIDB4MmRjLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDIwMjIsIDB4MjAyMCwgMHgyMDIxLCAweDIwMjYsIDB4MjAxNCwgMHgyMDEzLCAweDE5MiwgMHgyMDQ0LCAweDIwMzksIDB4MjAzYSwgMHgyMjEyLCAweDIwMzAsIDB4MjAxZSwgMHgyMDFjLCAweDIwMWQsIDB4MjAxOCwgMHgyMDE5LCAweDIwMWEsIDB4MjEyMiwgMHhmYjAxLCAweGZiMDIsIDB4MTQxLCAweDE1MiwgMHgxNjAsIDB4MTc4LCAweDE3ZCwgMHgxMzEsIDB4MTQyLCAweDE1MywgMHgxNjEsIDB4MTdlLCAwLCAweDIwYWNdO1xuZnVuY3Rpb24gc3RyaW5nVG9QREZTdHJpbmcoc3RyKSB7XG4gIGlmIChzdHJbMF0gPj0gXCJcXHhFRlwiKSB7XG4gICAgbGV0IGVuY29kaW5nO1xuICAgIGlmIChzdHJbMF0gPT09IFwiXFx4RkVcIiAmJiBzdHJbMV0gPT09IFwiXFx4RkZcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi0xNmJlXCI7XG4gICAgfSBlbHNlIGlmIChzdHJbMF0gPT09IFwiXFx4RkZcIiAmJiBzdHJbMV0gPT09IFwiXFx4RkVcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi0xNmxlXCI7XG4gICAgfSBlbHNlIGlmIChzdHJbMF0gPT09IFwiXFx4RUZcIiAmJiBzdHJbMV0gPT09IFwiXFx4QkJcIiAmJiBzdHJbMl0gPT09IFwiXFx4QkZcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi04XCI7XG4gICAgfVxuICAgIGlmIChlbmNvZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZywge1xuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBzdHJpbmdUb0J5dGVzKHN0cik7XG4gICAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShidWZmZXIpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgd2Fybihgc3RyaW5nVG9QREZTdHJpbmc6IFwiJHtleH1cIi5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3Qgc3RyQnVmID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IHN0ci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IFBERlN0cmluZ1RyYW5zbGF0ZVRhYmxlW3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICBzdHJCdWYucHVzaChjb2RlID8gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSA6IHN0ci5jaGFyQXQoaSkpO1xuICB9XG4gIHJldHVybiBzdHJCdWYuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3RyKSk7XG59XG5mdW5jdGlvbiB1dGY4U3RyaW5nVG9TdHJpbmcoc3RyKSB7XG4gIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHY/LmJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzQXJyYXlFcXVhbChhcnIxLCBhcnIyKSB7XG4gIGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gYXJyMS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRNb2RpZmljYXRpb25EYXRlKGRhdGUgPSBuZXcgRGF0ZSgpKSB7XG4gIGNvbnN0IGJ1ZmZlciA9IFtkYXRlLmdldFVUQ0Z1bGxZZWFyKCkudG9TdHJpbmcoKSwgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ0RhdGUoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENIb3VycygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ01pbnV0ZXMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENTZWNvbmRzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIildO1xuICByZXR1cm4gYnVmZmVyLmpvaW4oXCJcIik7XG59XG5jbGFzcyBQcm9taXNlQ2FwYWJpbGl0eSB7XG4gICNzZXR0bGVkID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IGRhdGEgPT4ge1xuICAgICAgICB0aGlzLiNzZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnJlamVjdCA9IHJlYXNvbiA9PiB7XG4gICAgICAgIHRoaXMuI3NldHRsZWQgPSB0cnVlO1xuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHNldHRsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NldHRsZWQ7XG4gIH1cbn1cbmV4cG9ydHMuUHJvbWlzZUNhcGFiaWxpdHkgPSBQcm9taXNlQ2FwYWJpbGl0eTtcbmxldCBOb3JtYWxpemVSZWdleCA9IG51bGw7XG5sZXQgTm9ybWFsaXphdGlvbk1hcCA9IG51bGw7XG5mdW5jdGlvbiBub3JtYWxpemVVbmljb2RlKHN0cikge1xuICBpZiAoIU5vcm1hbGl6ZVJlZ2V4KSB7XG4gICAgTm9ybWFsaXplUmVnZXggPSAvKFtcXHUwMGEwXFx1MDBiNVxcdTAzN2VcXHUwZWIzXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIxMjZcXHVmYjAwLVxcdWZiMDRcXHVmYjA2XFx1ZmIyMC1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmJhMVxcdWZiYTQtXFx1ZmJhOVxcdWZiYWUtXFx1ZmJiMVxcdWZiZDMtXFx1ZmJkY1xcdWZiZGUtXFx1ZmJlN1xcdWZiZWEtXFx1ZmJmOFxcdWZiZmMtXFx1ZmJmZFxcdWZjMDAtXFx1ZmM1ZFxcdWZjNjQtXFx1ZmNmMVxcdWZjZjUtXFx1ZmQzZFxcdWZkODhcXHVmZGY0XFx1ZmRmYS1cXHVmZGZiXFx1ZmU3MVxcdWZlNzdcXHVmZTc5XFx1ZmU3YlxcdWZlN2RdKyl8KFxcdWZiMDUrKS9ndTtcbiAgICBOb3JtYWxpemF0aW9uTWFwID0gbmV3IE1hcChbW1wi76yFXCIsIFwixb90XCJdXSk7XG4gIH1cbiAgcmV0dXJuIHN0ci5yZXBsYWNlQWxsKE5vcm1hbGl6ZVJlZ2V4LCAoXywgcDEsIHAyKSA9PiB7XG4gICAgcmV0dXJuIHAxID8gcDEubm9ybWFsaXplKFwiTkZLQ1wiKSA6IE5vcm1hbGl6YXRpb25NYXAuZ2V0KHAyKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRVdWlkKCkge1xuICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY3J5cHRvPy5yYW5kb21VVUlEID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgfVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGlmICh0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjcnlwdG8/LmdldFJhbmRvbVZhbHVlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhidWYpO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgYnVmW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU1KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVzVG9TdHJpbmcoYnVmKTtcbn1cbmNvbnN0IEFubm90YXRpb25QcmVmaXggPSBcInBkZmpzX2ludGVybmFsX2lkX1wiO1xuZXhwb3J0cy5Bbm5vdGF0aW9uUHJlZml4ID0gQW5ub3RhdGlvblByZWZpeDtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlJlbmRlclRhc2sgPSBleHBvcnRzLlBERldvcmtlclV0aWwgPSBleHBvcnRzLlBERldvcmtlciA9IGV4cG9ydHMuUERGUGFnZVByb3h5ID0gZXhwb3J0cy5QREZEb2N1bWVudFByb3h5ID0gZXhwb3J0cy5QREZEb2N1bWVudExvYWRpbmdUYXNrID0gZXhwb3J0cy5QREZEYXRhUmFuZ2VUcmFuc3BvcnQgPSBleHBvcnRzLkxvb3BiYWNrUG9ydCA9IGV4cG9ydHMuRGVmYXVsdFN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gZXhwb3J0cy5EZWZhdWx0RmlsdGVyRmFjdG9yeSA9IGV4cG9ydHMuRGVmYXVsdENhbnZhc0ZhY3RvcnkgPSBleHBvcnRzLkRlZmF1bHRDTWFwUmVhZGVyRmFjdG9yeSA9IHZvaWQgMDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNWR0dyYXBoaWNzXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheVN2Zy5TVkdHcmFwaGljcztcbiAgfVxufSkpO1xuZXhwb3J0cy5idWlsZCA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0RG9jdW1lbnQgPSBnZXREb2N1bWVudDtcbmV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2Fubm90YXRpb25fc3RvcmFnZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMyk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xudmFyIF9mb250X2xvYWRlciA9IF9fd19wZGZqc19yZXF1aXJlX18oOSk7XG52YXIgX2Rpc3BsYXlOb2RlX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxMCk7XG52YXIgX2NhbnZhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpO1xudmFyIF93b3JrZXJfb3B0aW9ucyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xudmFyIF9tZXNzYWdlX2hhbmRsZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE1KTtcbnZhciBfbWV0YWRhdGEgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2KTtcbnZhciBfb3B0aW9uYWxfY29udGVudF9jb25maWcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3KTtcbnZhciBfdHJhbnNwb3J0X3N0cmVhbSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTgpO1xudmFyIF9kaXNwbGF5RmV0Y2hfc3RyZWFtID0gX193X3BkZmpzX3JlcXVpcmVfXygxOSk7XG52YXIgX2Rpc3BsYXlOZXR3b3JrID0gX193X3BkZmpzX3JlcXVpcmVfXygyMik7XG52YXIgX2Rpc3BsYXlOb2RlX3N0cmVhbSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjMpO1xudmFyIF9kaXNwbGF5U3ZnID0gX193X3BkZmpzX3JlcXVpcmVfXygyNCk7XG52YXIgX3hmYV90ZXh0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNSk7XG5jb25zdCBERUZBVUxUX1JBTkdFX0NIVU5LX1NJWkUgPSA2NTUzNjtcbmNvbnN0IFJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVCA9IDEwMDtcbmNvbnN0IERFTEFZRURfQ0xFQU5VUF9USU1FT1VUID0gNTAwMDtcbmNvbnN0IERlZmF1bHRDYW52YXNGYWN0b3J5ID0gX3V0aWwuaXNOb2RlSlMgPyBfZGlzcGxheU5vZGVfdXRpbHMuTm9kZUNhbnZhc0ZhY3RvcnkgOiBfZGlzcGxheV91dGlscy5ET01DYW52YXNGYWN0b3J5O1xuZXhwb3J0cy5EZWZhdWx0Q2FudmFzRmFjdG9yeSA9IERlZmF1bHRDYW52YXNGYWN0b3J5O1xuY29uc3QgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5ID0gX3V0aWwuaXNOb2RlSlMgPyBfZGlzcGxheU5vZGVfdXRpbHMuTm9kZUNNYXBSZWFkZXJGYWN0b3J5IDogX2Rpc3BsYXlfdXRpbHMuRE9NQ01hcFJlYWRlckZhY3Rvcnk7XG5leHBvcnRzLkRlZmF1bHRDTWFwUmVhZGVyRmFjdG9yeSA9IERlZmF1bHRDTWFwUmVhZGVyRmFjdG9yeTtcbmNvbnN0IERlZmF1bHRGaWx0ZXJGYWN0b3J5ID0gX3V0aWwuaXNOb2RlSlMgPyBfZGlzcGxheU5vZGVfdXRpbHMuTm9kZUZpbHRlckZhY3RvcnkgOiBfZGlzcGxheV91dGlscy5ET01GaWx0ZXJGYWN0b3J5O1xuZXhwb3J0cy5EZWZhdWx0RmlsdGVyRmFjdG9yeSA9IERlZmF1bHRGaWx0ZXJGYWN0b3J5O1xuY29uc3QgRGVmYXVsdFN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gX3V0aWwuaXNOb2RlSlMgPyBfZGlzcGxheU5vZGVfdXRpbHMuTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IDogX2Rpc3BsYXlfdXRpbHMuRE9NU3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG5leHBvcnRzLkRlZmF1bHRTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IERlZmF1bHRTdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcbmZ1bmN0aW9uIGdldERvY3VtZW50KHNyYykge1xuICBpZiAodHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIiB8fCBzcmMgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBzcmMgPSB7XG4gICAgICB1cmw6IHNyY1xuICAgIH07XG4gIH0gZWxzZSBpZiAoKDAsIF91dGlsLmlzQXJyYXlCdWZmZXIpKHNyYykpIHtcbiAgICBzcmMgPSB7XG4gICAgICBkYXRhOiBzcmNcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2Ygc3JjICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgaW4gZ2V0RG9jdW1lbnQsIG5lZWQgcGFyYW1ldGVyIG9iamVjdC5cIik7XG4gIH1cbiAgaWYgKCFzcmMudXJsICYmICFzcmMuZGF0YSAmJiAhc3JjLnJhbmdlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgb2JqZWN0OiBuZWVkIGVpdGhlciAuZGF0YSwgLnJhbmdlIG9yIC51cmxcIik7XG4gIH1cbiAgY29uc3QgdGFzayA9IG5ldyBQREZEb2N1bWVudExvYWRpbmdUYXNrKCk7XG4gIGNvbnN0IHtcbiAgICBkb2NJZFxuICB9ID0gdGFzaztcbiAgY29uc3QgdXJsID0gc3JjLnVybCA/IGdldFVybFByb3Aoc3JjLnVybCkgOiBudWxsO1xuICBjb25zdCBkYXRhID0gc3JjLmRhdGEgPyBnZXREYXRhUHJvcChzcmMuZGF0YSkgOiBudWxsO1xuICBjb25zdCBodHRwSGVhZGVycyA9IHNyYy5odHRwSGVhZGVycyB8fCBudWxsO1xuICBjb25zdCB3aXRoQ3JlZGVudGlhbHMgPSBzcmMud2l0aENyZWRlbnRpYWxzID09PSB0cnVlO1xuICBjb25zdCBwYXNzd29yZCA9IHNyYy5wYXNzd29yZCA/PyBudWxsO1xuICBjb25zdCByYW5nZVRyYW5zcG9ydCA9IHNyYy5yYW5nZSBpbnN0YW5jZW9mIFBERkRhdGFSYW5nZVRyYW5zcG9ydCA/IHNyYy5yYW5nZSA6IG51bGw7XG4gIGNvbnN0IHJhbmdlQ2h1bmtTaXplID0gTnVtYmVyLmlzSW50ZWdlcihzcmMucmFuZ2VDaHVua1NpemUpICYmIHNyYy5yYW5nZUNodW5rU2l6ZSA+IDAgPyBzcmMucmFuZ2VDaHVua1NpemUgOiBERUZBVUxUX1JBTkdFX0NIVU5LX1NJWkU7XG4gIGxldCB3b3JrZXIgPSBzcmMud29ya2VyIGluc3RhbmNlb2YgUERGV29ya2VyID8gc3JjLndvcmtlciA6IG51bGw7XG4gIGNvbnN0IHZlcmJvc2l0eSA9IHNyYy52ZXJib3NpdHk7XG4gIGNvbnN0IGRvY0Jhc2VVcmwgPSB0eXBlb2Ygc3JjLmRvY0Jhc2VVcmwgPT09IFwic3RyaW5nXCIgJiYgISgwLCBfZGlzcGxheV91dGlscy5pc0RhdGFTY2hlbWUpKHNyYy5kb2NCYXNlVXJsKSA/IHNyYy5kb2NCYXNlVXJsIDogbnVsbDtcbiAgY29uc3QgY01hcFVybCA9IHR5cGVvZiBzcmMuY01hcFVybCA9PT0gXCJzdHJpbmdcIiA/IHNyYy5jTWFwVXJsIDogbnVsbDtcbiAgY29uc3QgY01hcFBhY2tlZCA9IHNyYy5jTWFwUGFja2VkICE9PSBmYWxzZTtcbiAgY29uc3QgQ01hcFJlYWRlckZhY3RvcnkgPSBzcmMuQ01hcFJlYWRlckZhY3RvcnkgfHwgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5O1xuICBjb25zdCBzdGFuZGFyZEZvbnREYXRhVXJsID0gdHlwZW9mIHNyYy5zdGFuZGFyZEZvbnREYXRhVXJsID09PSBcInN0cmluZ1wiID8gc3JjLnN0YW5kYXJkRm9udERhdGFVcmwgOiBudWxsO1xuICBjb25zdCBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IHNyYy5TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB8fCBEZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG4gIGNvbnN0IGlnbm9yZUVycm9ycyA9IHNyYy5zdG9wQXRFcnJvcnMgIT09IHRydWU7XG4gIGNvbnN0IG1heEltYWdlU2l6ZSA9IE51bWJlci5pc0ludGVnZXIoc3JjLm1heEltYWdlU2l6ZSkgJiYgc3JjLm1heEltYWdlU2l6ZSA+IC0xID8gc3JjLm1heEltYWdlU2l6ZSA6IC0xO1xuICBjb25zdCBpc0V2YWxTdXBwb3J0ZWQgPSBzcmMuaXNFdmFsU3VwcG9ydGVkICE9PSBmYWxzZTtcbiAgY29uc3QgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgPSB0eXBlb2Ygc3JjLmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkID09PSBcImJvb2xlYW5cIiA/IHNyYy5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA6ICFfdXRpbC5pc05vZGVKUztcbiAgY29uc3QgY2FudmFzTWF4QXJlYUluQnl0ZXMgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5jYW52YXNNYXhBcmVhSW5CeXRlcykgPyBzcmMuY2FudmFzTWF4QXJlYUluQnl0ZXMgOiAtMTtcbiAgY29uc3QgZGlzYWJsZUZvbnRGYWNlID0gdHlwZW9mIHNyYy5kaXNhYmxlRm9udEZhY2UgPT09IFwiYm9vbGVhblwiID8gc3JjLmRpc2FibGVGb250RmFjZSA6IF91dGlsLmlzTm9kZUpTO1xuICBjb25zdCBmb250RXh0cmFQcm9wZXJ0aWVzID0gc3JjLmZvbnRFeHRyYVByb3BlcnRpZXMgPT09IHRydWU7XG4gIGNvbnN0IGVuYWJsZVhmYSA9IHNyYy5lbmFibGVYZmEgPT09IHRydWU7XG4gIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBzcmMub3duZXJEb2N1bWVudCB8fCBnbG9iYWxUaGlzLmRvY3VtZW50O1xuICBjb25zdCBkaXNhYmxlUmFuZ2UgPSBzcmMuZGlzYWJsZVJhbmdlID09PSB0cnVlO1xuICBjb25zdCBkaXNhYmxlU3RyZWFtID0gc3JjLmRpc2FibGVTdHJlYW0gPT09IHRydWU7XG4gIGNvbnN0IGRpc2FibGVBdXRvRmV0Y2ggPSBzcmMuZGlzYWJsZUF1dG9GZXRjaCA9PT0gdHJ1ZTtcbiAgY29uc3QgcGRmQnVnID0gc3JjLnBkZkJ1ZyA9PT0gdHJ1ZTtcbiAgY29uc3QgbGVuZ3RoID0gcmFuZ2VUcmFuc3BvcnQgPyByYW5nZVRyYW5zcG9ydC5sZW5ndGggOiBzcmMubGVuZ3RoID8/IE5hTjtcbiAgY29uc3QgdXNlU3lzdGVtRm9udHMgPSB0eXBlb2Ygc3JjLnVzZVN5c3RlbUZvbnRzID09PSBcImJvb2xlYW5cIiA/IHNyYy51c2VTeXN0ZW1Gb250cyA6ICFfdXRpbC5pc05vZGVKUyAmJiAhZGlzYWJsZUZvbnRGYWNlO1xuICBjb25zdCB1c2VXb3JrZXJGZXRjaCA9IHR5cGVvZiBzcmMudXNlV29ya2VyRmV0Y2ggPT09IFwiYm9vbGVhblwiID8gc3JjLnVzZVdvcmtlckZldGNoIDogQ01hcFJlYWRlckZhY3RvcnkgPT09IF9kaXNwbGF5X3V0aWxzLkRPTUNNYXBSZWFkZXJGYWN0b3J5ICYmIFN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID09PSBfZGlzcGxheV91dGlscy5ET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSAmJiBjTWFwVXJsICYmIHN0YW5kYXJkRm9udERhdGFVcmwgJiYgKDAsIF9kaXNwbGF5X3V0aWxzLmlzVmFsaWRGZXRjaFVybCkoY01hcFVybCwgZG9jdW1lbnQuYmFzZVVSSSkgJiYgKDAsIF9kaXNwbGF5X3V0aWxzLmlzVmFsaWRGZXRjaFVybCkoc3RhbmRhcmRGb250RGF0YVVybCwgZG9jdW1lbnQuYmFzZVVSSSk7XG4gIGNvbnN0IGNhbnZhc0ZhY3RvcnkgPSBzcmMuY2FudmFzRmFjdG9yeSB8fCBuZXcgRGVmYXVsdENhbnZhc0ZhY3Rvcnkoe1xuICAgIG93bmVyRG9jdW1lbnRcbiAgfSk7XG4gIGNvbnN0IGZpbHRlckZhY3RvcnkgPSBzcmMuZmlsdGVyRmFjdG9yeSB8fCBuZXcgRGVmYXVsdEZpbHRlckZhY3Rvcnkoe1xuICAgIGRvY0lkLFxuICAgIG93bmVyRG9jdW1lbnRcbiAgfSk7XG4gIGNvbnN0IHN0eWxlRWxlbWVudCA9IG51bGw7XG4gICgwLCBfdXRpbC5zZXRWZXJib3NpdHlMZXZlbCkodmVyYm9zaXR5KTtcbiAgY29uc3QgdHJhbnNwb3J0RmFjdG9yeSA9IHtcbiAgICBjYW52YXNGYWN0b3J5LFxuICAgIGZpbHRlckZhY3RvcnlcbiAgfTtcbiAgaWYgKCF1c2VXb3JrZXJGZXRjaCkge1xuICAgIHRyYW5zcG9ydEZhY3RvcnkuY01hcFJlYWRlckZhY3RvcnkgPSBuZXcgQ01hcFJlYWRlckZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogY01hcFVybCxcbiAgICAgIGlzQ29tcHJlc3NlZDogY01hcFBhY2tlZFxuICAgIH0pO1xuICAgIHRyYW5zcG9ydEZhY3Rvcnkuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBuZXcgU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogc3RhbmRhcmRGb250RGF0YVVybFxuICAgIH0pO1xuICB9XG4gIGlmICghd29ya2VyKSB7XG4gICAgY29uc3Qgd29ya2VyUGFyYW1zID0ge1xuICAgICAgdmVyYm9zaXR5LFxuICAgICAgcG9ydDogX3dvcmtlcl9vcHRpb25zLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydFxuICAgIH07XG4gICAgd29ya2VyID0gd29ya2VyUGFyYW1zLnBvcnQgPyBQREZXb3JrZXIuZnJvbVBvcnQod29ya2VyUGFyYW1zKSA6IG5ldyBQREZXb3JrZXIod29ya2VyUGFyYW1zKTtcbiAgICB0YXNrLl93b3JrZXIgPSB3b3JrZXI7XG4gIH1cbiAgY29uc3QgZmV0Y2hEb2NQYXJhbXMgPSB7XG4gICAgZG9jSWQsXG4gICAgYXBpVmVyc2lvbjogJzMuMTEuMTc0JyxcbiAgICBkYXRhLFxuICAgIHBhc3N3b3JkLFxuICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgcmFuZ2VDaHVua1NpemUsXG4gICAgbGVuZ3RoLFxuICAgIGRvY0Jhc2VVcmwsXG4gICAgZW5hYmxlWGZhLFxuICAgIGV2YWx1YXRvck9wdGlvbnM6IHtcbiAgICAgIG1heEltYWdlU2l6ZSxcbiAgICAgIGRpc2FibGVGb250RmFjZSxcbiAgICAgIGlnbm9yZUVycm9ycyxcbiAgICAgIGlzRXZhbFN1cHBvcnRlZCxcbiAgICAgIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkLFxuICAgICAgY2FudmFzTWF4QXJlYUluQnl0ZXMsXG4gICAgICBmb250RXh0cmFQcm9wZXJ0aWVzLFxuICAgICAgdXNlU3lzdGVtRm9udHMsXG4gICAgICBjTWFwVXJsOiB1c2VXb3JrZXJGZXRjaCA/IGNNYXBVcmwgOiBudWxsLFxuICAgICAgc3RhbmRhcmRGb250RGF0YVVybDogdXNlV29ya2VyRmV0Y2ggPyBzdGFuZGFyZEZvbnREYXRhVXJsIDogbnVsbFxuICAgIH1cbiAgfTtcbiAgY29uc3QgdHJhbnNwb3J0UGFyYW1zID0ge1xuICAgIGlnbm9yZUVycm9ycyxcbiAgICBpc0V2YWxTdXBwb3J0ZWQsXG4gICAgZGlzYWJsZUZvbnRGYWNlLFxuICAgIGZvbnRFeHRyYVByb3BlcnRpZXMsXG4gICAgZW5hYmxlWGZhLFxuICAgIG93bmVyRG9jdW1lbnQsXG4gICAgZGlzYWJsZUF1dG9GZXRjaCxcbiAgICBwZGZCdWcsXG4gICAgc3R5bGVFbGVtZW50XG4gIH07XG4gIHdvcmtlci5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBhYm9ydGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB3b3JrZXJJZFByb21pc2UgPSBfZmV0Y2hEb2N1bWVudCh3b3JrZXIsIGZldGNoRG9jUGFyYW1zKTtcbiAgICBjb25zdCBuZXR3b3JrU3RyZWFtUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBsZXQgbmV0d29ya1N0cmVhbTtcbiAgICAgIGlmIChyYW5nZVRyYW5zcG9ydCkge1xuICAgICAgICBuZXR3b3JrU3RyZWFtID0gbmV3IF90cmFuc3BvcnRfc3RyZWFtLlBERkRhdGFUcmFuc3BvcnRTdHJlYW0oe1xuICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICBpbml0aWFsRGF0YTogcmFuZ2VUcmFuc3BvcnQuaW5pdGlhbERhdGEsXG4gICAgICAgICAgcHJvZ3Jlc3NpdmVEb25lOiByYW5nZVRyYW5zcG9ydC5wcm9ncmVzc2l2ZURvbmUsXG4gICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU6IHJhbmdlVHJhbnNwb3J0LmNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lLFxuICAgICAgICAgIGRpc2FibGVSYW5nZSxcbiAgICAgICAgICBkaXNhYmxlU3RyZWFtXG4gICAgICAgIH0sIHJhbmdlVHJhbnNwb3J0KTtcbiAgICAgIH0gZWxzZSBpZiAoIWRhdGEpIHtcbiAgICAgICAgY29uc3QgY3JlYXRlUERGTmV0d29ya1N0cmVhbSA9IHBhcmFtcyA9PiB7XG4gICAgICAgICAgaWYgKF91dGlsLmlzTm9kZUpTKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IF9kaXNwbGF5Tm9kZV9zdHJlYW0uUERGTm9kZVN0cmVhbShwYXJhbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKDAsIF9kaXNwbGF5X3V0aWxzLmlzVmFsaWRGZXRjaFVybCkocGFyYW1zLnVybCkgPyBuZXcgX2Rpc3BsYXlGZXRjaF9zdHJlYW0uUERGRmV0Y2hTdHJlYW0ocGFyYW1zKSA6IG5ldyBfZGlzcGxheU5ldHdvcmsuUERGTmV0d29ya1N0cmVhbShwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICBuZXR3b3JrU3RyZWFtID0gY3JlYXRlUERGTmV0d29ya1N0cmVhbSh7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICBodHRwSGVhZGVycyxcbiAgICAgICAgICB3aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgICAgcmFuZ2VDaHVua1NpemUsXG4gICAgICAgICAgZGlzYWJsZVJhbmdlLFxuICAgICAgICAgIGRpc2FibGVTdHJlYW1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXNvbHZlKG5ldHdvcmtTdHJlYW0pO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbd29ya2VySWRQcm9taXNlLCBuZXR3b3JrU3RyZWFtUHJvbWlzZV0pLnRoZW4oZnVuY3Rpb24gKFt3b3JrZXJJZCwgbmV0d29ya1N0cmVhbV0pIHtcbiAgICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2FkaW5nIGFib3J0ZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IG5ldyBfbWVzc2FnZV9oYW5kbGVyLk1lc3NhZ2VIYW5kbGVyKGRvY0lkLCB3b3JrZXJJZCwgd29ya2VyLnBvcnQpO1xuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFdvcmtlclRyYW5zcG9ydChtZXNzYWdlSGFuZGxlciwgdGFzaywgbmV0d29ya1N0cmVhbSwgdHJhbnNwb3J0UGFyYW1zLCB0cmFuc3BvcnRGYWN0b3J5KTtcbiAgICAgIHRhc2suX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJSZWFkeVwiLCBudWxsKTtcbiAgICB9KTtcbiAgfSkuY2F0Y2godGFzay5fY2FwYWJpbGl0eS5yZWplY3QpO1xuICByZXR1cm4gdGFzaztcbn1cbmFzeW5jIGZ1bmN0aW9uIF9mZXRjaERvY3VtZW50KHdvcmtlciwgc291cmNlKSB7XG4gIGlmICh3b3JrZXIuZGVzdHJveWVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIik7XG4gIH1cbiAgY29uc3Qgd29ya2VySWQgPSBhd2FpdCB3b3JrZXIubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RG9jUmVxdWVzdFwiLCBzb3VyY2UsIHNvdXJjZS5kYXRhID8gW3NvdXJjZS5kYXRhLmJ1ZmZlcl0gOiBudWxsKTtcbiAgaWYgKHdvcmtlci5kZXN0cm95ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKTtcbiAgfVxuICByZXR1cm4gd29ya2VySWQ7XG59XG5mdW5jdGlvbiBnZXRVcmxQcm9wKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgcmV0dXJuIHZhbC5ocmVmO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBVUkwodmFsLCB3aW5kb3cubG9jYXRpb24pLmhyZWY7XG4gIH0gY2F0Y2gge1xuICAgIGlmIChfdXRpbC5pc05vZGVKUyAmJiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBERiB1cmwgZGF0YTogXCIgKyBcImVpdGhlciBzdHJpbmcgb3IgVVJMLW9iamVjdCBpcyBleHBlY3RlZCBpbiB0aGUgdXJsIHByb3BlcnR5LlwiKTtcbn1cbmZ1bmN0aW9uIGdldERhdGFQcm9wKHZhbCkge1xuICBpZiAoX3V0aWwuaXNOb2RlSlMgJiYgdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWwgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBiaW5hcnkgZGF0YSBhcyBgVWludDhBcnJheWAsIHJhdGhlciB0aGFuIGBCdWZmZXJgLlwiKTtcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB2YWwuYnl0ZUxlbmd0aCA9PT0gdmFsLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc3RyaW5nVG9CeXRlcykodmFsKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiAhaXNOYU4odmFsPy5sZW5ndGgpIHx8ICgwLCBfdXRpbC5pc0FycmF5QnVmZmVyKSh2YWwpKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQREYgYmluYXJ5IGRhdGE6IGVpdGhlciBUeXBlZEFycmF5LCBcIiArIFwic3RyaW5nLCBvciBhcnJheS1saWtlIG9iamVjdCBpcyBleHBlY3RlZCBpbiB0aGUgZGF0YSBwcm9wZXJ0eS5cIik7XG59XG5jbGFzcyBQREZEb2N1bWVudExvYWRpbmdUYXNrIHtcbiAgc3RhdGljICNkb2NJZCA9IDA7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2NhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgdGhpcy5kb2NJZCA9IGBkJHtQREZEb2N1bWVudExvYWRpbmdUYXNrLiNkb2NJZCsrfWA7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9uUGFzc3dvcmQgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBhc3luYyBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuX3dvcmtlcj8ucG9ydCkge1xuICAgICAgICB0aGlzLl93b3JrZXIuX3BlbmRpbmdEZXN0cm95ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydD8uZGVzdHJveSgpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAodGhpcy5fd29ya2VyPy5wb3J0KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl93b3JrZXIuX3BlbmRpbmdEZXN0cm95O1xuICAgICAgfVxuICAgICAgdGhyb3cgZXg7XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3dvcmtlcikge1xuICAgICAgdGhpcy5fd29ya2VyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLlBERkRvY3VtZW50TG9hZGluZ1Rhc2sgPSBQREZEb2N1bWVudExvYWRpbmdUYXNrO1xuY2xhc3MgUERGRGF0YVJhbmdlVHJhbnNwb3J0IHtcbiAgY29uc3RydWN0b3IobGVuZ3RoLCBpbml0aWFsRGF0YSwgcHJvZ3Jlc3NpdmVEb25lID0gZmFsc2UsIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gbnVsbCkge1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuaW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICB0aGlzLnByb2dyZXNzaXZlRG9uZSA9IHByb2dyZXNzaXZlRG9uZTtcbiAgICB0aGlzLmNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU7XG4gICAgdGhpcy5fcmFuZ2VMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc0xpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICB9XG4gIGFkZFJhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9yYW5nZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBhZGRQcm9ncmVzc0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgYWRkUHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgb25EYXRhUmFuZ2UoYmVnaW4sIGNodW5rKSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9yYW5nZUxpc3RlbmVycykge1xuICAgICAgbGlzdGVuZXIoYmVnaW4sIGNodW5rKTtcbiAgICB9XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3MobG9hZGVkLCB0b3RhbCkge1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9wcm9ncmVzc0xpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihsb2FkZWQsIHRvdGFsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBvbkRhdGFQcm9ncmVzc2l2ZVJlYWQoY2h1bmspIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBvbkRhdGFQcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHRyYW5zcG9ydFJlYWR5KCkge1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgcmVxdWVzdERhdGFSYW5nZShiZWdpbiwgZW5kKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBQREZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZVwiKTtcbiAgfVxuICBhYm9ydCgpIHt9XG59XG5leHBvcnRzLlBERkRhdGFSYW5nZVRyYW5zcG9ydCA9IFBERkRhdGFSYW5nZVRyYW5zcG9ydDtcbmNsYXNzIFBERkRvY3VtZW50UHJveHkge1xuICBjb25zdHJ1Y3RvcihwZGZJbmZvLCB0cmFuc3BvcnQpIHtcbiAgICB0aGlzLl9wZGZJbmZvID0gcGRmSW5mbztcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0SmF2YVNjcmlwdFwiLCB7XG4gICAgICB2YWx1ZTogKCkgPT4ge1xuICAgICAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZGVwcmVjYXRlZCkoXCJgUERGRG9jdW1lbnRQcm94eS5nZXRKYXZhU2NyaXB0YCwgXCIgKyBcInBsZWFzZSB1c2UgYFBERkRvY3VtZW50UHJveHkuZ2V0SlNBY3Rpb25zYCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SlNBY3Rpb25zKCkudGhlbihqcyA9PiB7XG4gICAgICAgICAgaWYgKCFqcykge1xuICAgICAgICAgICAgcmV0dXJuIGpzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBqc0FyciA9IFtdO1xuICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBqcykge1xuICAgICAgICAgICAganNBcnIucHVzaCguLi5qc1tuYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBqc0FycjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGFubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuYW5ub3RhdGlvblN0b3JhZ2U7XG4gIH1cbiAgZ2V0IGZpbHRlckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5O1xuICB9XG4gIGdldCBudW1QYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGRmSW5mby5udW1QYWdlcztcbiAgfVxuICBnZXQgZmluZ2VycHJpbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wZGZJbmZvLmZpbmdlcnByaW50cztcbiAgfVxuICBnZXQgaXNQdXJlWGZhKCkge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImlzUHVyZVhmYVwiLCAhIXRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSk7XG4gIH1cbiAgZ2V0IGFsbFhmYUh0bWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYTtcbiAgfVxuICBnZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2UocGFnZU51bWJlcik7XG4gIH1cbiAgZ2V0UGFnZUluZGV4KHJlZikge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUluZGV4KHJlZik7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGVzdGluYXRpb25zKCk7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERlc3RpbmF0aW9uKGlkKTtcbiAgfVxuICBnZXRQYWdlTGFiZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUxhYmVscygpO1xuICB9XG4gIGdldFBhZ2VMYXlvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTGF5b3V0KCk7XG4gIH1cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTW9kZSgpO1xuICB9XG4gIGdldFZpZXdlclByZWZlcmVuY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKTtcbiAgfVxuICBnZXRPcGVuQWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3BlbkFjdGlvbigpO1xuICB9XG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0QXR0YWNobWVudHMoKTtcbiAgfVxuICBnZXRKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREb2NKU0FjdGlvbnMoKTtcbiAgfVxuICBnZXRPdXRsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3V0bGluZSgpO1xuICB9XG4gIGdldE9wdGlvbmFsQ29udGVudENvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE9wdGlvbmFsQ29udGVudENvbmZpZygpO1xuICB9XG4gIGdldFBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGVybWlzc2lvbnMoKTtcbiAgfVxuICBnZXRNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE1ldGFkYXRhKCk7XG4gIH1cbiAgZ2V0TWFya0luZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRNYXJrSW5mbygpO1xuICB9XG4gIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREYXRhKCk7XG4gIH1cbiAgc2F2ZURvY3VtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc2F2ZURvY3VtZW50KCk7XG4gIH1cbiAgZ2V0RG93bmxvYWRJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNsZWFudXAoa2VlcExvYWRlZEZvbnRzID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LnN0YXJ0Q2xlYW51cChrZWVwTG9hZGVkRm9udHMgfHwgdGhpcy5pc1B1cmVYZmEpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGluZ1Rhc2suZGVzdHJveSgpO1xuICB9XG4gIGdldCBsb2FkaW5nUGFyYW1zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubG9hZGluZ1BhcmFtcztcbiAgfVxuICBnZXQgbG9hZGluZ1Rhc2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5sb2FkaW5nVGFzaztcbiAgfVxuICBnZXRGaWVsZE9iamVjdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRGaWVsZE9iamVjdHMoKTtcbiAgfVxuICBoYXNKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5oYXNKU0FjdGlvbnMoKTtcbiAgfVxuICBnZXRDYWxjdWxhdGlvbk9yZGVySWRzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0Q2FsY3VsYXRpb25PcmRlcklkcygpO1xuICB9XG59XG5leHBvcnRzLlBERkRvY3VtZW50UHJveHkgPSBQREZEb2N1bWVudFByb3h5O1xuY2xhc3MgUERGUGFnZVByb3h5IHtcbiAgI2RlbGF5ZWRDbGVhbnVwVGltZW91dCA9IG51bGw7XG4gICNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICBjb25zdHJ1Y3RvcihwYWdlSW5kZXgsIHBhZ2VJbmZvLCB0cmFuc3BvcnQsIHBkZkJ1ZyA9IGZhbHNlKSB7XG4gICAgdGhpcy5fcGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuX3BhZ2VJbmZvID0gcGFnZUluZm87XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuX3N0YXRzID0gcGRmQnVnID8gbmV3IF9kaXNwbGF5X3V0aWxzLlN0YXRUaW1lcigpIDogbnVsbDtcbiAgICB0aGlzLl9wZGZCdWcgPSBwZGZCdWc7XG4gICAgdGhpcy5jb21tb25PYmpzID0gdHJhbnNwb3J0LmNvbW1vbk9ianM7XG4gICAgdGhpcy5vYmpzID0gbmV3IFBERk9iamVjdHMoKTtcbiAgICB0aGlzLl9tYXliZUNsZWFudXBBZnRlclJlbmRlciA9IGZhbHNlO1xuICAgIHRoaXMuX2ludGVudFN0YXRlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICB9XG4gIGdldCBwYWdlTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5kZXggKyAxO1xuICB9XG4gIGdldCByb3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnJvdGF0ZTtcbiAgfVxuICBnZXQgcmVmKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yZWY7XG4gIH1cbiAgZ2V0IHVzZXJVbml0KCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby51c2VyVW5pdDtcbiAgfVxuICBnZXQgdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8udmlldztcbiAgfVxuICBnZXRWaWV3cG9ydCh7XG4gICAgc2NhbGUsXG4gICAgcm90YXRpb24gPSB0aGlzLnJvdGF0ZSxcbiAgICBvZmZzZXRYID0gMCxcbiAgICBvZmZzZXRZID0gMCxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBuZXcgX2Rpc3BsYXlfdXRpbHMuUGFnZVZpZXdwb3J0KHtcbiAgICAgIHZpZXdCb3g6IHRoaXMudmlldyxcbiAgICAgIHNjYWxlLFxuICAgICAgcm90YXRpb24sXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIGRvbnRGbGlwXG4gICAgfSk7XG4gIH1cbiAgZ2V0QW5ub3RhdGlvbnMoe1xuICAgIGludGVudCA9IFwiZGlzcGxheVwiXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IGludGVudEFyZ3MgPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRBbm5vdGF0aW9ucyh0aGlzLl9wYWdlSW5kZXgsIGludGVudEFyZ3MucmVuZGVyaW5nSW50ZW50KTtcbiAgfVxuICBnZXRKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSlNBY3Rpb25zKHRoaXMuX3BhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0IGZpbHRlckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5O1xuICB9XG4gIGdldCBpc1B1cmVYZmEoKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaXNQdXJlWGZhXCIsICEhdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKTtcbiAgfVxuICBhc3luYyBnZXRYZmEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYT8uY2hpbGRyZW5bdGhpcy5fcGFnZUluZGV4XSB8fCBudWxsO1xuICB9XG4gIHJlbmRlcih7XG4gICAgY2FudmFzQ29udGV4dCxcbiAgICB2aWV3cG9ydCxcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIixcbiAgICBhbm5vdGF0aW9uTW9kZSA9IF91dGlsLkFubm90YXRpb25Nb2RlLkVOQUJMRSxcbiAgICB0cmFuc2Zvcm0gPSBudWxsLFxuICAgIGJhY2tncm91bmQgPSBudWxsLFxuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgPSBudWxsLFxuICAgIGFubm90YXRpb25DYW52YXNNYXAgPSBudWxsLFxuICAgIHBhZ2VDb2xvcnMgPSBudWxsLFxuICAgIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLl9zdGF0cz8udGltZShcIk92ZXJhbGxcIik7XG4gICAgY29uc3QgaW50ZW50QXJncyA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSk7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgICB0aGlzLiNhYm9ydERlbGF5ZWRDbGVhbnVwKCk7XG4gICAgaWYgKCFvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlKSB7XG4gICAgICBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlID0gdGhpcy5fdHJhbnNwb3J0LmdldE9wdGlvbmFsQ29udGVudENvbmZpZygpO1xuICAgIH1cbiAgICBsZXQgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGludGVudEFyZ3MuY2FjaGVLZXkpO1xuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIGludGVudFN0YXRlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuX2ludGVudFN0YXRlcy5zZXQoaW50ZW50QXJncy5jYWNoZUtleSwgaW50ZW50U3RhdGUpO1xuICAgIH1cbiAgICBpZiAoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpO1xuICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGludGVudFByaW50ID0gISEoaW50ZW50QXJncy5yZW5kZXJpbmdJbnRlbnQgJiBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UKTtcbiAgICBpZiAoIWludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkpIHtcbiAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCA9IHtcbiAgICAgICAgZm5BcnJheTogW10sXG4gICAgICAgIGFyZ3NBcnJheTogW10sXG4gICAgICAgIGxhc3RDaHVuazogZmFsc2UsXG4gICAgICAgIHNlcGFyYXRlQW5ub3RzOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgICB0aGlzLl9wdW1wT3BlcmF0b3JMaXN0KGludGVudEFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBjb21wbGV0ZSA9IGVycm9yID0+IHtcbiAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzLmRlbGV0ZShpbnRlcm5hbFJlbmRlclRhc2spO1xuICAgICAgaWYgKHRoaXMuX21heWJlQ2xlYW51cEFmdGVyUmVuZGVyIHx8IGludGVudFByaW50KSB7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3RyeUNsZWFudXAoIWludGVudFByaW50KTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgICAgcmVhc29uOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoZXJyb3IpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RhdHM/LnRpbWVFbmQoXCJSZW5kZXJpbmdcIik7XG4gICAgICB0aGlzLl9zdGF0cz8udGltZUVuZChcIk92ZXJhbGxcIik7XG4gICAgfTtcbiAgICBjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgPSBuZXcgSW50ZXJuYWxSZW5kZXJUYXNrKHtcbiAgICAgIGNhbGxiYWNrOiBjb21wbGV0ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBjYW52YXNDb250ZXh0LFxuICAgICAgICB2aWV3cG9ydCxcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICBiYWNrZ3JvdW5kXG4gICAgICB9LFxuICAgICAgb2JqczogdGhpcy5vYmpzLFxuICAgICAgY29tbW9uT2JqczogdGhpcy5jb21tb25PYmpzLFxuICAgICAgYW5ub3RhdGlvbkNhbnZhc01hcCxcbiAgICAgIG9wZXJhdG9yTGlzdDogaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LFxuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBjYW52YXNGYWN0b3J5OiB0aGlzLl90cmFuc3BvcnQuY2FudmFzRmFjdG9yeSxcbiAgICAgIGZpbHRlckZhY3Rvcnk6IHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5LFxuICAgICAgdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lOiAhaW50ZW50UHJpbnQsXG4gICAgICBwZGZCdWc6IHRoaXMuX3BkZkJ1ZyxcbiAgICAgIHBhZ2VDb2xvcnNcbiAgICB9KTtcbiAgICAoaW50ZW50U3RhdGUucmVuZGVyVGFza3MgfHw9IG5ldyBTZXQoKSkuYWRkKGludGVybmFsUmVuZGVyVGFzayk7XG4gICAgY29uc3QgcmVuZGVyVGFzayA9IGludGVybmFsUmVuZGVyVGFzay50YXNrO1xuICAgIFByb21pc2UuYWxsKFtpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5LnByb21pc2UsIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2VdKS50aGVuKChbdHJhbnNwYXJlbmN5LCBvcHRpb25hbENvbnRlbnRDb25maWddKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJSZW5kZXJpbmdcIik7XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2suaW5pdGlhbGl6ZUdyYXBoaWNzKHtcbiAgICAgICAgdHJhbnNwYXJlbmN5LFxuICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgICAgIH0pO1xuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICB9KS5jYXRjaChjb21wbGV0ZSk7XG4gICAgcmV0dXJuIHJlbmRlclRhc2s7XG4gIH1cbiAgZ2V0T3BlcmF0b3JMaXN0KHtcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIixcbiAgICBhbm5vdGF0aW9uTW9kZSA9IF91dGlsLkFubm90YXRpb25Nb2RlLkVOQUJMRSxcbiAgICBwcmludEFubm90YXRpb25TdG9yYWdlID0gbnVsbFxuICB9ID0ge30pIHtcbiAgICBmdW5jdGlvbiBvcGVyYXRvckxpc3RDaGFuZ2VkKCkge1xuICAgICAgaWYgKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucmVzb2x2ZShpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QpO1xuICAgICAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5kZWxldGUob3BMaXN0VGFzayk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGludGVudEFyZ3MgPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCwgYW5ub3RhdGlvbk1vZGUsIHByaW50QW5ub3RhdGlvblN0b3JhZ2UsIHRydWUpO1xuICAgIGxldCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoaW50ZW50QXJncy5jYWNoZUtleSk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgaW50ZW50U3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5faW50ZW50U3RhdGVzLnNldChpbnRlbnRBcmdzLmNhY2hlS2V5LCBpbnRlbnRTdGF0ZSk7XG4gICAgfVxuICAgIGxldCBvcExpc3RUYXNrO1xuICAgIGlmICghaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgIG9wTGlzdFRhc2sgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgb3BMaXN0VGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkID0gb3BlcmF0b3JMaXN0Q2hhbmdlZDtcbiAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgICAoaW50ZW50U3RhdGUucmVuZGVyVGFza3MgfHw9IG5ldyBTZXQoKSkuYWRkKG9wTGlzdFRhc2spO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0ID0ge1xuICAgICAgICBmbkFycmF5OiBbXSxcbiAgICAgICAgYXJnc0FycmF5OiBbXSxcbiAgICAgICAgbGFzdENodW5rOiBmYWxzZSxcbiAgICAgICAgc2VwYXJhdGVBbm5vdHM6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICAgIHRoaXMuX3B1bXBPcGVyYXRvckxpc3QoaW50ZW50QXJncyk7XG4gICAgfVxuICAgIHJldHVybiBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHN0cmVhbVRleHRDb250ZW50KHtcbiAgICBpbmNsdWRlTWFya2VkQ29udGVudCA9IGZhbHNlLFxuICAgIGRpc2FibGVOb3JtYWxpemF0aW9uID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgVEVYVF9DT05URU5UX0NIVU5LX1NJWkUgPSAxMDA7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFN0cmVhbShcIkdldFRleHRDb250ZW50XCIsIHtcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgaW5jbHVkZU1hcmtlZENvbnRlbnQ6IGluY2x1ZGVNYXJrZWRDb250ZW50ID09PSB0cnVlLFxuICAgICAgZGlzYWJsZU5vcm1hbGl6YXRpb246IGRpc2FibGVOb3JtYWxpemF0aW9uID09PSB0cnVlXG4gICAgfSwge1xuICAgICAgaGlnaFdhdGVyTWFyazogVEVYVF9DT05URU5UX0NIVU5LX1NJWkUsXG4gICAgICBzaXplKHRleHRDb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0ZXh0Q29udGVudC5pdGVtcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0VGV4dENvbnRlbnQocGFyYW1zID0ge30pIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRYZmEoKS50aGVuKHhmYSA9PiB7XG4gICAgICAgIHJldHVybiBfeGZhX3RleHQuWGZhVGV4dC50ZXh0Q29udGVudCh4ZmEpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRhYmxlU3RyZWFtID0gdGhpcy5zdHJlYW1UZXh0Q29udGVudChwYXJhbXMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBwdW1wKCkge1xuICAgICAgICByZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIE9iamVjdC5hc3NpZ24odGV4dENvbnRlbnQuc3R5bGVzLCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgICAgIHRleHRDb250ZW50Lml0ZW1zLnB1c2goLi4udmFsdWUuaXRlbXMpO1xuICAgICAgICAgIHB1bXAoKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSB7XG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgc3R5bGVzOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICB9O1xuICAgICAgcHVtcCgpO1xuICAgIH0pO1xuICB9XG4gIGdldFN0cnVjdFRyZWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRTdHJ1Y3RUcmVlKHRoaXMuX3BhZ2VJbmRleCk7XG4gIH1cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIGNvbnN0IHdhaXRPbiA9IFtdO1xuICAgIGZvciAoY29uc3QgaW50ZW50U3RhdGUgb2YgdGhpcy5faW50ZW50U3RhdGVzLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICByZWFzb246IG5ldyBFcnJvcihcIlBhZ2Ugd2FzIGRlc3Ryb3llZC5cIiksXG4gICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICAgIHdhaXRPbi5wdXNoKGludGVybmFsUmVuZGVyVGFzay5jb21wbGV0ZWQpO1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgdGhpcy4jYWJvcnREZWxheWVkQ2xlYW51cCgpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh3YWl0T24pO1xuICB9XG4gIGNsZWFudXAocmVzZXRTdGF0cyA9IGZhbHNlKSB7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSB0cnVlO1xuICAgIGNvbnN0IHN1Y2Nlc3MgPSB0aGlzLiN0cnlDbGVhbnVwKGZhbHNlKTtcbiAgICBpZiAocmVzZXRTdGF0cyAmJiBzdWNjZXNzKSB7XG4gICAgICB0aGlzLl9zdGF0cyAmJj0gbmV3IF9kaXNwbGF5X3V0aWxzLlN0YXRUaW1lcigpO1xuICAgIH1cbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuICAjdHJ5Q2xlYW51cChkZWxheWVkID0gZmFsc2UpIHtcbiAgICB0aGlzLiNhYm9ydERlbGF5ZWRDbGVhbnVwKCk7XG4gICAgaWYgKCF0aGlzLiNwZW5kaW5nQ2xlYW51cCB8fCB0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGVsYXllZCkge1xuICAgICAgdGhpcy4jZGVsYXllZENsZWFudXBUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuI3RyeUNsZWFudXAoZmFsc2UpO1xuICAgICAgfSwgREVMQVlFRF9DTEVBTlVQX1RJTUVPVVQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHJlbmRlclRhc2tzLFxuICAgICAgb3BlcmF0b3JMaXN0XG4gICAgfSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChyZW5kZXJUYXNrcy5zaXplID4gMCB8fCAhb3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2ludGVudFN0YXRlcy5jbGVhcigpO1xuICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgI2Fib3J0RGVsYXllZENsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCk7XG4gICAgICB0aGlzLiNkZWxheWVkQ2xlYW51cFRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBfc3RhcnRSZW5kZXJQYWdlKHRyYW5zcGFyZW5jeSwgY2FjaGVLZXkpIHtcbiAgICBjb25zdCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc3RhdHM/LnRpbWVFbmQoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eT8ucmVzb2x2ZSh0cmFuc3BhcmVuY3kpO1xuICB9XG4gIF9yZW5kZXJQYWdlQ2h1bmsob3BlcmF0b3JMaXN0Q2h1bmssIGludGVudFN0YXRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gb3BlcmF0b3JMaXN0Q2h1bmsubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LmZuQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5mbkFycmF5W2ldKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5hcmdzQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5hcmdzQXJyYXlbaV0pO1xuICAgIH1cbiAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rID0gb3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rO1xuICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5zZXBhcmF0ZUFubm90cyA9IG9wZXJhdG9yTGlzdENodW5rLnNlcGFyYXRlQW5ub3RzO1xuICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgIH1cbiAgICBpZiAob3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rKSB7XG4gICAgICB0aGlzLiN0cnlDbGVhbnVwKHRydWUpO1xuICAgIH1cbiAgfVxuICBfcHVtcE9wZXJhdG9yTGlzdCh7XG4gICAgcmVuZGVyaW5nSW50ZW50LFxuICAgIGNhY2hlS2V5LFxuICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICB0cmFuc2ZlcnNcbiAgICB9ID0gYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGU7XG4gICAgY29uc3QgcmVhZGFibGVTdHJlYW0gPSB0aGlzLl90cmFuc3BvcnQubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhTdHJlYW0oXCJHZXRPcGVyYXRvckxpc3RcIiwge1xuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBpbnRlbnQ6IHJlbmRlcmluZ0ludGVudCxcbiAgICAgIGNhY2hlS2V5LFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IG1hcFxuICAgIH0sIHRyYW5zZmVycyk7XG4gICAgY29uc3QgcmVhZGVyID0gcmVhZGFibGVTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSByZWFkZXI7XG4gICAgY29uc3QgcHVtcCA9ICgpID0+IHtcbiAgICAgIHJlYWRlci5yZWFkKCkudGhlbigoe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlclBhZ2VDaHVuayh2YWx1ZSwgaW50ZW50U3RhdGUpO1xuICAgICAgICBwdW1wKCk7XG4gICAgICB9LCByZWFzb24gPT4ge1xuICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuayA9IHRydWU7XG4gICAgICAgICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgICAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuI3RyeUNsZWFudXAodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHB1bXAoKTtcbiAgfVxuICBfYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgIGludGVudFN0YXRlLFxuICAgIHJlYXNvbixcbiAgICBmb3JjZSA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAoIWludGVudFN0YXRlLnN0cmVhbVJlYWRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpO1xuICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5zaXplID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVhc29uIGluc3RhbmNlb2YgX2Rpc3BsYXlfdXRpbHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKSB7XG4gICAgICAgIGxldCBkZWxheSA9IFJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVDtcbiAgICAgICAgaWYgKHJlYXNvbi5leHRyYURlbGF5ID4gMCAmJiByZWFzb24uZXh0cmFEZWxheSA8IDEwMDApIHtcbiAgICAgICAgICBkZWxheSArPSByZWFzb24uZXh0cmFEZWxheTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyLmNhbmNlbChuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UpKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtjdXJDYWNoZUtleSwgY3VySW50ZW50U3RhdGVdIG9mIHRoaXMuX2ludGVudFN0YXRlcykge1xuICAgICAgaWYgKGN1ckludGVudFN0YXRlID09PSBpbnRlbnRTdGF0ZSkge1xuICAgICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuZGVsZXRlKGN1ckNhY2hlS2V5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIGdldCBzdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHM7XG4gIH1cbn1cbmV4cG9ydHMuUERGUGFnZVByb3h5ID0gUERGUGFnZVByb3h5O1xuY2xhc3MgTG9vcGJhY2tQb3J0IHtcbiAgI2xpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgI2RlZmVycmVkID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHBvc3RNZXNzYWdlKG9iaiwgdHJhbnNmZXIpIHtcbiAgICBjb25zdCBldmVudCA9IHtcbiAgICAgIGRhdGE6IHN0cnVjdHVyZWRDbG9uZShvYmosIHRyYW5zZmVyID8ge1xuICAgICAgICB0cmFuc2ZlclxuICAgICAgfSA6IG51bGwpXG4gICAgfTtcbiAgICB0aGlzLiNkZWZlcnJlZC50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4jbGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLiNsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy4jbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH1cbiAgdGVybWluYXRlKCkge1xuICAgIHRoaXMuI2xpc3RlbmVycy5jbGVhcigpO1xuICB9XG59XG5leHBvcnRzLkxvb3BiYWNrUG9ydCA9IExvb3BiYWNrUG9ydDtcbmNvbnN0IFBERldvcmtlclV0aWwgPSB7XG4gIGlzV29ya2VyRGlzYWJsZWQ6IGZhbHNlLFxuICBmYWxsYmFja1dvcmtlclNyYzogbnVsbCxcbiAgZmFrZVdvcmtlcklkOiAwXG59O1xuZXhwb3J0cy5QREZXb3JrZXJVdGlsID0gUERGV29ya2VyVXRpbDtcbntcbiAgaWYgKF91dGlsLmlzTm9kZUpTICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBQREZXb3JrZXJVdGlsLmlzV29ya2VyRGlzYWJsZWQgPSB0cnVlO1xuICAgIFBERldvcmtlclV0aWwuZmFsbGJhY2tXb3JrZXJTcmMgPSBcIi4vcGRmLndvcmtlci5qc1wiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnN0IHBkZmpzRmlsZVBhdGggPSBkb2N1bWVudD8uY3VycmVudFNjcmlwdD8uc3JjO1xuICAgIGlmIChwZGZqc0ZpbGVQYXRoKSB7XG4gICAgICBQREZXb3JrZXJVdGlsLmZhbGxiYWNrV29ya2VyU3JjID0gcGRmanNGaWxlUGF0aC5yZXBsYWNlKC8oXFwuKD86bWluXFwuKT9qcykoXFw/LiopPyQvaSwgXCIud29ya2VyJDEkMlwiKTtcbiAgICB9XG4gIH1cbiAgUERGV29ya2VyVXRpbC5pc1NhbWVPcmlnaW4gPSBmdW5jdGlvbiAoYmFzZVVybCwgb3RoZXJVcmwpIHtcbiAgICBsZXQgYmFzZTtcbiAgICB0cnkge1xuICAgICAgYmFzZSA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgICBpZiAoIWJhc2Uub3JpZ2luIHx8IGJhc2Uub3JpZ2luID09PSBcIm51bGxcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG90aGVyID0gbmV3IFVSTChvdGhlclVybCwgYmFzZSk7XG4gICAgcmV0dXJuIGJhc2Uub3JpZ2luID09PSBvdGhlci5vcmlnaW47XG4gIH07XG4gIFBERldvcmtlclV0aWwuY3JlYXRlQ0ROV3JhcHBlciA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBjb25zdCB3cmFwcGVyID0gYGltcG9ydFNjcmlwdHMoXCIke3VybH1cIik7YDtcbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbd3JhcHBlcl0pKTtcbiAgfTtcbn1cbmNsYXNzIFBERldvcmtlciB7XG4gIHN0YXRpYyAjd29ya2VyUG9ydHM7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBuYW1lID0gbnVsbCxcbiAgICBwb3J0ID0gbnVsbCxcbiAgICB2ZXJib3NpdHkgPSAoMCwgX3V0aWwuZ2V0VmVyYm9zaXR5TGV2ZWwpKClcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMudmVyYm9zaXR5ID0gdmVyYm9zaXR5O1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX3dlYldvcmtlciA9IG51bGw7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAgIGlmIChwb3J0KSB7XG4gICAgICBpZiAoUERGV29ya2VyLiN3b3JrZXJQb3J0cz8uaGFzKHBvcnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgbW9yZSB0aGFuIG9uZSBQREZXb3JrZXIgcGVyIHBvcnQuXCIpO1xuICAgICAgfVxuICAgICAgKFBERldvcmtlci4jd29ya2VyUG9ydHMgfHw9IG5ldyBXZWFrTWFwKCkpLnNldChwb3J0LCB0aGlzKTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVGcm9tUG9ydChwb3J0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICB9XG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBnZXQgcG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9ydDtcbiAgfVxuICBnZXQgbWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VIYW5kbGVyO1xuICB9XG4gIF9pbml0aWFsaXplRnJvbVBvcnQocG9ydCkge1xuICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbmV3IF9tZXNzYWdlX2hhbmRsZXIuTWVzc2FnZUhhbmRsZXIoXCJtYWluXCIsIFwid29ya2VyXCIsIHBvcnQpO1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyLm9uKFwicmVhZHlcIiwgZnVuY3Rpb24gKCkge30pO1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIuc2VuZChcImNvbmZpZ3VyZVwiLCB7XG4gICAgICB2ZXJib3NpdHk6IHRoaXMudmVyYm9zaXR5XG4gICAgfSk7XG4gIH1cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgaWYgKCFQREZXb3JrZXJVdGlsLmlzV29ya2VyRGlzYWJsZWQgJiYgIVBERldvcmtlci5fbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICBsZXQge1xuICAgICAgICB3b3JrZXJTcmNcbiAgICAgIH0gPSBQREZXb3JrZXI7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIVBERldvcmtlclV0aWwuaXNTYW1lT3JpZ2luKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB3b3JrZXJTcmMpKSB7XG4gICAgICAgICAgd29ya2VyU3JjID0gUERGV29ya2VyVXRpbC5jcmVhdGVDRE5XcmFwcGVyKG5ldyBVUkwod29ya2VyU3JjLCB3aW5kb3cubG9jYXRpb24pLmhyZWYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyU3JjKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgX21lc3NhZ2VfaGFuZGxlci5NZXNzYWdlSGFuZGxlcihcIm1haW5cIiwgXCJ3b3JrZXJcIiwgd29ya2VyKTtcbiAgICAgICAgY29uc3QgdGVybWluYXRlRWFybHkgPSAoKSA9PiB7XG4gICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbldvcmtlckVycm9yKTtcbiAgICAgICAgICBtZXNzYWdlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25Xb3JrZXJFcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuX3dlYldvcmtlcikge1xuICAgICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Xb3JrZXJFcnJvcik7XG4gICAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwidGVzdFwiLCBkYXRhID0+IHtcbiAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uV29ya2VyRXJyb3IpO1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgICAgICAgICB0aGlzLl9wb3J0ID0gd29ya2VyO1xuICAgICAgICAgICAgdGhpcy5fd2ViV29ya2VyID0gd29ya2VyO1xuICAgICAgICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJjb25maWd1cmVcIiwge1xuICAgICAgICAgICAgICB2ZXJib3NpdHk6IHRoaXMudmVyYm9zaXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICAgICAgICBtZXNzYWdlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVzc2FnZUhhbmRsZXIub24oXCJyZWFkeVwiLCBkYXRhID0+IHtcbiAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uV29ya2VyRXJyb3IpO1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlbmRUZXN0KCk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzZW5kVGVzdCA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCB0ZXN0T2JqID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwidGVzdFwiLCB0ZXN0T2JqLCBbdGVzdE9iai5idWZmZXJdKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VuZFRlc3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgICgwLCBfdXRpbC5pbmZvKShcIlRoZSB3b3JrZXIgaGFzIGJlZW4gZGlzYWJsZWQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgfVxuICBfc2V0dXBGYWtlV29ya2VyKCkge1xuICAgIGlmICghUERGV29ya2VyVXRpbC5pc1dvcmtlckRpc2FibGVkKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoXCJTZXR0aW5nIHVwIGZha2Ugd29ya2VyLlwiKTtcbiAgICAgIFBERldvcmtlclV0aWwuaXNXb3JrZXJEaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIFBERldvcmtlci5fc2V0dXBGYWtlV29ya2VyR2xvYmFsLnRoZW4oV29ya2VyTWVzc2FnZUhhbmRsZXIgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwb3J0ID0gbmV3IExvb3BiYWNrUG9ydCgpO1xuICAgICAgdGhpcy5fcG9ydCA9IHBvcnQ7XG4gICAgICBjb25zdCBpZCA9IGBmYWtlJHtQREZXb3JrZXJVdGlsLmZha2VXb3JrZXJJZCsrfWA7XG4gICAgICBjb25zdCB3b3JrZXJIYW5kbGVyID0gbmV3IF9tZXNzYWdlX2hhbmRsZXIuTWVzc2FnZUhhbmRsZXIoaWQgKyBcIl93b3JrZXJcIiwgaWQsIHBvcnQpO1xuICAgICAgV29ya2VyTWVzc2FnZUhhbmRsZXIuc2V0dXAod29ya2VySGFuZGxlciwgcG9ydCk7XG4gICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IG5ldyBfbWVzc2FnZV9oYW5kbGVyLk1lc3NhZ2VIYW5kbGVyKGlkLCBpZCArIFwiX3dvcmtlclwiLCBwb3J0KTtcbiAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcImNvbmZpZ3VyZVwiLCB7XG4gICAgICAgIHZlcmJvc2l0eTogdGhpcy52ZXJib3NpdHlcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihgU2V0dGluZyB1cCBmYWtlIHdvcmtlciBmYWlsZWQ6IFwiJHtyZWFzb24ubWVzc2FnZX1cIi5gKSk7XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuX3dlYldvcmtlcikge1xuICAgICAgdGhpcy5fd2ViV29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgdGhpcy5fd2ViV29ya2VyID0gbnVsbDtcbiAgICB9XG4gICAgUERGV29ya2VyLiN3b3JrZXJQb3J0cz8uZGVsZXRlKHRoaXMuX3BvcnQpO1xuICAgIHRoaXMuX3BvcnQgPSBudWxsO1xuICAgIGlmICh0aGlzLl9tZXNzYWdlSGFuZGxlcikge1xuICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbVBvcnQocGFyYW1zKSB7XG4gICAgaWYgKCFwYXJhbXM/LnBvcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBERldvcmtlci5mcm9tUG9ydCAtIGludmFsaWQgbWV0aG9kIHNpZ25hdHVyZS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlZFBvcnQgPSB0aGlzLiN3b3JrZXJQb3J0cz8uZ2V0KHBhcmFtcy5wb3J0KTtcbiAgICBpZiAoY2FjaGVkUG9ydCkge1xuICAgICAgaWYgKGNhY2hlZFBvcnQuX3BlbmRpbmdEZXN0cm95KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBERldvcmtlci5mcm9tUG9ydCAtIHRoZSB3b3JrZXIgaXMgYmVpbmcgZGVzdHJveWVkLlxcblwiICsgXCJQbGVhc2UgcmVtZW1iZXIgdG8gYXdhaXQgYFBERkRvY3VtZW50TG9hZGluZ1Rhc2suZGVzdHJveSgpYC1jYWxscy5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGVkUG9ydDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQREZXb3JrZXIocGFyYW1zKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHdvcmtlclNyYygpIHtcbiAgICBpZiAoX3dvcmtlcl9vcHRpb25zLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjKSB7XG4gICAgICByZXR1cm4gX3dvcmtlcl9vcHRpb25zLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjO1xuICAgIH1cbiAgICBpZiAoUERGV29ya2VyVXRpbC5mYWxsYmFja1dvcmtlclNyYyAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFfdXRpbC5pc05vZGVKUykge1xuICAgICAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZGVwcmVjYXRlZCkoJ05vIFwiR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmNcIiBzcGVjaWZpZWQuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUERGV29ya2VyVXRpbC5mYWxsYmFja1dvcmtlclNyYztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBcIkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjXCIgc3BlY2lmaWVkLicpO1xuICB9XG4gIHN0YXRpYyBnZXQgX21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGdsb2JhbFRoaXMucGRmanNXb3JrZXI/Lldvcmtlck1lc3NhZ2VIYW5kbGVyIHx8IG51bGw7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBfc2V0dXBGYWtlV29ya2VyR2xvYmFsKCkge1xuICAgIGNvbnN0IGxvYWRlciA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1haW5Xb3JrZXJNZXNzYWdlSGFuZGxlciA9IHRoaXMuX21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICAgIGlmIChtYWluV29ya2VyTWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIG1haW5Xb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICAgIH1cbiAgICAgIGlmIChfdXRpbC5pc05vZGVKUyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHdvcmtlciA9IGV2YWwoXCJyZXF1aXJlXCIpKHRoaXMud29ya2VyU3JjKTtcbiAgICAgICAgcmV0dXJuIHdvcmtlci5Xb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICAgIH1cbiAgICAgIGF3YWl0ICgwLCBfZGlzcGxheV91dGlscy5sb2FkU2NyaXB0KSh0aGlzLndvcmtlclNyYyk7XG4gICAgICByZXR1cm4gd2luZG93LnBkZmpzV29ya2VyLldvcmtlck1lc3NhZ2VIYW5kbGVyO1xuICAgIH07XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiX3NldHVwRmFrZVdvcmtlckdsb2JhbFwiLCBsb2FkZXIoKSk7XG4gIH1cbn1cbmV4cG9ydHMuUERGV29ya2VyID0gUERGV29ya2VyO1xuY2xhc3MgV29ya2VyVHJhbnNwb3J0IHtcbiAgI21ldGhvZFByb21pc2VzID0gbmV3IE1hcCgpO1xuICAjcGFnZUNhY2hlID0gbmV3IE1hcCgpO1xuICAjcGFnZVByb21pc2VzID0gbmV3IE1hcCgpO1xuICAjcGFzc3dvcmRDYXBhYmlsaXR5ID0gbnVsbDtcbiAgY29uc3RydWN0b3IobWVzc2FnZUhhbmRsZXIsIGxvYWRpbmdUYXNrLCBuZXR3b3JrU3RyZWFtLCBwYXJhbXMsIGZhY3RvcnkpIHtcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgdGhpcy5sb2FkaW5nVGFzayA9IGxvYWRpbmdUYXNrO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IG5ldyBQREZPYmplY3RzKCk7XG4gICAgdGhpcy5mb250TG9hZGVyID0gbmV3IF9mb250X2xvYWRlci5Gb250TG9hZGVyKHtcbiAgICAgIG93bmVyRG9jdW1lbnQ6IHBhcmFtcy5vd25lckRvY3VtZW50LFxuICAgICAgc3R5bGVFbGVtZW50OiBwYXJhbXMuc3R5bGVFbGVtZW50XG4gICAgfSk7XG4gICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGZhY3RvcnkuY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmYWN0b3J5LmZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5jTWFwUmVhZGVyRmFjdG9yeSA9IGZhY3RvcnkuY01hcFJlYWRlckZhY3Rvcnk7XG4gICAgdGhpcy5zdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IGZhY3Rvcnkuc3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5ID0gbnVsbDtcbiAgICB0aGlzLl9uZXR3b3JrU3RyZWFtID0gbmV0d29ya1N0cmVhbTtcbiAgICB0aGlzLl9mdWxsUmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuc2V0dXBNZXNzYWdlSGFuZGxlcigpO1xuICB9XG4gICNjYWNoZVNpbXBsZU1ldGhvZChuYW1lLCBkYXRhID0gbnVsbCkge1xuICAgIGNvbnN0IGNhY2hlZFByb21pc2UgPSB0aGlzLiNtZXRob2RQcm9taXNlcy5nZXQobmFtZSk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UobmFtZSwgZGF0YSk7XG4gICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuc2V0KG5hbWUsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGdldCBhbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJhbm5vdGF0aW9uU3RvcmFnZVwiLCBuZXcgX2Fubm90YXRpb25fc3RvcmFnZS5Bbm5vdGF0aW9uU3RvcmFnZSgpKTtcbiAgfVxuICBnZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSA9IF91dGlsLkFubm90YXRpb25Nb2RlLkVOQUJMRSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGwsIGlzT3BMaXN0ID0gZmFsc2UpIHtcbiAgICBsZXQgcmVuZGVyaW5nSW50ZW50ID0gX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5ESVNQTEFZO1xuICAgIGxldCBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSA9IF9hbm5vdGF0aW9uX3N0b3JhZ2UuU2VyaWFsaXphYmxlRW1wdHk7XG4gICAgc3dpdGNoIChpbnRlbnQpIHtcbiAgICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ID0gX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5BTlk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRpc3BsYXlcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicHJpbnRcIjpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ID0gX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAoMCwgX3V0aWwud2FybikoYGdldFJlbmRlcmluZ0ludGVudCAtIGludmFsaWQgaW50ZW50OiAke2ludGVudH1gKTtcbiAgICB9XG4gICAgc3dpdGNoIChhbm5vdGF0aW9uTW9kZSkge1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uTW9kZS5ESVNBQkxFOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19ESVNBQkxFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbk1vZGUuRU5BQkxFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbk1vZGUuRU5BQkxFX0ZPUk1TOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19GT1JNUztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Nb2RlLkVOQUJMRV9TVE9SQUdFOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19TVE9SQUdFO1xuICAgICAgICBjb25zdCBhbm5vdGF0aW9uU3RvcmFnZSA9IHJlbmRlcmluZ0ludGVudCAmIF91dGlsLlJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQgJiYgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSBpbnN0YW5jZW9mIF9hbm5vdGF0aW9uX3N0b3JhZ2UuUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA/IHByaW50QW5ub3RhdGlvblN0b3JhZ2UgOiB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgICAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSA9IGFubm90YXRpb25TdG9yYWdlLnNlcmlhbGl6YWJsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAoMCwgX3V0aWwud2FybikoYGdldFJlbmRlcmluZ0ludGVudCAtIGludmFsaWQgYW5ub3RhdGlvbk1vZGU6ICR7YW5ub3RhdGlvbk1vZGV9YCk7XG4gICAgfVxuICAgIGlmIChpc09wTGlzdCkge1xuICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IF91dGlsLlJlbmRlcmluZ0ludGVudEZsYWcuT1BMSVNUO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyaW5nSW50ZW50LFxuICAgICAgY2FjaGVLZXk6IGAke3JlbmRlcmluZ0ludGVudH1fJHthbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZS5oYXNofWAsXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZVxuICAgIH07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95Q2FwYWJpbGl0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHk/LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZCBkdXJpbmcgb25QYXNzd29yZCBjYWxsYmFja1wiKSk7XG4gICAgY29uc3Qgd2FpdE9uID0gW107XG4gICAgZm9yIChjb25zdCBwYWdlIG9mIHRoaXMuI3BhZ2VDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgd2FpdE9uLnB1c2gocGFnZS5fZGVzdHJveSgpKTtcbiAgICB9XG4gICAgdGhpcy4jcGFnZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy4jcGFnZVByb21pc2VzLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoXCJhbm5vdGF0aW9uU3RvcmFnZVwiKSkge1xuICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5yZXNldE1vZGlmaWVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHRlcm1pbmF0ZWQgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIlRlcm1pbmF0ZVwiLCBudWxsKTtcbiAgICB3YWl0T24ucHVzaCh0ZXJtaW5hdGVkKTtcbiAgICBQcm9taXNlLmFsbCh3YWl0T24pLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5jb21tb25PYmpzLmNsZWFyKCk7XG4gICAgICB0aGlzLmZvbnRMb2FkZXIuY2xlYXIoKTtcbiAgICAgIHRoaXMuI21ldGhvZFByb21pc2VzLmNsZWFyKCk7XG4gICAgICB0aGlzLmZpbHRlckZhY3RvcnkuZGVzdHJveSgpO1xuICAgICAgdGhpcy5fbmV0d29ya1N0cmVhbT8uY2FuY2VsQWxsUmVxdWVzdHMobmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKFwiV29ya2VyIHdhcyB0ZXJtaW5hdGVkLlwiKSk7XG4gICAgICBpZiAodGhpcy5tZXNzYWdlSGFuZGxlcikge1xuICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9LCB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgcmV0dXJuIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBzZXR1cE1lc3NhZ2VIYW5kbGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLFxuICAgICAgbG9hZGluZ1Rhc2tcbiAgICB9ID0gdGhpcztcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldFJlYWRlclwiLCAoZGF0YSwgc2luaykgPT4ge1xuICAgICAgKDAsIF91dGlsLmFzc2VydCkodGhpcy5fbmV0d29ya1N0cmVhbSwgXCJHZXRSZWFkZXIgLSBubyBgSVBERlN0cmVhbWAgaW5zdGFuY2UgYXZhaWxhYmxlLlwiKTtcbiAgICAgIHRoaXMuX2Z1bGxSZWFkZXIgPSB0aGlzLl9uZXR3b3JrU3RyZWFtLmdldEZ1bGxSZWFkZXIoKTtcbiAgICAgIHRoaXMuX2Z1bGxSZWFkZXIub25Qcm9ncmVzcyA9IGV2dCA9PiB7XG4gICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzcyA9IHtcbiAgICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHNpbmsub25QdWxsID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9mdWxsUmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgKDAsIF91dGlsLmFzc2VydCkodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciwgXCJHZXRSZWFkZXIgLSBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlci5cIik7XG4gICAgICAgICAgc2luay5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSwgMSwgW3ZhbHVlXSk7XG4gICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgc2luay5lcnJvcihyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uQ2FuY2VsID0gcmVhc29uID0+IHtcbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgc2luay5yZWFkeS5jYXRjaChyZWFkeVJlYXNvbiA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHJlYWR5UmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJSZWFkZXJIZWFkZXJzUmVhZHlcIiwgZGF0YSA9PiB7XG4gICAgICBjb25zdCBoZWFkZXJzQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgY29uc3QgZnVsbFJlYWRlciA9IHRoaXMuX2Z1bGxSZWFkZXI7XG4gICAgICBmdWxsUmVhZGVyLmhlYWRlcnNSZWFkeS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKCFmdWxsUmVhZGVyLmlzU3RyZWFtaW5nU3VwcG9ydGVkIHx8ICFmdWxsUmVhZGVyLmlzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5fbGFzdFByb2dyZXNzKSB7XG4gICAgICAgICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4odGhpcy5fbGFzdFByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVsbFJlYWRlci5vblByb2dyZXNzID0gZXZ0ID0+IHtcbiAgICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICBpc1N0cmVhbWluZ1N1cHBvcnRlZDogZnVsbFJlYWRlci5pc1N0cmVhbWluZ1N1cHBvcnRlZCxcbiAgICAgICAgICBpc1JhbmdlU3VwcG9ydGVkOiBmdWxsUmVhZGVyLmlzUmFuZ2VTdXBwb3J0ZWQsXG4gICAgICAgICAgY29udGVudExlbmd0aDogZnVsbFJlYWRlci5jb250ZW50TGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgfSwgaGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KTtcbiAgICAgIHJldHVybiBoZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0UmFuZ2VSZWFkZXJcIiwgKGRhdGEsIHNpbmspID0+IHtcbiAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHRoaXMuX25ldHdvcmtTdHJlYW0sIFwiR2V0UmFuZ2VSZWFkZXIgLSBubyBgSVBERlN0cmVhbWAgaW5zdGFuY2UgYXZhaWxhYmxlLlwiKTtcbiAgICAgIGNvbnN0IHJhbmdlUmVhZGVyID0gdGhpcy5fbmV0d29ya1N0cmVhbS5nZXRSYW5nZVJlYWRlcihkYXRhLmJlZ2luLCBkYXRhLmVuZCk7XG4gICAgICBpZiAoIXJhbmdlUmVhZGVyKSB7XG4gICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2luay5vblB1bGwgPSAoKSA9PiB7XG4gICAgICAgIHJhbmdlUmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgKDAsIF91dGlsLmFzc2VydCkodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciwgXCJHZXRSYW5nZVJlYWRlciAtIGV4cGVjdGVkIGFuIEFycmF5QnVmZmVyLlwiKTtcbiAgICAgICAgICBzaW5rLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCAxLCBbdmFsdWVdKTtcbiAgICAgICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICBzaW5rLmVycm9yKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHNpbmsub25DYW5jZWwgPSByZWFzb24gPT4ge1xuICAgICAgICByYW5nZVJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgc2luay5yZWFkeS5jYXRjaChyZWFkeVJlYXNvbiA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHJlYWR5UmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXREb2NcIiwgKHtcbiAgICAgIHBkZkluZm9cbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLl9udW1QYWdlcyA9IHBkZkluZm8ubnVtUGFnZXM7XG4gICAgICB0aGlzLl9odG1sRm9yWGZhID0gcGRmSW5mby5odG1sRm9yWGZhO1xuICAgICAgZGVsZXRlIHBkZkluZm8uaHRtbEZvclhmYTtcbiAgICAgIGxvYWRpbmdUYXNrLl9jYXBhYmlsaXR5LnJlc29sdmUobmV3IFBERkRvY3VtZW50UHJveHkocGRmSW5mbywgdGhpcykpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRG9jRXhjZXB0aW9uXCIsIGZ1bmN0aW9uIChleCkge1xuICAgICAgbGV0IHJlYXNvbjtcbiAgICAgIHN3aXRjaCAoZXgubmFtZSkge1xuICAgICAgICBjYXNlIFwiUGFzc3dvcmRFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuUGFzc3dvcmRFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguY29kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJJbnZhbGlkUERGRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IF91dGlsLkludmFsaWRQREZFeGNlcHRpb24oZXgubWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJNaXNzaW5nUERGRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24oZXgubWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LnN0YXR1cyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuVW5rbm93bkVycm9yRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LmRldGFpbHMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJEb2NFeGNlcHRpb24gLSBleHBlY3RlZCBhIHZhbGlkIEVycm9yLlwiKTtcbiAgICAgIH1cbiAgICAgIGxvYWRpbmdUYXNrLl9jYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiUGFzc3dvcmRSZXF1ZXN0XCIsIGV4Y2VwdGlvbiA9PiB7XG4gICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgIGlmIChsb2FkaW5nVGFzay5vblBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVBhc3N3b3JkID0gcGFzc3dvcmQgPT4ge1xuICAgICAgICAgIGlmIChwYXNzd29yZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KHBhc3N3b3JkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgICAgICBwYXNzd29yZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQodXBkYXRlUGFzc3dvcmQsIGV4Y2VwdGlvbi5jb2RlKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KGV4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChuZXcgX3V0aWwuUGFzc3dvcmRFeGNlcHRpb24oZXhjZXB0aW9uLm1lc3NhZ2UsIGV4Y2VwdGlvbi5jb2RlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJEYXRhTG9hZGVkXCIsIGRhdGEgPT4ge1xuICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgdG90YWw6IGRhdGEubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eS5yZXNvbHZlKGRhdGEpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiU3RhcnRSZW5kZXJQYWdlXCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLiNwYWdlQ2FjaGUuZ2V0KGRhdGEucGFnZUluZGV4KTtcbiAgICAgIHBhZ2UuX3N0YXJ0UmVuZGVyUGFnZShkYXRhLnRyYW5zcGFyZW5jeSwgZGF0YS5jYWNoZUtleSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJjb21tb25vYmpcIiwgKFtpZCwgdHlwZSwgZXhwb3J0ZWREYXRhXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbW1vbk9ianMuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkZvbnRcIjpcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLl9wYXJhbXM7XG4gICAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiBleHBvcnRlZERhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9ydGVkRXJyb3IgPSBleHBvcnRlZERhdGEuZXJyb3I7XG4gICAgICAgICAgICAoMCwgX3V0aWwud2FybikoYEVycm9yIGR1cmluZyBmb250IGxvYWRpbmc6ICR7ZXhwb3J0ZWRFcnJvcn1gKTtcbiAgICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBleHBvcnRlZEVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpbnNwZWN0Rm9udCA9IHBhcmFtcy5wZGZCdWcgJiYgZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yPy5lbmFibGVkID8gKGZvbnQsIHVybCkgPT4gZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yLmZvbnRBZGRlZChmb250LCB1cmwpIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBmb250ID0gbmV3IF9mb250X2xvYWRlci5Gb250RmFjZU9iamVjdChleHBvcnRlZERhdGEsIHtcbiAgICAgICAgICAgIGlzRXZhbFN1cHBvcnRlZDogcGFyYW1zLmlzRXZhbFN1cHBvcnRlZCxcbiAgICAgICAgICAgIGRpc2FibGVGb250RmFjZTogcGFyYW1zLmRpc2FibGVGb250RmFjZSxcbiAgICAgICAgICAgIGlnbm9yZUVycm9yczogcGFyYW1zLmlnbm9yZUVycm9ycyxcbiAgICAgICAgICAgIGluc3BlY3RGb250XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5mb250TG9hZGVyLmJpbmQoZm9udCkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJGb250RmFsbGJhY2tcIiwge1xuICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXBhcmFtcy5mb250RXh0cmFQcm9wZXJ0aWVzICYmIGZvbnQuZGF0YSkge1xuICAgICAgICAgICAgICBmb250LmRhdGEgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIGZvbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRm9udFBhdGhcIjpcbiAgICAgICAgY2FzZSBcIkltYWdlXCI6XG4gICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIGV4cG9ydGVkRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgdW5rbm93biBjb21tb24gb2JqZWN0IHR5cGUgJHt0eXBlfWApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwib2JqXCIsIChbaWQsIHBhZ2VJbmRleCwgdHlwZSwgaW1hZ2VEYXRhXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2VQcm94eSA9IHRoaXMuI3BhZ2VDYWNoZS5nZXQocGFnZUluZGV4KTtcbiAgICAgIGlmIChwYWdlUHJveHkub2Jqcy5oYXMoaWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcbiAgICAgICAgICBwYWdlUHJveHkub2Jqcy5yZXNvbHZlKGlkLCBpbWFnZURhdGEpO1xuICAgICAgICAgIGlmIChpbWFnZURhdGEpIHtcbiAgICAgICAgICAgIGxldCBsZW5ndGg7XG4gICAgICAgICAgICBpZiAoaW1hZ2VEYXRhLmJpdG1hcCkge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0XG4gICAgICAgICAgICAgIH0gPSBpbWFnZURhdGE7XG4gICAgICAgICAgICAgIGxlbmd0aCA9IHdpZHRoICogaGVpZ2h0ICogNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxlbmd0aCA9IGltYWdlRGF0YS5kYXRhPy5sZW5ndGggfHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiBfdXRpbC5NQVhfSU1BR0VfU0laRV9UT19DQUNIRSkge1xuICAgICAgICAgICAgICBwYWdlUHJveHkuX21heWJlQ2xlYW51cEFmdGVyUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgICAgcGFnZVByb3h5Lm9ianMucmVzb2x2ZShpZCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmtub3duIG9iamVjdCB0eXBlICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRvY1Byb2dyZXNzXCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZGF0YS5sb2FkZWQsXG4gICAgICAgIHRvdGFsOiBkYXRhLnRvdGFsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkZldGNoQnVpbHRJbkNNYXBcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkLlwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY01hcFJlYWRlckZhY3RvcnkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkNNYXBSZWFkZXJGYWN0b3J5IG5vdCBpbml0aWFsaXplZCwgc2VlIHRoZSBgdXNlV29ya2VyRmV0Y2hgIHBhcmFtZXRlci5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY01hcFJlYWRlckZhY3RvcnkuZmV0Y2goZGF0YSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJGZXRjaFN0YW5kYXJkRm9udERhdGFcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkLlwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlN0YW5kYXJkRm9udERhdGFGYWN0b3J5IG5vdCBpbml0aWFsaXplZCwgc2VlIHRoZSBgdXNlV29ya2VyRmV0Y2hgIHBhcmFtZXRlci5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkuZmV0Y2goZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREYXRhXCIsIG51bGwpO1xuICB9XG4gIHNhdmVEb2N1bWVudCgpIHtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zaXplIDw9IDApIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShcInNhdmVEb2N1bWVudCBjYWxsZWQgd2hpbGUgYGFubm90YXRpb25TdG9yYWdlYCBpcyBlbXB0eSwgXCIgKyBcInBsZWFzZSB1c2UgdGhlIGdldERhdGEtbWV0aG9kIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICB0cmFuc2ZlcnNcbiAgICB9ID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXJpYWxpemFibGU7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiU2F2ZURvY3VtZW50XCIsIHtcbiAgICAgIGlzUHVyZVhmYTogISF0aGlzLl9odG1sRm9yWGZhLFxuICAgICAgbnVtUGFnZXM6IHRoaXMuX251bVBhZ2VzLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IG1hcCxcbiAgICAgIGZpbGVuYW1lOiB0aGlzLl9mdWxsUmVhZGVyPy5maWxlbmFtZSA/PyBudWxsXG4gICAgfSwgdHJhbnNmZXJzKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UucmVzZXRNb2RpZmllZCgpO1xuICAgIH0pO1xuICB9XG4gIGdldFBhZ2UocGFnZU51bWJlcikge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihwYWdlTnVtYmVyKSB8fCBwYWdlTnVtYmVyIDw9IDAgfHwgcGFnZU51bWJlciA+IHRoaXMuX251bVBhZ2VzKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBwYWdlIHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgY29uc3QgcGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDEsXG4gICAgICBjYWNoZWRQcm9taXNlID0gdGhpcy4jcGFnZVByb21pc2VzLmdldChwYWdlSW5kZXgpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZVwiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KS50aGVuKHBhZ2VJbmZvID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BvcnQgZGVzdHJveWVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZSA9IG5ldyBQREZQYWdlUHJveHkocGFnZUluZGV4LCBwYWdlSW5mbywgdGhpcywgdGhpcy5fcGFyYW1zLnBkZkJ1Zyk7XG4gICAgICB0aGlzLiNwYWdlQ2FjaGUuc2V0KHBhZ2VJbmRleCwgcGFnZSk7XG4gICAgICByZXR1cm4gcGFnZTtcbiAgICB9KTtcbiAgICB0aGlzLiNwYWdlUHJvbWlzZXMuc2V0KHBhZ2VJbmRleCwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZ2V0UGFnZUluZGV4KHJlZikge1xuICAgIGlmICh0eXBlb2YgcmVmICE9PSBcIm9iamVjdFwiIHx8IHJlZiA9PT0gbnVsbCB8fCAhTnVtYmVyLmlzSW50ZWdlcihyZWYubnVtKSB8fCByZWYubnVtIDwgMCB8fCAhTnVtYmVyLmlzSW50ZWdlcihyZWYuZ2VuKSB8fCByZWYuZ2VuIDwgMCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgcGFnZUluZGV4IHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUluZGV4XCIsIHtcbiAgICAgIG51bTogcmVmLm51bSxcbiAgICAgIGdlbjogcmVmLmdlblxuICAgIH0pO1xuICB9XG4gIGdldEFubm90YXRpb25zKHBhZ2VJbmRleCwgaW50ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0QW5ub3RhdGlvbnNcIiwge1xuICAgICAgcGFnZUluZGV4LFxuICAgICAgaW50ZW50XG4gICAgfSk7XG4gIH1cbiAgZ2V0RmllbGRPYmplY3RzKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkdldEZpZWxkT2JqZWN0c1wiKTtcbiAgfVxuICBoYXNKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiSGFzSlNBY3Rpb25zXCIpO1xuICB9XG4gIGdldENhbGN1bGF0aW9uT3JkZXJJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Q2FsY3VsYXRpb25PcmRlcklkc1wiLCBudWxsKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGVzdGluYXRpb25zXCIsIG51bGwpO1xuICB9XG4gIGdldERlc3RpbmF0aW9uKGlkKSB7XG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgZGVzdGluYXRpb24gcmVxdWVzdC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvblwiLCB7XG4gICAgICBpZFxuICAgIH0pO1xuICB9XG4gIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUxhYmVsc1wiLCBudWxsKTtcbiAgfVxuICBnZXRQYWdlTGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VMYXlvdXRcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZU1vZGVcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Vmlld2VyUHJlZmVyZW5jZXNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0T3BlbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPcGVuQWN0aW9uXCIsIG51bGwpO1xuICB9XG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEF0dGFjaG1lbnRzXCIsIG51bGwpO1xuICB9XG4gIGdldERvY0pTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJHZXREb2NKU0FjdGlvbnNcIik7XG4gIH1cbiAgZ2V0UGFnZUpTQWN0aW9ucyhwYWdlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlSlNBY3Rpb25zXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pO1xuICB9XG4gIGdldFN0cnVjdFRyZWUocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0U3RydWN0VHJlZVwiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KTtcbiAgfVxuICBnZXRPdXRsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE91dGxpbmVcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE9wdGlvbmFsQ29udGVudENvbmZpZ1wiLCBudWxsKS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBfb3B0aW9uYWxfY29udGVudF9jb25maWcuT3B0aW9uYWxDb250ZW50Q29uZmlnKHJlc3VsdHMpO1xuICAgIH0pO1xuICB9XG4gIGdldFBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBlcm1pc3Npb25zXCIsIG51bGwpO1xuICB9XG4gIGdldE1ldGFkYXRhKCkge1xuICAgIGNvbnN0IG5hbWUgPSBcIkdldE1ldGFkYXRhXCIsXG4gICAgICBjYWNoZWRQcm9taXNlID0gdGhpcy4jbWV0aG9kUHJvbWlzZXMuZ2V0KG5hbWUpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKG5hbWUsIG51bGwpLnRoZW4ocmVzdWx0cyA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmZvOiByZXN1bHRzWzBdLFxuICAgICAgICBtZXRhZGF0YTogcmVzdWx0c1sxXSA/IG5ldyBfbWV0YWRhdGEuTWV0YWRhdGEocmVzdWx0c1sxXSkgOiBudWxsLFxuICAgICAgICBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTogdGhpcy5fZnVsbFJlYWRlcj8uZmlsZW5hbWUgPz8gbnVsbCxcbiAgICAgICAgY29udGVudExlbmd0aDogdGhpcy5fZnVsbFJlYWRlcj8uY29udGVudExlbmd0aCA/PyBudWxsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLnNldChuYW1lLCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXRNYXJrSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRNYXJrSW5mb1wiLCBudWxsKTtcbiAgfVxuICBhc3luYyBzdGFydENsZWFudXAoa2VlcExvYWRlZEZvbnRzID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJDbGVhbnVwXCIsIG51bGwpO1xuICAgIGZvciAoY29uc3QgcGFnZSBvZiB0aGlzLiNwYWdlQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IGNsZWFudXBTdWNjZXNzZnVsID0gcGFnZS5jbGVhbnVwKCk7XG4gICAgICBpZiAoIWNsZWFudXBTdWNjZXNzZnVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgc3RhcnRDbGVhbnVwOiBQYWdlICR7cGFnZS5wYWdlTnVtYmVyfSBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLmApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbW1vbk9ianMuY2xlYXIoKTtcbiAgICBpZiAoIWtlZXBMb2FkZWRGb250cykge1xuICAgICAgdGhpcy5mb250TG9hZGVyLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLmNsZWFyKCk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5LmRlc3Ryb3kodHJ1ZSk7XG4gIH1cbiAgZ2V0IGxvYWRpbmdQYXJhbXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGlzYWJsZUF1dG9GZXRjaCxcbiAgICAgIGVuYWJsZVhmYVxuICAgIH0gPSB0aGlzLl9wYXJhbXM7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwibG9hZGluZ1BhcmFtc1wiLCB7XG4gICAgICBkaXNhYmxlQXV0b0ZldGNoLFxuICAgICAgZW5hYmxlWGZhXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFBERk9iamVjdHMge1xuICAjb2JqcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICNlbnN1cmVPYmoob2JqSWQpIHtcbiAgICByZXR1cm4gdGhpcy4jb2Jqc1tvYmpJZF0gfHw9IHtcbiAgICAgIGNhcGFiaWxpdHk6IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpLFxuICAgICAgZGF0YTogbnVsbFxuICAgIH07XG4gIH1cbiAgZ2V0KG9iaklkLCBjYWxsYmFjayA9IG51bGwpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IG9iaiA9IHRoaXMuI2Vuc3VyZU9iaihvYmpJZCk7XG4gICAgICBvYmouY2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4gY2FsbGJhY2sob2JqLmRhdGEpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvYmogPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICBpZiAoIW9iaj8uY2FwYWJpbGl0eS5zZXR0bGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcXVlc3Rpbmcgb2JqZWN0IHRoYXQgaXNuJ3QgcmVzb2x2ZWQgeWV0ICR7b2JqSWR9LmApO1xuICAgIH1cbiAgICByZXR1cm4gb2JqLmRhdGE7XG4gIH1cbiAgaGFzKG9iaklkKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgcmV0dXJuIG9iaj8uY2FwYWJpbGl0eS5zZXR0bGVkIHx8IGZhbHNlO1xuICB9XG4gIHJlc29sdmUob2JqSWQsIGRhdGEgPSBudWxsKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jZW5zdXJlT2JqKG9iaklkKTtcbiAgICBvYmouZGF0YSA9IGRhdGE7XG4gICAgb2JqLmNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3Qgb2JqSWQgaW4gdGhpcy4jb2Jqcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhXG4gICAgICB9ID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgICBkYXRhPy5iaXRtYXA/LmNsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuI29ianMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG59XG5jbGFzcyBSZW5kZXJUYXNrIHtcbiAgI2ludGVybmFsUmVuZGVyVGFzayA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGludGVybmFsUmVuZGVyVGFzaykge1xuICAgIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzayA9IGludGVybmFsUmVuZGVyVGFzaztcbiAgICB0aGlzLm9uQ29udGludWUgPSBudWxsO1xuICB9XG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChleHRyYURlbGF5ID0gMCkge1xuICAgIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5jYW5jZWwobnVsbCwgZXh0cmFEZWxheSk7XG4gIH1cbiAgZ2V0IHNlcGFyYXRlQW5ub3RzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNlcGFyYXRlQW5ub3RzXG4gICAgfSA9IHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3Q7XG4gICAgaWYgKCFzZXBhcmF0ZUFubm90cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uQ2FudmFzTWFwXG4gICAgfSA9IHRoaXMuI2ludGVybmFsUmVuZGVyVGFzaztcbiAgICByZXR1cm4gc2VwYXJhdGVBbm5vdHMuZm9ybSB8fCBzZXBhcmF0ZUFubm90cy5jYW52YXMgJiYgYW5ub3RhdGlvbkNhbnZhc01hcD8uc2l6ZSA+IDA7XG4gIH1cbn1cbmV4cG9ydHMuUmVuZGVyVGFzayA9IFJlbmRlclRhc2s7XG5jbGFzcyBJbnRlcm5hbFJlbmRlclRhc2sge1xuICBzdGF0aWMgI2NhbnZhc0luVXNlID0gbmV3IFdlYWtTZXQoKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNhbGxiYWNrLFxuICAgIHBhcmFtcyxcbiAgICBvYmpzLFxuICAgIGNvbW1vbk9ianMsXG4gICAgYW5ub3RhdGlvbkNhbnZhc01hcCxcbiAgICBvcGVyYXRvckxpc3QsXG4gICAgcGFnZUluZGV4LFxuICAgIGNhbnZhc0ZhY3RvcnksXG4gICAgZmlsdGVyRmFjdG9yeSxcbiAgICB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmYWxzZSxcbiAgICBwZGZCdWcgPSBmYWxzZSxcbiAgICBwYWdlQ29sb3JzID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgdGhpcy5jb21tb25PYmpzID0gY29tbW9uT2JqcztcbiAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAgPSBhbm5vdGF0aW9uQ2FudmFzTWFwO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gbnVsbDtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdCA9IG9wZXJhdG9yTGlzdDtcbiAgICB0aGlzLl9wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmaWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuX3BkZkJ1ZyA9IHBkZkJ1ZztcbiAgICB0aGlzLnBhZ2VDb2xvcnMgPSBwYWdlQ29sb3JzO1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IHRydWUgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMudGFzayA9IG5ldyBSZW5kZXJUYXNrKHRoaXMpO1xuICAgIHRoaXMuX2NhbmNlbEJvdW5kID0gdGhpcy5jYW5jZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jb250aW51ZUJvdW5kID0gdGhpcy5fY29udGludWUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9zY2hlZHVsZU5leHRCb3VuZCA9IHRoaXMuX3NjaGVkdWxlTmV4dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX25leHRCb3VuZCA9IHRoaXMuX25leHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jYW52YXMgPSBwYXJhbXMuY2FudmFzQ29udGV4dC5jYW52YXM7XG4gIH1cbiAgZ2V0IGNvbXBsZXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYXBhYmlsaXR5LnByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICB9XG4gIGluaXRpYWxpemVHcmFwaGljcyh7XG4gICAgdHJhbnNwYXJlbmN5ID0gZmFsc2UsXG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnXG4gIH0pIHtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhbnZhcykge1xuICAgICAgaWYgKEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuaGFzKHRoaXMuX2NhbnZhcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSB0aGUgc2FtZSBjYW52YXMgZHVyaW5nIG11bHRpcGxlIHJlbmRlcigpIG9wZXJhdGlvbnMuIFwiICsgXCJVc2UgZGlmZmVyZW50IGNhbnZhcyBvciBlbnN1cmUgcHJldmlvdXMgb3BlcmF0aW9ucyB3ZXJlIFwiICsgXCJjYW5jZWxsZWQgb3IgY29tcGxldGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuYWRkKHRoaXMuX2NhbnZhcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9wZGZCdWcgJiYgZ2xvYmFsVGhpcy5TdGVwcGVyTWFuYWdlcj8uZW5hYmxlZCkge1xuICAgICAgdGhpcy5zdGVwcGVyID0gZ2xvYmFsVGhpcy5TdGVwcGVyTWFuYWdlci5jcmVhdGUodGhpcy5fcGFnZUluZGV4KTtcbiAgICAgIHRoaXMuc3RlcHBlci5pbml0KHRoaXMub3BlcmF0b3JMaXN0KTtcbiAgICAgIHRoaXMuc3RlcHBlci5uZXh0QnJlYWtQb2ludCA9IHRoaXMuc3RlcHBlci5nZXROZXh0QnJlYWtQb2ludCgpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYW52YXNDb250ZXh0LFxuICAgICAgdmlld3BvcnQsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBiYWNrZ3JvdW5kXG4gICAgfSA9IHRoaXMucGFyYW1zO1xuICAgIHRoaXMuZ2Z4ID0gbmV3IF9jYW52YXMuQ2FudmFzR3JhcGhpY3MoY2FudmFzQ29udGV4dCwgdGhpcy5jb21tb25PYmpzLCB0aGlzLm9ianMsIHRoaXMuY2FudmFzRmFjdG9yeSwgdGhpcy5maWx0ZXJGYWN0b3J5LCB7XG4gICAgICBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgICB9LCB0aGlzLmFubm90YXRpb25DYW52YXNNYXAsIHRoaXMucGFnZUNvbG9ycyk7XG4gICAgdGhpcy5nZnguYmVnaW5EcmF3aW5nKHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgdHJhbnNwYXJlbmN5LFxuICAgICAgYmFja2dyb3VuZFxuICAgIH0pO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gMDtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrPy4oKTtcbiAgfVxuICBjYW5jZWwoZXJyb3IgPSBudWxsLCBleHRyYURlbGF5ID0gMCkge1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB0aGlzLmdmeD8uZW5kRHJhd2luZygpO1xuICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuZGVsZXRlKHRoaXMuX2NhbnZhcyk7XG4gICAgdGhpcy5jYWxsYmFjayhlcnJvciB8fCBuZXcgX2Rpc3BsYXlfdXRpbHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKGBSZW5kZXJpbmcgY2FuY2VsbGVkLCBwYWdlICR7dGhpcy5fcGFnZUluZGV4ICsgMX1gLCBleHRyYURlbGF5KSk7XG4gIH1cbiAgb3BlcmF0b3JMaXN0Q2hhbmdlZCgpIHtcbiAgICBpZiAoIXRoaXMuZ3JhcGhpY3NSZWFkeSkge1xuICAgICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2sgfHw9IHRoaXMuX2NvbnRpbnVlQm91bmQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RlcHBlcj8udXBkYXRlT3BlcmF0b3JMaXN0KHRoaXMub3BlcmF0b3JMaXN0KTtcbiAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NvbnRpbnVlKCk7XG4gIH1cbiAgX2NvbnRpbnVlKCkge1xuICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnRhc2sub25Db250aW51ZSkge1xuICAgICAgdGhpcy50YXNrLm9uQ29udGludWUodGhpcy5fc2NoZWR1bGVOZXh0Qm91bmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZU5leHQoKTtcbiAgICB9XG4gIH1cbiAgX3NjaGVkdWxlTmV4dCgpIHtcbiAgICBpZiAodGhpcy5fdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5fbmV4dEJvdW5kKCkuY2F0Y2godGhpcy5fY2FuY2VsQm91bmQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4odGhpcy5fbmV4dEJvdW5kKS5jYXRjaCh0aGlzLl9jYW5jZWxCb3VuZCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIF9uZXh0KCkge1xuICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9wZXJhdG9yTGlzdElkeCA9IHRoaXMuZ2Z4LmV4ZWN1dGVPcGVyYXRvckxpc3QodGhpcy5vcGVyYXRvckxpc3QsIHRoaXMub3BlcmF0b3JMaXN0SWR4LCB0aGlzLl9jb250aW51ZUJvdW5kLCB0aGlzLnN0ZXBwZXIpO1xuICAgIGlmICh0aGlzLm9wZXJhdG9yTGlzdElkeCA9PT0gdGhpcy5vcGVyYXRvckxpc3QuYXJnc0FycmF5Lmxlbmd0aCkge1xuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5vcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgIHRoaXMuZ2Z4LmVuZERyYXdpbmcoKTtcbiAgICAgICAgSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5kZWxldGUodGhpcy5fY2FudmFzKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY29uc3QgdmVyc2lvbiA9ICczLjExLjE3NCc7XG5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuY29uc3QgYnVpbGQgPSAnY2U4NzE2NzQzJztcbmV4cG9ydHMuYnVpbGQgPSBidWlsZDtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlNlcmlhbGl6YWJsZUVtcHR5ID0gZXhwb3J0cy5QcmludEFubm90YXRpb25TdG9yYWdlID0gZXhwb3J0cy5Bbm5vdGF0aW9uU3RvcmFnZSA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2VkaXRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG52YXIgX211cm11cmhhc2ggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDgpO1xuY29uc3QgU2VyaWFsaXphYmxlRW1wdHkgPSBPYmplY3QuZnJlZXplKHtcbiAgbWFwOiBudWxsLFxuICBoYXNoOiBcIlwiLFxuICB0cmFuc2ZlcnM6IHVuZGVmaW5lZFxufSk7XG5leHBvcnRzLlNlcmlhbGl6YWJsZUVtcHR5ID0gU2VyaWFsaXphYmxlRW1wdHk7XG5jbGFzcyBBbm5vdGF0aW9uU3RvcmFnZSB7XG4gICNtb2RpZmllZCA9IGZhbHNlO1xuICAjc3RvcmFnZSA9IG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5vblNldE1vZGlmaWVkID0gbnVsbDtcbiAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCA9IG51bGw7XG4gICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPSBudWxsO1xuICB9XG4gIGdldFZhbHVlKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWZhdWx0VmFsdWUsIHZhbHVlKTtcbiAgfVxuICBnZXRSYXdWYWx1ZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgfVxuICByZW1vdmUoa2V5KSB7XG4gICAgdGhpcy4jc3RvcmFnZS5kZWxldGUoa2V5KTtcbiAgICBpZiAodGhpcy4jc3RvcmFnZS5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLnJlc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuI3N0b3JhZ2UudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvcihudWxsKTtcbiAgICB9XG4gIH1cbiAgc2V0VmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gICAgbGV0IG1vZGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGNvbnN0IFtlbnRyeSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKG9ialtlbnRyeV0gIT09IHZhbCkge1xuICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICBvYmpbZW50cnldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuI3N0b3JhZ2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgIHRoaXMuI3NldE1vZGlmaWVkKCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvciAmJiB0eXBlb2YgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IodmFsdWUuY29uc3RydWN0b3IuX3R5cGUpO1xuICAgIH1cbiAgfVxuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2UuaGFzKGtleSk7XG4gIH1cbiAgZ2V0QWxsKCkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLnNpemUgPiAwID8gKDAsIF91dGlsLm9iamVjdEZyb21NYXApKHRoaXMuI3N0b3JhZ2UpIDogbnVsbDtcbiAgfVxuICBzZXRBbGwob2JqKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICAgIHRoaXMuc2V0VmFsdWUoa2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5zaXplO1xuICB9XG4gICNzZXRNb2RpZmllZCgpIHtcbiAgICBpZiAoIXRoaXMuI21vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNtb2RpZmllZCA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub25TZXRNb2RpZmllZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25TZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXNldE1vZGlmaWVkKCkge1xuICAgIGlmICh0aGlzLiNtb2RpZmllZCkge1xuICAgICAgdGhpcy4jbW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vblJlc2V0TW9kaWZpZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgcHJpbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcmludEFubm90YXRpb25TdG9yYWdlKHRoaXMpO1xuICB9XG4gIGdldCBzZXJpYWxpemFibGUoKSB7XG4gICAgaWYgKHRoaXMuI3N0b3JhZ2Uuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUVtcHR5O1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCksXG4gICAgICBoYXNoID0gbmV3IF9tdXJtdXJoYXNoLk11cm11ckhhc2gzXzY0KCksXG4gICAgICB0cmFuc2ZlcnMgPSBbXTtcbiAgICBjb25zdCBjb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgaGFzQml0bWFwID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMuI3N0b3JhZ2UpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB2YWwgaW5zdGFuY2VvZiBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IgPyB2YWwuc2VyaWFsaXplKGZhbHNlLCBjb250ZXh0KSA6IHZhbDtcbiAgICAgIGlmIChzZXJpYWxpemVkKSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCBzZXJpYWxpemVkKTtcbiAgICAgICAgaGFzaC51cGRhdGUoYCR7a2V5fToke0pTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZWQpfWApO1xuICAgICAgICBoYXNCaXRtYXAgfHw9ICEhc2VyaWFsaXplZC5iaXRtYXA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNCaXRtYXApIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgbWFwLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5iaXRtYXApIHtcbiAgICAgICAgICB0cmFuc2ZlcnMucHVzaCh2YWx1ZS5iaXRtYXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXAuc2l6ZSA+IDAgPyB7XG4gICAgICBtYXAsXG4gICAgICBoYXNoOiBoYXNoLmhleGRpZ2VzdCgpLFxuICAgICAgdHJhbnNmZXJzXG4gICAgfSA6IFNlcmlhbGl6YWJsZUVtcHR5O1xuICB9XG59XG5leHBvcnRzLkFubm90YXRpb25TdG9yYWdlID0gQW5ub3RhdGlvblN0b3JhZ2U7XG5jbGFzcyBQcmludEFubm90YXRpb25TdG9yYWdlIGV4dGVuZHMgQW5ub3RhdGlvblN0b3JhZ2Uge1xuICAjc2VyaWFsaXphYmxlO1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHtcbiAgICAgIG1hcCxcbiAgICAgIGhhc2gsXG4gICAgICB0cmFuc2ZlcnNcbiAgICB9ID0gcGFyZW50LnNlcmlhbGl6YWJsZTtcbiAgICBjb25zdCBjbG9uZSA9IHN0cnVjdHVyZWRDbG9uZShtYXAsIHRyYW5zZmVycyA/IHtcbiAgICAgIHRyYW5zZmVyOiB0cmFuc2ZlcnNcbiAgICB9IDogbnVsbCk7XG4gICAgdGhpcy4jc2VyaWFsaXphYmxlID0ge1xuICAgICAgbWFwOiBjbG9uZSxcbiAgICAgIGhhc2gsXG4gICAgICB0cmFuc2ZlcnNcbiAgICB9O1xuICB9XG4gIGdldCBwcmludCgpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiU2hvdWxkIG5vdCBjYWxsIFByaW50QW5ub3RhdGlvblN0b3JhZ2UucHJpbnRcIik7XG4gIH1cbiAgZ2V0IHNlcmlhbGl6YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VyaWFsaXphYmxlO1xuICB9XG59XG5leHBvcnRzLlByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBQcmludEFubm90YXRpb25TdG9yYWdlO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvciA9IHZvaWQgMDtcbnZhciBfdG9vbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2FsdFRleHQgPSBcIlwiO1xuICAjYWx0VGV4dERlY29yYXRpdmUgPSBmYWxzZTtcbiAgI2FsdFRleHRCdXR0b24gPSBudWxsO1xuICAjYWx0VGV4dFRvb2x0aXAgPSBudWxsO1xuICAjYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgI2tlZXBBc3BlY3RSYXRpbyA9IGZhbHNlO1xuICAjcmVzaXplcnNEaXYgPSBudWxsO1xuICAjYm91bmRGb2N1c2luID0gdGhpcy5mb2N1c2luLmJpbmQodGhpcyk7XG4gICNib3VuZEZvY3Vzb3V0ID0gdGhpcy5mb2N1c291dC5iaW5kKHRoaXMpO1xuICAjaGFzQmVlbkNsaWNrZWQgPSBmYWxzZTtcbiAgI2lzRWRpdGluZyA9IGZhbHNlO1xuICAjaXNJbkVkaXRNb2RlID0gZmFsc2U7XG4gIF9pbml0aWFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIF91aU1hbmFnZXIgPSBudWxsO1xuICBfZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgX2wxMG5Qcm9taXNlID0gbnVsbDtcbiAgI2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICN6SW5kZXggPSBBbm5vdGF0aW9uRWRpdG9yLl96SW5kZXgrKztcbiAgc3RhdGljIF9ib3JkZXJMaW5lV2lkdGggPSAtMTtcbiAgc3RhdGljIF9jb2xvck1hbmFnZXIgPSBuZXcgX3Rvb2xzLkNvbG9yTWFuYWdlcigpO1xuICBzdGF0aWMgX3pJbmRleCA9IDE7XG4gIHN0YXRpYyBTTUFMTF9FRElUT1JfU0laRSA9IDA7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQW5ub3RhdGlvbkVkaXRvcikge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEFubm90YXRpb25FZGl0b3IuXCIpO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudCA9IHBhcmFtZXRlcnMucGFyZW50O1xuICAgIHRoaXMuaWQgPSBwYXJhbWV0ZXJzLmlkO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IG51bGw7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYXJhbWV0ZXJzLnBhcmVudC5wYWdlSW5kZXg7XG4gICAgdGhpcy5uYW1lID0gcGFyYW1ldGVycy5uYW1lO1xuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICB0aGlzLl91aU1hbmFnZXIgPSBwYXJhbWV0ZXJzLnVpTWFuYWdlcjtcbiAgICB0aGlzLmFubm90YXRpb25FbGVtZW50SWQgPSBudWxsO1xuICAgIHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucy5pc0NlbnRlcmVkID0gcGFyYW1ldGVycy5pc0NlbnRlcmVkO1xuICAgIHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZCA9IG51bGw7XG4gICAgY29uc3Qge1xuICAgICAgcm90YXRpb24sXG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgcGFnZVgsXG4gICAgICAgIHBhZ2VZXG4gICAgICB9XG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0O1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLnBhZ2VSb3RhdGlvbiA9ICgzNjAgKyByb3RhdGlvbiAtIHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yb3RhdGlvbikgJSAzNjA7XG4gICAgdGhpcy5wYWdlRGltZW5zaW9ucyA9IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdO1xuICAgIHRoaXMucGFnZVRyYW5zbGF0aW9uID0gW3BhZ2VYLCBwYWdlWV07XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMueCA9IHBhcmFtZXRlcnMueCAvIHdpZHRoO1xuICAgIHRoaXMueSA9IHBhcmFtZXRlcnMueSAvIGhlaWdodDtcbiAgICB0aGlzLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuICAgIHRoaXMuZGVsZXRlZCA9IGZhbHNlO1xuICB9XG4gIGdldCBlZGl0b3JUeXBlKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IuX3R5cGU7XG4gIH1cbiAgc3RhdGljIGdldCBfZGVmYXVsdExpbmVDb2xvcigpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJfZGVmYXVsdExpbmVDb2xvclwiLCB0aGlzLl9jb2xvck1hbmFnZXIuZ2V0SGV4Q29kZShcIkNhbnZhc1RleHRcIikpO1xuICB9XG4gIHN0YXRpYyBkZWxldGVBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICBjb25zdCBmYWtlRWRpdG9yID0gbmV3IEZha2VFZGl0b3Ioe1xuICAgICAgaWQ6IGVkaXRvci5wYXJlbnQuZ2V0TmV4dElkKCksXG4gICAgICBwYXJlbnQ6IGVkaXRvci5wYXJlbnQsXG4gICAgICB1aU1hbmFnZXI6IGVkaXRvci5fdWlNYW5hZ2VyXG4gICAgfSk7XG4gICAgZmFrZUVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgZmFrZUVkaXRvci5kZWxldGVkID0gdHJ1ZTtcbiAgICBmYWtlRWRpdG9yLl91aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShmYWtlRWRpdG9yKTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCBvcHRpb25zID0gbnVsbCkge1xuICAgIEFubm90YXRpb25FZGl0b3IuX2wxMG5Qcm9taXNlIHx8PSBuZXcgTWFwKFtcImVkaXRvcl9hbHRfdGV4dF9idXR0b25fbGFiZWxcIiwgXCJlZGl0b3JfYWx0X3RleHRfZWRpdF9idXR0b25fbGFiZWxcIiwgXCJlZGl0b3JfYWx0X3RleHRfZGVjb3JhdGl2ZV90b29sdGlwXCJdLm1hcChzdHIgPT4gW3N0ciwgbDEwbi5nZXQoc3RyKV0pKTtcbiAgICBpZiAob3B0aW9ucz8uc3RyaW5ncykge1xuICAgICAgZm9yIChjb25zdCBzdHIgb2Ygb3B0aW9ucy5zdHJpbmdzKSB7XG4gICAgICAgIEFubm90YXRpb25FZGl0b3IuX2wxMG5Qcm9taXNlLnNldChzdHIsIGwxMG4uZ2V0KHN0cikpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQW5ub3RhdGlvbkVkaXRvci5fYm9yZGVyTGluZVdpZHRoICE9PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9ib3JkZXJMaW5lV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLW91dGxpbmUtd2lkdGhcIikpIHx8IDA7XG4gIH1cbiAgc3RhdGljIHVwZGF0ZURlZmF1bHRQYXJhbXMoX3R5cGUsIF92YWx1ZSkge31cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBzdGF0aWMgaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKG1pbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIHBhc3RlKGl0ZW0sIHBhcmVudCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0IF9pc0RyYWdnYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNEcmFnZ2FibGU7XG4gIH1cbiAgc2V0IF9pc0RyYWdnYWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuI2lzRHJhZ2dhYmxlID0gdmFsdWU7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC50b2dnbGUoXCJkcmFnZ2FibGVcIiwgdmFsdWUpO1xuICB9XG4gIGNlbnRlcigpIHtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudFJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICB0aGlzLnggLT0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0IC8gKHBhZ2VXaWR0aCAqIDIpO1xuICAgICAgICB0aGlzLnkgKz0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aCAvIChwYWdlSGVpZ2h0ICogMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHRoaXMueCArPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy55ICs9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgdGhpcy54ICs9IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAvIChwYWdlV2lkdGggKiAyKTtcbiAgICAgICAgdGhpcy55IC09IHRoaXMud2lkdGggKiBwYWdlV2lkdGggLyAocGFnZUhlaWdodCAqIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMueCAtPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy55IC09IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBhZGRDb21tYW5kcyhwYXJhbXMpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkQ29tbWFuZHMocGFyYW1zKTtcbiAgfVxuICBnZXQgY3VycmVudExheWVyKCkge1xuICAgIHJldHVybiB0aGlzLl91aU1hbmFnZXIuY3VycmVudExheWVyO1xuICB9XG4gIHNldEluQmFja2dyb3VuZCgpIHtcbiAgICB0aGlzLmRpdi5zdHlsZS56SW5kZXggPSAwO1xuICB9XG4gIHNldEluRm9yZWdyb3VuZCgpIHtcbiAgICB0aGlzLmRpdi5zdHlsZS56SW5kZXggPSB0aGlzLiN6SW5kZXg7XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMucGFnZUluZGV4ID0gcGFyZW50LnBhZ2VJbmRleDtcbiAgICAgIHRoaXMucGFnZURpbWVuc2lvbnMgPSBwYXJlbnQucGFnZURpbWVuc2lvbnM7XG4gICAgfVxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG4gIGZvY3VzaW4oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZvY3VzRXZlbnRzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2hhc0JlZW5DbGlja2VkKSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaGFzQmVlbkNsaWNrZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9jdXNvdXQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZvY3VzRXZlbnRzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgaWYgKHRhcmdldD8uY2xvc2VzdChgIyR7dGhpcy5pZH1gKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghdGhpcy5wYXJlbnQ/LmlzTXVsdGlwbGVTZWxlY3Rpb24pIHtcbiAgICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgY29tbWl0T3JSZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgIH1cbiAgfVxuICBjb21taXQoKSB7XG4gICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKCk7XG4gIH1cbiAgYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSh0aGlzKTtcbiAgfVxuICBzZXRBdCh4LCB5LCB0eCwgdHkpIHtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgW3R4LCB0eV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHR4LCB0eSk7XG4gICAgdGhpcy54ID0gKHggKyB0eCkgLyB3aWR0aDtcbiAgICB0aGlzLnkgPSAoeSArIHR5KSAvIGhlaWdodDtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgI3RyYW5zbGF0ZShbd2lkdGgsIGhlaWdodF0sIHgsIHkpIHtcbiAgICBbeCwgeV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHgsIHkpO1xuICAgIHRoaXMueCArPSB4IC8gd2lkdGg7XG4gICAgdGhpcy55ICs9IHkgLyBoZWlnaHQ7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgdGhpcy4jdHJhbnNsYXRlKHRoaXMucGFyZW50RGltZW5zaW9ucywgeCwgeSk7XG4gIH1cbiAgdHJhbnNsYXRlSW5QYWdlKHgsIHkpIHtcbiAgICB0aGlzLiN0cmFuc2xhdGUodGhpcy5wYWdlRGltZW5zaW9ucywgeCwgeSk7XG4gICAgdGhpcy5kaXYuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgfSk7XG4gIH1cbiAgZHJhZyh0eCwgdHkpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy54ICs9IHR4IC8gcGFyZW50V2lkdGg7XG4gICAgdGhpcy55ICs9IHR5IC8gcGFyZW50SGVpZ2h0O1xuICAgIGlmICh0aGlzLnBhcmVudCAmJiAodGhpcy54IDwgMCB8fCB0aGlzLnggPiAxIHx8IHRoaXMueSA8IDAgfHwgdGhpcy55ID4gMSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKHRoaXMucGFyZW50LmZpbmROZXdQYXJlbnQodGhpcywgeCwgeSkpIHtcbiAgICAgICAgdGhpcy54IC09IE1hdGguZmxvb3IodGhpcy54KTtcbiAgICAgICAgdGhpcy55IC09IE1hdGguZmxvb3IodGhpcy55KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgW2J4LCBieV0gPSB0aGlzLiNnZXRCYXNlVHJhbnNsYXRpb24oKTtcbiAgICB4ICs9IGJ4O1xuICAgIHkgKz0gYnk7XG4gICAgdGhpcy5kaXYuc3R5bGUubGVmdCA9IGAkeygxMDAgKiB4KS50b0ZpeGVkKDIpfSVgO1xuICAgIHRoaXMuZGl2LnN0eWxlLnRvcCA9IGAkeygxMDAgKiB5KS50b0ZpeGVkKDIpfSVgO1xuICAgIHRoaXMuZGl2LnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIlxuICAgIH0pO1xuICB9XG4gICNnZXRCYXNlVHJhbnNsYXRpb24oKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHtcbiAgICAgIF9ib3JkZXJMaW5lV2lkdGhcbiAgICB9ID0gQW5ub3RhdGlvbkVkaXRvcjtcbiAgICBjb25zdCB4ID0gX2JvcmRlckxpbmVXaWR0aCAvIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IHkgPSBfYm9yZGVyTGluZVdpZHRoIC8gcGFyZW50SGVpZ2h0O1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsteCwgeV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3gsIC15XTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbLXgsIC15XTtcbiAgICB9XG4gIH1cbiAgZml4QW5kU2V0UG9zaXRpb24oKSB7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIGxldCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgd2lkdGggKj0gcGFnZVdpZHRoO1xuICAgIGhlaWdodCAqPSBwYWdlSGVpZ2h0O1xuICAgIHggKj0gcGFnZVdpZHRoO1xuICAgIHkgKj0gcGFnZUhlaWdodDtcbiAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VXaWR0aCAtIHdpZHRoLCB4KSk7XG4gICAgICAgIHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlSGVpZ2h0IC0gaGVpZ2h0LCB5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VXaWR0aCAtIGhlaWdodCwgeCkpO1xuICAgICAgICB5ID0gTWF0aC5taW4ocGFnZUhlaWdodCwgTWF0aC5tYXgod2lkdGgsIHkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgeCA9IE1hdGgubWluKHBhZ2VXaWR0aCwgTWF0aC5tYXgod2lkdGgsIHgpKTtcbiAgICAgICAgeSA9IE1hdGgubWluKHBhZ2VIZWlnaHQsIE1hdGgubWF4KGhlaWdodCwgeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB4ID0gTWF0aC5taW4ocGFnZVdpZHRoLCBNYXRoLm1heChoZWlnaHQsIHgpKTtcbiAgICAgICAgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VIZWlnaHQgLSB3aWR0aCwgeSkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy54ID0geCAvPSBwYWdlV2lkdGg7XG4gICAgdGhpcy55ID0geSAvPSBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IFtieCwgYnldID0gdGhpcy4jZ2V0QmFzZVRyYW5zbGF0aW9uKCk7XG4gICAgeCArPSBieDtcbiAgICB5ICs9IGJ5O1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIHN0eWxlLmxlZnQgPSBgJHsoMTAwICogeCkudG9GaXhlZCgyKX0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsoMTAwICogeSkudG9GaXhlZCgyKX0lYDtcbiAgICB0aGlzLm1vdmVJbkRPTSgpO1xuICB9XG4gIHN0YXRpYyAjcm90YXRlUG9pbnQoeCwgeSwgYW5nbGUpIHtcbiAgICBzd2l0Y2ggKGFuZ2xlKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3ksIC14XTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWy14LCAteV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFsteSwgeF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgfVxuICBzY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3IuI3JvdGF0ZVBvaW50KHgsIHksIHRoaXMucGFyZW50Um90YXRpb24pO1xuICB9XG4gIHBhZ2VUcmFuc2xhdGlvblRvU2NyZWVuKHgsIHkpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvci4jcm90YXRlUG9pbnQoeCwgeSwgMzYwIC0gdGhpcy5wYXJlbnRSb3RhdGlvbik7XG4gIH1cbiAgI2dldFJvdGF0aW9uTWF0cml4KHJvdGF0aW9uKSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgICByZXR1cm4gWzAsIC1wYWdlV2lkdGggLyBwYWdlSGVpZ2h0LCBwYWdlSGVpZ2h0IC8gcGFnZVdpZHRoLCAwXTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbLTEsIDAsIDAsIC0xXTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICAgIHJldHVybiBbMCwgcGFnZVdpZHRoIC8gcGFnZUhlaWdodCwgLXBhZ2VIZWlnaHQgLyBwYWdlV2lkdGgsIDBdO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWzEsIDAsIDAsIDFdO1xuICAgIH1cbiAgfVxuICBnZXQgcGFyZW50U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yZWFsU2NhbGU7XG4gIH1cbiAgZ2V0IHBhcmVudFJvdGF0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uICsgdGhpcy5wYWdlUm90YXRpb24pICUgMzYwO1xuICB9XG4gIGdldCBwYXJlbnREaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudFNjYWxlLFxuICAgICAgcGFnZURpbWVuc2lvbnM6IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2NhbGVkV2lkdGggPSBwYWdlV2lkdGggKiBwYXJlbnRTY2FsZTtcbiAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSBwYWdlSGVpZ2h0ICogcGFyZW50U2NhbGU7XG4gICAgcmV0dXJuIF91dGlsLkZlYXR1cmVUZXN0LmlzQ1NTUm91bmRTdXBwb3J0ZWQgPyBbTWF0aC5yb3VuZChzY2FsZWRXaWR0aCksIE1hdGgucm91bmQoc2NhbGVkSGVpZ2h0KV0gOiBbc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodF07XG4gIH1cbiAgc2V0RGltcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuZGl2LnN0eWxlLndpZHRoID0gYCR7KDEwMCAqIHdpZHRoIC8gcGFyZW50V2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgaWYgKCF0aGlzLiNrZWVwQXNwZWN0UmF0aW8pIHtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLmhlaWdodCA9IGAkeygxMDAgKiBoZWlnaHQgLyBwYXJlbnRIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHRCdXR0b24/LmNsYXNzTGlzdC50b2dnbGUoXCJzbWFsbFwiLCB3aWR0aCA8IEFubm90YXRpb25FZGl0b3IuU01BTExfRURJVE9SX1NJWkUgfHwgaGVpZ2h0IDwgQW5ub3RhdGlvbkVkaXRvci5TTUFMTF9FRElUT1JfU0laRSk7XG4gIH1cbiAgZml4RGltcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBjb25zdCB7XG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aFxuICAgIH0gPSBzdHlsZTtcbiAgICBjb25zdCB3aWR0aFBlcmNlbnQgPSB3aWR0aC5lbmRzV2l0aChcIiVcIik7XG4gICAgY29uc3QgaGVpZ2h0UGVyY2VudCA9ICF0aGlzLiNrZWVwQXNwZWN0UmF0aW8gJiYgaGVpZ2h0LmVuZHNXaXRoKFwiJVwiKTtcbiAgICBpZiAod2lkdGhQZXJjZW50ICYmIGhlaWdodFBlcmNlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGlmICghd2lkdGhQZXJjZW50KSB7XG4gICAgICBzdHlsZS53aWR0aCA9IGAkeygxMDAgKiBwYXJzZUZsb2F0KHdpZHRoKSAvIHBhcmVudFdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2tlZXBBc3BlY3RSYXRpbyAmJiAhaGVpZ2h0UGVyY2VudCkge1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7KDEwMCAqIHBhcnNlRmxvYXQoaGVpZ2h0KSAvIHBhcmVudEhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgICB9XG4gIH1cbiAgZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgI2NyZWF0ZVJlc2l6ZXJzKCkge1xuICAgIGlmICh0aGlzLiNyZXNpemVyc0Rpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNyZXNpemVyc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy4jcmVzaXplcnNEaXYuY2xhc3NMaXN0LmFkZChcInJlc2l6ZXJzXCIpO1xuICAgIGNvbnN0IGNsYXNzZXMgPSBbXCJ0b3BMZWZ0XCIsIFwidG9wUmlnaHRcIiwgXCJib3R0b21SaWdodFwiLCBcImJvdHRvbUxlZnRcIl07XG4gICAgaWYgKCF0aGlzLl93aWxsS2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICBjbGFzc2VzLnB1c2goXCJ0b3BNaWRkbGVcIiwgXCJtaWRkbGVSaWdodFwiLCBcImJvdHRvbU1pZGRsZVwiLCBcIm1pZGRsZUxlZnRcIik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBjbGFzc2VzKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy4jcmVzaXplcnNEaXYuYXBwZW5kKGRpdik7XG4gICAgICBkaXYuY2xhc3NMaXN0LmFkZChcInJlc2l6ZXJcIiwgbmFtZSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI3Jlc2l6ZXJQb2ludGVyZG93bi5iaW5kKHRoaXMsIG5hbWUpKTtcbiAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgX2Rpc3BsYXlfdXRpbHMubm9Db250ZXh0TWVudSk7XG4gICAgfVxuICAgIHRoaXMuZGl2LnByZXBlbmQodGhpcy4jcmVzaXplcnNEaXYpO1xuICB9XG4gICNyZXNpemVyUG9pbnRlcmRvd24obmFtZSwgZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBib3VuZFJlc2l6ZXJQb2ludGVybW92ZSA9IHRoaXMuI3Jlc2l6ZXJQb2ludGVybW92ZS5iaW5kKHRoaXMsIG5hbWUpO1xuICAgIGNvbnN0IHNhdmVkRHJhZ2dhYmxlID0gdGhpcy5faXNEcmFnZ2FibGU7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICBjb25zdCBwb2ludGVyTW92ZU9wdGlvbnMgPSB7XG4gICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBib3VuZFJlc2l6ZXJQb2ludGVybW92ZSwgcG9pbnRlck1vdmVPcHRpb25zKTtcbiAgICBjb25zdCBzYXZlZFggPSB0aGlzLng7XG4gICAgY29uc3Qgc2F2ZWRZID0gdGhpcy55O1xuICAgIGNvbnN0IHNhdmVkV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IHNhdmVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3Qgc2F2ZWRQYXJlbnRDdXJzb3IgPSB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yO1xuICAgIGNvbnN0IHNhdmVkQ3Vyc29yID0gdGhpcy5kaXYuc3R5bGUuY3Vyc29yO1xuICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShldmVudC50YXJnZXQpLmN1cnNvcjtcbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gc2F2ZWREcmFnZ2FibGU7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2spO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBib3VuZFJlc2l6ZXJQb2ludGVybW92ZSwgcG9pbnRlck1vdmVPcHRpb25zKTtcbiAgICAgIHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3IgPSBzYXZlZFBhcmVudEN1cnNvcjtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IHNhdmVkQ3Vyc29yO1xuICAgICAgY29uc3QgbmV3WCA9IHRoaXMueDtcbiAgICAgIGNvbnN0IG5ld1kgPSB0aGlzLnk7XG4gICAgICBjb25zdCBuZXdXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICBjb25zdCBuZXdIZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgIGlmIChuZXdYID09PSBzYXZlZFggJiYgbmV3WSA9PT0gc2F2ZWRZICYmIG5ld1dpZHRoID09PSBzYXZlZFdpZHRoICYmIG5ld0hlaWdodCA9PT0gc2F2ZWRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICAgIHRoaXMud2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICB0aGlzLnggPSBuZXdYO1xuICAgICAgICAgIHRoaXMueSA9IG5ld1k7XG4gICAgICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgICAgIHRoaXMuc2V0RGltcyhwYXJlbnRXaWR0aCAqIG5ld1dpZHRoLCBwYXJlbnRIZWlnaHQgKiBuZXdIZWlnaHQpO1xuICAgICAgICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICAgIHRoaXMud2lkdGggPSBzYXZlZFdpZHRoO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc2F2ZWRIZWlnaHQ7XG4gICAgICAgICAgdGhpcy54ID0gc2F2ZWRYO1xuICAgICAgICAgIHRoaXMueSA9IHNhdmVkWTtcbiAgICAgICAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICAgICAgdGhpcy5zZXREaW1zKHBhcmVudFdpZHRoICogc2F2ZWRXaWR0aCwgcGFyZW50SGVpZ2h0ICogc2F2ZWRIZWlnaHQpO1xuICAgICAgICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2spO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gIH1cbiAgI3Jlc2l6ZXJQb2ludGVybW92ZShuYW1lLCBldmVudCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCBzYXZlZFggPSB0aGlzLng7XG4gICAgY29uc3Qgc2F2ZWRZID0gdGhpcy55O1xuICAgIGNvbnN0IHNhdmVkV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IHNhdmVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluV2lkdGggPSBBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFIC8gcGFyZW50V2lkdGg7XG4gICAgY29uc3QgbWluSGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudEhlaWdodDtcbiAgICBjb25zdCByb3VuZCA9IHggPT4gTWF0aC5yb3VuZCh4ICogMTAwMDApIC8gMTAwMDA7XG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSB0aGlzLiNnZXRSb3RhdGlvbk1hdHJpeCh0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCB0cmFuc2YgPSAoeCwgeSkgPT4gW3JvdGF0aW9uTWF0cml4WzBdICogeCArIHJvdGF0aW9uTWF0cml4WzJdICogeSwgcm90YXRpb25NYXRyaXhbMV0gKiB4ICsgcm90YXRpb25NYXRyaXhbM10gKiB5XTtcbiAgICBjb25zdCBpbnZSb3RhdGlvbk1hdHJpeCA9IHRoaXMuI2dldFJvdGF0aW9uTWF0cml4KDM2MCAtIHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IGludlRyYW5zZiA9ICh4LCB5KSA9PiBbaW52Um90YXRpb25NYXRyaXhbMF0gKiB4ICsgaW52Um90YXRpb25NYXRyaXhbMl0gKiB5LCBpbnZSb3RhdGlvbk1hdHJpeFsxXSAqIHggKyBpbnZSb3RhdGlvbk1hdHJpeFszXSAqIHldO1xuICAgIGxldCBnZXRQb2ludDtcbiAgICBsZXQgZ2V0T3Bwb3NpdGU7XG4gICAgbGV0IGlzRGlhZ29uYWwgPSBmYWxzZTtcbiAgICBsZXQgaXNIb3Jpem9udGFsID0gZmFsc2U7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwidG9wTGVmdFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdywgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvcE1pZGRsZVwiOlxuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdyAvIDIsIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdyAvIDIsIGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b3BSaWdodFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3csIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbMCwgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pZGRsZVJpZ2h0XCI6XG4gICAgICAgIGlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3LCBoIC8gMl07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCBoIC8gMl07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbVJpZ2h0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdywgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tTWlkZGxlXCI6XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3IC8gMiwgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3IC8gMiwgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbUxlZnRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3csIDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaWRkbGVMZWZ0XCI6XG4gICAgICAgIGlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCBoIC8gMl07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3LCBoIC8gMl07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBwb2ludCA9IGdldFBvaW50KHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KTtcbiAgICBjb25zdCBvcHBvc2l0ZVBvaW50ID0gZ2V0T3Bwb3NpdGUoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgIGxldCB0cmFuc2ZPcHBvc2l0ZVBvaW50ID0gdHJhbnNmKC4uLm9wcG9zaXRlUG9pbnQpO1xuICAgIGNvbnN0IG9wcG9zaXRlWCA9IHJvdW5kKHNhdmVkWCArIHRyYW5zZk9wcG9zaXRlUG9pbnRbMF0pO1xuICAgIGNvbnN0IG9wcG9zaXRlWSA9IHJvdW5kKHNhdmVkWSArIHRyYW5zZk9wcG9zaXRlUG9pbnRbMV0pO1xuICAgIGxldCByYXRpb1ggPSAxO1xuICAgIGxldCByYXRpb1kgPSAxO1xuICAgIGxldCBbZGVsdGFYLCBkZWx0YVldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbihldmVudC5tb3ZlbWVudFgsIGV2ZW50Lm1vdmVtZW50WSk7XG4gICAgW2RlbHRhWCwgZGVsdGFZXSA9IGludlRyYW5zZihkZWx0YVggLyBwYXJlbnRXaWR0aCwgZGVsdGFZIC8gcGFyZW50SGVpZ2h0KTtcbiAgICBpZiAoaXNEaWFnb25hbCkge1xuICAgICAgY29uc3Qgb2xkRGlhZyA9IE1hdGguaHlwb3Qoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgICAgcmF0aW9YID0gcmF0aW9ZID0gTWF0aC5tYXgoTWF0aC5taW4oTWF0aC5oeXBvdChvcHBvc2l0ZVBvaW50WzBdIC0gcG9pbnRbMF0gLSBkZWx0YVgsIG9wcG9zaXRlUG9pbnRbMV0gLSBwb2ludFsxXSAtIGRlbHRhWSkgLyBvbGREaWFnLCAxIC8gc2F2ZWRXaWR0aCwgMSAvIHNhdmVkSGVpZ2h0KSwgbWluV2lkdGggLyBzYXZlZFdpZHRoLCBtaW5IZWlnaHQgLyBzYXZlZEhlaWdodCk7XG4gICAgfSBlbHNlIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIHJhdGlvWCA9IE1hdGgubWF4KG1pbldpZHRoLCBNYXRoLm1pbigxLCBNYXRoLmFicyhvcHBvc2l0ZVBvaW50WzBdIC0gcG9pbnRbMF0gLSBkZWx0YVgpKSkgLyBzYXZlZFdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByYXRpb1kgPSBNYXRoLm1heChtaW5IZWlnaHQsIE1hdGgubWluKDEsIE1hdGguYWJzKG9wcG9zaXRlUG9pbnRbMV0gLSBwb2ludFsxXSAtIGRlbHRhWSkpKSAvIHNhdmVkSGVpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBuZXdXaWR0aCA9IHJvdW5kKHNhdmVkV2lkdGggKiByYXRpb1gpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IHJvdW5kKHNhdmVkSGVpZ2h0ICogcmF0aW9ZKTtcbiAgICB0cmFuc2ZPcHBvc2l0ZVBvaW50ID0gdHJhbnNmKC4uLmdldE9wcG9zaXRlKG5ld1dpZHRoLCBuZXdIZWlnaHQpKTtcbiAgICBjb25zdCBuZXdYID0gb3Bwb3NpdGVYIC0gdHJhbnNmT3Bwb3NpdGVQb2ludFswXTtcbiAgICBjb25zdCBuZXdZID0gb3Bwb3NpdGVZIC0gdHJhbnNmT3Bwb3NpdGVQb2ludFsxXTtcbiAgICB0aGlzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgdGhpcy54ID0gbmV3WDtcbiAgICB0aGlzLnkgPSBuZXdZO1xuICAgIHRoaXMuc2V0RGltcyhwYXJlbnRXaWR0aCAqIG5ld1dpZHRoLCBwYXJlbnRIZWlnaHQgKiBuZXdIZWlnaHQpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBhc3luYyBhZGRBbHRUZXh0QnV0dG9uKCkge1xuICAgIGlmICh0aGlzLiNhbHRUZXh0QnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFsdFRleHQgPSB0aGlzLiNhbHRUZXh0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBhbHRUZXh0LmNsYXNzTmFtZSA9IFwiYWx0VGV4dFwiO1xuICAgIGNvbnN0IG1zZyA9IGF3YWl0IEFubm90YXRpb25FZGl0b3IuX2wxMG5Qcm9taXNlLmdldChcImVkaXRvcl9hbHRfdGV4dF9idXR0b25fbGFiZWxcIik7XG4gICAgYWx0VGV4dC50ZXh0Q29udGVudCA9IG1zZztcbiAgICBhbHRUZXh0LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbXNnKTtcbiAgICBhbHRUZXh0LnRhYkluZGV4ID0gXCIwXCI7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgX2Rpc3BsYXlfdXRpbHMubm9Db250ZXh0TWVudSk7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZXZlbnQgPT4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCkpO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZWRpdEFsdFRleHQodGhpcyk7XG4gICAgfSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gYWx0VGV4dCAmJiBldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl91aU1hbmFnZXIuZWRpdEFsdFRleHQodGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy4jc2V0QWx0VGV4dEJ1dHRvblN0YXRlKCk7XG4gICAgdGhpcy5kaXYuYXBwZW5kKGFsdFRleHQpO1xuICAgIGlmICghQW5ub3RhdGlvbkVkaXRvci5TTUFMTF9FRElUT1JfU0laRSkge1xuICAgICAgY29uc3QgUEVSQ0VOVCA9IDQwO1xuICAgICAgQW5ub3RhdGlvbkVkaXRvci5TTUFMTF9FRElUT1JfU0laRSA9IE1hdGgubWluKDEyOCwgTWF0aC5yb3VuZChhbHRUZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICogKDEgKyBQRVJDRU5UIC8gMTAwKSkpO1xuICAgIH1cbiAgfVxuICBhc3luYyAjc2V0QWx0VGV4dEJ1dHRvblN0YXRlKCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuI2FsdFRleHRCdXR0b247XG4gICAgaWYgKCFidXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNhbHRUZXh0ICYmICF0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSkge1xuICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJkb25lXCIpO1xuICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXA/LnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZS5nZXQoXCJlZGl0b3JfYWx0X3RleHRfZWRpdF9idXR0b25fbGFiZWxcIikudGhlbihtc2cgPT4ge1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbXNnKTtcbiAgICB9KTtcbiAgICBsZXQgdG9vbHRpcCA9IHRoaXMuI2FsdFRleHRUb29sdGlwO1xuICAgIGlmICghdG9vbHRpcCkge1xuICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAgPSB0b29sdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICB0b29sdGlwLmNsYXNzTmFtZSA9IFwidG9vbHRpcFwiO1xuICAgICAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidG9vbHRpcFwiKTtcbiAgICAgIGNvbnN0IGlkID0gdG9vbHRpcC5pZCA9IGBhbHQtdGV4dC10b29sdGlwLSR7dGhpcy5pZH1gO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIiwgaWQpO1xuICAgICAgY29uc3QgREVMQVlfVE9fU0hPV19UT09MVElQID0gMTAwO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcC5jbGFzc0xpc3QuYWRkKFwic2hvd1wiKTtcbiAgICAgICAgICB0aGlzLl91aU1hbmFnZXIuX2V2ZW50QnVzLmRpc3BhdGNoKFwicmVwb3J0dGVsZW1ldHJ5XCIsIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlZGl0aW5nXCIsXG4gICAgICAgICAgICAgIHN1YnR5cGU6IHRoaXMuZWRpdG9yVHlwZSxcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJhbHRfdGV4dF90b29sdGlwXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBERUxBWV9UT19TSE9XX1RPT0xUSVApO1xuICAgICAgfSk7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KTtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXA/LmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwiZG9uZVwiKTtcbiAgICB0b29sdGlwLmlubmVyVGV4dCA9IHRoaXMuI2FsdFRleHREZWNvcmF0aXZlID8gYXdhaXQgQW5ub3RhdGlvbkVkaXRvci5fbDEwblByb21pc2UuZ2V0KFwiZWRpdG9yX2FsdF90ZXh0X2RlY29yYXRpdmVfdG9vbHRpcFwiKSA6IHRoaXMuI2FsdFRleHQ7XG4gICAgaWYgKCF0b29sdGlwLnBhcmVudE5vZGUpIHtcbiAgICAgIGJ1dHRvbi5hcHBlbmQodG9vbHRpcCk7XG4gICAgfVxuICB9XG4gIGdldENsaWVudERpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG4gIGdldCBhbHRUZXh0RGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWx0VGV4dDogdGhpcy4jYWx0VGV4dCxcbiAgICAgIGRlY29yYXRpdmU6IHRoaXMuI2FsdFRleHREZWNvcmF0aXZlXG4gICAgfTtcbiAgfVxuICBzZXQgYWx0VGV4dERhdGEoe1xuICAgIGFsdFRleHQsXG4gICAgZGVjb3JhdGl2ZVxuICB9KSB7XG4gICAgaWYgKHRoaXMuI2FsdFRleHQgPT09IGFsdFRleHQgJiYgdGhpcy4jYWx0VGV4dERlY29yYXRpdmUgPT09IGRlY29yYXRpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dCA9IGFsdFRleHQ7XG4gICAgdGhpcy4jYWx0VGV4dERlY29yYXRpdmUgPSBkZWNvcmF0aXZlO1xuICAgIHRoaXMuI3NldEFsdFRleHRCdXR0b25TdGF0ZSgpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1lZGl0b3Itcm90YXRpb25cIiwgKDM2MCAtIHRoaXMucm90YXRpb24pICUgMzYwKTtcbiAgICB0aGlzLmRpdi5jbGFzc05hbWUgPSB0aGlzLm5hbWU7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy5pZCk7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgMCk7XG4gICAgdGhpcy5zZXRJbkZvcmVncm91bmQoKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCB0aGlzLiNib3VuZEZvY3VzaW4pO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLiNib3VuZEZvY3Vzb3V0KTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgaWYgKHRoaXMucGFyZW50Um90YXRpb24gJSAxODAgIT09IDApIHtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLm1heFdpZHRoID0gYCR7KDEwMCAqIHBhcmVudEhlaWdodCAvIHBhcmVudFdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgICAgdGhpcy5kaXYuc3R5bGUubWF4SGVpZ2h0ID0gYCR7KDEwMCAqIHBhcmVudFdpZHRoIC8gcGFyZW50SGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgICBjb25zdCBbdHgsIHR5XSA9IHRoaXMuZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCk7XG4gICAgdGhpcy50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAoMCwgX3Rvb2xzLmJpbmRFdmVudHMpKHRoaXMsIHRoaXMuZGl2LCBbXCJwb2ludGVyZG93blwiXSk7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIHBvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gX3V0aWwuRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IHRydWU7XG4gICAgdGhpcy4jc2V0VXBEcmFnU2Vzc2lvbihldmVudCk7XG4gIH1cbiAgI3NldFVwRHJhZ1Nlc3Npb24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2lzRHJhZ2dhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSB0aGlzLl91aU1hbmFnZXIuaXNTZWxlY3RlZCh0aGlzKTtcbiAgICB0aGlzLl91aU1hbmFnZXIuc2V0VXBEcmFnU2Vzc2lvbigpO1xuICAgIGxldCBwb2ludGVyTW92ZU9wdGlvbnMsIHBvaW50ZXJNb3ZlQ2FsbGJhY2s7XG4gICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgIHBvaW50ZXJNb3ZlT3B0aW9ucyA9IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHBvaW50ZXJNb3ZlQ2FsbGJhY2sgPSBlID0+IHtcbiAgICAgICAgY29uc3QgW3R4LCB0eV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKGUubW92ZW1lbnRYLCBlLm1vdmVtZW50WSk7XG4gICAgICAgIHRoaXMuX3VpTWFuYWdlci5kcmFnU2VsZWN0ZWRFZGl0b3JzKHR4LCB0eSk7XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBwb2ludGVyTW92ZUNhbGxiYWNrLCBwb2ludGVyTW92ZU9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHBvaW50ZXJNb3ZlQ2FsbGJhY2ssIHBvaW50ZXJNb3ZlT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAgICAgaWYgKCF0aGlzLl91aU1hbmFnZXIuZW5kRHJhZ1Nlc3Npb24oKSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaXNNYWNcbiAgICAgICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiAhaXNNYWMgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQubWV0YUtleSAmJiBpc01hYykge1xuICAgICAgICAgIHRoaXMucGFyZW50LnRvZ2dsZVNlbGVjdGVkKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJVcENhbGxiYWNrKTtcbiAgfVxuICBtb3ZlSW5ET00oKSB7XG4gICAgdGhpcy5wYXJlbnQ/Lm1vdmVFZGl0b3JJbkRPTSh0aGlzKTtcbiAgfVxuICBfc2V0UGFyZW50QW5kUG9zaXRpb24ocGFyZW50LCB4LCB5KSB7XG4gICAgcGFyZW50LmNoYW5nZVBhcmVudCh0aGlzKTtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIGdldFJlY3QodHgsIHR5KSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnBhcmVudFNjYWxlO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgIGNvbnN0IHNoaWZ0WCA9IHR4IC8gc2NhbGU7XG4gICAgY29uc3Qgc2hpZnRZID0gdHkgLyBzY2FsZTtcbiAgICBjb25zdCB4ID0gdGhpcy54ICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IHkgPSB0aGlzLnkgKiBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbeCArIHNoaWZ0WCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WSAtIGhlaWdodCArIHBhZ2VZLCB4ICsgc2hpZnRYICsgd2lkdGggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFkgKyBwYWdlWV07XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3ggKyBzaGlmdFkgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFggKyBwYWdlWSwgeCArIHNoaWZ0WSArIGhlaWdodCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WCArIHdpZHRoICsgcGFnZVldO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbeCAtIHNoaWZ0WCAtIHdpZHRoICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRZICsgcGFnZVksIHggLSBzaGlmdFggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFkgKyBoZWlnaHQgKyBwYWdlWV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt4IC0gc2hpZnRZIC0gaGVpZ2h0ICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRYIC0gd2lkdGggKyBwYWdlWSwgeCAtIHNoaWZ0WSArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WCArIHBhZ2VZXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm90YXRpb25cIik7XG4gICAgfVxuICB9XG4gIGdldFJlY3RJbkN1cnJlbnRDb29yZHMocmVjdCwgcGFnZUhlaWdodCkge1xuICAgIGNvbnN0IFt4MSwgeTEsIHgyLCB5Ml0gPSByZWN0O1xuICAgIGNvbnN0IHdpZHRoID0geDIgLSB4MTtcbiAgICBjb25zdCBoZWlnaHQgPSB5MiAtIHkxO1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW3gxLCBwYWdlSGVpZ2h0IC0geTIsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt4MSwgcGFnZUhlaWdodCAtIHkxLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3gyLCBwYWdlSGVpZ2h0IC0geTEsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeDIsIHBhZ2VIZWlnaHQgLSB5MiwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgfVxuICBvbmNlQWRkZWQoKSB7fVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICB0aGlzLiNpc0luRWRpdE1vZGUgPSB0cnVlO1xuICB9XG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICB0aGlzLiNpc0luRWRpdE1vZGUgPSBmYWxzZTtcbiAgfVxuICBpc0luRWRpdE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzSW5FZGl0TW9kZTtcbiAgfVxuICBzaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbmVlZHNUb0JlUmVidWlsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXYgJiYgIXRoaXMuaXNBdHRhY2hlZFRvRE9NO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgdGhpcy5kaXY/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuI2JvdW5kRm9jdXNpbik7XG4gICAgdGhpcy5kaXY/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLiNib3VuZEZvY3Vzb3V0KTtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFuIGVkaXRvciBtdXN0IGJlIHNlcmlhbGl6YWJsZVwiKTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBjb25zdCBlZGl0b3IgPSBuZXcgdGhpcy5wcm90b3R5cGUuY29uc3RydWN0b3Ioe1xuICAgICAgcGFyZW50LFxuICAgICAgaWQ6IHBhcmVudC5nZXROZXh0SWQoKSxcbiAgICAgIHVpTWFuYWdlclxuICAgIH0pO1xuICAgIGVkaXRvci5yb3RhdGlvbiA9IGRhdGEucm90YXRpb247XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gZWRpdG9yLmdldFJlY3RJbkN1cnJlbnRDb29yZHMoZGF0YS5yZWN0LCBwYWdlSGVpZ2h0KTtcbiAgICBlZGl0b3IueCA9IHggLyBwYWdlV2lkdGg7XG4gICAgZWRpdG9yLnkgPSB5IC8gcGFnZUhlaWdodDtcbiAgICBlZGl0b3Iud2lkdGggPSB3aWR0aCAvIHBhZ2VXaWR0aDtcbiAgICBlZGl0b3IuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFnZUhlaWdodDtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCB0aGlzLiNib3VuZEZvY3VzaW4pO1xuICAgIHRoaXMuZGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLiNib3VuZEZvY3Vzb3V0KTtcbiAgICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnJlbW92ZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlbW92ZUVkaXRvcih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAgPSBudWxsO1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWFrZVJlc2l6YWJsZSgpIHtcbiAgICBpZiAodGhpcy5pc1Jlc2l6YWJsZSkge1xuICAgICAgdGhpcy4jY3JlYXRlUmVzaXplcnMoKTtcbiAgICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgfVxuICB9XG4gIHNlbGVjdCgpIHtcbiAgICB0aGlzLm1ha2VSZXNpemFibGUoKTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkRWRpdG9yXCIpO1xuICB9XG4gIHVuc2VsZWN0KCkge1xuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2Py5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuZGl2Py5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gICAgaWYgKHRoaXMuZGl2Py5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmN1cnJlbnRMYXllci5kaXYuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7fVxuICBkaXNhYmxlRWRpdGluZygpIHtcbiAgICBpZiAodGhpcy4jYWx0VGV4dEJ1dHRvbikge1xuICAgICAgdGhpcy4jYWx0VGV4dEJ1dHRvbi5oaWRkZW4gPSB0cnVlO1xuICAgIH1cbiAgfVxuICBlbmFibGVFZGl0aW5nKCkge1xuICAgIGlmICh0aGlzLiNhbHRUZXh0QnV0dG9uKSB7XG4gICAgICB0aGlzLiNhbHRUZXh0QnV0dG9uLmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBlbnRlckluRWRpdE1vZGUoKSB7fVxuICBnZXQgY29udGVudERpdigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgZ2V0IGlzRWRpdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNFZGl0aW5nO1xuICB9XG4gIHNldCBpc0VkaXRpbmcodmFsdWUpIHtcbiAgICB0aGlzLiNpc0VkaXRpbmcgPSB2YWx1ZTtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgICB0aGlzLnBhcmVudC5zZXRBY3RpdmVFZGl0b3IodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyZW50LnNldEFjdGl2ZUVkaXRvcihudWxsKTtcbiAgICB9XG4gIH1cbiAgc2V0QXNwZWN0UmF0aW8od2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuI2tlZXBBc3BlY3RSYXRpbyA9IHRydWU7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBzdHlsZS5hc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvO1xuICAgIHN0eWxlLmhlaWdodCA9IFwiYXV0b1wiO1xuICB9XG4gIHN0YXRpYyBnZXQgTUlOX1NJWkUoKSB7XG4gICAgcmV0dXJuIDE2O1xuICB9XG59XG5leHBvcnRzLkFubm90YXRpb25FZGl0b3IgPSBBbm5vdGF0aW9uRWRpdG9yO1xuY2xhc3MgRmFrZUVkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcihwYXJhbXMpO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IHBhcmFtcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHRoaXMuZGVsZXRlZCA9IHRydWU7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkLFxuICAgICAgZGVsZXRlZDogdHJ1ZSxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXhcbiAgICB9O1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5LZXlib2FyZE1hbmFnZXIgPSBleHBvcnRzLkNvbW1hbmRNYW5hZ2VyID0gZXhwb3J0cy5Db2xvck1hbmFnZXIgPSBleHBvcnRzLkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIgPSB2b2lkIDA7XG5leHBvcnRzLmJpbmRFdmVudHMgPSBiaW5kRXZlbnRzO1xuZXhwb3J0cy5vcGFjaXR5VG9IZXggPSBvcGFjaXR5VG9IZXg7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbmZ1bmN0aW9uIGJpbmRFdmVudHMob2JqLCBlbGVtZW50LCBuYW1lcykge1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgb2JqW25hbWVdLmJpbmQob2JqKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9wYWNpdHlUb0hleChvcGFjaXR5KSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMSwgMjU1ICogb3BhY2l0eSkpKS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xufVxuY2xhc3MgSWRNYW5hZ2VyIHtcbiAgI2lkID0gMDtcbiAgZ2V0SWQoKSB7XG4gICAgcmV0dXJuIGAke191dGlsLkFubm90YXRpb25FZGl0b3JQcmVmaXh9JHt0aGlzLiNpZCsrfWA7XG4gIH1cbn1cbmNsYXNzIEltYWdlTWFuYWdlciB7XG4gICNiYXNlSWQgPSAoMCwgX3V0aWwuZ2V0VXVpZCkoKTtcbiAgI2lkID0gMDtcbiAgI2NhY2hlID0gbnVsbDtcbiAgc3RhdGljIGdldCBfaXNTVkdGaXR0aW5nQ2FudmFzKCkge1xuICAgIGNvbnN0IHN2ZyA9IGBkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD1VVEYtOCw8c3ZnIHZpZXdCb3g9XCIwIDAgMSAxXCIgd2lkdGg9XCIxXCIgaGVpZ2h0PVwiMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cmVjdCB3aWR0aD1cIjFcIiBoZWlnaHQ9XCIxXCIgc3R5bGU9XCJmaWxsOnJlZDtcIi8+PC9zdmc+YDtcbiAgICBjb25zdCBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDMpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWFnZS5zcmMgPSBzdmc7XG4gICAgY29uc3QgcHJvbWlzZSA9IGltYWdlLmRlY29kZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgMSwgMSwgMCwgMCwgMSwgMyk7XG4gICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YS5idWZmZXIpWzBdID09PSAwO1xuICAgIH0pO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcIl9pc1NWR0ZpdHRpbmdDYW52YXNcIiwgcHJvbWlzZSk7XG4gIH1cbiAgYXN5bmMgI2dldChrZXksIHJhd0RhdGEpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGxldCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YT8uYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgZGF0YSB8fD0ge1xuICAgICAgICBiaXRtYXA6IG51bGwsXG4gICAgICAgIGlkOiBgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9XyR7dGhpcy4jaWQrK31gLFxuICAgICAgICByZWZDb3VudGVyOiAwLFxuICAgICAgICBpc1N2ZzogZmFsc2VcbiAgICAgIH07XG4gICAgICBsZXQgaW1hZ2U7XG4gICAgICBpZiAodHlwZW9mIHJhd0RhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGF0YS51cmwgPSByYXdEYXRhO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJhd0RhdGEpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIGltYWdlID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW1hZ2UgPSBkYXRhLmZpbGUgPSByYXdEYXRhO1xuICAgICAgfVxuICAgICAgaWYgKGltYWdlLnR5cGUgPT09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XG4gICAgICAgIGNvbnN0IG11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UgPSBJbWFnZU1hbmFnZXIuX2lzU1ZHRml0dGluZ0NhbnZhcztcbiAgICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGNvbnN0IGltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBjb25zdCBpbWFnZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgaW1hZ2VFbGVtZW50Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGRhdGEuYml0bWFwID0gaW1hZ2VFbGVtZW50O1xuICAgICAgICAgICAgZGF0YS5pc1N2ZyA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGRhdGEuc3ZnVXJsID0gZmlsZVJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQuc3JjID0gKGF3YWl0IG11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UpID8gYCR7dXJsfSNzdmdWaWV3KHByZXNlcnZlQXNwZWN0UmF0aW8obm9uZSkpYCA6IHVybDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGltYWdlRWxlbWVudC5vbmVycm9yID0gZmlsZVJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGltYWdlKTtcbiAgICAgICAgYXdhaXQgaW1hZ2VQcm9taXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5iaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChpbWFnZSk7XG4gICAgICB9XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgPSAxO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICBkYXRhID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgZGF0YSk7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnNldChkYXRhLmlkLCBkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUZpbGUoZmlsZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RNb2RpZmllZCxcbiAgICAgIG5hbWUsXG4gICAgICBzaXplLFxuICAgICAgdHlwZVxuICAgIH0gPSBmaWxlO1xuICAgIHJldHVybiB0aGlzLiNnZXQoYCR7bGFzdE1vZGlmaWVkfV8ke25hbWV9XyR7c2l6ZX1fJHt0eXBlfWAsIGZpbGUpO1xuICB9XG4gIGFzeW5jIGdldEZyb21VcmwodXJsKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dldCh1cmwsIHVybCk7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUlkKGlkKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YS5iaXRtYXApIHtcbiAgICAgIGRhdGEucmVmQ291bnRlciArPSAxO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmIChkYXRhLmZpbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEZyb21GaWxlKGRhdGEuZmlsZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEZyb21VcmwoZGF0YS51cmwpO1xuICB9XG4gIGdldFN2Z1VybChpZCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoaWQpO1xuICAgIGlmICghZGF0YT8uaXNTdmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5zdmdVcmw7XG4gIH1cbiAgZGVsZXRlSWQoaWQpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoaWQpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhLnJlZkNvdW50ZXIgLT0gMTtcbiAgICBpZiAoZGF0YS5yZWZDb3VudGVyICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGEuYml0bWFwID0gbnVsbDtcbiAgfVxuICBpc1ZhbGlkSWQoaWQpIHtcbiAgICByZXR1cm4gaWQuc3RhcnRzV2l0aChgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9X2ApO1xuICB9XG59XG5jbGFzcyBDb21tYW5kTWFuYWdlciB7XG4gICNjb21tYW5kcyA9IFtdO1xuICAjbG9ja2VkID0gZmFsc2U7XG4gICNtYXhTaXplO1xuICAjcG9zaXRpb24gPSAtMTtcbiAgY29uc3RydWN0b3IobWF4U2l6ZSA9IDEyOCkge1xuICAgIHRoaXMuI21heFNpemUgPSBtYXhTaXplO1xuICB9XG4gIGFkZCh7XG4gICAgY21kLFxuICAgIHVuZG8sXG4gICAgbXVzdEV4ZWMsXG4gICAgdHlwZSA9IE5hTixcbiAgICBvdmVyd3JpdGVJZlNhbWVUeXBlID0gZmFsc2UsXG4gICAga2VlcFVuZG8gPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKG11c3RFeGVjKSB7XG4gICAgICBjbWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2xvY2tlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzYXZlID0ge1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIHR5cGVcbiAgICB9O1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgIGlmICh0aGlzLiNjb21tYW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuI2NvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IDA7XG4gICAgICB0aGlzLiNjb21tYW5kcy5wdXNoKHNhdmUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3ZlcndyaXRlSWZTYW1lVHlwZSAmJiB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0udHlwZSA9PT0gdHlwZSkge1xuICAgICAgaWYgKGtlZXBVbmRvKSB7XG4gICAgICAgIHNhdmUudW5kbyA9IHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXS51bmRvO1xuICAgICAgfVxuICAgICAgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dID0gc2F2ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuI3Bvc2l0aW9uICsgMTtcbiAgICBpZiAobmV4dCA9PT0gdGhpcy4jbWF4U2l6ZSkge1xuICAgICAgdGhpcy4jY29tbWFuZHMuc3BsaWNlKDAsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IG5leHQ7XG4gICAgICBpZiAobmV4dCA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5zcGxpY2UobmV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NvbW1hbmRzLnB1c2goc2F2ZSk7XG4gIH1cbiAgdW5kbygpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2xvY2tlZCA9IHRydWU7XG4gICAgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dLnVuZG8oKTtcbiAgICB0aGlzLiNsb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLiNwb3NpdGlvbiAtPSAxO1xuICB9XG4gIHJlZG8oKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uIDwgdGhpcy4jY29tbWFuZHMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy4jcG9zaXRpb24gKz0gMTtcbiAgICAgIHRoaXMuI2xvY2tlZCA9IHRydWU7XG4gICAgICB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0uY21kKCk7XG4gICAgICB0aGlzLiNsb2NrZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9VbmRvKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3NpdGlvbiAhPT0gLTE7XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9SZWRvKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3NpdGlvbiA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCAtIDE7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNjb21tYW5kcyA9IG51bGw7XG4gIH1cbn1cbmV4cG9ydHMuQ29tbWFuZE1hbmFnZXIgPSBDb21tYW5kTWFuYWdlcjtcbmNsYXNzIEtleWJvYXJkTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrcykge1xuICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgdGhpcy5jYWxsYmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hbGxLZXlzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGZvciAoY29uc3QgW2tleXMsIGNhbGxiYWNrLCBvcHRpb25zID0ge31dIG9mIGNhbGxiYWNrcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBjb25zdCBpc01hY0tleSA9IGtleS5zdGFydHNXaXRoKFwibWFjK1wiKTtcbiAgICAgICAgaWYgKGlzTWFjICYmIGlzTWFjS2V5KSB7XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3Muc2V0KGtleS5zbGljZSg0KSwge1xuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5hbGxLZXlzLmFkZChrZXkuc3BsaXQoXCIrXCIpLmF0KC0xKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTWFjICYmICFpc01hY0tleSkge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnNldChrZXksIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYWxsS2V5cy5hZGQoa2V5LnNwbGl0KFwiK1wiKS5hdCgtMSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNzZXJpYWxpemUoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiYWx0XCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQuY3RybEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcImN0cmxcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5tZXRhS2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwibWV0YVwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwic2hpZnRcIik7XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyLnB1c2goZXZlbnQua2V5KTtcbiAgICBjb25zdCBzdHIgPSB0aGlzLmJ1ZmZlci5qb2luKFwiK1wiKTtcbiAgICB0aGlzLmJ1ZmZlci5sZW5ndGggPSAwO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgZXhlYyhzZWxmLCBldmVudCkge1xuICAgIGlmICghdGhpcy5hbGxLZXlzLmhhcyhldmVudC5rZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZm8gPSB0aGlzLmNhbGxiYWNrcy5nZXQodGhpcy4jc2VyaWFsaXplKGV2ZW50KSk7XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBidWJibGVzID0gZmFsc2UsXG4gICAgICAgIGFyZ3MgPSBbXSxcbiAgICAgICAgY2hlY2tlciA9IG51bGxcbiAgICAgIH1cbiAgICB9ID0gaW5mbztcbiAgICBpZiAoY2hlY2tlciAmJiAhY2hlY2tlcihzZWxmLCBldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2suYmluZChzZWxmLCAuLi5hcmdzKSgpO1xuICAgIGlmICghYnViYmxlcykge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5LZXlib2FyZE1hbmFnZXIgPSBLZXlib2FyZE1hbmFnZXI7XG5jbGFzcyBDb2xvck1hbmFnZXIge1xuICBzdGF0aWMgX2NvbG9yc01hcHBpbmcgPSBuZXcgTWFwKFtbXCJDYW52YXNUZXh0XCIsIFswLCAwLCAwXV0sIFtcIkNhbnZhc1wiLCBbMjU1LCAyNTUsIDI1NV1dXSk7XG4gIGdldCBfY29sb3JzKCkge1xuICAgIGNvbnN0IGNvbG9ycyA9IG5ldyBNYXAoW1tcIkNhbnZhc1RleHRcIiwgbnVsbF0sIFtcIkNhbnZhc1wiLCBudWxsXV0pO1xuICAgICgwLCBfZGlzcGxheV91dGlscy5nZXRDb2xvclZhbHVlcykoY29sb3JzKTtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJfY29sb3JzXCIsIGNvbG9ycyk7XG4gIH1cbiAgY29udmVydChjb2xvcikge1xuICAgIGNvbnN0IHJnYiA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRSR0IpKGNvbG9yKTtcbiAgICBpZiAoIXdpbmRvdy5tYXRjaE1lZGlhKFwiKGZvcmNlZC1jb2xvcnM6IGFjdGl2ZSlcIikubWF0Y2hlcykge1xuICAgICAgcmV0dXJuIHJnYjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbbmFtZSwgUkdCXSBvZiB0aGlzLl9jb2xvcnMpIHtcbiAgICAgIGlmIChSR0IuZXZlcnkoKHgsIGkpID0+IHggPT09IHJnYltpXSkpIHtcbiAgICAgICAgcmV0dXJuIENvbG9yTWFuYWdlci5fY29sb3JzTWFwcGluZy5nZXQobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZ2I7XG4gIH1cbiAgZ2V0SGV4Q29kZShuYW1lKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fY29sb3JzLmdldChuYW1lKTtcbiAgICBpZiAoIXJnYikge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvciguLi5yZ2IpO1xuICB9XG59XG5leHBvcnRzLkNvbG9yTWFuYWdlciA9IENvbG9yTWFuYWdlcjtcbmNsYXNzIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIge1xuICAjYWN0aXZlRWRpdG9yID0gbnVsbDtcbiAgI2FsbEVkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICNhbGxMYXllcnMgPSBuZXcgTWFwKCk7XG4gICNhbHRUZXh0TWFuYWdlciA9IG51bGw7XG4gICNhbm5vdGF0aW9uU3RvcmFnZSA9IG51bGw7XG4gICNjb21tYW5kTWFuYWdlciA9IG5ldyBDb21tYW5kTWFuYWdlcigpO1xuICAjY3VycmVudFBhZ2VJbmRleCA9IDA7XG4gICNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzID0gbmV3IFNldCgpO1xuICAjZHJhZ2dpbmdFZGl0b3JzID0gbnVsbDtcbiAgI2VkaXRvclR5cGVzID0gbnVsbDtcbiAgI2VkaXRvcnNUb1Jlc2NhbGUgPSBuZXcgU2V0KCk7XG4gICNmaWx0ZXJGYWN0b3J5ID0gbnVsbDtcbiAgI2lkTWFuYWdlciA9IG5ldyBJZE1hbmFnZXIoKTtcbiAgI2lzRW5hYmxlZCA9IGZhbHNlO1xuICAjaXNXYWl0aW5nID0gZmFsc2U7XG4gICNsYXN0QWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICNtb2RlID0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTtcbiAgI3NlbGVjdGVkRWRpdG9ycyA9IG5ldyBTZXQoKTtcbiAgI3BhZ2VDb2xvcnMgPSBudWxsO1xuICAjYm91bmRCbHVyID0gdGhpcy5ibHVyLmJpbmQodGhpcyk7XG4gICNib3VuZEZvY3VzID0gdGhpcy5mb2N1cy5iaW5kKHRoaXMpO1xuICAjYm91bmRDb3B5ID0gdGhpcy5jb3B5LmJpbmQodGhpcyk7XG4gICNib3VuZEN1dCA9IHRoaXMuY3V0LmJpbmQodGhpcyk7XG4gICNib3VuZFBhc3RlID0gdGhpcy5wYXN0ZS5iaW5kKHRoaXMpO1xuICAjYm91bmRLZXlkb3duID0gdGhpcy5rZXlkb3duLmJpbmQodGhpcyk7XG4gICNib3VuZE9uRWRpdGluZ0FjdGlvbiA9IHRoaXMub25FZGl0aW5nQWN0aW9uLmJpbmQodGhpcyk7XG4gICNib3VuZE9uUGFnZUNoYW5naW5nID0gdGhpcy5vblBhZ2VDaGFuZ2luZy5iaW5kKHRoaXMpO1xuICAjYm91bmRPblNjYWxlQ2hhbmdpbmcgPSB0aGlzLm9uU2NhbGVDaGFuZ2luZy5iaW5kKHRoaXMpO1xuICAjYm91bmRPblJvdGF0aW9uQ2hhbmdpbmcgPSB0aGlzLm9uUm90YXRpb25DaGFuZ2luZy5iaW5kKHRoaXMpO1xuICAjcHJldmlvdXNTdGF0ZXMgPSB7XG4gICAgaXNFZGl0aW5nOiBmYWxzZSxcbiAgICBpc0VtcHR5OiB0cnVlLFxuICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogZmFsc2UsXG4gICAgaGFzU29tZXRoaW5nVG9SZWRvOiBmYWxzZSxcbiAgICBoYXNTZWxlY3RlZEVkaXRvcjogZmFsc2VcbiAgfTtcbiAgI3RyYW5zbGF0aW9uID0gWzAsIDBdO1xuICAjdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAjY29udGFpbmVyID0gbnVsbDtcbiAgI3ZpZXdlciA9IG51bGw7XG4gIHN0YXRpYyBUUkFOU0xBVEVfU01BTEwgPSAxO1xuICBzdGF0aWMgVFJBTlNMQVRFX0JJRyA9IDEwO1xuICBzdGF0aWMgZ2V0IF9rZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgY29uc3QgcHJvdG8gPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLnByb3RvdHlwZTtcbiAgICBjb25zdCBhcnJvd0NoZWNrZXIgPSBzZWxmID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWN0aXZlRWxlbWVudFxuICAgICAgfSA9IGRvY3VtZW50O1xuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQgJiYgc2VsZi4jY29udGFpbmVyLmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpICYmIHNlbGYuaGFzU29tZXRoaW5nVG9Db250cm9sKCk7XG4gICAgfTtcbiAgICBjb25zdCBzbWFsbCA9IHRoaXMuVFJBTlNMQVRFX1NNQUxMO1xuICAgIGNvbnN0IGJpZyA9IHRoaXMuVFJBTlNMQVRFX0JJRztcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJjdHJsK2FcIiwgXCJtYWMrbWV0YSthXCJdLCBwcm90by5zZWxlY3RBbGxdLCBbW1wiY3RybCt6XCIsIFwibWFjK21ldGErelwiXSwgcHJvdG8udW5kb10sIFtbXCJjdHJsK3lcIiwgXCJjdHJsK3NoaWZ0K3pcIiwgXCJtYWMrbWV0YStzaGlmdCt6XCIsIFwiY3RybCtzaGlmdCtaXCIsIFwibWFjK21ldGErc2hpZnQrWlwiXSwgcHJvdG8ucmVkb10sIFtbXCJCYWNrc3BhY2VcIiwgXCJhbHQrQmFja3NwYWNlXCIsIFwiY3RybCtCYWNrc3BhY2VcIiwgXCJzaGlmdCtCYWNrc3BhY2VcIiwgXCJtYWMrQmFja3NwYWNlXCIsIFwibWFjK2FsdCtCYWNrc3BhY2VcIiwgXCJtYWMrY3RybCtCYWNrc3BhY2VcIiwgXCJEZWxldGVcIiwgXCJjdHJsK0RlbGV0ZVwiLCBcInNoaWZ0K0RlbGV0ZVwiLCBcIm1hYytEZWxldGVcIl0sIHByb3RvLmRlbGV0ZV0sIFtbXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBwcm90by51bnNlbGVjdEFsbF0sIFtbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFstc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93TGVmdFwiLCBcIm1hYytzaGlmdCtBcnJvd0xlZnRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWy1iaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogW3NtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1JpZ2h0XCIsIFwibWFjK3NoaWZ0K0Fycm93UmlnaHRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogW2JpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgLXNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1VwXCIsIFwibWFjK3NoaWZ0K0Fycm93VXBcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIC1iaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCBzbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dEb3duXCIsIFwibWFjK3NoaWZ0K0Fycm93RG93blwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgdmlld2VyLCBhbHRUZXh0TWFuYWdlciwgZXZlbnRCdXMsIHBkZkRvY3VtZW50LCBwYWdlQ29sb3JzKSB7XG4gICAgdGhpcy4jY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuI3ZpZXdlciA9IHZpZXdlcjtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlciA9IGFsdFRleHRNYW5hZ2VyO1xuICAgIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gICAgdGhpcy5fZXZlbnRCdXMuX29uKFwiZWRpdGluZ2FjdGlvblwiLCB0aGlzLiNib3VuZE9uRWRpdGluZ0FjdGlvbik7XG4gICAgdGhpcy5fZXZlbnRCdXMuX29uKFwicGFnZWNoYW5naW5nXCIsIHRoaXMuI2JvdW5kT25QYWdlQ2hhbmdpbmcpO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vbihcInNjYWxlY2hhbmdpbmdcIiwgdGhpcy4jYm91bmRPblNjYWxlQ2hhbmdpbmcpO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vbihcInJvdGF0aW9uY2hhbmdpbmdcIiwgdGhpcy4jYm91bmRPblJvdGF0aW9uQ2hhbmdpbmcpO1xuICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlID0gcGRmRG9jdW1lbnQuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgdGhpcy4jZmlsdGVyRmFjdG9yeSA9IHBkZkRvY3VtZW50LmZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy4jcGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy52aWV3UGFyYW1ldGVycyA9IHtcbiAgICAgIHJlYWxTY2FsZTogX2Rpc3BsYXlfdXRpbHMuUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTLFxuICAgICAgcm90YXRpb246IDBcbiAgICB9O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jcmVtb3ZlS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgdGhpcy4jcmVtb3ZlRm9jdXNNYW5hZ2VyKCk7XG4gICAgdGhpcy5fZXZlbnRCdXMuX29mZihcImVkaXRpbmdhY3Rpb25cIiwgdGhpcy4jYm91bmRPbkVkaXRpbmdBY3Rpb24pO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vZmYoXCJwYWdlY2hhbmdpbmdcIiwgdGhpcy4jYm91bmRPblBhZ2VDaGFuZ2luZyk7XG4gICAgdGhpcy5fZXZlbnRCdXMuX29mZihcInNjYWxlY2hhbmdpbmdcIiwgdGhpcy4jYm91bmRPblNjYWxlQ2hhbmdpbmcpO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vZmYoXCJyb3RhdGlvbmNoYW5naW5nXCIsIHRoaXMuI2JvdW5kT25Sb3RhdGlvbkNoYW5naW5nKTtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgbGF5ZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLiNhbGxMYXllcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNhbGxFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5jbGVhcigpO1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvciA9IG51bGw7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuI2FsdFRleHRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgfVxuICBnZXQgaGNtRmlsdGVyKCkge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImhjbUZpbHRlclwiLCB0aGlzLiNwYWdlQ29sb3JzID8gdGhpcy4jZmlsdGVyRmFjdG9yeS5hZGRIQ01GaWx0ZXIodGhpcy4jcGFnZUNvbG9ycy5mb3JlZ3JvdW5kLCB0aGlzLiNwYWdlQ29sb3JzLmJhY2tncm91bmQpIDogXCJub25lXCIpO1xuICB9XG4gIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiZGlyZWN0aW9uXCIsIGdldENvbXB1dGVkU3R5bGUodGhpcy4jY29udGFpbmVyKS5kaXJlY3Rpb24pO1xuICB9XG4gIGVkaXRBbHRUZXh0KGVkaXRvcikge1xuICAgIHRoaXMuI2FsdFRleHRNYW5hZ2VyPy5lZGl0QWx0VGV4dCh0aGlzLCBlZGl0b3IpO1xuICB9XG4gIG9uUGFnZUNoYW5naW5nKHtcbiAgICBwYWdlTnVtYmVyXG4gIH0pIHtcbiAgICB0aGlzLiNjdXJyZW50UGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDE7XG4gIH1cbiAgZm9jdXNNYWluQ29udGFpbmVyKCkge1xuICAgIHRoaXMuI2NvbnRhaW5lci5mb2N1cygpO1xuICB9XG4gIGZpbmRQYXJlbnQoeCwgeSkge1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHg6IGxheWVyWCxcbiAgICAgICAgeTogbGF5ZXJZLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gbGF5ZXIuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKHggPj0gbGF5ZXJYICYmIHggPD0gbGF5ZXJYICsgd2lkdGggJiYgeSA+PSBsYXllclkgJiYgeSA8PSBsYXllclkgKyBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBkaXNhYmxlVXNlclNlbGVjdCh2YWx1ZSA9IGZhbHNlKSB7XG4gICAgdGhpcy4jdmlld2VyLmNsYXNzTGlzdC50b2dnbGUoXCJub1VzZXJTZWxlY3RcIiwgdmFsdWUpO1xuICB9XG4gIGFkZFNob3VsZFJlc2NhbGUoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5hZGQoZWRpdG9yKTtcbiAgfVxuICByZW1vdmVTaG91bGRSZXNjYWxlKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuZGVsZXRlKGVkaXRvcik7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKHtcbiAgICBzY2FsZVxuICB9KSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMudmlld1BhcmFtZXRlcnMucmVhbFNjYWxlID0gc2NhbGUgKiBfZGlzcGxheV91dGlscy5QaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFM7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZSkge1xuICAgICAgZWRpdG9yLm9uU2NhbGVDaGFuZ2luZygpO1xuICAgIH1cbiAgfVxuICBvblJvdGF0aW9uQ2hhbmdpbmcoe1xuICAgIHBhZ2VzUm90YXRpb25cbiAgfSkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uID0gcGFnZXNSb3RhdGlvbjtcbiAgfVxuICBhZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcikge1xuICAgIGlmICghZWRpdG9yLmlzRW1wdHkoKSAmJiB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZSAmJiAhdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgI2FkZEZvY3VzTWFuYWdlcigpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuI2JvdW5kRm9jdXMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLiNib3VuZEJsdXIpO1xuICB9XG4gICNyZW1vdmVGb2N1c01hbmFnZXIoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLiNib3VuZEZvY3VzKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy4jYm91bmRCbHVyKTtcbiAgfVxuICBibHVyKCkge1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZlRWxlbWVudFxuICAgIH0gPSBkb2N1bWVudDtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50ID0gW2VkaXRvciwgYWN0aXZlRWxlbWVudF07XG4gICAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb2N1cygpIHtcbiAgICBpZiAoIXRoaXMuI2xhc3RBY3RpdmVFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtsYXN0RWRpdG9yLCBsYXN0QWN0aXZlRWxlbWVudF0gPSB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudDtcbiAgICB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgbGFzdEFjdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgKCkgPT4ge1xuICAgICAgbGFzdEVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICB9LCB7XG4gICAgICBvbmNlOiB0cnVlXG4gICAgfSk7XG4gICAgbGFzdEFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgfVxuICAjYWRkS2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleWRvd24sIHtcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KTtcbiAgfVxuICAjcmVtb3ZlS2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleWRvd24sIHtcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KTtcbiAgfVxuICAjYWRkQ29weVBhc3RlTGlzdGVuZXJzKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsIHRoaXMuI2JvdW5kQ29weSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImN1dFwiLCB0aGlzLiNib3VuZEN1dCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsIHRoaXMuI2JvdW5kUGFzdGUpO1xuICB9XG4gICNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvcHlcIiwgdGhpcy4jYm91bmRDb3B5KTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY3V0XCIsIHRoaXMuI2JvdW5kQ3V0KTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFzdGVcIiwgdGhpcy4jYm91bmRQYXN0ZSk7XG4gIH1cbiAgYWRkRWRpdExpc3RlbmVycygpIHtcbiAgICB0aGlzLiNhZGRLZXlib2FyZE1hbmFnZXIoKTtcbiAgICB0aGlzLiNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgfVxuICByZW1vdmVFZGl0TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuI3JlbW92ZUtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI3JlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycygpO1xuICB9XG4gIGNvcHkoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvcj8uY29tbWl0T3JSZW1vdmUoKTtcbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBlZGl0b3Iuc2VyaWFsaXplKHRydWUpO1xuICAgICAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgZWRpdG9ycy5wdXNoKHNlcmlhbGl6ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWRpdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwiYXBwbGljYXRpb24vcGRmanNcIiwgSlNPTi5zdHJpbmdpZnkoZWRpdG9ycykpO1xuICB9XG4gIGN1dChldmVudCkge1xuICAgIHRoaXMuY29weShldmVudCk7XG4gICAgdGhpcy5kZWxldGUoKTtcbiAgfVxuICBwYXN0ZShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qge1xuICAgICAgY2xpcGJvYXJkRGF0YVxuICAgIH0gPSBldmVudDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY2xpcGJvYXJkRGF0YS5pdGVtcykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGlmIChlZGl0b3JUeXBlLmlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgZWRpdG9yVHlwZS5wYXN0ZShpdGVtLCB0aGlzLmN1cnJlbnRMYXllcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBkYXRhID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24vcGRmanNcIik7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKGBwYXN0ZTogXCIke2V4Lm1lc3NhZ2V9XCIuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmN1cnJlbnRMYXllcjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmV3RWRpdG9ycyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZGF0YSkge1xuICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWRFZGl0b3IgPSBsYXllci5kZXNlcmlhbGl6ZShlZGl0b3IpO1xuICAgICAgICBpZiAoIWRlc2VyaWFsaXplZEVkaXRvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZXdFZGl0b3JzLnB1c2goZGVzZXJpYWxpemVkRWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNtZCA9ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgbmV3RWRpdG9ycykge1xuICAgICAgICAgIHRoaXMuI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNzZWxlY3RFZGl0b3JzKG5ld0VkaXRvcnMpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIG5ld0VkaXRvcnMpIHtcbiAgICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgY21kLFxuICAgICAgICB1bmRvLFxuICAgICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShgcGFzdGU6IFwiJHtleC5tZXNzYWdlfVwiLmApO1xuICAgIH1cbiAgfVxuICBrZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmdldEFjdGl2ZSgpPy5zaG91bGRHZXRLZXlib2FyZEV2ZW50cygpKSB7XG4gICAgICBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLl9rZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9XG4gIG9uRWRpdGluZ0FjdGlvbihkZXRhaWxzKSB7XG4gICAgaWYgKFtcInVuZG9cIiwgXCJyZWRvXCIsIFwiZGVsZXRlXCIsIFwic2VsZWN0QWxsXCJdLmluY2x1ZGVzKGRldGFpbHMubmFtZSkpIHtcbiAgICAgIHRoaXNbZGV0YWlscy5uYW1lXSgpO1xuICAgIH1cbiAgfVxuICAjZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoZGV0YWlscykge1xuICAgIGNvbnN0IGhhc0NoYW5nZWQgPSBPYmplY3QuZW50cmllcyhkZXRhaWxzKS5zb21lKChba2V5LCB2YWx1ZV0pID0+IHRoaXMuI3ByZXZpb3VzU3RhdGVzW2tleV0gIT09IHZhbHVlKTtcbiAgICBpZiAoaGFzQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJhbm5vdGF0aW9uZWRpdG9yc3RhdGVzY2hhbmdlZFwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgZGV0YWlsczogT2JqZWN0LmFzc2lnbih0aGlzLiNwcmV2aW91c1N0YXRlcywgZGV0YWlscylcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAjZGlzcGF0Y2hVcGRhdGVVSShkZXRhaWxzKSB7XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJhbm5vdGF0aW9uZWRpdG9ycGFyYW1zY2hhbmdlZFwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBkZXRhaWxzXG4gICAgfSk7XG4gIH1cbiAgc2V0RWRpdGluZ1N0YXRlKGlzRWRpdGluZykge1xuICAgIGlmIChpc0VkaXRpbmcpIHtcbiAgICAgIHRoaXMuI2FkZEZvY3VzTWFuYWdlcigpO1xuICAgICAgdGhpcy4jYWRkS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaXNFZGl0aW5nOiB0aGlzLiNtb2RlICE9PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FLFxuICAgICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KCksXG4gICAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9VbmRvKCksXG4gICAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9SZWRvKCksXG4gICAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3JlbW92ZUZvY3VzTWFuYWdlcigpO1xuICAgICAgdGhpcy4jcmVtb3ZlS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaXNFZGl0aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJFZGl0b3JUeXBlcyh0eXBlcykge1xuICAgIGlmICh0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNlZGl0b3JUeXBlcyA9IHR5cGVzO1xuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3JUeXBlLmRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIH1cbiAgfVxuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jaWRNYW5hZ2VyLmdldElkKCk7XG4gIH1cbiAgZ2V0IGN1cnJlbnRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy4jYWxsTGF5ZXJzLmdldCh0aGlzLiNjdXJyZW50UGFnZUluZGV4KTtcbiAgfVxuICBnZXRMYXllcihwYWdlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWxsTGF5ZXJzLmdldChwYWdlSW5kZXgpO1xuICB9XG4gIGdldCBjdXJyZW50UGFnZUluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50UGFnZUluZGV4O1xuICB9XG4gIGFkZExheWVyKGxheWVyKSB7XG4gICAgdGhpcy4jYWxsTGF5ZXJzLnNldChsYXllci5wYWdlSW5kZXgsIGxheWVyKTtcbiAgICBpZiAodGhpcy4jaXNFbmFibGVkKSB7XG4gICAgICBsYXllci5lbmFibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXIuZGlzYWJsZSgpO1xuICAgIH1cbiAgfVxuICByZW1vdmVMYXllcihsYXllcikge1xuICAgIHRoaXMuI2FsbExheWVycy5kZWxldGUobGF5ZXIucGFnZUluZGV4KTtcbiAgfVxuICB1cGRhdGVNb2RlKG1vZGUsIGVkaXRJZCA9IG51bGwpIHtcbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gbW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNtb2RlID0gbW9kZTtcbiAgICBpZiAobW9kZSA9PT0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSkge1xuICAgICAgdGhpcy5zZXRFZGl0aW5nU3RhdGUoZmFsc2UpO1xuICAgICAgdGhpcy4jZGlzYWJsZUFsbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICB0aGlzLiNlbmFibGVBbGwoKTtcbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGxheWVyLnVwZGF0ZU1vZGUobW9kZSk7XG4gICAgfVxuICAgIGlmICghZWRpdElkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9PT0gZWRpdElkKSB7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0ZWQoZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLmVudGVySW5FZGl0TW9kZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdXBkYXRlVG9vbGJhcihtb2RlKSB7XG4gICAgaWYgKG1vZGUgPT09IHRoaXMuI21vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ybW9kZVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBtb2RlXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuQ1JFQVRFKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMYXllci5hZGROZXdFZGl0b3IodHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLnVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgZWRpdG9yVHlwZS51cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZW5hYmxlV2FpdGluZyhtdXN0V2FpdCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuI2lzV2FpdGluZyA9PT0gbXVzdFdhaXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaXNXYWl0aW5nID0gbXVzdFdhaXQ7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChtdXN0V2FpdCkge1xuICAgICAgICBsYXllci5kaXNhYmxlQ2xpY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxheWVyLmVuYWJsZUNsaWNrKCk7XG4gICAgICB9XG4gICAgICBsYXllci5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcIndhaXRpbmdcIiwgbXVzdFdhaXQpO1xuICAgIH1cbiAgfVxuICAjZW5hYmxlQWxsKCkge1xuICAgIGlmICghdGhpcy4jaXNFbmFibGVkKSB7XG4gICAgICB0aGlzLiNpc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgICAgbGF5ZXIuZW5hYmxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNkaXNhYmxlQWxsKCkge1xuICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICBpZiAodGhpcy4jaXNFbmFibGVkKSB7XG4gICAgICB0aGlzLiNpc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICAgIGxheWVyLmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0RWRpdG9ycyhwYWdlSW5kZXgpIHtcbiAgICBjb25zdCBlZGl0b3JzID0gW107XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5wYWdlSW5kZXggPT09IHBhZ2VJbmRleCkge1xuICAgICAgICBlZGl0b3JzLnB1c2goZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcnM7XG4gIH1cbiAgZ2V0RWRpdG9yKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbEVkaXRvcnMuZ2V0KGlkKTtcbiAgfVxuICBhZGRFZGl0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5zZXQoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICB9XG4gIHJlbW92ZUVkaXRvcihlZGl0b3IpIHtcbiAgICB0aGlzLiNhbGxFZGl0b3JzLmRlbGV0ZShlZGl0b3IuaWQpO1xuICAgIHRoaXMudW5zZWxlY3QoZWRpdG9yKTtcbiAgICBpZiAoIWVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkIHx8ICF0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmhhcyhlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkpIHtcbiAgICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlPy5yZW1vdmUoZWRpdG9yLmlkKTtcbiAgICB9XG4gIH1cbiAgYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcikge1xuICAgIHRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuYWRkKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICBlZGl0b3IuZGVsZXRlZCA9IHRydWU7XG4gIH1cbiAgaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgIHJldHVybiB0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmhhcyhhbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgfVxuICByZW1vdmVEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKSB7XG4gICAgdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5kZWxldGUoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIGVkaXRvci5kZWxldGVkID0gZmFsc2U7XG4gIH1cbiAgI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLiNhbGxMYXllcnMuZ2V0KGVkaXRvci5wYWdlSW5kZXgpO1xuICAgIGlmIChsYXllcikge1xuICAgICAgbGF5ZXIuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIHNldEFjdGl2ZUVkaXRvcihlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jYWN0aXZlRWRpdG9yID09PSBlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yID0gZWRpdG9yO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgfVxuICB9XG4gIHRvZ2dsZVNlbGVjdGVkKGVkaXRvcikge1xuICAgIGlmICh0aGlzLiNzZWxlY3RlZEVkaXRvcnMuaGFzKGVkaXRvcikpIHtcbiAgICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcbiAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdGhpcy5oYXNTZWxlY3Rpb25cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgZWRpdG9yLnNlbGVjdCgpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzZXRTZWxlY3RlZChlZGl0b3IpIHtcbiAgICBmb3IgKGNvbnN0IGVkIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgaWYgKGVkICE9PSBlZGl0b3IpIHtcbiAgICAgICAgZWQudW5zZWxlY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmFkZChlZGl0b3IpO1xuICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgaXNTZWxlY3RlZChlZGl0b3IpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmhhcyhlZGl0b3IpO1xuICB9XG4gIHVuc2VsZWN0KGVkaXRvcikge1xuICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdGhpcy5oYXNTZWxlY3Rpb25cbiAgICB9KTtcbiAgfVxuICBnZXQgaGFzU2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuc2l6ZSAhPT0gMDtcbiAgfVxuICB1bmRvKCkge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLnVuZG8oKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvVW5kbygpLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0cnVlLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cbiAgcmVkbygpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5yZWRvKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0cnVlLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1JlZG8oKSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICB9XG4gIGFkZENvbW1hbmRzKHBhcmFtcykge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmFkZChwYXJhbXMpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdHJ1ZSxcbiAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogZmFsc2UsXG4gICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KClcbiAgICB9KTtcbiAgfVxuICAjaXNFbXB0eSgpIHtcbiAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuc2l6ZSA9PT0gMSkge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICByZXR1cm4gZWRpdG9yLmlzRW1wdHkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlbGV0ZSgpIHtcbiAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3JzID0gWy4uLnRoaXMuI3NlbGVjdGVkRWRpdG9yc107XG4gICAgY29uc3QgY21kID0gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICB0aGlzLiNhZGRFZGl0b3JUb0xheWVyKGVkaXRvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGNvbW1pdE9yUmVtb3ZlKCkge1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvcj8uY29tbWl0T3JSZW1vdmUoKTtcbiAgfVxuICBoYXNTb21ldGhpbmdUb0NvbnRyb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvciB8fCB0aGlzLmhhc1NlbGVjdGlvbjtcbiAgfVxuICAjc2VsZWN0RWRpdG9ycyhlZGl0b3JzKSB7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgaWYgKGVkaXRvci5pc0VtcHR5KCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc2VsZWN0QWxsKCkge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLmNvbW1pdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RFZGl0b3JzKHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpO1xuICB9XG4gIHVuc2VsZWN0QWxsKCkge1xuICAgIGlmICh0aGlzLiNhY3RpdmVFZGl0b3IpIHtcbiAgICAgIHRoaXMuI2FjdGl2ZUVkaXRvci5jb21taXRPclJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycyh4LCB5LCBub0NvbW1pdCA9IGZhbHNlKSB7XG4gICAgaWYgKCFub0NvbW1pdCkge1xuICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3RyYW5zbGF0aW9uWzBdICs9IHg7XG4gICAgdGhpcy4jdHJhbnNsYXRpb25bMV0gKz0geTtcbiAgICBjb25zdCBbdG90YWxYLCB0b3RhbFldID0gdGhpcy4jdHJhbnNsYXRpb247XG4gICAgY29uc3QgZWRpdG9ycyA9IFsuLi50aGlzLiNzZWxlY3RlZEVkaXRvcnNdO1xuICAgIGNvbnN0IFRJTUVfVE9fV0FJVCA9IDEwMDA7XG4gICAgaWYgKHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpO1xuICAgIH1cbiAgICB0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgICAgdGhpcy4jdHJhbnNsYXRpb25bMF0gPSB0aGlzLiN0cmFuc2xhdGlvblsxXSA9IDA7XG4gICAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0ZUluUGFnZSh0b3RhbFgsIHRvdGFsWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0ZUluUGFnZSgtdG90YWxYLCAtdG90YWxZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSwgVElNRV9UT19XQUlUKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKHgsIHkpO1xuICAgIH1cbiAgfVxuICBzZXRVcERyYWdTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdCh0cnVlKTtcbiAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMuc2V0KGVkaXRvciwge1xuICAgICAgICBzYXZlZFg6IGVkaXRvci54LFxuICAgICAgICBzYXZlZFk6IGVkaXRvci55LFxuICAgICAgICBzYXZlZFBhZ2VJbmRleDogZWRpdG9yLnBhZ2VJbmRleCxcbiAgICAgICAgbmV3WDogMCxcbiAgICAgICAgbmV3WTogMCxcbiAgICAgICAgbmV3UGFnZUluZGV4OiAtMVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGVuZERyYWdTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy4jZHJhZ2dpbmdFZGl0b3JzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuI2RyYWdnaW5nRWRpdG9ycztcbiAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMgPSBudWxsO1xuICAgIGxldCBtdXN0QmVBZGRlZEluVW5kb1N0YWNrID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBbe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwYWdlSW5kZXhcbiAgICB9LCB2YWx1ZV0gb2YgbWFwKSB7XG4gICAgICB2YWx1ZS5uZXdYID0geDtcbiAgICAgIHZhbHVlLm5ld1kgPSB5O1xuICAgICAgdmFsdWUubmV3UGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgbXVzdEJlQWRkZWRJblVuZG9TdGFjayB8fD0geCAhPT0gdmFsdWUuc2F2ZWRYIHx8IHkgIT09IHZhbHVlLnNhdmVkWSB8fCBwYWdlSW5kZXggIT09IHZhbHVlLnNhdmVkUGFnZUluZGV4O1xuICAgIH1cbiAgICBpZiAoIW11c3RCZUFkZGVkSW5VbmRvU3RhY2spIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbW92ZSA9IChlZGl0b3IsIHgsIHksIHBhZ2VJbmRleCkgPT4ge1xuICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy4jYWxsTGF5ZXJzLmdldChwYWdlSW5kZXgpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgZWRpdG9yLl9zZXRQYXJlbnRBbmRQb3NpdGlvbihwYXJlbnQsIHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgICAgICAgZWRpdG9yLnggPSB4O1xuICAgICAgICAgIGVkaXRvci55ID0geTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgbmV3WCxcbiAgICAgICAgICBuZXdZLFxuICAgICAgICAgIG5ld1BhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgbmV3WCwgbmV3WSwgbmV3UGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgc2F2ZWRYLFxuICAgICAgICAgIHNhdmVkWSxcbiAgICAgICAgICBzYXZlZFBhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgc2F2ZWRYLCBzYXZlZFksIHNhdmVkUGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZHJhZ1NlbGVjdGVkRWRpdG9ycyh0eCwgdHkpIHtcbiAgICBpZiAoIXRoaXMuI2RyYWdnaW5nRWRpdG9ycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMua2V5cygpKSB7XG4gICAgICBlZGl0b3IuZHJhZyh0eCwgdHkpO1xuICAgIH1cbiAgfVxuICByZWJ1aWxkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IucGFyZW50ID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldExheWVyKGVkaXRvci5wYWdlSW5kZXgpO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgICAgIHBhcmVudC5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpO1xuICAgICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IucGFyZW50LmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBpc0FjdGl2ZShlZGl0b3IpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yID09PSBlZGl0b3I7XG4gIH1cbiAgZ2V0QWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLiNhY3RpdmVFZGl0b3I7XG4gIH1cbiAgZ2V0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jbW9kZTtcbiAgfVxuICBnZXQgaW1hZ2VNYW5hZ2VyKCkge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImltYWdlTWFuYWdlclwiLCBuZXcgSW1hZ2VNYW5hZ2VyKCkpO1xuICB9XG59XG5leHBvcnRzLkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuU3RhdFRpbWVyID0gZXhwb3J0cy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24gPSBleHBvcnRzLlBpeGVsc1BlckluY2ggPSBleHBvcnRzLlBhZ2VWaWV3cG9ydCA9IGV4cG9ydHMuUERGRGF0ZVN0cmluZyA9IGV4cG9ydHMuRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBleHBvcnRzLkRPTVNWR0ZhY3RvcnkgPSBleHBvcnRzLkRPTUZpbHRlckZhY3RvcnkgPSBleHBvcnRzLkRPTUNhbnZhc0ZhY3RvcnkgPSBleHBvcnRzLkRPTUNNYXBSZWFkZXJGYWN0b3J5ID0gdm9pZCAwO1xuZXhwb3J0cy5kZXByZWNhdGVkID0gZGVwcmVjYXRlZDtcbmV4cG9ydHMuZ2V0Q29sb3JWYWx1ZXMgPSBnZXRDb2xvclZhbHVlcztcbmV4cG9ydHMuZ2V0Q3VycmVudFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm07XG5leHBvcnRzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlID0gZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2U7XG5leHBvcnRzLmdldEZpbGVuYW1lRnJvbVVybCA9IGdldEZpbGVuYW1lRnJvbVVybDtcbmV4cG9ydHMuZ2V0UGRmRmlsZW5hbWVGcm9tVXJsID0gZ2V0UGRmRmlsZW5hbWVGcm9tVXJsO1xuZXhwb3J0cy5nZXRSR0IgPSBnZXRSR0I7XG5leHBvcnRzLmdldFhmYVBhZ2VWaWV3cG9ydCA9IGdldFhmYVBhZ2VWaWV3cG9ydDtcbmV4cG9ydHMuaXNEYXRhU2NoZW1lID0gaXNEYXRhU2NoZW1lO1xuZXhwb3J0cy5pc1BkZkZpbGUgPSBpc1BkZkZpbGU7XG5leHBvcnRzLmlzVmFsaWRGZXRjaFVybCA9IGlzVmFsaWRGZXRjaFVybDtcbmV4cG9ydHMubG9hZFNjcmlwdCA9IGxvYWRTY3JpcHQ7XG5leHBvcnRzLm5vQ29udGV4dE1lbnUgPSBub0NvbnRleHRNZW51O1xuZXhwb3J0cy5zZXRMYXllckRpbWVuc2lvbnMgPSBzZXRMYXllckRpbWVuc2lvbnM7XG52YXIgX2Jhc2VfZmFjdG9yeSA9IF9fd19wZGZqc19yZXF1aXJlX18oNyk7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuY29uc3QgU1ZHX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuY2xhc3MgUGl4ZWxzUGVySW5jaCB7XG4gIHN0YXRpYyBDU1MgPSA5Ni4wO1xuICBzdGF0aWMgUERGID0gNzIuMDtcbiAgc3RhdGljIFBERl9UT19DU1NfVU5JVFMgPSB0aGlzLkNTUyAvIHRoaXMuUERGO1xufVxuZXhwb3J0cy5QaXhlbHNQZXJJbmNoID0gUGl4ZWxzUGVySW5jaDtcbmNsYXNzIERPTUZpbHRlckZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5LkJhc2VGaWx0ZXJGYWN0b3J5IHtcbiAgI19jYWNoZTtcbiAgI19kZWZzO1xuICAjZG9jSWQ7XG4gICNkb2N1bWVudDtcbiAgI2hjbUZpbHRlcjtcbiAgI2hjbUtleTtcbiAgI2hjbVVybDtcbiAgI2hjbUhpZ2hsaWdodEZpbHRlcjtcbiAgI2hjbUhpZ2hsaWdodEtleTtcbiAgI2hjbUhpZ2hsaWdodFVybDtcbiAgI2lkID0gMDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRvY0lkLFxuICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jZG9jSWQgPSBkb2NJZDtcbiAgICB0aGlzLiNkb2N1bWVudCA9IG93bmVyRG9jdW1lbnQ7XG4gIH1cbiAgZ2V0ICNjYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jX2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0ICNkZWZzKCkge1xuICAgIGlmICghdGhpcy4jX2RlZnMpIHtcbiAgICAgIGNvbnN0IGRpdiA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0eWxlXG4gICAgICB9ID0gZGl2O1xuICAgICAgc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICBzdHlsZS5jb250YWluID0gXCJzdHJpY3RcIjtcbiAgICAgIHN0eWxlLndpZHRoID0gc3R5bGUuaGVpZ2h0ID0gMDtcbiAgICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgc3R5bGUudG9wID0gc3R5bGUubGVmdCA9IDA7XG4gICAgICBzdHlsZS56SW5kZXggPSAtMTtcbiAgICAgIGNvbnN0IHN2ZyA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwic3ZnXCIpO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDApO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCAwKTtcbiAgICAgIHRoaXMuI19kZWZzID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJkZWZzXCIpO1xuICAgICAgZGl2LmFwcGVuZChzdmcpO1xuICAgICAgc3ZnLmFwcGVuZCh0aGlzLiNfZGVmcyk7XG4gICAgICB0aGlzLiNkb2N1bWVudC5ib2R5LmFwcGVuZChkaXYpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jX2RlZnM7XG4gIH1cbiAgYWRkRmlsdGVyKG1hcHMpIHtcbiAgICBpZiAoIW1hcHMpIHtcbiAgICAgIHJldHVybiBcIm5vbmVcIjtcbiAgICB9XG4gICAgbGV0IHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KG1hcHMpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgdGFibGVSLCB0YWJsZUcsIHRhYmxlQiwga2V5O1xuICAgIGlmIChtYXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgbWFwUiA9IG1hcHNbMF07XG4gICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgYnVmZmVyW2ldID0gbWFwUltpXSAvIDI1NTtcbiAgICAgIH1cbiAgICAgIGtleSA9IHRhYmxlUiA9IHRhYmxlRyA9IHRhYmxlQiA9IGJ1ZmZlci5qb2luKFwiLFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW21hcFIsIG1hcEcsIG1hcEJdID0gbWFwcztcbiAgICAgIGNvbnN0IGJ1ZmZlclIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGNvbnN0IGJ1ZmZlckcgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGNvbnN0IGJ1ZmZlckIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgYnVmZmVyUltpXSA9IG1hcFJbaV0gLyAyNTU7XG4gICAgICAgIGJ1ZmZlckdbaV0gPSBtYXBHW2ldIC8gMjU1O1xuICAgICAgICBidWZmZXJCW2ldID0gbWFwQltpXSAvIDI1NTtcbiAgICAgIH1cbiAgICAgIHRhYmxlUiA9IGJ1ZmZlclIuam9pbihcIixcIik7XG4gICAgICB0YWJsZUcgPSBidWZmZXJHLmpvaW4oXCIsXCIpO1xuICAgICAgdGFibGVCID0gYnVmZmVyQi5qb2luKFwiLFwiKTtcbiAgICAgIGtleSA9IGAke3RhYmxlUn0ke3RhYmxlR30ke3RhYmxlQn1gO1xuICAgIH1cbiAgICB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KG1hcHMsIHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV90cmFuc2Zlcl9tYXBfJHt0aGlzLiNpZCsrfWA7XG4gICAgY29uc3QgdXJsID0gYHVybCgjJHtpZH0pYDtcbiAgICB0aGlzLiNjYWNoZS5zZXQobWFwcywgdXJsKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCB1cmwpO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHRhYmxlUiwgdGFibGVHLCB0YWJsZUIsIGZpbHRlcik7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBhZGRIQ01GaWx0ZXIoZmdDb2xvciwgYmdDb2xvcikge1xuICAgIGNvbnN0IGtleSA9IGAke2ZnQ29sb3J9LSR7YmdDb2xvcn1gO1xuICAgIGlmICh0aGlzLiNoY21LZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuI2hjbVVybDtcbiAgICB9XG4gICAgdGhpcy4jaGNtS2V5ID0ga2V5O1xuICAgIHRoaXMuI2hjbVVybCA9IFwibm9uZVwiO1xuICAgIHRoaXMuI2hjbUZpbHRlcj8ucmVtb3ZlKCk7XG4gICAgaWYgKCFmZ0NvbG9yIHx8ICFiZ0NvbG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy4jaGNtVXJsO1xuICAgIH1cbiAgICBjb25zdCBmZ1JHQiA9IHRoaXMuI2dldFJHQihmZ0NvbG9yKTtcbiAgICBmZ0NvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoLi4uZmdSR0IpO1xuICAgIGNvbnN0IGJnUkdCID0gdGhpcy4jZ2V0UkdCKGJnQ29sb3IpO1xuICAgIGJnQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvciguLi5iZ1JHQik7XG4gICAgdGhpcy4jZGVmcy5zdHlsZS5jb2xvciA9IFwiXCI7XG4gICAgaWYgKGZnQ29sb3IgPT09IFwiIzAwMDAwMFwiICYmIGJnQ29sb3IgPT09IFwiI2ZmZmZmZlwiIHx8IGZnQ29sb3IgPT09IGJnQ29sb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLiNoY21Vcmw7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDI1NTsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gaSAvIDI1NTtcbiAgICAgIG1hcFtpXSA9IHggPD0gMC4wMzkyOCA/IHggLyAxMi45MiA6ICgoeCArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQ7XG4gICAgfVxuICAgIGNvbnN0IHRhYmxlID0gbWFwLmpvaW4oXCIsXCIpO1xuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1faGNtX2ZpbHRlcmA7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jaGNtSGlnaGxpZ2h0RmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24odGFibGUsIHRhYmxlLCB0YWJsZSwgZmlsdGVyKTtcbiAgICB0aGlzLiNhZGRHcmF5Q29udmVyc2lvbihmaWx0ZXIpO1xuICAgIGNvbnN0IGdldFN0ZXBzID0gKGMsIG4pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gZmdSR0JbY10gLyAyNTU7XG4gICAgICBjb25zdCBlbmQgPSBiZ1JHQltjXSAvIDI1NTtcbiAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheShuICsgMSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gc3RhcnQgKyBpIC8gbiAqIChlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyLmpvaW4oXCIsXCIpO1xuICAgIH07XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKGdldFN0ZXBzKDAsIDUpLCBnZXRTdGVwcygxLCA1KSwgZ2V0U3RlcHMoMiwgNSksIGZpbHRlcik7XG4gICAgdGhpcy4jaGNtVXJsID0gYHVybCgjJHtpZH0pYDtcbiAgICByZXR1cm4gdGhpcy4jaGNtVXJsO1xuICB9XG4gIGFkZEhpZ2hsaWdodEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yLCBuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmdDb2xvcn0tJHtiZ0NvbG9yfS0ke25ld0ZnQ29sb3J9LSR7bmV3QmdDb2xvcn1gO1xuICAgIGlmICh0aGlzLiNoY21IaWdobGlnaHRLZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuI2hjbUhpZ2hsaWdodFVybDtcbiAgICB9XG4gICAgdGhpcy4jaGNtSGlnaGxpZ2h0S2V5ID0ga2V5O1xuICAgIHRoaXMuI2hjbUhpZ2hsaWdodFVybCA9IFwibm9uZVwiO1xuICAgIHRoaXMuI2hjbUhpZ2hsaWdodEZpbHRlcj8ucmVtb3ZlKCk7XG4gICAgaWYgKCFmZ0NvbG9yIHx8ICFiZ0NvbG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy4jaGNtSGlnaGxpZ2h0VXJsO1xuICAgIH1cbiAgICBjb25zdCBbZmdSR0IsIGJnUkdCXSA9IFtmZ0NvbG9yLCBiZ0NvbG9yXS5tYXAodGhpcy4jZ2V0UkdCLmJpbmQodGhpcykpO1xuICAgIGxldCBmZ0dyYXkgPSBNYXRoLnJvdW5kKDAuMjEyNiAqIGZnUkdCWzBdICsgMC43MTUyICogZmdSR0JbMV0gKyAwLjA3MjIgKiBmZ1JHQlsyXSk7XG4gICAgbGV0IGJnR3JheSA9IE1hdGgucm91bmQoMC4yMTI2ICogYmdSR0JbMF0gKyAwLjcxNTIgKiBiZ1JHQlsxXSArIDAuMDcyMiAqIGJnUkdCWzJdKTtcbiAgICBsZXQgW25ld0ZnUkdCLCBuZXdCZ1JHQl0gPSBbbmV3RmdDb2xvciwgbmV3QmdDb2xvcl0ubWFwKHRoaXMuI2dldFJHQi5iaW5kKHRoaXMpKTtcbiAgICBpZiAoYmdHcmF5IDwgZmdHcmF5KSB7XG4gICAgICBbZmdHcmF5LCBiZ0dyYXksIG5ld0ZnUkdCLCBuZXdCZ1JHQl0gPSBbYmdHcmF5LCBmZ0dyYXksIG5ld0JnUkdCLCBuZXdGZ1JHQl07XG4gICAgfVxuICAgIHRoaXMuI2RlZnMuc3R5bGUuY29sb3IgPSBcIlwiO1xuICAgIGNvbnN0IGdldFN0ZXBzID0gKGZnLCBiZywgbikgPT4ge1xuICAgICAgY29uc3QgYXJyID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICBjb25zdCBzdGVwID0gKGJnR3JheSAtIGZnR3JheSkgLyBuO1xuICAgICAgY29uc3QgbmV3U3RhcnQgPSBmZyAvIDI1NTtcbiAgICAgIGNvbnN0IG5ld1N0ZXAgPSAoYmcgLSBmZykgLyAoMjU1ICogbik7XG4gICAgICBsZXQgcHJldiA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgY29uc3QgayA9IE1hdGgucm91bmQoZmdHcmF5ICsgaSAqIHN0ZXApO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG5ld1N0YXJ0ICsgaSAqIG5ld1N0ZXA7XG4gICAgICAgIGZvciAobGV0IGogPSBwcmV2OyBqIDw9IGs7IGorKykge1xuICAgICAgICAgIGFycltqXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHByZXYgPSBrICsgMTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSBwcmV2OyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYXJyW3ByZXYgLSAxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnIuam9pbihcIixcIik7XG4gICAgfTtcbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2hjbV9oaWdobGlnaHRfZmlsdGVyYDtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNoY21IaWdobGlnaHRGaWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcik7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKGdldFN0ZXBzKG5ld0ZnUkdCWzBdLCBuZXdCZ1JHQlswXSwgNSksIGdldFN0ZXBzKG5ld0ZnUkdCWzFdLCBuZXdCZ1JHQlsxXSwgNSksIGdldFN0ZXBzKG5ld0ZnUkdCWzJdLCBuZXdCZ1JHQlsyXSwgNSksIGZpbHRlcik7XG4gICAgdGhpcy4jaGNtSGlnaGxpZ2h0VXJsID0gYHVybCgjJHtpZH0pYDtcbiAgICByZXR1cm4gdGhpcy4jaGNtSGlnaGxpZ2h0VXJsO1xuICB9XG4gIGRlc3Ryb3koa2VlcEhDTSA9IGZhbHNlKSB7XG4gICAgaWYgKGtlZXBIQ00gJiYgKHRoaXMuI2hjbVVybCB8fCB0aGlzLiNoY21IaWdobGlnaHRVcmwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNfZGVmcykge1xuICAgICAgdGhpcy4jX2RlZnMucGFyZW50Tm9kZS5wYXJlbnROb2RlLnJlbW92ZSgpO1xuICAgICAgdGhpcy4jX2RlZnMgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy4jX2NhY2hlKSB7XG4gICAgICB0aGlzLiNfY2FjaGUuY2xlYXIoKTtcbiAgICAgIHRoaXMuI19jYWNoZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI2lkID0gMDtcbiAgfVxuICAjYWRkR3JheUNvbnZlcnNpb24oZmlsdGVyKSB7XG4gICAgY29uc3QgZmVDb2xvck1hdHJpeCA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmVDb2xvck1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJtYXRyaXhcIik7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZXNcIiwgXCIwLjIxMjYgMC43MTUyIDAuMDcyMiAwIDAgMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIDAuMjEyNiAwLjcxNTIgMC4wNzIyIDAgMCAwIDAgMCAxIDBcIik7XG4gICAgZmlsdGVyLmFwcGVuZChmZUNvbG9yTWF0cml4KTtcbiAgfVxuICAjY3JlYXRlRmlsdGVyKGlkKSB7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmaWx0ZXJcIik7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZShcImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyc1wiLCBcInNSR0JcIik7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZShcImlkXCIsIGlkKTtcbiAgICB0aGlzLiNkZWZzLmFwcGVuZChmaWx0ZXIpO1xuICAgIHJldHVybiBmaWx0ZXI7XG4gIH1cbiAgI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBmdW5jLCB0YWJsZSkge1xuICAgIGNvbnN0IGZlRnVuYyA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIGZ1bmMpO1xuICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiZGlzY3JldGVcIik7XG4gICAgZmVGdW5jLnNldEF0dHJpYnV0ZShcInRhYmxlVmFsdWVzXCIsIHRhYmxlKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLmFwcGVuZChmZUZ1bmMpO1xuICB9XG4gICNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oclRhYmxlLCBnVGFibGUsIGJUYWJsZSwgZmlsdGVyKSB7XG4gICAgY29uc3QgZmVDb21wb25lbnRUcmFuc2ZlciA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmVDb21wb25lbnRUcmFuc2ZlclwiKTtcbiAgICBmaWx0ZXIuYXBwZW5kKGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY1JcIiwgclRhYmxlKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNHXCIsIGdUYWJsZSk7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jQlwiLCBiVGFibGUpO1xuICB9XG4gICNnZXRSR0IoY29sb3IpIHtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgcmV0dXJuIGdldFJHQihnZXRDb21wdXRlZFN0eWxlKHRoaXMuI2RlZnMpLmdldFByb3BlcnR5VmFsdWUoXCJjb2xvclwiKSk7XG4gIH1cbn1cbmV4cG9ydHMuRE9NRmlsdGVyRmFjdG9yeSA9IERPTUZpbHRlckZhY3Rvcnk7XG5jbGFzcyBET01DYW52YXNGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlQ2FudmFzRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudFxuICB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgfVxuICBfY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxufVxuZXhwb3J0cy5ET01DYW52YXNGYWN0b3J5ID0gRE9NQ2FudmFzRmFjdG9yeTtcbmFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YSh1cmwsIGFzVHlwZWRBcnJheSA9IGZhbHNlKSB7XG4gIGlmIChpc1ZhbGlkRmV0Y2hVcmwodXJsLCBkb2N1bWVudC5iYXNlVVJJKSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBhc1R5cGVkQXJyYXkgPyBuZXcgVWludDhBcnJheShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKSA6ICgwLCBfdXRpbC5zdHJpbmdUb0J5dGVzKShhd2FpdCByZXNwb25zZS50ZXh0KCkpO1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xuICAgIGlmIChhc1R5cGVkQXJyYXkpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgIH1cbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDAgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGlmIChhc1R5cGVkQXJyYXkgJiYgcmVxdWVzdC5yZXNwb25zZSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgfSBlbHNlIGlmICghYXNUeXBlZEFycmF5ICYmIHJlcXVlc3QucmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgZGF0YSA9ICgwLCBfdXRpbC5zdHJpbmdUb0J5dGVzKShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXF1ZXN0LnN0YXR1c1RleHQpKTtcbiAgICB9O1xuICAgIHJlcXVlc3Quc2VuZChudWxsKTtcbiAgfSk7XG59XG5jbGFzcyBET01DTWFwUmVhZGVyRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnkuQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgX2ZldGNoRGF0YSh1cmwsIGNvbXByZXNzaW9uVHlwZSkge1xuICAgIHJldHVybiBmZXRjaERhdGEodXJsLCB0aGlzLmlzQ29tcHJlc3NlZCkudGhlbihkYXRhID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNNYXBEYXRhOiBkYXRhLFxuICAgICAgICBjb21wcmVzc2lvblR5cGVcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn1cbmV4cG9ydHMuRE9NQ01hcFJlYWRlckZhY3RvcnkgPSBET01DTWFwUmVhZGVyRmFjdG9yeTtcbmNsYXNzIERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkge1xuICBfZmV0Y2hEYXRhKHVybCkge1xuICAgIHJldHVybiBmZXRjaERhdGEodXJsLCB0cnVlKTtcbiAgfVxufVxuZXhwb3J0cy5ET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuY2xhc3MgRE9NU1ZHRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnkuQmFzZVNWR0ZhY3Rvcnkge1xuICBfY3JlYXRlU1ZHKHR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgdHlwZSk7XG4gIH1cbn1cbmV4cG9ydHMuRE9NU1ZHRmFjdG9yeSA9IERPTVNWR0ZhY3Rvcnk7XG5jbGFzcyBQYWdlVmlld3BvcnQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdmlld0JveCxcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvbixcbiAgICBvZmZzZXRYID0gMCxcbiAgICBvZmZzZXRZID0gMCxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLnZpZXdCb3ggPSB2aWV3Qm94O1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy5vZmZzZXRYID0gb2Zmc2V0WDtcbiAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZO1xuICAgIGNvbnN0IGNlbnRlclggPSAodmlld0JveFsyXSArIHZpZXdCb3hbMF0pIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gKHZpZXdCb3hbM10gKyB2aWV3Qm94WzFdKSAvIDI7XG4gICAgbGV0IHJvdGF0ZUEsIHJvdGF0ZUIsIHJvdGF0ZUMsIHJvdGF0ZUQ7XG4gICAgcm90YXRpb24gJT0gMzYwO1xuICAgIGlmIChyb3RhdGlvbiA8IDApIHtcbiAgICAgIHJvdGF0aW9uICs9IDM2MDtcbiAgICB9XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJvdGF0ZUEgPSAtMTtcbiAgICAgICAgcm90YXRlQiA9IDA7XG4gICAgICAgIHJvdGF0ZUMgPSAwO1xuICAgICAgICByb3RhdGVEID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByb3RhdGVBID0gMDtcbiAgICAgICAgcm90YXRlQiA9IDE7XG4gICAgICAgIHJvdGF0ZUMgPSAxO1xuICAgICAgICByb3RhdGVEID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcm90YXRlQSA9IDA7XG4gICAgICAgIHJvdGF0ZUIgPSAtMTtcbiAgICAgICAgcm90YXRlQyA9IC0xO1xuICAgICAgICByb3RhdGVEID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJvdGF0ZUEgPSAxO1xuICAgICAgICByb3RhdGVCID0gMDtcbiAgICAgICAgcm90YXRlQyA9IDA7XG4gICAgICAgIHJvdGF0ZUQgPSAtMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYWdlVmlld3BvcnQ6IEludmFsaWQgcm90YXRpb24sIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA5MCBkZWdyZWVzLlwiKTtcbiAgICB9XG4gICAgaWYgKGRvbnRGbGlwKSB7XG4gICAgICByb3RhdGVDID0gLXJvdGF0ZUM7XG4gICAgICByb3RhdGVEID0gLXJvdGF0ZUQ7XG4gICAgfVxuICAgIGxldCBvZmZzZXRDYW52YXNYLCBvZmZzZXRDYW52YXNZO1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuICAgIGlmIChyb3RhdGVBID09PSAwKSB7XG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWSAtIHZpZXdCb3hbMV0pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgIHdpZHRoID0gKHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAqIHNjYWxlO1xuICAgICAgaGVpZ2h0ID0gKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWCAtIHZpZXdCb3hbMF0pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclkgLSB2aWV3Qm94WzFdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgIHdpZHRoID0gKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xuICAgICAgaGVpZ2h0ID0gKHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAqIHNjYWxlO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zZm9ybSA9IFtyb3RhdGVBICogc2NhbGUsIHJvdGF0ZUIgKiBzY2FsZSwgcm90YXRlQyAqIHNjYWxlLCByb3RhdGVEICogc2NhbGUsIG9mZnNldENhbnZhc1ggLSByb3RhdGVBICogc2NhbGUgKiBjZW50ZXJYIC0gcm90YXRlQyAqIHNjYWxlICogY2VudGVyWSwgb2Zmc2V0Q2FudmFzWSAtIHJvdGF0ZUIgKiBzY2FsZSAqIGNlbnRlclggLSByb3RhdGVEICogc2NhbGUgKiBjZW50ZXJZXTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgZ2V0IHJhd0RpbXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmlld0JveFxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcInJhd0RpbXNcIiwge1xuICAgICAgcGFnZVdpZHRoOiB2aWV3Qm94WzJdIC0gdmlld0JveFswXSxcbiAgICAgIHBhZ2VIZWlnaHQ6IHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdLFxuICAgICAgcGFnZVg6IHZpZXdCb3hbMF0sXG4gICAgICBwYWdlWTogdmlld0JveFsxXVxuICAgIH0pO1xuICB9XG4gIGNsb25lKHtcbiAgICBzY2FsZSA9IHRoaXMuc2NhbGUsXG4gICAgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uLFxuICAgIG9mZnNldFggPSB0aGlzLm9mZnNldFgsXG4gICAgb2Zmc2V0WSA9IHRoaXMub2Zmc2V0WSxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBuZXcgUGFnZVZpZXdwb3J0KHtcbiAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveC5zbGljZSgpLFxuICAgICAgc2NhbGUsXG4gICAgICByb3RhdGlvbixcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgZG9udEZsaXBcbiAgICB9KTtcbiAgfVxuICBjb252ZXJ0VG9WaWV3cG9ydFBvaW50KHgsIHkpIHtcbiAgICByZXR1cm4gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbeCwgeV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgfVxuICBjb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZShyZWN0KSB7XG4gICAgY29uc3QgdG9wTGVmdCA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3JlY3RbMF0sIHJlY3RbMV1dLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgY29uc3QgYm90dG9tUmlnaHQgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzJdLCByZWN0WzNdXSwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIHJldHVybiBbdG9wTGVmdFswXSwgdG9wTGVmdFsxXSwgYm90dG9tUmlnaHRbMF0sIGJvdHRvbVJpZ2h0WzFdXTtcbiAgfVxuICBjb252ZXJ0VG9QZGZQb2ludCh4LCB5KSB7XG4gICAgcmV0dXJuIF91dGlsLlV0aWwuYXBwbHlJbnZlcnNlVHJhbnNmb3JtKFt4LCB5XSwgdGhpcy50cmFuc2Zvcm0pO1xuICB9XG59XG5leHBvcnRzLlBhZ2VWaWV3cG9ydCA9IFBhZ2VWaWV3cG9ydDtcbmNsYXNzIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiBleHRlbmRzIF91dGlsLkJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGV4dHJhRGVsYXkgPSAwKSB7XG4gICAgc3VwZXIobXNnLCBcIlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLmV4dHJhRGVsYXkgPSBleHRyYURlbGF5O1xuICB9XG59XG5leHBvcnRzLlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiA9IFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbjtcbmZ1bmN0aW9uIGlzRGF0YVNjaGVtZSh1cmwpIHtcbiAgY29uc3QgaWkgPSB1cmwubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgaWkgJiYgdXJsW2ldLnRyaW0oKSA9PT0gXCJcIikge1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gdXJsLnN1YnN0cmluZyhpLCBpICsgNSkudG9Mb3dlckNhc2UoKSA9PT0gXCJkYXRhOlwiO1xufVxuZnVuY3Rpb24gaXNQZGZGaWxlKGZpbGVuYW1lKSB7XG4gIHJldHVybiB0eXBlb2YgZmlsZW5hbWUgPT09IFwic3RyaW5nXCIgJiYgL1xcLnBkZiQvaS50ZXN0KGZpbGVuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEZpbGVuYW1lRnJvbVVybCh1cmwsIG9ubHlTdHJpcFBhdGggPSBmYWxzZSkge1xuICBpZiAoIW9ubHlTdHJpcFBhdGgpIHtcbiAgICBbdXJsXSA9IHVybC5zcGxpdCgvWyM/XS8sIDEpO1xuICB9XG4gIHJldHVybiB1cmwuc3Vic3RyaW5nKHVybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbn1cbmZ1bmN0aW9uIGdldFBkZkZpbGVuYW1lRnJvbVVybCh1cmwsIGRlZmF1bHRGaWxlbmFtZSA9IFwiZG9jdW1lbnQucGRmXCIpIHtcbiAgaWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xuICB9XG4gIGlmIChpc0RhdGFTY2hlbWUodXJsKSkge1xuICAgICgwLCBfdXRpbC53YXJuKSgnZ2V0UGRmRmlsZW5hbWVGcm9tVXJsOiBpZ25vcmUgXCJkYXRhOlwiLVVSTCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4nKTtcbiAgICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xuICB9XG4gIGNvbnN0IHJlVVJJID0gL14oPzooPzpbXjpdKzopP1xcL1xcL1teL10rKT8oW14/I10qKShcXD9bXiNdKik/KCMuKik/JC87XG4gIGNvbnN0IHJlRmlsZW5hbWUgPSAvW14vPyM9XStcXC5wZGZcXGIoPyEuKlxcLnBkZlxcYikvaTtcbiAgY29uc3Qgc3BsaXRVUkkgPSByZVVSSS5leGVjKHVybCk7XG4gIGxldCBzdWdnZXN0ZWRGaWxlbmFtZSA9IHJlRmlsZW5hbWUuZXhlYyhzcGxpdFVSSVsxXSkgfHwgcmVGaWxlbmFtZS5leGVjKHNwbGl0VVJJWzJdKSB8fCByZUZpbGVuYW1lLmV4ZWMoc3BsaXRVUklbM10pO1xuICBpZiAoc3VnZ2VzdGVkRmlsZW5hbWUpIHtcbiAgICBzdWdnZXN0ZWRGaWxlbmFtZSA9IHN1Z2dlc3RlZEZpbGVuYW1lWzBdO1xuICAgIGlmIChzdWdnZXN0ZWRGaWxlbmFtZS5pbmNsdWRlcyhcIiVcIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN1Z2dlc3RlZEZpbGVuYW1lID0gcmVGaWxlbmFtZS5leGVjKGRlY29kZVVSSUNvbXBvbmVudChzdWdnZXN0ZWRGaWxlbmFtZSkpWzBdO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3VnZ2VzdGVkRmlsZW5hbWUgfHwgZGVmYXVsdEZpbGVuYW1lO1xufVxuY2xhc3MgU3RhdFRpbWVyIHtcbiAgc3RhcnRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRpbWVzID0gW107XG4gIHRpbWUobmFtZSkge1xuICAgIGlmIChuYW1lIGluIHRoaXMuc3RhcnRlZCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKGBUaW1lciBpcyBhbHJlYWR5IHJ1bm5pbmcgZm9yICR7bmFtZX1gKTtcbiAgICB9XG4gICAgdGhpcy5zdGFydGVkW25hbWVdID0gRGF0ZS5ub3coKTtcbiAgfVxuICB0aW1lRW5kKG5hbWUpIHtcbiAgICBpZiAoIShuYW1lIGluIHRoaXMuc3RhcnRlZCkpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShgVGltZXIgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgZm9yICR7bmFtZX1gKTtcbiAgICB9XG4gICAgdGhpcy50aW1lcy5wdXNoKHtcbiAgICAgIG5hbWUsXG4gICAgICBzdGFydDogdGhpcy5zdGFydGVkW25hbWVdLFxuICAgICAgZW5kOiBEYXRlLm5vdygpXG4gICAgfSk7XG4gICAgZGVsZXRlIHRoaXMuc3RhcnRlZFtuYW1lXTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBvdXRCdWYgPSBbXTtcbiAgICBsZXQgbG9uZ2VzdCA9IDA7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBuYW1lXG4gICAgfSBvZiB0aGlzLnRpbWVzKSB7XG4gICAgICBsb25nZXN0ID0gTWF0aC5tYXgobmFtZS5sZW5ndGgsIGxvbmdlc3QpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH0gb2YgdGhpcy50aW1lcykge1xuICAgICAgb3V0QnVmLnB1c2goYCR7bmFtZS5wYWRFbmQobG9uZ2VzdCl9ICR7ZW5kIC0gc3RhcnR9bXNcXG5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dEJ1Zi5qb2luKFwiXCIpO1xuICB9XG59XG5leHBvcnRzLlN0YXRUaW1lciA9IFN0YXRUaW1lcjtcbmZ1bmN0aW9uIGlzVmFsaWRGZXRjaFVybCh1cmwsIGJhc2VVcmwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7XG4gICAgICBwcm90b2NvbFxuICAgIH0gPSBiYXNlVXJsID8gbmV3IFVSTCh1cmwsIGJhc2VVcmwpIDogbmV3IFVSTCh1cmwpO1xuICAgIHJldHVybiBwcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IHByb3RvY29sID09PSBcImh0dHBzOlwiO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vQ29udGV4dE1lbnUoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5mdW5jdGlvbiBsb2FkU2NyaXB0KHNyYywgcmVtb3ZlU2NyaXB0RWxlbWVudCA9IGZhbHNlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICBzY3JpcHQuc3JjID0gc3JjO1xuICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAocmVtb3ZlU2NyaXB0RWxlbWVudCkge1xuICAgICAgICBzY3JpcHQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICByZXNvbHZlKGV2dCk7XG4gICAgfTtcbiAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoYENhbm5vdCBsb2FkIHNjcmlwdCBhdDogJHtzY3JpcHQuc3JjfWApKTtcbiAgICB9O1xuICAgIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuYXBwZW5kKHNjcmlwdCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZGVwcmVjYXRlZChkZXRhaWxzKSB7XG4gIGNvbnNvbGUubG9nKFwiRGVwcmVjYXRlZCBBUEkgdXNhZ2U6IFwiICsgZGV0YWlscyk7XG59XG5sZXQgcGRmRGF0ZVN0cmluZ1JlZ2V4O1xuY2xhc3MgUERGRGF0ZVN0cmluZyB7XG4gIHN0YXRpYyB0b0RhdGVPYmplY3QoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0IHx8IHR5cGVvZiBpbnB1dCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBkZkRhdGVTdHJpbmdSZWdleCB8fD0gbmV3IFJlZ0V4cChcIl5EOlwiICsgXCIoXFxcXGR7NH0pXCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihbWnwrfC1dKT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIik7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHBkZkRhdGVTdHJpbmdSZWdleC5leGVjKGlucHV0KTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB5ZWFyID0gcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApO1xuICAgIGxldCBtb250aCA9IHBhcnNlSW50KG1hdGNoZXNbMl0sIDEwKTtcbiAgICBtb250aCA9IG1vbnRoID49IDEgJiYgbW9udGggPD0gMTIgPyBtb250aCAtIDEgOiAwO1xuICAgIGxldCBkYXkgPSBwYXJzZUludChtYXRjaGVzWzNdLCAxMCk7XG4gICAgZGF5ID0gZGF5ID49IDEgJiYgZGF5IDw9IDMxID8gZGF5IDogMTtcbiAgICBsZXQgaG91ciA9IHBhcnNlSW50KG1hdGNoZXNbNF0sIDEwKTtcbiAgICBob3VyID0gaG91ciA+PSAwICYmIGhvdXIgPD0gMjMgPyBob3VyIDogMDtcbiAgICBsZXQgbWludXRlID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuICAgIG1pbnV0ZSA9IG1pbnV0ZSA+PSAwICYmIG1pbnV0ZSA8PSA1OSA/IG1pbnV0ZSA6IDA7XG4gICAgbGV0IHNlY29uZCA9IHBhcnNlSW50KG1hdGNoZXNbNl0sIDEwKTtcbiAgICBzZWNvbmQgPSBzZWNvbmQgPj0gMCAmJiBzZWNvbmQgPD0gNTkgPyBzZWNvbmQgOiAwO1xuICAgIGNvbnN0IHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9IG1hdGNoZXNbN10gfHwgXCJaXCI7XG4gICAgbGV0IG9mZnNldEhvdXIgPSBwYXJzZUludChtYXRjaGVzWzhdLCAxMCk7XG4gICAgb2Zmc2V0SG91ciA9IG9mZnNldEhvdXIgPj0gMCAmJiBvZmZzZXRIb3VyIDw9IDIzID8gb2Zmc2V0SG91ciA6IDA7XG4gICAgbGV0IG9mZnNldE1pbnV0ZSA9IHBhcnNlSW50KG1hdGNoZXNbOV0sIDEwKSB8fCAwO1xuICAgIG9mZnNldE1pbnV0ZSA9IG9mZnNldE1pbnV0ZSA+PSAwICYmIG9mZnNldE1pbnV0ZSA8PSA1OSA/IG9mZnNldE1pbnV0ZSA6IDA7XG4gICAgaWYgKHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9PT0gXCItXCIpIHtcbiAgICAgIGhvdXIgKz0gb2Zmc2V0SG91cjtcbiAgICAgIG1pbnV0ZSArPSBvZmZzZXRNaW51dGU7XG4gICAgfSBlbHNlIGlmICh1bml2ZXJzYWxUaW1lUmVsYXRpb24gPT09IFwiK1wiKSB7XG4gICAgICBob3VyIC09IG9mZnNldEhvdXI7XG4gICAgICBtaW51dGUgLT0gb2Zmc2V0TWludXRlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQpKTtcbiAgfVxufVxuZXhwb3J0cy5QREZEYXRlU3RyaW5nID0gUERGRGF0ZVN0cmluZztcbmZ1bmN0aW9uIGdldFhmYVBhZ2VWaWV3cG9ydCh4ZmFQYWdlLCB7XG4gIHNjYWxlID0gMSxcbiAgcm90YXRpb24gPSAwXG59KSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IHhmYVBhZ2UuYXR0cmlidXRlcy5zdHlsZTtcbiAgY29uc3Qgdmlld0JveCA9IFswLCAwLCBwYXJzZUludCh3aWR0aCksIHBhcnNlSW50KGhlaWdodCldO1xuICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgdmlld0JveCxcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvblxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJHQihjb2xvcikge1xuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICBjb25zdCBjb2xvclJHQiA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDEpLCAxNik7XG4gICAgcmV0dXJuIFsoY29sb3JSR0IgJiAweGZmMDAwMCkgPj4gMTYsIChjb2xvclJHQiAmIDB4MDBmZjAwKSA+PiA4LCBjb2xvclJHQiAmIDB4MDAwMGZmXTtcbiAgfVxuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcInJnYihcIikpIHtcbiAgICByZXR1cm4gY29sb3Iuc2xpY2UoNCwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoeCA9PiBwYXJzZUludCh4KSk7XG4gIH1cbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCJyZ2JhKFwiKSkge1xuICAgIHJldHVybiBjb2xvci5zbGljZSg1LCAtMSkuc3BsaXQoXCIsXCIpLm1hcCh4ID0+IHBhcnNlSW50KHgpKS5zbGljZSgwLCAzKTtcbiAgfVxuICAoMCwgX3V0aWwud2FybikoYE5vdCBhIHZhbGlkIGNvbG9yIGZvcm1hdDogXCIke2NvbG9yfVwiYCk7XG4gIHJldHVybiBbMCwgMCwgMF07XG59XG5mdW5jdGlvbiBnZXRDb2xvclZhbHVlcyhjb2xvcnMpIHtcbiAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICBzcGFuLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZChzcGFuKTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIGNvbG9ycy5rZXlzKCkpIHtcbiAgICBzcGFuLnN0eWxlLmNvbG9yID0gbmFtZTtcbiAgICBjb25zdCBjb21wdXRlZENvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3BhbikuY29sb3I7XG4gICAgY29sb3JzLnNldChuYW1lLCBnZXRSR0IoY29tcHV0ZWRDb2xvcikpO1xuICB9XG4gIHNwYW4ucmVtb3ZlKCk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCkge1xuICBjb25zdCB7XG4gICAgYSxcbiAgICBiLFxuICAgIGMsXG4gICAgZCxcbiAgICBlLFxuICAgIGZcbiAgfSA9IGN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgcmV0dXJuIFthLCBiLCBjLCBkLCBlLCBmXTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCkge1xuICBjb25zdCB7XG4gICAgYSxcbiAgICBiLFxuICAgIGMsXG4gICAgZCxcbiAgICBlLFxuICAgIGZcbiAgfSA9IGN0eC5nZXRUcmFuc2Zvcm0oKS5pbnZlcnRTZWxmKCk7XG4gIHJldHVybiBbYSwgYiwgYywgZCwgZSwgZl07XG59XG5mdW5jdGlvbiBzZXRMYXllckRpbWVuc2lvbnMoZGl2LCB2aWV3cG9ydCwgbXVzdEZsaXAgPSBmYWxzZSwgbXVzdFJvdGF0ZSA9IHRydWUpIHtcbiAgaWYgKHZpZXdwb3J0IGluc3RhbmNlb2YgUGFnZVZpZXdwb3J0KSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodFxuICAgIH0gPSB2aWV3cG9ydC5yYXdEaW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGRpdjtcbiAgICBjb25zdCB1c2VSb3VuZCA9IF91dGlsLkZlYXR1cmVUZXN0LmlzQ1NTUm91bmRTdXBwb3J0ZWQ7XG4gICAgY29uc3QgdyA9IGB2YXIoLS1zY2FsZS1mYWN0b3IpICogJHtwYWdlV2lkdGh9cHhgLFxuICAgICAgaCA9IGB2YXIoLS1zY2FsZS1mYWN0b3IpICogJHtwYWdlSGVpZ2h0fXB4YDtcbiAgICBjb25zdCB3aWR0aFN0ciA9IHVzZVJvdW5kID8gYHJvdW5kKCR7d30sIDFweClgIDogYGNhbGMoJHt3fSlgLFxuICAgICAgaGVpZ2h0U3RyID0gdXNlUm91bmQgPyBgcm91bmQoJHtofSwgMXB4KWAgOiBgY2FsYygke2h9KWA7XG4gICAgaWYgKCFtdXN0RmxpcCB8fCB2aWV3cG9ydC5yb3RhdGlvbiAlIDE4MCA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSB3aWR0aFN0cjtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodFN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUud2lkdGggPSBoZWlnaHRTdHI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSB3aWR0aFN0cjtcbiAgICB9XG4gIH1cbiAgaWYgKG11c3RSb3RhdGUpIHtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1tYWluLXJvdGF0aW9uXCIsIHZpZXdwb3J0LnJvdGF0aW9uKTtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gZXhwb3J0cy5CYXNlU1ZHRmFjdG9yeSA9IGV4cG9ydHMuQmFzZUZpbHRlckZhY3RvcnkgPSBleHBvcnRzLkJhc2VDYW52YXNGYWN0b3J5ID0gZXhwb3J0cy5CYXNlQ01hcFJlYWRlckZhY3RvcnkgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuY2xhc3MgQmFzZUZpbHRlckZhY3Rvcnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZUZpbHRlckZhY3RvcnkpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlRmlsdGVyRmFjdG9yeS5cIik7XG4gICAgfVxuICB9XG4gIGFkZEZpbHRlcihtYXBzKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEhpZ2hsaWdodEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yLCBuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGRlc3Ryb3koa2VlcEhDTSA9IGZhbHNlKSB7fVxufVxuZXhwb3J0cy5CYXNlRmlsdGVyRmFjdG9yeSA9IEJhc2VGaWx0ZXJGYWN0b3J5O1xuY2xhc3MgQmFzZUNhbnZhc0ZhY3Rvcnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZUNhbnZhc0ZhY3RvcnkpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlQ2FudmFzRmFjdG9yeS5cIik7XG4gICAgfVxuICB9XG4gIGNyZWF0ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2FudmFzIHNpemVcIik7XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzLFxuICAgICAgY29udGV4dDogY2FudmFzLmdldENvbnRleHQoXCIyZFwiKVxuICAgIH07XG4gIH1cbiAgcmVzZXQoY2FudmFzQW5kQ29udGV4dCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghY2FudmFzQW5kQ29udGV4dC5jYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgIH1cbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICB9XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgZGVzdHJveShjYW52YXNBbmRDb250ZXh0KSB7XG4gICAgaWYgKCFjYW52YXNBbmRDb250ZXh0LmNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLndpZHRoID0gMDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzID0gbnVsbDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB9XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYF9jcmVhdGVDYW52YXNgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmV4cG9ydHMuQmFzZUNhbnZhc0ZhY3RvcnkgPSBCYXNlQ2FudmFzRmFjdG9yeTtcbmNsYXNzIEJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVXJsID0gbnVsbCxcbiAgICBpc0NvbXByZXNzZWQgPSB0cnVlXG4gIH0pIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZUNNYXBSZWFkZXJGYWN0b3J5KSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZUNNYXBSZWFkZXJGYWN0b3J5LlwiKTtcbiAgICB9XG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICB0aGlzLmlzQ29tcHJlc3NlZCA9IGlzQ29tcHJlc3NlZDtcbiAgfVxuICBhc3luYyBmZXRjaCh7XG4gICAgbmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmJhc2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIENNYXAgXCJiYXNlVXJsXCIgcGFyYW1ldGVyIG11c3QgYmUgc3BlY2lmaWVkLCBlbnN1cmUgdGhhdCAnICsgJ3RoZSBcImNNYXBVcmxcIiBhbmQgXCJjTWFwUGFja2VkXCIgQVBJIHBhcmFtZXRlcnMgYXJlIHByb3ZpZGVkLicpO1xuICAgIH1cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNNYXAgbmFtZSBtdXN0IGJlIHNwZWNpZmllZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IHRoaXMuYmFzZVVybCArIG5hbWUgKyAodGhpcy5pc0NvbXByZXNzZWQgPyBcIi5iY21hcFwiIDogXCJcIik7XG4gICAgY29uc3QgY29tcHJlc3Npb25UeXBlID0gdGhpcy5pc0NvbXByZXNzZWQgPyBfdXRpbC5DTWFwQ29tcHJlc3Npb25UeXBlLkJJTkFSWSA6IF91dGlsLkNNYXBDb21wcmVzc2lvblR5cGUuTk9ORTtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2hEYXRhKHVybCwgY29tcHJlc3Npb25UeXBlKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCAke3RoaXMuaXNDb21wcmVzc2VkID8gXCJiaW5hcnkgXCIgOiBcIlwifUNNYXAgYXQ6ICR7dXJsfWApO1xuICAgIH0pO1xuICB9XG4gIF9mZXRjaERhdGEodXJsLCBjb21wcmVzc2lvblR5cGUpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBfZmV0Y2hEYXRhYCBjYWxsZWQuXCIpO1xuICB9XG59XG5leHBvcnRzLkJhc2VDTWFwUmVhZGVyRmFjdG9yeSA9IEJhc2VDTWFwUmVhZGVyRmFjdG9yeTtcbmNsYXNzIEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVXJsID0gbnVsbFxuICB9KSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeS5cIik7XG4gICAgfVxuICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gIH1cbiAgYXN5bmMgZmV0Y2goe1xuICAgIGZpbGVuYW1lXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuYmFzZVVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3RhbmRhcmQgZm9udCBcImJhc2VVcmxcIiBwYXJhbWV0ZXIgbXVzdCBiZSBzcGVjaWZpZWQsIGVuc3VyZSB0aGF0ICcgKyAndGhlIFwic3RhbmRhcmRGb250RGF0YVVybFwiIEFQSSBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQuJyk7XG4gICAgfVxuICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvbnQgZmlsZW5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9JHtmaWxlbmFtZX1gO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaERhdGEodXJsKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCBmb250IGRhdGEgYXQ6ICR7dXJsfWApO1xuICAgIH0pO1xuICB9XG4gIF9mZXRjaERhdGEodXJsKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoRGF0YWAgY2FsbGVkLlwiKTtcbiAgfVxufVxuZXhwb3J0cy5CYXNlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBCYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG5jbGFzcyBCYXNlU1ZHRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlU1ZHRmFjdG9yeSkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VTVkdGYWN0b3J5LlwiKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHNraXBEaW1lbnNpb25zID0gZmFsc2UpIHtcbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBTVkcgZGltZW5zaW9uc1wiKTtcbiAgICB9XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5fY3JlYXRlU1ZHKFwic3ZnOnN2Z1wiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmVyc2lvblwiLCBcIjEuMVwiKTtcbiAgICBpZiAoIXNraXBEaW1lbnNpb25zKSB7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgYCR7d2lkdGh9cHhgKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgYCR7aGVpZ2h0fXB4YCk7XG4gICAgfVxuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsIFwibm9uZVwiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApO1xuICAgIHJldHVybiBzdmc7XG4gIH1cbiAgY3JlYXRlRWxlbWVudCh0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNWRyBlbGVtZW50IHR5cGVcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVTVkcodHlwZSk7XG4gIH1cbiAgX2NyZWF0ZVNWRyh0eXBlKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgX2NyZWF0ZVNWR2AgY2FsbGVkLlwiKTtcbiAgfVxufVxuZXhwb3J0cy5CYXNlU1ZHRmFjdG9yeSA9IEJhc2VTVkdGYWN0b3J5O1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuTXVybXVySGFzaDNfNjQgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuY29uc3QgU0VFRCA9IDB4YzNkMmUxZjA7XG5jb25zdCBNQVNLX0hJR0ggPSAweGZmZmYwMDAwO1xuY29uc3QgTUFTS19MT1cgPSAweGZmZmY7XG5jbGFzcyBNdXJtdXJIYXNoM182NCB7XG4gIGNvbnN0cnVjdG9yKHNlZWQpIHtcbiAgICB0aGlzLmgxID0gc2VlZCA/IHNlZWQgJiAweGZmZmZmZmZmIDogU0VFRDtcbiAgICB0aGlzLmgyID0gc2VlZCA/IHNlZWQgJiAweGZmZmZmZmZmIDogU0VFRDtcbiAgfVxuICB1cGRhdGUoaW5wdXQpIHtcbiAgICBsZXQgZGF0YSwgbGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGggKiAyKTtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbnB1dC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA8PSAweGZmKSB7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZSA+Pj4gODtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGUgJiAweGZmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoMCwgX3V0aWwuaXNBcnJheUJ1ZmZlcikoaW5wdXQpKSB7XG4gICAgICBkYXRhID0gaW5wdXQuc2xpY2UoKTtcbiAgICAgIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgZGF0YSBmb3JtYXQgaW4gTXVybXVySGFzaDNfNjRfdXBkYXRlLiBcIiArIFwiSW5wdXQgbXVzdCBiZSBhIHN0cmluZyBvciBhcnJheS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrQ291bnRzID0gbGVuZ3RoID4+IDI7XG4gICAgY29uc3QgdGFpbExlbmd0aCA9IGxlbmd0aCAtIGJsb2NrQ291bnRzICogNDtcbiAgICBjb25zdCBkYXRhVWludDMyID0gbmV3IFVpbnQzMkFycmF5KGRhdGEuYnVmZmVyLCAwLCBibG9ja0NvdW50cyk7XG4gICAgbGV0IGsxID0gMCxcbiAgICAgIGsyID0gMDtcbiAgICBsZXQgaDEgPSB0aGlzLmgxLFxuICAgICAgaDIgPSB0aGlzLmgyO1xuICAgIGNvbnN0IEMxID0gMHhjYzllMmQ1MSxcbiAgICAgIEMyID0gMHgxYjg3MzU5MztcbiAgICBjb25zdCBDMV9MT1cgPSBDMSAmIE1BU0tfTE9XLFxuICAgICAgQzJfTE9XID0gQzIgJiBNQVNLX0xPVztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrQ291bnRzOyBpKyspIHtcbiAgICAgIGlmIChpICYgMSkge1xuICAgICAgICBrMSA9IGRhdGFVaW50MzJbaV07XG4gICAgICAgIGsxID0gazEgKiBDMSAmIE1BU0tfSElHSCB8IGsxICogQzFfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGsxID0gazEgPDwgMTUgfCBrMSA+Pj4gMTc7XG4gICAgICAgIGsxID0gazEgKiBDMiAmIE1BU0tfSElHSCB8IGsxICogQzJfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGgxIF49IGsxO1xuICAgICAgICBoMSA9IGgxIDw8IDEzIHwgaDEgPj4+IDE5O1xuICAgICAgICBoMSA9IGgxICogNSArIDB4ZTY1NDZiNjQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrMiA9IGRhdGFVaW50MzJbaV07XG4gICAgICAgIGsyID0gazIgKiBDMSAmIE1BU0tfSElHSCB8IGsyICogQzFfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGsyID0gazIgPDwgMTUgfCBrMiA+Pj4gMTc7XG4gICAgICAgIGsyID0gazIgKiBDMiAmIE1BU0tfSElHSCB8IGsyICogQzJfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGgyIF49IGsyO1xuICAgICAgICBoMiA9IGgyIDw8IDEzIHwgaDIgPj4+IDE5O1xuICAgICAgICBoMiA9IGgyICogNSArIDB4ZTY1NDZiNjQ7XG4gICAgICB9XG4gICAgfVxuICAgIGsxID0gMDtcbiAgICBzd2l0Y2ggKHRhaWxMZW5ndGgpIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDQgKyAyXSA8PCAxNjtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDQgKyAxXSA8PCA4O1xuICAgICAgY2FzZSAxOlxuICAgICAgICBrMSBePSBkYXRhW2Jsb2NrQ291bnRzICogNF07XG4gICAgICAgIGsxID0gazEgKiBDMSAmIE1BU0tfSElHSCB8IGsxICogQzFfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGsxID0gazEgPDwgMTUgfCBrMSA+Pj4gMTc7XG4gICAgICAgIGsxID0gazEgKiBDMiAmIE1BU0tfSElHSCB8IGsxICogQzJfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGlmIChibG9ja0NvdW50cyAmIDEpIHtcbiAgICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoMiBePSBrMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmgxID0gaDE7XG4gICAgdGhpcy5oMiA9IGgyO1xuICB9XG4gIGhleGRpZ2VzdCgpIHtcbiAgICBsZXQgaDEgPSB0aGlzLmgxLFxuICAgICAgaDIgPSB0aGlzLmgyO1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIGgxID0gaDEgKiAweGVkNTU4Y2NkICYgTUFTS19ISUdIIHwgaDEgKiAweDhjY2QgJiBNQVNLX0xPVztcbiAgICBoMiA9IGgyICogMHhmZjUxYWZkNyAmIE1BU0tfSElHSCB8ICgoaDIgPDwgMTYgfCBoMSA+Pj4gMTYpICogMHhhZmQ3ZWQ1NSAmIE1BU0tfSElHSCkgPj4+IDE2O1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIGgxID0gaDEgKiAweDFhODVlYzUzICYgTUFTS19ISUdIIHwgaDEgKiAweGVjNTMgJiBNQVNLX0xPVztcbiAgICBoMiA9IGgyICogMHhjNGNlYjlmZSAmIE1BU0tfSElHSCB8ICgoaDIgPDwgMTYgfCBoMSA+Pj4gMTYpICogMHhiOWZlMWE4NSAmIE1BU0tfSElHSCkgPj4+IDE2O1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIHJldHVybiAoaDEgPj4+IDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIikgKyAoaDIgPj4+IDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIik7XG4gIH1cbn1cbmV4cG9ydHMuTXVybXVySGFzaDNfNjQgPSBNdXJtdXJIYXNoM182NDtcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkZvbnRMb2FkZXIgPSBleHBvcnRzLkZvbnRGYWNlT2JqZWN0ID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbmNsYXNzIEZvbnRMb2FkZXIge1xuICAjc3lzdGVtRm9udHMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudCxcbiAgICBzdHlsZUVsZW1lbnQgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLl9kb2N1bWVudCA9IG93bmVyRG9jdW1lbnQ7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMubG9hZGluZ1JlcXVlc3RzID0gW107XG4gICAgdGhpcy5sb2FkVGVzdEZvbnRJZCA9IDA7XG4gIH1cbiAgYWRkTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpIHtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5hZGQobmF0aXZlRm9udEZhY2UpO1xuICAgIHRoaXMuX2RvY3VtZW50LmZvbnRzLmFkZChuYXRpdmVGb250RmFjZSk7XG4gIH1cbiAgcmVtb3ZlTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpIHtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICAgIHRoaXMuX2RvY3VtZW50LmZvbnRzLmRlbGV0ZShuYXRpdmVGb250RmFjZSk7XG4gIH1cbiAgaW5zZXJ0UnVsZShydWxlKSB7XG4gICAgaWYgKCF0aGlzLnN0eWxlRWxlbWVudCkge1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICB0aGlzLl9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZCh0aGlzLnN0eWxlRWxlbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlU2hlZXQgPSB0aGlzLnN0eWxlRWxlbWVudC5zaGVldDtcbiAgICBzdHlsZVNoZWV0Lmluc2VydFJ1bGUocnVsZSwgc3R5bGVTaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3QgbmF0aXZlRm9udEZhY2Ugb2YgdGhpcy5uYXRpdmVGb250RmFjZXMpIHtcbiAgICAgIHRoaXMuX2RvY3VtZW50LmZvbnRzLmRlbGV0ZShuYXRpdmVGb250RmFjZSk7XG4gICAgfVxuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLmNsZWFyKCk7XG4gICAgdGhpcy4jc3lzdGVtRm9udHMuY2xlYXIoKTtcbiAgICBpZiAodGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBhc3luYyBsb2FkU3lzdGVtRm9udChpbmZvKSB7XG4gICAgaWYgKCFpbmZvIHx8IHRoaXMuI3N5c3RlbUZvbnRzLmhhcyhpbmZvLmxvYWRlZE5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICgwLCBfdXRpbC5hc3NlcnQpKCF0aGlzLmRpc2FibGVGb250RmFjZSwgXCJsb2FkU3lzdGVtRm9udCBzaG91bGRuJ3QgYmUgY2FsbGVkIHdoZW4gYGRpc2FibGVGb250RmFjZWAgaXMgc2V0LlwiKTtcbiAgICBpZiAodGhpcy5pc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxvYWRlZE5hbWUsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBpbmZvO1xuICAgICAgY29uc3QgZm9udEZhY2UgPSBuZXcgRm9udEZhY2UobG9hZGVkTmFtZSwgc3JjLCBzdHlsZSk7XG4gICAgICB0aGlzLmFkZE5hdGl2ZUZvbnRGYWNlKGZvbnRGYWNlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZvbnRGYWNlLmxvYWQoKTtcbiAgICAgICAgdGhpcy4jc3lzdGVtRm9udHMuYWRkKGxvYWRlZE5hbWUpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShgQ2Fubm90IGxvYWQgc3lzdGVtIGZvbnQ6ICR7aW5mby5iYXNlRm9udE5hbWV9LCBpbnN0YWxsaW5nIGl0IGNvdWxkIGhlbHAgdG8gaW1wcm92ZSBQREYgcmVuZGVyaW5nLmApO1xuICAgICAgICB0aGlzLnJlbW92ZU5hdGl2ZUZvbnRGYWNlKGZvbnRGYWNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIk5vdCBpbXBsZW1lbnRlZDogbG9hZFN5c3RlbUZvbnQgd2l0aG91dCB0aGUgRm9udCBMb2FkaW5nIEFQSS5cIik7XG4gIH1cbiAgYXN5bmMgYmluZChmb250KSB7XG4gICAgaWYgKGZvbnQuYXR0YWNoZWQgfHwgZm9udC5taXNzaW5nRmlsZSAmJiAhZm9udC5zeXN0ZW1Gb250SW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb250LmF0dGFjaGVkID0gdHJ1ZTtcbiAgICBpZiAoZm9udC5zeXN0ZW1Gb250SW5mbykge1xuICAgICAgYXdhaXQgdGhpcy5sb2FkU3lzdGVtRm9udChmb250LnN5c3RlbUZvbnRJbmZvKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCkge1xuICAgICAgY29uc3QgbmF0aXZlRm9udEZhY2UgPSBmb250LmNyZWF0ZU5hdGl2ZUZvbnRGYWNlKCk7XG4gICAgICBpZiAobmF0aXZlRm9udEZhY2UpIHtcbiAgICAgICAgdGhpcy5hZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgbmF0aXZlRm9udEZhY2UubG9hZGVkO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgRmFpbGVkIHRvIGxvYWQgZm9udCAnJHtuYXRpdmVGb250RmFjZS5mYW1pbHl9JzogJyR7ZXh9Jy5gKTtcbiAgICAgICAgICBmb250LmRpc2FibGVGb250RmFjZSA9IHRydWU7XG4gICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IGZvbnQuY3JlYXRlRm9udEZhY2VSdWxlKCk7XG4gICAgaWYgKHJ1bGUpIHtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgIGlmICh0aGlzLmlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fcXVldWVMb2FkaW5nQ2FsbGJhY2socmVzb2x2ZSk7XG4gICAgICAgIHRoaXMuX3ByZXBhcmVGb250TG9hZEV2ZW50KGZvbnQsIHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKCkge1xuICAgIGNvbnN0IGhhc0ZvbnRzID0gISF0aGlzLl9kb2N1bWVudD8uZm9udHM7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZFwiLCBoYXNGb250cyk7XG4gIH1cbiAgZ2V0IGlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkKCkge1xuICAgIGxldCBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICBpZiAoX3V0aWwuaXNOb2RlSlMpIHtcbiAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIC9Nb3ppbGxhXFwvNS4wLio/cnY6XFxkKy4qPyBHZWNrby8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWRcIiwgc3VwcG9ydGVkKTtcbiAgfVxuICBfcXVldWVMb2FkaW5nQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBjb21wbGV0ZVJlcXVlc3QoKSB7XG4gICAgICAoMCwgX3V0aWwuYXNzZXJ0KSghcmVxdWVzdC5kb25lLCBcImNvbXBsZXRlUmVxdWVzdCgpIGNhbm5vdCBiZSBjYWxsZWQgdHdpY2UuXCIpO1xuICAgICAgcmVxdWVzdC5kb25lID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChsb2FkaW5nUmVxdWVzdHMubGVuZ3RoID4gMCAmJiBsb2FkaW5nUmVxdWVzdHNbMF0uZG9uZSkge1xuICAgICAgICBjb25zdCBvdGhlclJlcXVlc3QgPSBsb2FkaW5nUmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgc2V0VGltZW91dChvdGhlclJlcXVlc3QuY2FsbGJhY2ssIDApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsb2FkaW5nUmVxdWVzdHNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICBjb21wbGV0ZTogY29tcGxldGVSZXF1ZXN0LFxuICAgICAgY2FsbGJhY2tcbiAgICB9O1xuICAgIGxvYWRpbmdSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9XG4gIGdldCBfbG9hZFRlc3RGb250KCkge1xuICAgIGNvbnN0IHRlc3RGb250ID0gYXRvYihcIlQxUlVUd0FMQUlBQUF3QXdRMFpHSURIdFpnNEFBQU9ZQUFBQWdVWkdWRTFsa3pad0FBQUVIQUFBQUJ4SFJFVkdBQlFBXCIgKyBcIkZRQUFCRGdBQUFBZVQxTXZNbFlOWXdrQUFBRWdBQUFBWUdOdFlYQUJEUUxVQUFBQ05BQUFBVUpvWldGay94VkZEUUFBXCIgKyBcIkFMd0FBQUEyYUdobFlRZGtBK29BQUFEMEFBQUFKR2h0ZEhnRDZBQUFBQUFFV0FBQUFBWnRZWGh3QUFKUUFBQUFBUmdBXCIgKyBcIkFBQUdibUZ0WlZqbWRINEFBQUdBQUFBQXNYQnZjM1QvaGdBekFBQURlQUFBQUNBQUFRQUFBQUVBQUxaUkZzUmZEenoxXCIgKyBcIkFBc0Q2QUFBQUFET0JPVExBQUFBQU00S0hEd0FBQUFBQStnRElRQUFBQWdBQWdBQUFBQUFBQUFCQUFBRElRQUFBRm9EXCIgKyBcIjZBQUFBQUFENkFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQVFBQVVBQUFBZ0FBQUFRRDZBSDBBQVVBQUFLS0Fyd0FBQUNNXCIgKyBcIkFvb0N2QUFBQWVBQU1RRUNBQUFDQUFZSkFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBRkJtUldRQXdBQXVBQzREXCIgKyBcIklQODRBRm9ESVFBQUFBQUFBUUFBQUFBQUFBQUFBQ0FBSUFBQkFBQUFEZ0N1QUFFQUFBQUFBQUFBQVFBQUFBRUFBQUFBXCIgKyBcIkFBRUFBUUFBQUFFQUFBQUFBQUlBQVFBQUFBRUFBQUFBQUFNQUFRQUFBQUVBQUFBQUFBUUFBUUFBQUFFQUFBQUFBQVVBXCIgKyBcIkFRQUFBQUVBQUFBQUFBWUFBUUFBQUFNQUFRUUpBQUFBQWdBQkFBTUFBUVFKQUFFQUFnQUJBQU1BQVFRSkFBSUFBZ0FCXCIgKyBcIkFBTUFBUVFKQUFNQUFnQUJBQU1BQVFRSkFBUUFBZ0FCQUFNQUFRUUpBQVVBQWdBQkFBTUFBUVFKQUFZQUFnQUJXQUJZXCIgKyBcIkFBQUFBQUFBQXdBQUFBTUFBQUFjQUFFQUFBQUFBRHdBQXdBQkFBQUFIQUFFQUNBQUFBQUVBQVFBQVFBQUFDNy8vd0FBXCIgKyBcIkFDNy8vLy9UQUFFQUFBQUFBQUFCQmdBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1BQUFBQUFBRC9nd0F5QUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUJBQVFFQUFFQkFRSllBQUVCQVNINER3RDRHd0hFQXZnY0EvZ1hCSXdNQVl1TCtuejV0UVhrRDVqM0NCTG5FUUFDXCIgKyBcIkFRRUJJVmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWUFBQUJBUUFBRHdBQ0FRRUVFL3QzXCIgKyBcIkRvdjZmQUg2ZkFUK2ZQcDgrbndIRG9zTUN2bTFDdm0xREF6NmZCUUFBQUFBQUFBQkFBQUFBTW1KYnpFQUFBQUF6Z1RqXCIgKyBcIkZRQUFBQURPQk9RcEFBRUFBQUFBQUFBQURBQVVBQVFBQUFBQkFBQUFBZ0FCQUFBQUFBQUFBQUFENkFBQUFBQUFBQT09XCIpO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcIl9sb2FkVGVzdEZvbnRcIiwgdGVzdEZvbnQpO1xuICB9XG4gIF9wcmVwYXJlRm9udExvYWRFdmVudChmb250LCByZXF1ZXN0KSB7XG4gICAgZnVuY3Rpb24gaW50MzIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZGF0YS5jaGFyQ29kZUF0KG9mZnNldCkgPDwgMjQgfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMSkgPDwgMTYgfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAzKSAmIDB4ZmY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwbGljZVN0cmluZyhzLCBvZmZzZXQsIHJlbW92ZSwgaW5zZXJ0KSB7XG4gICAgICBjb25zdCBjaHVuazEgPSBzLnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgY29uc3QgY2h1bmsyID0gcy5zdWJzdHJpbmcob2Zmc2V0ICsgcmVtb3ZlKTtcbiAgICAgIHJldHVybiBjaHVuazEgKyBpbnNlcnQgKyBjaHVuazI7XG4gICAgfVxuICAgIGxldCBpLCBpaTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBsZXQgY2FsbGVkID0gMDtcbiAgICBmdW5jdGlvbiBpc0ZvbnRSZWFkeShuYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCsrY2FsbGVkID4gMzApIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiTG9hZCB0ZXN0IGZvbnQgbmV2ZXIgbG9hZGVkLlwiKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LmZvbnQgPSBcIjMwcHggXCIgKyBuYW1lO1xuICAgICAgY3R4LmZpbGxUZXh0KFwiLlwiLCAwLCAyMCk7XG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpO1xuICAgICAgaWYgKGltYWdlRGF0YS5kYXRhWzNdID4gMCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KGlzRm9udFJlYWR5LmJpbmQobnVsbCwgbmFtZSwgY2FsbGJhY2spKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZFRlc3RGb250SWQgPSBgbHQke0RhdGUubm93KCl9JHt0aGlzLmxvYWRUZXN0Rm9udElkKyt9YDtcbiAgICBsZXQgZGF0YSA9IHRoaXMuX2xvYWRUZXN0Rm9udDtcbiAgICBjb25zdCBDT01NRU5UX09GRlNFVCA9IDk3NjtcbiAgICBkYXRhID0gc3BsaWNlU3RyaW5nKGRhdGEsIENPTU1FTlRfT0ZGU0VULCBsb2FkVGVzdEZvbnRJZC5sZW5ndGgsIGxvYWRUZXN0Rm9udElkKTtcbiAgICBjb25zdCBDRkZfQ0hFQ0tTVU1fT0ZGU0VUID0gMTY7XG4gICAgY29uc3QgWFhYWF9WQUxVRSA9IDB4NTg1ODU4NTg7XG4gICAgbGV0IGNoZWNrc3VtID0gaW50MzIoZGF0YSwgQ0ZGX0NIRUNLU1VNX09GRlNFVCk7XG4gICAgZm9yIChpID0gMCwgaWkgPSBsb2FkVGVzdEZvbnRJZC5sZW5ndGggLSAzOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCwgaSkgfCAwO1xuICAgIH1cbiAgICBpZiAoaSA8IGxvYWRUZXN0Rm9udElkLmxlbmd0aCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCArIFwiWFhYXCIsIGkpIHwgMDtcbiAgICB9XG4gICAgZGF0YSA9IHNwbGljZVN0cmluZyhkYXRhLCBDRkZfQ0hFQ0tTVU1fT0ZGU0VULCA0LCAoMCwgX3V0aWwuc3RyaW5nMzIpKGNoZWNrc3VtKSk7XG4gICAgY29uc3QgdXJsID0gYHVybChkYXRhOmZvbnQvb3BlbnR5cGU7YmFzZTY0LCR7YnRvYShkYXRhKX0pO2A7XG4gICAgY29uc3QgcnVsZSA9IGBAZm9udC1mYWNlIHtmb250LWZhbWlseTpcIiR7bG9hZFRlc3RGb250SWR9XCI7c3JjOiR7dXJsfX1gO1xuICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcbiAgICBjb25zdCBkaXYgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICBkaXYuc3R5bGUud2lkdGggPSBkaXYuc3R5bGUuaGVpZ2h0ID0gXCIxMHB4XCI7XG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGRpdi5zdHlsZS50b3AgPSBkaXYuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIFtmb250LmxvYWRlZE5hbWUsIGxvYWRUZXN0Rm9udElkXSkge1xuICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IFwiSGlcIjtcbiAgICAgIHNwYW4uc3R5bGUuZm9udEZhbWlseSA9IG5hbWU7XG4gICAgICBkaXYuYXBwZW5kKHNwYW4pO1xuICAgIH1cbiAgICB0aGlzLl9kb2N1bWVudC5ib2R5LmFwcGVuZChkaXYpO1xuICAgIGlzRm9udFJlYWR5KGxvYWRUZXN0Rm9udElkLCAoKSA9PiB7XG4gICAgICBkaXYucmVtb3ZlKCk7XG4gICAgICByZXF1ZXN0LmNvbXBsZXRlKCk7XG4gICAgfSk7XG4gIH1cbn1cbmV4cG9ydHMuRm9udExvYWRlciA9IEZvbnRMb2FkZXI7XG5jbGFzcyBGb250RmFjZU9iamVjdCB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zbGF0ZWREYXRhLCB7XG4gICAgaXNFdmFsU3VwcG9ydGVkID0gdHJ1ZSxcbiAgICBkaXNhYmxlRm9udEZhY2UgPSBmYWxzZSxcbiAgICBpZ25vcmVFcnJvcnMgPSBmYWxzZSxcbiAgICBpbnNwZWN0Rm9udCA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuY29tcGlsZWRHbHlwaHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAoY29uc3QgaSBpbiB0cmFuc2xhdGVkRGF0YSkge1xuICAgICAgdGhpc1tpXSA9IHRyYW5zbGF0ZWREYXRhW2ldO1xuICAgIH1cbiAgICB0aGlzLmlzRXZhbFN1cHBvcnRlZCA9IGlzRXZhbFN1cHBvcnRlZCAhPT0gZmFsc2U7XG4gICAgdGhpcy5kaXNhYmxlRm9udEZhY2UgPSBkaXNhYmxlRm9udEZhY2UgPT09IHRydWU7XG4gICAgdGhpcy5pZ25vcmVFcnJvcnMgPSBpZ25vcmVFcnJvcnMgPT09IHRydWU7XG4gICAgdGhpcy5faW5zcGVjdEZvbnQgPSBpbnNwZWN0Rm9udDtcbiAgfVxuICBjcmVhdGVOYXRpdmVGb250RmFjZSgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRpc2FibGVGb250RmFjZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBuYXRpdmVGb250RmFjZTtcbiAgICBpZiAoIXRoaXMuY3NzRm9udEluZm8pIHtcbiAgICAgIG5hdGl2ZUZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKHRoaXMubG9hZGVkTmFtZSwgdGhpcy5kYXRhLCB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNzcyA9IHtcbiAgICAgICAgd2VpZ2h0OiB0aGlzLmNzc0ZvbnRJbmZvLmZvbnRXZWlnaHRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZSkge1xuICAgICAgICBjc3Muc3R5bGUgPSBgb2JsaXF1ZSAke3RoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGV9ZGVnYDtcbiAgICAgIH1cbiAgICAgIG5hdGl2ZUZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKHRoaXMuY3NzRm9udEluZm8uZm9udEZhbWlseSwgdGhpcy5kYXRhLCBjc3MpO1xuICAgIH1cbiAgICB0aGlzLl9pbnNwZWN0Rm9udD8uKHRoaXMpO1xuICAgIHJldHVybiBuYXRpdmVGb250RmFjZTtcbiAgfVxuICBjcmVhdGVGb250RmFjZVJ1bGUoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kaXNhYmxlRm9udEZhY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gKDAsIF91dGlsLmJ5dGVzVG9TdHJpbmcpKHRoaXMuZGF0YSk7XG4gICAgY29uc3QgdXJsID0gYHVybChkYXRhOiR7dGhpcy5taW1ldHlwZX07YmFzZTY0LCR7YnRvYShkYXRhKX0pO2A7XG4gICAgbGV0IHJ1bGU7XG4gICAgaWYgKCF0aGlzLmNzc0ZvbnRJbmZvKSB7XG4gICAgICBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHt0aGlzLmxvYWRlZE5hbWV9XCI7c3JjOiR7dXJsfX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY3NzID0gYGZvbnQtd2VpZ2h0OiAke3RoaXMuY3NzRm9udEluZm8uZm9udFdlaWdodH07YDtcbiAgICAgIGlmICh0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlKSB7XG4gICAgICAgIGNzcyArPSBgZm9udC1zdHlsZTogb2JsaXF1ZSAke3RoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGV9ZGVnO2A7XG4gICAgICB9XG4gICAgICBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHt0aGlzLmNzc0ZvbnRJbmZvLmZvbnRGYW1pbHl9XCI7JHtjc3N9c3JjOiR7dXJsfX1gO1xuICAgIH1cbiAgICB0aGlzLl9pbnNwZWN0Rm9udD8uKHRoaXMsIHVybCk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgZ2V0UGF0aEdlbmVyYXRvcihvYmpzLCBjaGFyYWN0ZXIpIHtcbiAgICBpZiAodGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl07XG4gICAgfVxuICAgIGxldCBjbWRzO1xuICAgIHRyeSB7XG4gICAgICBjbWRzID0gb2Jqcy5nZXQodGhpcy5sb2FkZWROYW1lICsgXCJfcGF0aF9cIiArIGNoYXJhY3Rlcik7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmICghdGhpcy5pZ25vcmVFcnJvcnMpIHtcbiAgICAgICAgdGhyb3cgZXg7XG4gICAgICB9XG4gICAgICAoMCwgX3V0aWwud2FybikoYGdldFBhdGhHZW5lcmF0b3IgLSBpZ25vcmluZyBjaGFyYWN0ZXI6IFwiJHtleH1cIi5gKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gPSBmdW5jdGlvbiAoYywgc2l6ZSkge307XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRXZhbFN1cHBvcnRlZCAmJiBfdXRpbC5GZWF0dXJlVGVzdC5pc0V2YWxTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IGpzQnVmID0gW107XG4gICAgICBmb3IgKGNvbnN0IGN1cnJlbnQgb2YgY21kcykge1xuICAgICAgICBjb25zdCBhcmdzID0gY3VycmVudC5hcmdzICE9PSB1bmRlZmluZWQgPyBjdXJyZW50LmFyZ3Muam9pbihcIixcIikgOiBcIlwiO1xuICAgICAgICBqc0J1Zi5wdXNoKFwiYy5cIiwgY3VycmVudC5jbWQsIFwiKFwiLCBhcmdzLCBcIik7XFxuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSA9IG5ldyBGdW5jdGlvbihcImNcIiwgXCJzaXplXCIsIGpzQnVmLmpvaW4oXCJcIikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gZnVuY3Rpb24gKGMsIHNpemUpIHtcbiAgICAgIGZvciAoY29uc3QgY3VycmVudCBvZiBjbWRzKSB7XG4gICAgICAgIGlmIChjdXJyZW50LmNtZCA9PT0gXCJzY2FsZVwiKSB7XG4gICAgICAgICAgY3VycmVudC5hcmdzID0gW3NpemUsIC1zaXplXTtcbiAgICAgICAgfVxuICAgICAgICBjW2N1cnJlbnQuY21kXS5hcHBseShjLCBjdXJyZW50LmFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbmV4cG9ydHMuRm9udEZhY2VPYmplY3QgPSBGb250RmFjZU9iamVjdDtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5Ob2RlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBleHBvcnRzLk5vZGVGaWx0ZXJGYWN0b3J5ID0gZXhwb3J0cy5Ob2RlQ2FudmFzRmFjdG9yeSA9IGV4cG9ydHMuTm9kZUNNYXBSZWFkZXJGYWN0b3J5ID0gdm9pZCAwO1xudmFyIF9iYXNlX2ZhY3RvcnkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDcpO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbjtcbjtcbmNvbnN0IGZldGNoRGF0YSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgICBmcy5yZWFkRmlsZSh1cmwsIChlcnJvciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVycm9yIHx8ICFkYXRhKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgfSk7XG4gIH0pO1xufTtcbmNsYXNzIE5vZGVGaWx0ZXJGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlRmlsdGVyRmFjdG9yeSB7fVxuZXhwb3J0cy5Ob2RlRmlsdGVyRmFjdG9yeSA9IE5vZGVGaWx0ZXJGYWN0b3J5O1xuY2xhc3MgTm9kZUNhbnZhc0ZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5LkJhc2VDYW52YXNGYWN0b3J5IHtcbiAgX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgQ2FudmFzID0gcmVxdWlyZShcImNhbnZhc1wiKTtcbiAgICByZXR1cm4gQ2FudmFzLmNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxufVxuZXhwb3J0cy5Ob2RlQ2FudmFzRmFjdG9yeSA9IE5vZGVDYW52YXNGYWN0b3J5O1xuY2xhc3MgTm9kZUNNYXBSZWFkZXJGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlQ01hcFJlYWRlckZhY3Rvcnkge1xuICBfZmV0Y2hEYXRhKHVybCwgY29tcHJlc3Npb25UeXBlKSB7XG4gICAgcmV0dXJuIGZldGNoRGF0YSh1cmwpLnRoZW4oZGF0YSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjTWFwRGF0YTogZGF0YSxcbiAgICAgICAgY29tcHJlc3Npb25UeXBlXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG5leHBvcnRzLk5vZGVDTWFwUmVhZGVyRmFjdG9yeSA9IE5vZGVDTWFwUmVhZGVyRmFjdG9yeTtcbmNsYXNzIE5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnkuQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgX2ZldGNoRGF0YSh1cmwpIHtcbiAgICByZXR1cm4gZmV0Y2hEYXRhKHVybCk7XG4gIH1cbn1cbmV4cG9ydHMuTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkNhbnZhc0dyYXBoaWNzID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG52YXIgX3BhdHRlcm5faGVscGVyID0gX193X3BkZmpzX3JlcXVpcmVfXygxMik7XG52YXIgX2ltYWdlX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxMyk7XG5jb25zdCBNSU5fRk9OVF9TSVpFID0gMTY7XG5jb25zdCBNQVhfRk9OVF9TSVpFID0gMTAwO1xuY29uc3QgTUFYX0dST1VQX1NJWkUgPSA0MDk2O1xuY29uc3QgRVhFQ1VUSU9OX1RJTUUgPSAxNTtcbmNvbnN0IEVYRUNVVElPTl9TVEVQUyA9IDEwO1xuY29uc3QgTUFYX1NJWkVfVE9fQ09NUElMRSA9IDEwMDA7XG5jb25zdCBGVUxMX0NIVU5LX0hFSUdIVCA9IDE2O1xuZnVuY3Rpb24gbWlycm9yQ29udGV4dE9wZXJhdGlvbnMoY3R4LCBkZXN0Q3R4KSB7XG4gIGlmIChjdHguX3JlbW92ZU1pcnJvcmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRleHQgaXMgYWxyZWFkeSBmb3J3YXJkaW5nIG9wZXJhdGlvbnMuXCIpO1xuICB9XG4gIGN0eC5fX29yaWdpbmFsU2F2ZSA9IGN0eC5zYXZlO1xuICBjdHguX19vcmlnaW5hbFJlc3RvcmUgPSBjdHgucmVzdG9yZTtcbiAgY3R4Ll9fb3JpZ2luYWxSb3RhdGUgPSBjdHgucm90YXRlO1xuICBjdHguX19vcmlnaW5hbFNjYWxlID0gY3R4LnNjYWxlO1xuICBjdHguX19vcmlnaW5hbFRyYW5zbGF0ZSA9IGN0eC50cmFuc2xhdGU7XG4gIGN0eC5fX29yaWdpbmFsVHJhbnNmb3JtID0gY3R4LnRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0gPSBjdHguc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtID0gY3R4LnJlc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbENsaXAgPSBjdHguY2xpcDtcbiAgY3R4Ll9fb3JpZ2luYWxNb3ZlVG8gPSBjdHgubW92ZVRvO1xuICBjdHguX19vcmlnaW5hbExpbmVUbyA9IGN0eC5saW5lVG87XG4gIGN0eC5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbyA9IGN0eC5iZXppZXJDdXJ2ZVRvO1xuICBjdHguX19vcmlnaW5hbFJlY3QgPSBjdHgucmVjdDtcbiAgY3R4Ll9fb3JpZ2luYWxDbG9zZVBhdGggPSBjdHguY2xvc2VQYXRoO1xuICBjdHguX19vcmlnaW5hbEJlZ2luUGF0aCA9IGN0eC5iZWdpblBhdGg7XG4gIGN0eC5fcmVtb3ZlTWlycm9yaW5nID0gKCkgPT4ge1xuICAgIGN0eC5zYXZlID0gY3R4Ll9fb3JpZ2luYWxTYXZlO1xuICAgIGN0eC5yZXN0b3JlID0gY3R4Ll9fb3JpZ2luYWxSZXN0b3JlO1xuICAgIGN0eC5yb3RhdGUgPSBjdHguX19vcmlnaW5hbFJvdGF0ZTtcbiAgICBjdHguc2NhbGUgPSBjdHguX19vcmlnaW5hbFNjYWxlO1xuICAgIGN0eC50cmFuc2xhdGUgPSBjdHguX19vcmlnaW5hbFRyYW5zbGF0ZTtcbiAgICBjdHgudHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxUcmFuc2Zvcm07XG4gICAgY3R4LnNldFRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsU2V0VHJhbnNmb3JtO1xuICAgIGN0eC5yZXNldFRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm07XG4gICAgY3R4LmNsaXAgPSBjdHguX19vcmlnaW5hbENsaXA7XG4gICAgY3R4Lm1vdmVUbyA9IGN0eC5fX29yaWdpbmFsTW92ZVRvO1xuICAgIGN0eC5saW5lVG8gPSBjdHguX19vcmlnaW5hbExpbmVUbztcbiAgICBjdHguYmV6aWVyQ3VydmVUbyA9IGN0eC5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbztcbiAgICBjdHgucmVjdCA9IGN0eC5fX29yaWdpbmFsUmVjdDtcbiAgICBjdHguY2xvc2VQYXRoID0gY3R4Ll9fb3JpZ2luYWxDbG9zZVBhdGg7XG4gICAgY3R4LmJlZ2luUGF0aCA9IGN0eC5fX29yaWdpbmFsQmVnaW5QYXRoO1xuICAgIGRlbGV0ZSBjdHguX3JlbW92ZU1pcnJvcmluZztcbiAgfTtcbiAgY3R4LnNhdmUgPSBmdW5jdGlvbiBjdHhTYXZlKCkge1xuICAgIGRlc3RDdHguc2F2ZSgpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNhdmUoKTtcbiAgfTtcbiAgY3R4LnJlc3RvcmUgPSBmdW5jdGlvbiBjdHhSZXN0b3JlKCkge1xuICAgIGRlc3RDdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJlc3RvcmUoKTtcbiAgfTtcbiAgY3R4LnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIGN0eFRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgZGVzdEN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsVHJhbnNsYXRlKHgsIHkpO1xuICB9O1xuICBjdHguc2NhbGUgPSBmdW5jdGlvbiBjdHhTY2FsZSh4LCB5KSB7XG4gICAgZGVzdEN0eC5zY2FsZSh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxTY2FsZSh4LCB5KTtcbiAgfTtcbiAgY3R4LnRyYW5zZm9ybSA9IGZ1bmN0aW9uIGN0eFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgZGVzdEN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fX29yaWdpbmFsVHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICB9O1xuICBjdHguc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gY3R4U2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBkZXN0Q3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gIH07XG4gIGN0eC5yZXNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIGN0eFJlc2V0VHJhbnNmb3JtKCkge1xuICAgIGRlc3RDdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybSgpO1xuICB9O1xuICBjdHgucm90YXRlID0gZnVuY3Rpb24gY3R4Um90YXRlKGFuZ2xlKSB7XG4gICAgZGVzdEN0eC5yb3RhdGUoYW5nbGUpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJvdGF0ZShhbmdsZSk7XG4gIH07XG4gIGN0eC5jbGlwID0gZnVuY3Rpb24gY3R4Um90YXRlKHJ1bGUpIHtcbiAgICBkZXN0Q3R4LmNsaXAocnVsZSk7XG4gICAgdGhpcy5fX29yaWdpbmFsQ2xpcChydWxlKTtcbiAgfTtcbiAgY3R4Lm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgZGVzdEN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsTW92ZVRvKHgsIHkpO1xuICB9O1xuICBjdHgubGluZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBkZXN0Q3R4LmxpbmVUbyh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxMaW5lVG8oeCwgeSk7XG4gIH07XG4gIGN0eC5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24gKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcbiAgICBkZXN0Q3R4LmJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcbiAgfTtcbiAgY3R4LnJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGRlc3RDdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9O1xuICBjdHguY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHguY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsQ2xvc2VQYXRoKCk7XG4gIH07XG4gIGN0eC5iZWdpblBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5iZWdpblBhdGgoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxCZWdpblBhdGgoKTtcbiAgfTtcbn1cbmNsYXNzIENhY2hlZENhbnZhc2VzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzRmFjdG9yeSkge1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgZ2V0Q2FudmFzKGlkLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgbGV0IGNhbnZhc0VudHJ5O1xuICAgIGlmICh0aGlzLmNhY2hlW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXNFbnRyeSA9IHRoaXMuY2FjaGVbaWRdO1xuICAgICAgdGhpcy5jYW52YXNGYWN0b3J5LnJlc2V0KGNhbnZhc0VudHJ5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FudmFzRW50cnkgPSB0aGlzLmNhbnZhc0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jYWNoZVtpZF0gPSBjYW52YXNFbnRyeTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhc0VudHJ5O1xuICB9XG4gIGRlbGV0ZShpZCkge1xuICAgIGRlbGV0ZSB0aGlzLmNhY2hlW2lkXTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIGNvbnN0IGNhbnZhc0VudHJ5ID0gdGhpcy5jYWNoZVtpZF07XG4gICAgICB0aGlzLmNhbnZhc0ZhY3RvcnkuZGVzdHJveShjYW52YXNFbnRyeSk7XG4gICAgICBkZWxldGUgdGhpcy5jYWNoZVtpZF07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIGRlc3RYLCBkZXN0WSwgZGVzdFcsIGRlc3RIKSB7XG4gIGNvbnN0IFthLCBiLCBjLCBkLCB0eCwgdHldID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCk7XG4gIGlmIChiID09PSAwICYmIGMgPT09IDApIHtcbiAgICBjb25zdCB0bFggPSBkZXN0WCAqIGEgKyB0eDtcbiAgICBjb25zdCByVGxYID0gTWF0aC5yb3VuZCh0bFgpO1xuICAgIGNvbnN0IHRsWSA9IGRlc3RZICogZCArIHR5O1xuICAgIGNvbnN0IHJUbFkgPSBNYXRoLnJvdW5kKHRsWSk7XG4gICAgY29uc3QgYnJYID0gKGRlc3RYICsgZGVzdFcpICogYSArIHR4O1xuICAgIGNvbnN0IHJXaWR0aCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJYKSAtIHJUbFgpIHx8IDE7XG4gICAgY29uc3QgYnJZID0gKGRlc3RZICsgZGVzdEgpICogZCArIHR5O1xuICAgIGNvbnN0IHJIZWlnaHQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWSkgLSByVGxZKSB8fCAxO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oTWF0aC5zaWduKGEpLCAwLCAwLCBNYXRoLnNpZ24oZCksIHJUbFgsIHJUbFkpO1xuICAgIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCAwLCAwLCByV2lkdGgsIHJIZWlnaHQpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgdHgsIHR5KTtcbiAgICByZXR1cm4gW3JXaWR0aCwgckhlaWdodF07XG4gIH1cbiAgaWYgKGEgPT09IDAgJiYgZCA9PT0gMCkge1xuICAgIGNvbnN0IHRsWCA9IGRlc3RZICogYyArIHR4O1xuICAgIGNvbnN0IHJUbFggPSBNYXRoLnJvdW5kKHRsWCk7XG4gICAgY29uc3QgdGxZID0gZGVzdFggKiBiICsgdHk7XG4gICAgY29uc3QgclRsWSA9IE1hdGgucm91bmQodGxZKTtcbiAgICBjb25zdCBiclggPSAoZGVzdFkgKyBkZXN0SCkgKiBjICsgdHg7XG4gICAgY29uc3QgcldpZHRoID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclgpIC0gclRsWCkgfHwgMTtcbiAgICBjb25zdCBiclkgPSAoZGVzdFggKyBkZXN0VykgKiBiICsgdHk7XG4gICAgY29uc3QgckhlaWdodCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJZKSAtIHJUbFkpIHx8IDE7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgwLCBNYXRoLnNpZ24oYiksIE1hdGguc2lnbihjKSwgMCwgclRsWCwgclRsWSk7XG4gICAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIDAsIDAsIHJIZWlnaHQsIHJXaWR0aCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCB0eCwgdHkpO1xuICAgIHJldHVybiBbckhlaWdodCwgcldpZHRoXTtcbiAgfVxuICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgZGVzdFgsIGRlc3RZLCBkZXN0VywgZGVzdEgpO1xuICBjb25zdCBzY2FsZVggPSBNYXRoLmh5cG90KGEsIGIpO1xuICBjb25zdCBzY2FsZVkgPSBNYXRoLmh5cG90KGMsIGQpO1xuICByZXR1cm4gW3NjYWxlWCAqIGRlc3RXLCBzY2FsZVkgKiBkZXN0SF07XG59XG5mdW5jdGlvbiBjb21waWxlVHlwZTNHbHlwaChpbWdEYXRhKSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGltZ0RhdGE7XG4gIGlmICh3aWR0aCA+IE1BWF9TSVpFX1RPX0NPTVBJTEUgfHwgaGVpZ2h0ID4gTUFYX1NJWkVfVE9fQ09NUElMRSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IFBPSU5UX1RPX1BST0NFU1NfTElNSVQgPSAxMDAwO1xuICBjb25zdCBQT0lOVF9UWVBFUyA9IG5ldyBVaW50OEFycmF5KFswLCAyLCA0LCAwLCAxLCAwLCA1LCA0LCA4LCAxMCwgMCwgOCwgMCwgMiwgMSwgMF0pO1xuICBjb25zdCB3aWR0aDEgPSB3aWR0aCArIDE7XG4gIGxldCBwb2ludHMgPSBuZXcgVWludDhBcnJheSh3aWR0aDEgKiAoaGVpZ2h0ICsgMSkpO1xuICBsZXQgaSwgaiwgajA7XG4gIGNvbnN0IGxpbmVTaXplID0gd2lkdGggKyA3ICYgfjc7XG4gIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobGluZVNpemUgKiBoZWlnaHQpLFxuICAgIHBvcyA9IDA7XG4gIGZvciAoY29uc3QgZWxlbSBvZiBpbWdEYXRhLmRhdGEpIHtcbiAgICBsZXQgbWFzayA9IDEyODtcbiAgICB3aGlsZSAobWFzayA+IDApIHtcbiAgICAgIGRhdGFbcG9zKytdID0gZWxlbSAmIG1hc2sgPyAwIDogMjU1O1xuICAgICAgbWFzayA+Pj0gMTtcbiAgICB9XG4gIH1cbiAgbGV0IGNvdW50ID0gMDtcbiAgcG9zID0gMDtcbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1swXSA9IDE7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgIGlmIChkYXRhW3Bvc10gIT09IGRhdGFbcG9zICsgMV0pIHtcbiAgICAgIHBvaW50c1tqXSA9IGRhdGFbcG9zXSA/IDIgOiAxO1xuICAgICAgKytjb3VudDtcbiAgICB9XG4gICAgcG9zKys7XG4gIH1cbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1tqXSA9IDI7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGkgPSAxOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICBwb3MgPSBpICogbGluZVNpemU7XG4gICAgajAgPSBpICogd2lkdGgxO1xuICAgIGlmIChkYXRhW3BvcyAtIGxpbmVTaXplXSAhPT0gZGF0YVtwb3NdKSB7XG4gICAgICBwb2ludHNbajBdID0gZGF0YVtwb3NdID8gMSA6IDg7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgICBsZXQgc3VtID0gKGRhdGFbcG9zXSA/IDQgOiAwKSArIChkYXRhW3BvcyAtIGxpbmVTaXplXSA/IDggOiAwKTtcbiAgICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgc3VtID0gKHN1bSA+PiAyKSArIChkYXRhW3BvcyArIDFdID8gNCA6IDApICsgKGRhdGFbcG9zIC0gbGluZVNpemUgKyAxXSA/IDggOiAwKTtcbiAgICAgIGlmIChQT0lOVF9UWVBFU1tzdW1dKSB7XG4gICAgICAgIHBvaW50c1tqMCArIGpdID0gUE9JTlRfVFlQRVNbc3VtXTtcbiAgICAgICAgKytjb3VudDtcbiAgICAgIH1cbiAgICAgIHBvcysrO1xuICAgIH1cbiAgICBpZiAoZGF0YVtwb3MgLSBsaW5lU2l6ZV0gIT09IGRhdGFbcG9zXSkge1xuICAgICAgcG9pbnRzW2owICsgal0gPSBkYXRhW3Bvc10gPyAyIDogNDtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuICAgIGlmIChjb3VudCA+IFBPSU5UX1RPX1BST0NFU1NfTElNSVQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwb3MgPSBsaW5lU2l6ZSAqIChoZWlnaHQgLSAxKTtcbiAgajAgPSBpICogd2lkdGgxO1xuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2owXSA9IDg7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgIGlmIChkYXRhW3Bvc10gIT09IGRhdGFbcG9zICsgMV0pIHtcbiAgICAgIHBvaW50c1tqMCArIGpdID0gZGF0YVtwb3NdID8gNCA6IDg7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgICBwb3MrKztcbiAgfVxuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2owICsgal0gPSA0O1xuICAgICsrY291bnQ7XG4gIH1cbiAgaWYgKGNvdW50ID4gUE9JTlRfVE9fUFJPQ0VTU19MSU1JVCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHN0ZXBzID0gbmV3IEludDMyQXJyYXkoWzAsIHdpZHRoMSwgLTEsIDAsIC13aWR0aDEsIDAsIDAsIDAsIDFdKTtcbiAgY29uc3QgcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgZm9yIChpID0gMDsgY291bnQgJiYgaSA8PSBoZWlnaHQ7IGkrKykge1xuICAgIGxldCBwID0gaSAqIHdpZHRoMTtcbiAgICBjb25zdCBlbmQgPSBwICsgd2lkdGg7XG4gICAgd2hpbGUgKHAgPCBlbmQgJiYgIXBvaW50c1twXSkge1xuICAgICAgcCsrO1xuICAgIH1cbiAgICBpZiAocCA9PT0gZW5kKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcGF0aC5tb3ZlVG8ocCAlIHdpZHRoMSwgaSk7XG4gICAgY29uc3QgcDAgPSBwO1xuICAgIGxldCB0eXBlID0gcG9pbnRzW3BdO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IHN0ZXAgPSBzdGVwc1t0eXBlXTtcbiAgICAgIGRvIHtcbiAgICAgICAgcCArPSBzdGVwO1xuICAgICAgfSB3aGlsZSAoIXBvaW50c1twXSk7XG4gICAgICBjb25zdCBwcCA9IHBvaW50c1twXTtcbiAgICAgIGlmIChwcCAhPT0gNSAmJiBwcCAhPT0gMTApIHtcbiAgICAgICAgdHlwZSA9IHBwO1xuICAgICAgICBwb2ludHNbcF0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHBwICYgMHgzMyAqIHR5cGUgPj4gNDtcbiAgICAgICAgcG9pbnRzW3BdICY9IHR5cGUgPj4gMiB8IHR5cGUgPDwgMjtcbiAgICAgIH1cbiAgICAgIHBhdGgubGluZVRvKHAgJSB3aWR0aDEsIHAgLyB3aWR0aDEgfCAwKTtcbiAgICAgIGlmICghcG9pbnRzW3BdKSB7XG4gICAgICAgIC0tY291bnQ7XG4gICAgICB9XG4gICAgfSB3aGlsZSAocDAgIT09IHApO1xuICAgIC0taTtcbiAgfVxuICBkYXRhID0gbnVsbDtcbiAgcG9pbnRzID0gbnVsbDtcbiAgY29uc3QgZHJhd091dGxpbmUgPSBmdW5jdGlvbiAoYykge1xuICAgIGMuc2F2ZSgpO1xuICAgIGMuc2NhbGUoMSAvIHdpZHRoLCAtMSAvIGhlaWdodCk7XG4gICAgYy50cmFuc2xhdGUoMCwgLWhlaWdodCk7XG4gICAgYy5maWxsKHBhdGgpO1xuICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgYy5yZXN0b3JlKCk7XG4gIH07XG4gIHJldHVybiBkcmF3T3V0bGluZTtcbn1cbmNsYXNzIENhbnZhc0V4dHJhU3RhdGUge1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5hbHBoYUlzU2hhcGUgPSBmYWxzZTtcbiAgICB0aGlzLmZvbnRTaXplID0gMDtcbiAgICB0aGlzLmZvbnRTaXplU2NhbGUgPSAxO1xuICAgIHRoaXMudGV4dE1hdHJpeCA9IF91dGlsLklERU5USVRZX01BVFJJWDtcbiAgICB0aGlzLnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgdGhpcy5mb250TWF0cml4ID0gX3V0aWwuRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy5sZWFkaW5nID0gMDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5saW5lWCA9IDA7XG4gICAgdGhpcy5saW5lWSA9IDA7XG4gICAgdGhpcy5jaGFyU3BhY2luZyA9IDA7XG4gICAgdGhpcy53b3JkU3BhY2luZyA9IDA7XG4gICAgdGhpcy50ZXh0SFNjYWxlID0gMTtcbiAgICB0aGlzLnRleHRSZW5kZXJpbmdNb2RlID0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTDtcbiAgICB0aGlzLnRleHRSaXNlID0gMDtcbiAgICB0aGlzLmZpbGxDb2xvciA9IFwiIzAwMDAwMFwiO1xuICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBcIiMwMDAwMDBcIjtcbiAgICB0aGlzLnBhdHRlcm5GaWxsID0gZmFsc2U7XG4gICAgdGhpcy5maWxsQWxwaGEgPSAxO1xuICAgIHRoaXMuc3Ryb2tlQWxwaGEgPSAxO1xuICAgIHRoaXMubGluZVdpZHRoID0gMTtcbiAgICB0aGlzLmFjdGl2ZVNNYXNrID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZmVyTWFwcyA9IFwibm9uZVwiO1xuICAgIHRoaXMuc3RhcnROZXdQYXRoQW5kQ2xpcEJveChbMCwgMCwgd2lkdGgsIGhlaWdodF0pO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICBjbG9uZS5jbGlwQm94ID0gdGhpcy5jbGlwQm94LnNsaWNlKCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHNldEN1cnJlbnRQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG4gIHVwZGF0ZVBhdGhNaW5NYXgodHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgW3gsIHldID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbeCwgeV0sIHRyYW5zZm9ybSk7XG4gICAgdGhpcy5taW5YID0gTWF0aC5taW4odGhpcy5taW5YLCB4KTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHkpO1xuICAgIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgeCk7XG4gICAgdGhpcy5tYXhZID0gTWF0aC5tYXgodGhpcy5tYXhZLCB5KTtcbiAgfVxuICB1cGRhdGVSZWN0TWluTWF4KHRyYW5zZm9ybSwgcmVjdCkge1xuICAgIGNvbnN0IHAxID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShyZWN0LCB0cmFuc2Zvcm0pO1xuICAgIGNvbnN0IHAyID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShyZWN0LnNsaWNlKDIpLCB0cmFuc2Zvcm0pO1xuICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgcDFbMF0sIHAyWzBdKTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHAxWzFdLCBwMlsxXSk7XG4gICAgdGhpcy5tYXhYID0gTWF0aC5tYXgodGhpcy5tYXhYLCBwMVswXSwgcDJbMF0pO1xuICAgIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgcDFbMV0sIHAyWzFdKTtcbiAgfVxuICB1cGRhdGVTY2FsaW5nUGF0aE1pbk1heCh0cmFuc2Zvcm0sIG1pbk1heCkge1xuICAgIF91dGlsLlV0aWwuc2NhbGVNaW5NYXgodHJhbnNmb3JtLCBtaW5NYXgpO1xuICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgbWluTWF4WzBdKTtcbiAgICB0aGlzLm1heFggPSBNYXRoLm1heCh0aGlzLm1heFgsIG1pbk1heFsxXSk7XG4gICAgdGhpcy5taW5ZID0gTWF0aC5taW4odGhpcy5taW5ZLCBtaW5NYXhbMl0pO1xuICAgIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgbWluTWF4WzNdKTtcbiAgfVxuICB1cGRhdGVDdXJ2ZVBhdGhNaW5NYXgodHJhbnNmb3JtLCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIG1pbk1heCkge1xuICAgIGNvbnN0IGJveCA9IF91dGlsLlV0aWwuYmV6aWVyQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICBpZiAobWluTWF4KSB7XG4gICAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIGJveFswXSwgYm94WzJdKTtcbiAgICAgIG1pbk1heFsxXSA9IE1hdGgubWF4KG1pbk1heFsxXSwgYm94WzBdLCBib3hbMl0pO1xuICAgICAgbWluTWF4WzJdID0gTWF0aC5taW4obWluTWF4WzJdLCBib3hbMV0sIGJveFszXSk7XG4gICAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIGJveFsxXSwgYm94WzNdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVSZWN0TWluTWF4KHRyYW5zZm9ybSwgYm94KTtcbiAgfVxuICBnZXRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUgPSBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuRklMTCwgdHJhbnNmb3JtID0gbnVsbCkge1xuICAgIGNvbnN0IGJveCA9IFt0aGlzLm1pblgsIHRoaXMubWluWSwgdGhpcy5tYXhYLCB0aGlzLm1heFldO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gX3BhdHRlcm5faGVscGVyLlBhdGhUeXBlLlNUUk9LRSkge1xuICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIlN0cm9rZSBib3VuZGluZyBib3ggbXVzdCBpbmNsdWRlIHRyYW5zZm9ybS5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBzY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IHhTdHJva2VQYWQgPSBzY2FsZVswXSAqIHRoaXMubGluZVdpZHRoIC8gMjtcbiAgICAgIGNvbnN0IHlTdHJva2VQYWQgPSBzY2FsZVsxXSAqIHRoaXMubGluZVdpZHRoIC8gMjtcbiAgICAgIGJveFswXSAtPSB4U3Ryb2tlUGFkO1xuICAgICAgYm94WzFdIC09IHlTdHJva2VQYWQ7XG4gICAgICBib3hbMl0gKz0geFN0cm9rZVBhZDtcbiAgICAgIGJveFszXSArPSB5U3Ryb2tlUGFkO1xuICAgIH1cbiAgICByZXR1cm4gYm94O1xuICB9XG4gIHVwZGF0ZUNsaXBGcm9tUGF0aCgpIHtcbiAgICBjb25zdCBpbnRlcnNlY3QgPSBfdXRpbC5VdGlsLmludGVyc2VjdCh0aGlzLmNsaXBCb3gsIHRoaXMuZ2V0UGF0aEJvdW5kaW5nQm94KCkpO1xuICAgIHRoaXMuc3RhcnROZXdQYXRoQW5kQ2xpcEJveChpbnRlcnNlY3QgfHwgWzAsIDAsIDAsIDBdKTtcbiAgfVxuICBpc0VtcHR5Q2xpcCgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5YID09PSBJbmZpbml0eTtcbiAgfVxuICBzdGFydE5ld1BhdGhBbmRDbGlwQm94KGJveCkge1xuICAgIHRoaXMuY2xpcEJveCA9IGJveDtcbiAgICB0aGlzLm1pblggPSBJbmZpbml0eTtcbiAgICB0aGlzLm1pblkgPSBJbmZpbml0eTtcbiAgICB0aGlzLm1heFggPSAwO1xuICAgIHRoaXMubWF4WSA9IDA7XG4gIH1cbiAgZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSA9IF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5GSUxMLCB0cmFuc2Zvcm0gPSBudWxsKSB7XG4gICAgcmV0dXJuIF91dGlsLlV0aWwuaW50ZXJzZWN0KHRoaXMuY2xpcEJveCwgdGhpcy5nZXRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUsIHRyYW5zZm9ybSkpO1xuICB9XG59XG5mdW5jdGlvbiBwdXRCaW5hcnlJbWFnZURhdGEoY3R4LCBpbWdEYXRhKSB7XG4gIGlmICh0eXBlb2YgSW1hZ2VEYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGltZ0RhdGEgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIDAsIDApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCxcbiAgICB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gIGNvbnN0IHBhcnRpYWxDaHVua0hlaWdodCA9IGhlaWdodCAlIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCBmdWxsQ2h1bmtzID0gKGhlaWdodCAtIHBhcnRpYWxDaHVua0hlaWdodCkgLyBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgdG90YWxDaHVua3MgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQgPT09IDAgPyBmdWxsQ2h1bmtzIDogZnVsbENodW5rcyArIDE7XG4gIGNvbnN0IGNodW5rSW1nRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgbGV0IHNyY1BvcyA9IDAsXG4gICAgZGVzdFBvcztcbiAgY29uc3Qgc3JjID0gaW1nRGF0YS5kYXRhO1xuICBjb25zdCBkZXN0ID0gY2h1bmtJbWdEYXRhLmRhdGE7XG4gIGxldCBpLCBqLCB0aGlzQ2h1bmtIZWlnaHQsIGVsZW1zSW5UaGlzQ2h1bms7XG4gIGlmIChpbWdEYXRhLmtpbmQgPT09IF91dGlsLkltYWdlS2luZC5HUkFZU0NBTEVfMUJQUCkge1xuICAgIGNvbnN0IHNyY0xlbmd0aCA9IHNyYy5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGRlc3QzMiA9IG5ldyBVaW50MzJBcnJheShkZXN0LmJ1ZmZlciwgMCwgZGVzdC5ieXRlTGVuZ3RoID4+IDIpO1xuICAgIGNvbnN0IGRlc3QzMkRhdGFMZW5ndGggPSBkZXN0MzIubGVuZ3RoO1xuICAgIGNvbnN0IGZ1bGxTcmNEaWZmID0gd2lkdGggKyA3ID4+IDM7XG4gICAgY29uc3Qgd2hpdGUgPSAweGZmZmZmZmZmO1xuICAgIGNvbnN0IGJsYWNrID0gX3V0aWwuRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4gPyAweGZmMDAwMDAwIDogMHgwMDAwMDBmZjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAgIGRlc3RQb3MgPSAwO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXNDaHVua0hlaWdodDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHNyY0RpZmYgPSBzcmNMZW5ndGggLSBzcmNQb3M7XG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgY29uc3Qga0VuZCA9IHNyY0RpZmYgPiBmdWxsU3JjRGlmZiA/IHdpZHRoIDogc3JjRGlmZiAqIDggLSA3O1xuICAgICAgICBjb25zdCBrRW5kVW5yb2xsZWQgPSBrRW5kICYgfjc7XG4gICAgICAgIGxldCBtYXNrID0gMDtcbiAgICAgICAgbGV0IHNyY0J5dGUgPSAwO1xuICAgICAgICBmb3IgKDsgayA8IGtFbmRVbnJvbGxlZDsgayArPSA4KSB7XG4gICAgICAgICAgc3JjQnl0ZSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMTI4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA2NCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMzIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDE2ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA0ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAyID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgayA8IGtFbmQ7IGsrKykge1xuICAgICAgICAgIGlmIChtYXNrID09PSAwKSB7XG4gICAgICAgICAgICBzcmNCeXRlID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgICAgIG1hc2sgPSAxMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIG1hc2sgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIG1hc2sgPj49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChkZXN0UG9zIDwgZGVzdDMyRGF0YUxlbmd0aCkge1xuICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IDA7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSBfdXRpbC5JbWFnZUtpbmQuUkdCQV8zMkJQUCkge1xuICAgIGogPSAwO1xuICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIEZVTExfQ0hVTktfSEVJR0hUICogNDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZnVsbENodW5rczsgaSsrKSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjUG9zLCBzcmNQb3MgKyBlbGVtc0luVGhpc0NodW5rKSk7XG4gICAgICBzcmNQb3MgKz0gZWxlbXNJblRoaXNDaHVuaztcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBqKTtcbiAgICAgIGogKz0gRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgfVxuICAgIGlmIChpIDwgdG90YWxDaHVua3MpIHtcbiAgICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHBhcnRpYWxDaHVua0hlaWdodCAqIDQ7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjUG9zLCBzcmNQb3MgKyBlbGVtc0luVGhpc0NodW5rKSk7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGltZ0RhdGEua2luZCA9PT0gX3V0aWwuSW1hZ2VLaW5kLlJHQl8yNEJQUCkge1xuICAgIHRoaXNDaHVua0hlaWdodCA9IEZVTExfQ0hVTktfSEVJR0hUO1xuICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHRoaXNDaHVua0hlaWdodDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgaWYgKGkgPj0gZnVsbENodW5rcykge1xuICAgICAgICB0aGlzQ2h1bmtIZWlnaHQgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHRoaXNDaHVua0hlaWdodDtcbiAgICAgIH1cbiAgICAgIGRlc3RQb3MgPSAwO1xuICAgICAgZm9yIChqID0gZWxlbXNJblRoaXNDaHVuazsgai0tOykge1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSAyNTU7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgaW1hZ2Uga2luZDogJHtpbWdEYXRhLmtpbmR9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1dEJpbmFyeUltYWdlTWFzayhjdHgsIGltZ0RhdGEpIHtcbiAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgY3R4LmRyYXdJbWFnZShpbWdEYXRhLmJpdG1hcCwgMCwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0LFxuICAgIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgY29uc3QgcGFydGlhbENodW5rSGVpZ2h0ID0gaGVpZ2h0ICUgRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IGZ1bGxDaHVua3MgPSAoaGVpZ2h0IC0gcGFydGlhbENodW5rSGVpZ2h0KSAvIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCB0b3RhbENodW5rcyA9IHBhcnRpYWxDaHVua0hlaWdodCA9PT0gMCA/IGZ1bGxDaHVua3MgOiBmdWxsQ2h1bmtzICsgMTtcbiAgY29uc3QgY2h1bmtJbWdEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgRlVMTF9DSFVOS19IRUlHSFQpO1xuICBsZXQgc3JjUG9zID0gMDtcbiAgY29uc3Qgc3JjID0gaW1nRGF0YS5kYXRhO1xuICBjb25zdCBkZXN0ID0gY2h1bmtJbWdEYXRhLmRhdGE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgIGNvbnN0IHRoaXNDaHVua0hlaWdodCA9IGkgPCBmdWxsQ2h1bmtzID8gRlVMTF9DSFVOS19IRUlHSFQgOiBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgKHtcbiAgICAgIHNyY1Bvc1xuICAgIH0gPSAoMCwgX2ltYWdlX3V0aWxzLmNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKSh7XG4gICAgICBzcmMsXG4gICAgICBzcmNQb3MsXG4gICAgICBkZXN0LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXNDaHVua0hlaWdodCxcbiAgICAgIG5vbkJsYWNrQ29sb3I6IDBcbiAgICB9KSk7XG4gICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvcHlDdHhTdGF0ZShzb3VyY2VDdHgsIGRlc3RDdHgpIHtcbiAgY29uc3QgcHJvcGVydGllcyA9IFtcInN0cm9rZVN0eWxlXCIsIFwiZmlsbFN0eWxlXCIsIFwiZmlsbFJ1bGVcIiwgXCJnbG9iYWxBbHBoYVwiLCBcImxpbmVXaWR0aFwiLCBcImxpbmVDYXBcIiwgXCJsaW5lSm9pblwiLCBcIm1pdGVyTGltaXRcIiwgXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIiwgXCJmb250XCIsIFwiZmlsdGVyXCJdO1xuICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoc291cmNlQ3R4W3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0Q3R4W3Byb3BlcnR5XSA9IHNvdXJjZUN0eFtwcm9wZXJ0eV07XG4gICAgfVxuICB9XG4gIGlmIChzb3VyY2VDdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgIGRlc3RDdHguc2V0TGluZURhc2goc291cmNlQ3R4LmdldExpbmVEYXNoKCkpO1xuICAgIGRlc3RDdHgubGluZURhc2hPZmZzZXQgPSBzb3VyY2VDdHgubGluZURhc2hPZmZzZXQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc2V0Q3R4VG9EZWZhdWx0KGN0eCkge1xuICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlID0gXCIjMDAwMDAwXCI7XG4gIGN0eC5maWxsUnVsZSA9IFwibm9uemVyb1wiO1xuICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICBjdHgubGluZVdpZHRoID0gMTtcbiAgY3R4LmxpbmVDYXAgPSBcImJ1dHRcIjtcbiAgY3R4LmxpbmVKb2luID0gXCJtaXRlclwiO1xuICBjdHgubWl0ZXJMaW1pdCA9IDEwO1xuICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2Utb3ZlclwiO1xuICBjdHguZm9udCA9IFwiMTBweCBzYW5zLXNlcmlmXCI7XG4gIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgfVxuICBpZiAoIV91dGlsLmlzTm9kZUpTKSB7XG4gICAgY29uc3Qge1xuICAgICAgZmlsdGVyXG4gICAgfSA9IGN0eDtcbiAgICBpZiAoZmlsdGVyICE9PSBcIm5vbmVcIiAmJiBmaWx0ZXIgIT09IFwiXCIpIHtcbiAgICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2VTTWFza0JhY2tkcm9wKGJ5dGVzLCByMCwgZzAsIGIwKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDM7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xuICAgIGNvbnN0IGFscGhhID0gYnl0ZXNbaV07XG4gICAgaWYgKGFscGhhID09PSAwKSB7XG4gICAgICBieXRlc1tpIC0gM10gPSByMDtcbiAgICAgIGJ5dGVzW2kgLSAyXSA9IGcwO1xuICAgICAgYnl0ZXNbaSAtIDFdID0gYjA7XG4gICAgfSBlbHNlIGlmIChhbHBoYSA8IDI1NSkge1xuICAgICAgY29uc3QgYWxwaGFfID0gMjU1IC0gYWxwaGE7XG4gICAgICBieXRlc1tpIC0gM10gPSBieXRlc1tpIC0gM10gKiBhbHBoYSArIHIwICogYWxwaGFfID4+IDg7XG4gICAgICBieXRlc1tpIC0gMl0gPSBieXRlc1tpIC0gMl0gKiBhbHBoYSArIGcwICogYWxwaGFfID4+IDg7XG4gICAgICBieXRlc1tpIC0gMV0gPSBieXRlc1tpIC0gMV0gKiBhbHBoYSArIGIwICogYWxwaGFfID4+IDg7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb21wb3NlU01hc2tBbHBoYShtYXNrRGF0YSwgbGF5ZXJEYXRhLCB0cmFuc2Zlck1hcCkge1xuICBjb25zdCBsZW5ndGggPSBtYXNrRGF0YS5sZW5ndGg7XG4gIGNvbnN0IHNjYWxlID0gMSAvIDI1NTtcbiAgZm9yIChsZXQgaSA9IDM7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xuICAgIGNvbnN0IGFscGhhID0gdHJhbnNmZXJNYXAgPyB0cmFuc2Zlck1hcFttYXNrRGF0YVtpXV0gOiBtYXNrRGF0YVtpXTtcbiAgICBsYXllckRhdGFbaV0gPSBsYXllckRhdGFbaV0gKiBhbHBoYSAqIHNjYWxlIHwgMDtcbiAgfVxufVxuZnVuY3Rpb24gY29tcG9zZVNNYXNrTHVtaW5vc2l0eShtYXNrRGF0YSwgbGF5ZXJEYXRhLCB0cmFuc2Zlck1hcCkge1xuICBjb25zdCBsZW5ndGggPSBtYXNrRGF0YS5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAzOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCB5ID0gbWFza0RhdGFbaSAtIDNdICogNzcgKyBtYXNrRGF0YVtpIC0gMl0gKiAxNTIgKyBtYXNrRGF0YVtpIC0gMV0gKiAyODtcbiAgICBsYXllckRhdGFbaV0gPSB0cmFuc2Zlck1hcCA/IGxheWVyRGF0YVtpXSAqIHRyYW5zZmVyTWFwW3kgPj4gOF0gPj4gOCA6IGxheWVyRGF0YVtpXSAqIHkgPj4gMTY7XG4gIH1cbn1cbmZ1bmN0aW9uIGdlbmVyaWNDb21wb3NlU01hc2sobWFza0N0eCwgbGF5ZXJDdHgsIHdpZHRoLCBoZWlnaHQsIHN1YnR5cGUsIGJhY2tkcm9wLCB0cmFuc2Zlck1hcCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIG1hc2tPZmZzZXRYLCBtYXNrT2Zmc2V0WSkge1xuICBjb25zdCBoYXNCYWNrZHJvcCA9ICEhYmFja2Ryb3A7XG4gIGNvbnN0IHIwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFswXSA6IDA7XG4gIGNvbnN0IGcwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFsxXSA6IDA7XG4gIGNvbnN0IGIwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFsyXSA6IDA7XG4gIGNvbnN0IGNvbXBvc2VGbiA9IHN1YnR5cGUgPT09IFwiTHVtaW5vc2l0eVwiID8gY29tcG9zZVNNYXNrTHVtaW5vc2l0eSA6IGNvbXBvc2VTTWFza0FscGhhO1xuICBjb25zdCBQSVhFTFNfVE9fUFJPQ0VTUyA9IDEwNDg1NzY7XG4gIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgubWluKGhlaWdodCwgTWF0aC5jZWlsKFBJWEVMU19UT19QUk9DRVNTIC8gd2lkdGgpKTtcbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgaGVpZ2h0OyByb3cgKz0gY2h1bmtTaXplKSB7XG4gICAgY29uc3QgY2h1bmtIZWlnaHQgPSBNYXRoLm1pbihjaHVua1NpemUsIGhlaWdodCAtIHJvdyk7XG4gICAgY29uc3QgbWFza0RhdGEgPSBtYXNrQ3R4LmdldEltYWdlRGF0YShsYXllck9mZnNldFggLSBtYXNrT2Zmc2V0WCwgcm93ICsgKGxheWVyT2Zmc2V0WSAtIG1hc2tPZmZzZXRZKSwgd2lkdGgsIGNodW5rSGVpZ2h0KTtcbiAgICBjb25zdCBsYXllckRhdGEgPSBsYXllckN0eC5nZXRJbWFnZURhdGEobGF5ZXJPZmZzZXRYLCByb3cgKyBsYXllck9mZnNldFksIHdpZHRoLCBjaHVua0hlaWdodCk7XG4gICAgaWYgKGhhc0JhY2tkcm9wKSB7XG4gICAgICBjb21wb3NlU01hc2tCYWNrZHJvcChtYXNrRGF0YS5kYXRhLCByMCwgZzAsIGIwKTtcbiAgICB9XG4gICAgY29tcG9zZUZuKG1hc2tEYXRhLmRhdGEsIGxheWVyRGF0YS5kYXRhLCB0cmFuc2Zlck1hcCk7XG4gICAgbGF5ZXJDdHgucHV0SW1hZ2VEYXRhKGxheWVyRGF0YSwgbGF5ZXJPZmZzZXRYLCByb3cgKyBsYXllck9mZnNldFkpO1xuICB9XG59XG5mdW5jdGlvbiBjb21wb3NlU01hc2soY3R4LCBzbWFzaywgbGF5ZXJDdHgsIGxheWVyQm94KSB7XG4gIGNvbnN0IGxheWVyT2Zmc2V0WCA9IGxheWVyQm94WzBdO1xuICBjb25zdCBsYXllck9mZnNldFkgPSBsYXllckJveFsxXTtcbiAgY29uc3QgbGF5ZXJXaWR0aCA9IGxheWVyQm94WzJdIC0gbGF5ZXJPZmZzZXRYO1xuICBjb25zdCBsYXllckhlaWdodCA9IGxheWVyQm94WzNdIC0gbGF5ZXJPZmZzZXRZO1xuICBpZiAobGF5ZXJXaWR0aCA9PT0gMCB8fCBsYXllckhlaWdodCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBnZW5lcmljQ29tcG9zZVNNYXNrKHNtYXNrLmNvbnRleHQsIGxheWVyQ3R4LCBsYXllcldpZHRoLCBsYXllckhlaWdodCwgc21hc2suc3VidHlwZSwgc21hc2suYmFja2Ryb3AsIHNtYXNrLnRyYW5zZmVyTWFwLCBsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgc21hc2sub2Zmc2V0WCwgc21hc2sub2Zmc2V0WSk7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG4gIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gIGN0eC5kcmF3SW1hZ2UobGF5ZXJDdHguY2FudmFzLCAwLCAwKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGdldEltYWdlU21vb3RoaW5nRW5hYmxlZCh0cmFuc2Zvcm0sIGludGVycG9sYXRlKSB7XG4gIGNvbnN0IHNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0cmFuc2Zvcm0pO1xuICBzY2FsZVswXSA9IE1hdGguZnJvdW5kKHNjYWxlWzBdKTtcbiAgc2NhbGVbMV0gPSBNYXRoLmZyb3VuZChzY2FsZVsxXSk7XG4gIGNvbnN0IGFjdHVhbFNjYWxlID0gTWF0aC5mcm91bmQoKGdsb2JhbFRoaXMuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAqIF9kaXNwbGF5X3V0aWxzLlBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyk7XG4gIGlmIChpbnRlcnBvbGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGludGVycG9sYXRlO1xuICB9IGVsc2UgaWYgKHNjYWxlWzBdIDw9IGFjdHVhbFNjYWxlIHx8IHNjYWxlWzFdIDw9IGFjdHVhbFNjYWxlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgTElORV9DQVBfU1RZTEVTID0gW1wiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCJdO1xuY29uc3QgTElORV9KT0lOX1NUWUxFUyA9IFtcIm1pdGVyXCIsIFwicm91bmRcIiwgXCJiZXZlbFwiXTtcbmNvbnN0IE5PUk1BTF9DTElQID0ge307XG5jb25zdCBFT19DTElQID0ge307XG5jbGFzcyBDYW52YXNHcmFwaGljcyB7XG4gIGNvbnN0cnVjdG9yKGNhbnZhc0N0eCwgY29tbW9uT2Jqcywgb2JqcywgY2FudmFzRmFjdG9yeSwgZmlsdGVyRmFjdG9yeSwge1xuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZyxcbiAgICBtYXJrZWRDb250ZW50U3RhY2sgPSBudWxsXG4gIH0sIGFubm90YXRpb25DYW52YXNNYXAsIHBhZ2VDb2xvcnMpIHtcbiAgICB0aGlzLmN0eCA9IGNhbnZhc0N0eDtcbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgQ2FudmFzRXh0cmFTdGF0ZSh0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMuc3RhdGVTdGFjayA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgIHRoaXMucmVzID0gbnVsbDtcbiAgICB0aGlzLnhvYmpzID0gbnVsbDtcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmaWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuZ3JvdXBTdGFjayA9IFtdO1xuICAgIHRoaXMucHJvY2Vzc2luZ1R5cGUzID0gbnVsbDtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBudWxsO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybVN0YWNrID0gW107XG4gICAgdGhpcy5ncm91cExldmVsID0gMDtcbiAgICB0aGlzLnNtYXNrU3RhY2sgPSBbXTtcbiAgICB0aGlzLnNtYXNrQ291bnRlciA9IDA7XG4gICAgdGhpcy50ZW1wU01hc2sgPSBudWxsO1xuICAgIHRoaXMuc3VzcGVuZGVkQ3R4ID0gbnVsbDtcbiAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjayA9IG1hcmtlZENvbnRlbnRTdGFjayB8fCBbXTtcbiAgICB0aGlzLm9wdGlvbmFsQ29udGVudENvbmZpZyA9IG9wdGlvbmFsQ29udGVudENvbmZpZztcbiAgICB0aGlzLmNhY2hlZENhbnZhc2VzID0gbmV3IENhY2hlZENhbnZhc2VzKHRoaXMuY2FudmFzRmFjdG9yeSk7XG4gICAgdGhpcy5jYWNoZWRQYXR0ZXJucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAgPSBhbm5vdGF0aW9uQ2FudmFzTWFwO1xuICAgIHRoaXMudmlld3BvcnRTY2FsZSA9IDE7XG4gICAgdGhpcy5vdXRwdXRTY2FsZVggPSAxO1xuICAgIHRoaXMub3V0cHV0U2NhbGVZID0gMTtcbiAgICB0aGlzLnBhZ2VDb2xvcnMgPSBwYWdlQ29sb3JzO1xuICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmcgPSBbLTEsIDBdO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICAgIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAgPSBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0T2JqZWN0KGRhdGEsIGZhbGxiYWNrID0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGRhdGEuc3RhcnRzV2l0aChcImdfXCIpID8gdGhpcy5jb21tb25PYmpzLmdldChkYXRhKSA6IHRoaXMub2Jqcy5nZXQoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFjaztcbiAgfVxuICBiZWdpbkRyYXdpbmcoe1xuICAgIHRyYW5zZm9ybSxcbiAgICB2aWV3cG9ydCxcbiAgICB0cmFuc3BhcmVuY3kgPSBmYWxzZSxcbiAgICBiYWNrZ3JvdW5kID0gbnVsbFxuICB9KSB7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmN0eC5jYW52YXMud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jdHguY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBzYXZlZEZpbGxTdHlsZSA9IHRoaXMuY3R4LmZpbGxTdHlsZTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kIHx8IFwiI2ZmZmZmZlwiO1xuICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHNhdmVkRmlsbFN0eWxlO1xuICAgIGlmICh0cmFuc3BhcmVuY3kpIHtcbiAgICAgIGNvbnN0IHRyYW5zcGFyZW50Q2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJ0cmFuc3BhcmVudFwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY29tcG9zaXRlQ3R4ID0gdGhpcy5jdHg7XG4gICAgICB0aGlzLnRyYW5zcGFyZW50Q2FudmFzID0gdHJhbnNwYXJlbnRDYW52YXMuY2FudmFzO1xuICAgICAgdGhpcy5jdHggPSB0cmFuc3BhcmVudENhbnZhcy5jb250ZXh0O1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLigwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmNvbXBvc2l0ZUN0eCkpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi50cmFuc2Zvcm0pO1xuICAgICAgdGhpcy5vdXRwdXRTY2FsZVggPSB0cmFuc2Zvcm1bMF07XG4gICAgICB0aGlzLm91dHB1dFNjYWxlWSA9IHRyYW5zZm9ybVswXTtcbiAgICB9XG4gICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLnZpZXdwb3J0LnRyYW5zZm9ybSk7XG4gICAgdGhpcy52aWV3cG9ydFNjYWxlID0gdmlld3BvcnQuc2NhbGU7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KTtcbiAgfVxuICBleGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCwgZXhlY3V0aW9uU3RhcnRJZHgsIGNvbnRpbnVlQ2FsbGJhY2ssIHN0ZXBwZXIpIHtcbiAgICBjb25zdCBhcmdzQXJyYXkgPSBvcGVyYXRvckxpc3QuYXJnc0FycmF5O1xuICAgIGNvbnN0IGZuQXJyYXkgPSBvcGVyYXRvckxpc3QuZm5BcnJheTtcbiAgICBsZXQgaSA9IGV4ZWN1dGlvblN0YXJ0SWR4IHx8IDA7XG4gICAgY29uc3QgYXJnc0FycmF5TGVuID0gYXJnc0FycmF5Lmxlbmd0aDtcbiAgICBpZiAoYXJnc0FycmF5TGVuID09PSBpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtPcGVyYXRpb25zID0gYXJnc0FycmF5TGVuIC0gaSA+IEVYRUNVVElPTl9TVEVQUyAmJiB0eXBlb2YgY29udGludWVDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiO1xuICAgIGNvbnN0IGVuZFRpbWUgPSBjaHVua09wZXJhdGlvbnMgPyBEYXRlLm5vdygpICsgRVhFQ1VUSU9OX1RJTUUgOiAwO1xuICAgIGxldCBzdGVwcyA9IDA7XG4gICAgY29uc3QgY29tbW9uT2JqcyA9IHRoaXMuY29tbW9uT2JqcztcbiAgICBjb25zdCBvYmpzID0gdGhpcy5vYmpzO1xuICAgIGxldCBmbklkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoc3RlcHBlciAhPT0gdW5kZWZpbmVkICYmIGkgPT09IHN0ZXBwZXIubmV4dEJyZWFrUG9pbnQpIHtcbiAgICAgICAgc3RlcHBlci5icmVha0l0KGksIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIGZuSWQgPSBmbkFycmF5W2ldO1xuICAgICAgaWYgKGZuSWQgIT09IF91dGlsLk9QUy5kZXBlbmRlbmN5KSB7XG4gICAgICAgIHRoaXNbZm5JZF0uYXBwbHkodGhpcywgYXJnc0FycmF5W2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgZGVwT2JqSWQgb2YgYXJnc0FycmF5W2ldKSB7XG4gICAgICAgICAgY29uc3Qgb2Jqc1Bvb2wgPSBkZXBPYmpJZC5zdGFydHNXaXRoKFwiZ19cIikgPyBjb21tb25PYmpzIDogb2JqcztcbiAgICAgICAgICBpZiAoIW9ianNQb29sLmhhcyhkZXBPYmpJZCkpIHtcbiAgICAgICAgICAgIG9ianNQb29sLmdldChkZXBPYmpJZCwgY29udGludWVDYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICAgIGlmIChpID09PSBhcmdzQXJyYXlMZW4pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmtPcGVyYXRpb25zICYmICsrc3RlcHMgPiBFWEVDVVRJT05fU1RFUFMpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgPiBlbmRUaW1lKSB7XG4gICAgICAgICAgY29udGludWVDYWxsYmFjaygpO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXBzID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI3Jlc3RvcmVJbml0aWFsU3RhdGUoKSB7XG4gICAgd2hpbGUgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggfHwgdGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICBpZiAodGhpcy50cmFuc3BhcmVudENhbnZhcykge1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmNvbXBvc2l0ZUN0eDtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLnRyYW5zcGFyZW50Q2FudmFzLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMudHJhbnNwYXJlbnRDYW52YXMgPSBudWxsO1xuICAgIH1cbiAgfVxuICBlbmREcmF3aW5nKCkge1xuICAgIHRoaXMuI3Jlc3RvcmVJbml0aWFsU3RhdGUoKTtcbiAgICB0aGlzLmNhY2hlZENhbnZhc2VzLmNsZWFyKCk7XG4gICAgdGhpcy5jYWNoZWRQYXR0ZXJucy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgY2FjaGUgb2YgdGhpcy5fY2FjaGVkQml0bWFwc01hcC52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBjYW52YXMgb2YgY2FjaGUudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLmNsZWFyKCk7XG4gICAgdGhpcy4jZHJhd0ZpbHRlcigpO1xuICB9XG4gICNkcmF3RmlsdGVyKCkge1xuICAgIGlmICh0aGlzLnBhZ2VDb2xvcnMpIHtcbiAgICAgIGNvbnN0IGhjbUZpbHRlcklkID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEhDTUZpbHRlcih0aGlzLnBhZ2VDb2xvcnMuZm9yZWdyb3VuZCwgdGhpcy5wYWdlQ29sb3JzLmJhY2tncm91bmQpO1xuICAgICAgaWYgKGhjbUZpbHRlcklkICE9PSBcIm5vbmVcIikge1xuICAgICAgICBjb25zdCBzYXZlZEZpbHRlciA9IHRoaXMuY3R4LmZpbHRlcjtcbiAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gaGNtRmlsdGVySWQ7XG4gICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLmN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSBzYXZlZEZpbHRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3NjYWxlSW1hZ2UoaW1nLCBpbnZlcnNlVHJhbnNmb3JtKSB7XG4gICAgY29uc3Qgd2lkdGggPSBpbWcud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICBsZXQgd2lkdGhTY2FsZSA9IE1hdGgubWF4KE1hdGguaHlwb3QoaW52ZXJzZVRyYW5zZm9ybVswXSwgaW52ZXJzZVRyYW5zZm9ybVsxXSksIDEpO1xuICAgIGxldCBoZWlnaHRTY2FsZSA9IE1hdGgubWF4KE1hdGguaHlwb3QoaW52ZXJzZVRyYW5zZm9ybVsyXSwgaW52ZXJzZVRyYW5zZm9ybVszXSksIDEpO1xuICAgIGxldCBwYWludFdpZHRoID0gd2lkdGgsXG4gICAgICBwYWludEhlaWdodCA9IGhlaWdodDtcbiAgICBsZXQgdG1wQ2FudmFzSWQgPSBcInByZXNjYWxlMVwiO1xuICAgIGxldCB0bXBDYW52YXMsIHRtcEN0eDtcbiAgICB3aGlsZSAod2lkdGhTY2FsZSA+IDIgJiYgcGFpbnRXaWR0aCA+IDEgfHwgaGVpZ2h0U2NhbGUgPiAyICYmIHBhaW50SGVpZ2h0ID4gMSkge1xuICAgICAgbGV0IG5ld1dpZHRoID0gcGFpbnRXaWR0aCxcbiAgICAgICAgbmV3SGVpZ2h0ID0gcGFpbnRIZWlnaHQ7XG4gICAgICBpZiAod2lkdGhTY2FsZSA+IDIgJiYgcGFpbnRXaWR0aCA+IDEpIHtcbiAgICAgICAgbmV3V2lkdGggPSBwYWludFdpZHRoID49IDE2Mzg0ID8gTWF0aC5mbG9vcihwYWludFdpZHRoIC8gMikgLSAxIHx8IDEgOiBNYXRoLmNlaWwocGFpbnRXaWR0aCAvIDIpO1xuICAgICAgICB3aWR0aFNjYWxlIC89IHBhaW50V2lkdGggLyBuZXdXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHRTY2FsZSA+IDIgJiYgcGFpbnRIZWlnaHQgPiAxKSB7XG4gICAgICAgIG5ld0hlaWdodCA9IHBhaW50SGVpZ2h0ID49IDE2Mzg0ID8gTWF0aC5mbG9vcihwYWludEhlaWdodCAvIDIpIC0gMSB8fCAxIDogTWF0aC5jZWlsKHBhaW50SGVpZ2h0KSAvIDI7XG4gICAgICAgIGhlaWdodFNjYWxlIC89IHBhaW50SGVpZ2h0IC8gbmV3SGVpZ2h0O1xuICAgICAgfVxuICAgICAgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXModG1wQ2FudmFzSWQsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICB0bXBDdHguY2xlYXJSZWN0KDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgdG1wQ3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHBhaW50V2lkdGgsIHBhaW50SGVpZ2h0LCAwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIGltZyA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgICBwYWludFdpZHRoID0gbmV3V2lkdGg7XG4gICAgICBwYWludEhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgIHRtcENhbnZhc0lkID0gdG1wQ2FudmFzSWQgPT09IFwicHJlc2NhbGUxXCIgPyBcInByZXNjYWxlMlwiIDogXCJwcmVzY2FsZTFcIjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGltZyxcbiAgICAgIHBhaW50V2lkdGgsXG4gICAgICBwYWludEhlaWdodFxuICAgIH07XG4gIH1cbiAgX2NyZWF0ZU1hc2tDYW52YXMoaW1nKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gaW1nO1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgY29uc3QgaXNQYXR0ZXJuRmlsbCA9IHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCk7XG4gICAgbGV0IGNhY2hlLCBjYWNoZUtleSwgc2NhbGVkLCBtYXNrQ2FudmFzO1xuICAgIGlmICgoaW1nLmJpdG1hcCB8fCBpbWcuZGF0YSkgJiYgaW1nLmNvdW50ID4gMSkge1xuICAgICAgY29uc3QgbWFpbktleSA9IGltZy5iaXRtYXAgfHwgaW1nLmRhdGEuYnVmZmVyO1xuICAgICAgY2FjaGVLZXkgPSBKU09OLnN0cmluZ2lmeShpc1BhdHRlcm5GaWxsID8gY3VycmVudFRyYW5zZm9ybSA6IFtjdXJyZW50VHJhbnNmb3JtLnNsaWNlKDAsIDQpLCBmaWxsQ29sb3JdKTtcbiAgICAgIGNhY2hlID0gdGhpcy5fY2FjaGVkQml0bWFwc01hcC5nZXQobWFpbktleSk7XG4gICAgICBpZiAoIWNhY2hlKSB7XG4gICAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLnNldChtYWluS2V5LCBjYWNoZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjYWNoZWRJbWFnZSA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoY2FjaGVkSW1hZ2UgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVswXSwgY3VycmVudFRyYW5zZm9ybVsyXSkgKyBjdXJyZW50VHJhbnNmb3JtWzRdKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVsxXSwgY3VycmVudFRyYW5zZm9ybVszXSkgKyBjdXJyZW50VHJhbnNmb3JtWzVdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW52YXM6IGNhY2hlZEltYWdlLFxuICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc2NhbGVkID0gY2FjaGVkSW1hZ2U7XG4gICAgfVxuICAgIGlmICghc2NhbGVkKSB7XG4gICAgICBtYXNrQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrQ2FudmFzXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDYW52YXMuY29udGV4dCwgaW1nKTtcbiAgICB9XG4gICAgbGV0IG1hc2tUb0NhbnZhcyA9IF91dGlsLlV0aWwudHJhbnNmb3JtKGN1cnJlbnRUcmFuc2Zvcm0sIFsxIC8gd2lkdGgsIDAsIDAsIC0xIC8gaGVpZ2h0LCAwLCAwXSk7XG4gICAgbWFza1RvQ2FudmFzID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0obWFza1RvQ2FudmFzLCBbMSwgMCwgMCwgMSwgMCwgLWhlaWdodF0pO1xuICAgIGNvbnN0IGNvcmQxID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbMCwgMF0sIG1hc2tUb0NhbnZhcyk7XG4gICAgY29uc3QgY29yZDIgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt3aWR0aCwgaGVpZ2h0XSwgbWFza1RvQ2FudmFzKTtcbiAgICBjb25zdCByZWN0ID0gX3V0aWwuVXRpbC5ub3JtYWxpemVSZWN0KFtjb3JkMVswXSwgY29yZDFbMV0sIGNvcmQyWzBdLCBjb3JkMlsxXV0pO1xuICAgIGNvbnN0IGRyYXduV2lkdGggPSBNYXRoLnJvdW5kKHJlY3RbMl0gLSByZWN0WzBdKSB8fCAxO1xuICAgIGNvbnN0IGRyYXduSGVpZ2h0ID0gTWF0aC5yb3VuZChyZWN0WzNdIC0gcmVjdFsxXSkgfHwgMTtcbiAgICBjb25zdCBmaWxsQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJmaWxsQ2FudmFzXCIsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICBjb25zdCBmaWxsQ3R4ID0gZmlsbENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLm1pbihjb3JkMVswXSwgY29yZDJbMF0pO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLm1pbihjb3JkMVsxXSwgY29yZDJbMV0pO1xuICAgIGZpbGxDdHgudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gICAgZmlsbEN0eC50cmFuc2Zvcm0oLi4ubWFza1RvQ2FudmFzKTtcbiAgICBpZiAoIXNjYWxlZCkge1xuICAgICAgc2NhbGVkID0gdGhpcy5fc2NhbGVJbWFnZShtYXNrQ2FudmFzLmNhbnZhcywgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShmaWxsQ3R4KSk7XG4gICAgICBzY2FsZWQgPSBzY2FsZWQuaW1nO1xuICAgICAgaWYgKGNhY2hlICYmIGlzUGF0dGVybkZpbGwpIHtcbiAgICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBzY2FsZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmaWxsQ3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGdldEltYWdlU21vb3RoaW5nRW5hYmxlZCgoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoZmlsbEN0eCksIGltZy5pbnRlcnBvbGF0ZSk7XG4gICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGZpbGxDdHgsIHNjYWxlZCwgMCwgMCwgc2NhbGVkLndpZHRoLCBzY2FsZWQuaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBmaWxsQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgY29uc3QgaW52ZXJzZSA9IF91dGlsLlV0aWwudHJhbnNmb3JtKCgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoZmlsbEN0eCksIFsxLCAwLCAwLCAxLCAtb2Zmc2V0WCwgLW9mZnNldFldKTtcbiAgICBmaWxsQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGludmVyc2UsIF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5GSUxMKSA6IGZpbGxDb2xvcjtcbiAgICBmaWxsQ3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmIChjYWNoZSAmJiAhaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgdGhpcy5jYWNoZWRDYW52YXNlcy5kZWxldGUoXCJmaWxsQ2FudmFzXCIpO1xuICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBmaWxsQ2FudmFzLmNhbnZhcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjYW52YXM6IGZpbGxDYW52YXMuY2FudmFzLFxuICAgICAgb2Zmc2V0WDogTWF0aC5yb3VuZChvZmZzZXRYKSxcbiAgICAgIG9mZnNldFk6IE1hdGgucm91bmQob2Zmc2V0WSlcbiAgICB9O1xuICB9XG4gIHNldExpbmVXaWR0aCh3aWR0aCkge1xuICAgIGlmICh3aWR0aCAhPT0gdGhpcy5jdXJyZW50LmxpbmVXaWR0aCkge1xuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQubGluZVdpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5jdHgubGluZVdpZHRoID0gd2lkdGg7XG4gIH1cbiAgc2V0TGluZUNhcChzdHlsZSkge1xuICAgIHRoaXMuY3R4LmxpbmVDYXAgPSBMSU5FX0NBUF9TVFlMRVNbc3R5bGVdO1xuICB9XG4gIHNldExpbmVKb2luKHN0eWxlKSB7XG4gICAgdGhpcy5jdHgubGluZUpvaW4gPSBMSU5FX0pPSU5fU1RZTEVTW3N0eWxlXTtcbiAgfVxuICBzZXRNaXRlckxpbWl0KGxpbWl0KSB7XG4gICAgdGhpcy5jdHgubWl0ZXJMaW1pdCA9IGxpbWl0O1xuICB9XG4gIHNldERhc2goZGFzaEFycmF5LCBkYXNoUGhhc2UpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZGFzaFBoYXNlO1xuICAgIH1cbiAgfVxuICBzZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50KSB7fVxuICBzZXRGbGF0bmVzcyhmbGF0bmVzcykge31cbiAgc2V0R1N0YXRlKHN0YXRlcykge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHN0YXRlcykge1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcIkxXXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lV2lkdGgodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTENcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVDYXAodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTEpcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVKb2luKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1MXCI6XG4gICAgICAgICAgdGhpcy5zZXRNaXRlckxpbWl0KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICB0aGlzLnNldERhc2godmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlJJXCI6XG4gICAgICAgICAgdGhpcy5zZXRSZW5kZXJpbmdJbnRlbnQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRkxcIjpcbiAgICAgICAgICB0aGlzLnNldEZsYXRuZXNzKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZvbnRcIjpcbiAgICAgICAgICB0aGlzLnNldEZvbnQodmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkNBXCI6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnN0cm9rZUFscGhhID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjYVwiOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5maWxsQWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQk1cIjpcbiAgICAgICAgICB0aGlzLmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlNNYXNrXCI6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrID0gdmFsdWUgPyB0aGlzLnRlbXBTTWFzayA6IG51bGw7XG4gICAgICAgICAgdGhpcy50ZW1wU01hc2sgPSBudWxsO1xuICAgICAgICAgIHRoaXMuY2hlY2tTTWFza1N0YXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJUUlwiOlxuICAgICAgICAgIHRoaXMuY3R4LmZpbHRlciA9IHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHMgPSB0aGlzLmZpbHRlckZhY3RvcnkuYWRkRmlsdGVyKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IGluU01hc2tNb2RlKCkge1xuICAgIHJldHVybiAhIXRoaXMuc3VzcGVuZGVkQ3R4O1xuICB9XG4gIGNoZWNrU01hc2tTdGF0ZSgpIHtcbiAgICBjb25zdCBpblNNYXNrTW9kZSA9IHRoaXMuaW5TTWFza01vZGU7XG4gICAgaWYgKHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayAmJiAhaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMuYmVnaW5TTWFza01vZGUoKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgJiYgaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMuZW5kU01hc2tNb2RlKCk7XG4gICAgfVxuICB9XG4gIGJlZ2luU01hc2tNb2RlKCkge1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiZWdpblNNYXNrTW9kZSBjYWxsZWQgd2hpbGUgYWxyZWFkeSBpbiBzbWFzayBtb2RlXCIpO1xuICAgIH1cbiAgICBjb25zdCBkcmF3bldpZHRoID0gdGhpcy5jdHguY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGRyYXduSGVpZ2h0ID0gdGhpcy5jdHguY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBjYWNoZUlkID0gXCJzbWFza0dyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcbiAgICBjb25zdCBzY3JhdGNoQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoY2FjaGVJZCwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQpO1xuICAgIHRoaXMuc3VzcGVuZGVkQ3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5jdHggPSBzY3JhdGNoQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY3R4LnNldFRyYW5zZm9ybSguLi4oMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5zdXNwZW5kZWRDdHgpKTtcbiAgICBjb3B5Q3R4U3RhdGUodGhpcy5zdXNwZW5kZWRDdHgsIGN0eCk7XG4gICAgbWlycm9yQ29udGV4dE9wZXJhdGlvbnMoY3R4LCB0aGlzLnN1c3BlbmRlZEN0eCk7XG4gICAgdGhpcy5zZXRHU3RhdGUoW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl0sIFtcImNhXCIsIDFdLCBbXCJDQVwiLCAxXV0pO1xuICB9XG4gIGVuZFNNYXNrTW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImVuZFNNYXNrTW9kZSBjYWxsZWQgd2hpbGUgbm90IGluIHNtYXNrIG1vZGVcIik7XG4gICAgfVxuICAgIHRoaXMuY3R4Ll9yZW1vdmVNaXJyb3JpbmcoKTtcbiAgICBjb3B5Q3R4U3RhdGUodGhpcy5jdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB0aGlzLmN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIHRoaXMuc3VzcGVuZGVkQ3R4ID0gbnVsbDtcbiAgfVxuICBjb21wb3NlKGRpcnR5Qm94KSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFkaXJ0eUJveCkge1xuICAgICAgZGlydHlCb3ggPSBbMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlCb3hbMF0gPSBNYXRoLmZsb29yKGRpcnR5Qm94WzBdKTtcbiAgICAgIGRpcnR5Qm94WzFdID0gTWF0aC5mbG9vcihkaXJ0eUJveFsxXSk7XG4gICAgICBkaXJ0eUJveFsyXSA9IE1hdGguY2VpbChkaXJ0eUJveFsyXSk7XG4gICAgICBkaXJ0eUJveFszXSA9IE1hdGguY2VpbChkaXJ0eUJveFszXSk7XG4gICAgfVxuICAgIGNvbnN0IHNtYXNrID0gdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrO1xuICAgIGNvbnN0IHN1c3BlbmRlZEN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIGNvbXBvc2VTTWFzayhzdXNwZW5kZWRDdHgsIHNtYXNrLCB0aGlzLmN0eCwgZGlydHlCb3gpO1xuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICB9XG4gIHNhdmUoKSB7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIGNvcHlDdHhTdGF0ZSh0aGlzLmN0eCwgdGhpcy5zdXNwZW5kZWRDdHgpO1xuICAgICAgdGhpcy5zdXNwZW5kZWRDdHguc2F2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGNvbnN0IG9sZCA9IHRoaXMuY3VycmVudDtcbiAgICB0aGlzLnN0YXRlU3RhY2sucHVzaChvbGQpO1xuICAgIHRoaXMuY3VycmVudCA9IG9sZC5jbG9uZSgpO1xuICB9XG4gIHJlc3RvcmUoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggPT09IDAgJiYgdGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICAgIHRoaXMuc3VzcGVuZGVkQ3R4LnJlc3RvcmUoKTtcbiAgICAgICAgY29weUN0eFN0YXRlKHRoaXMuc3VzcGVuZGVkQ3R4LCB0aGlzLmN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrU01hc2tTdGF0ZSgpO1xuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgdHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICB0aGlzLmN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICB9XG4gIGNvbnN0cnVjdFBhdGgob3BzLCBhcmdzLCBtaW5NYXgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGxldCB4ID0gY3VycmVudC54LFxuICAgICAgeSA9IGN1cnJlbnQueTtcbiAgICBsZXQgc3RhcnRYLCBzdGFydFk7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpO1xuICAgIGNvbnN0IGlzU2NhbGluZ01hdHJpeCA9IGN1cnJlbnRUcmFuc2Zvcm1bMF0gPT09IDAgJiYgY3VycmVudFRyYW5zZm9ybVszXSA9PT0gMCB8fCBjdXJyZW50VHJhbnNmb3JtWzFdID09PSAwICYmIGN1cnJlbnRUcmFuc2Zvcm1bMl0gPT09IDA7XG4gICAgY29uc3QgbWluTWF4Rm9yQmV6aWVyID0gaXNTY2FsaW5nTWF0cml4ID8gbWluTWF4LnNsaWNlKDApIDogbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDAsIGlpID0gb3BzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHN3aXRjaCAob3BzW2ldIHwgMCkge1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5yZWN0YW5nbGU6XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gYXJnc1tqKytdO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCB4dyA9IHggKyB3aWR0aDtcbiAgICAgICAgICBjb25zdCB5aCA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICBpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHh3LCB5aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeHcsIHkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4dywgeWgpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNTY2FsaW5nTWF0cml4KSB7XG4gICAgICAgICAgICBjdXJyZW50LnVwZGF0ZVJlY3RNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgW3gsIHksIHh3LCB5aF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLm1vdmVUbzpcbiAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICBpZiAoIWlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgICAgICAgY3VycmVudC51cGRhdGVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMubGluZVRvOlxuICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgIGlmICghaXNTY2FsaW5nTWF0cml4KSB7XG4gICAgICAgICAgICBjdXJyZW50LnVwZGF0ZVBhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgeCwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvOlxuICAgICAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICAgICAgc3RhcnRZID0geTtcbiAgICAgICAgICB4ID0gYXJnc1tqICsgNF07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDVdO1xuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCBhcmdzW2ogKyAyXSwgYXJnc1tqICsgM10sIHgsIHkpO1xuICAgICAgICAgIGN1cnJlbnQudXBkYXRlQ3VydmVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHN0YXJ0WCwgc3RhcnRZLCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdLCB4LCB5LCBtaW5NYXhGb3JCZXppZXIpO1xuICAgICAgICAgIGogKz0gNjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzI6XG4gICAgICAgICAgc3RhcnRYID0geDtcbiAgICAgICAgICBzdGFydFkgPSB5O1xuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHksIGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCBhcmdzW2ogKyAyXSwgYXJnc1tqICsgM10pO1xuICAgICAgICAgIGN1cnJlbnQudXBkYXRlQ3VydmVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHN0YXJ0WCwgc3RhcnRZLCB4LCB5LCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdLCBtaW5NYXhGb3JCZXppZXIpO1xuICAgICAgICAgIHggPSBhcmdzW2ogKyAyXTtcbiAgICAgICAgICB5ID0gYXJnc1tqICsgM107XG4gICAgICAgICAgaiArPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvMzpcbiAgICAgICAgICBzdGFydFggPSB4O1xuICAgICAgICAgIHN0YXJ0WSA9IHk7XG4gICAgICAgICAgeCA9IGFyZ3NbaiArIDJdO1xuICAgICAgICAgIHkgPSBhcmdzW2ogKyAzXTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhhcmdzW2pdLCBhcmdzW2ogKyAxXSwgeCwgeSwgeCwgeSk7XG4gICAgICAgICAgY3VycmVudC51cGRhdGVDdXJ2ZVBhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgc3RhcnRYLCBzdGFydFksIGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCB4LCB5LCB4LCB5LCBtaW5NYXhGb3JCZXppZXIpO1xuICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VQYXRoOlxuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgY3VycmVudC51cGRhdGVTY2FsaW5nUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBtaW5NYXhGb3JCZXppZXIpO1xuICAgIH1cbiAgICBjdXJyZW50LnNldEN1cnJlbnRQb2ludCh4LCB5KTtcbiAgfVxuICBjbG9zZVBhdGgoKSB7XG4gICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XG4gIH1cbiAgc3Ryb2tlKGNvbnN1bWVQYXRoID0gdHJ1ZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5zdHJva2VBbHBoYTtcbiAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgaWYgKHR5cGVvZiBzdHJva2VDb2xvciA9PT0gXCJvYmplY3RcIiAmJiBzdHJva2VDb2xvcj8uZ2V0UGF0dGVybikge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShjdHgpLCBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuU1RST0tFKTtcbiAgICAgICAgdGhpcy5yZXNjYWxlQW5kU3Ryb2tlKGZhbHNlKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzY2FsZUFuZFN0cm9rZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnN1bWVQYXRoKSB7XG4gICAgICB0aGlzLmNvbnN1bWVQYXRoKHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KCkpO1xuICAgIH1cbiAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmN1cnJlbnQuZmlsbEFscGhhO1xuICB9XG4gIGNsb3NlU3Ryb2tlKCkge1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5zdHJva2UoKTtcbiAgfVxuICBmaWxsKGNvbnN1bWVQYXRoID0gdHJ1ZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgY29uc3QgaXNQYXR0ZXJuRmlsbCA9IHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBsZXQgbmVlZFJlc3RvcmUgPSBmYWxzZTtcbiAgICBpZiAoaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KSwgX3BhdHRlcm5faGVscGVyLlBhdGhUeXBlLkZJTEwpO1xuICAgICAgbmVlZFJlc3RvcmUgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcnNlY3QgPSB0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCgpO1xuICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlICYmIGludGVyc2VjdCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMucGVuZGluZ0VPRmlsbCkge1xuICAgICAgICBjdHguZmlsbChcImV2ZW5vZGRcIik7XG4gICAgICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5lZWRSZXN0b3JlKSB7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAoY29uc3VtZVBhdGgpIHtcbiAgICAgIHRoaXMuY29uc3VtZVBhdGgoaW50ZXJzZWN0KTtcbiAgICB9XG4gIH1cbiAgZW9GaWxsKCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsKCk7XG4gIH1cbiAgZmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLmZpbGwoZmFsc2UpO1xuICAgIHRoaXMuc3Ryb2tlKGZhbHNlKTtcbiAgICB0aGlzLmNvbnN1bWVQYXRoKCk7XG4gIH1cbiAgZW9GaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gIH1cbiAgY2xvc2VGaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gIH1cbiAgY2xvc2VFT0ZpbGxTdHJva2UoKSB7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gdHJ1ZTtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICB9XG4gIGVuZFBhdGgoKSB7XG4gICAgdGhpcy5jb25zdW1lUGF0aCgpO1xuICB9XG4gIGNsaXAoKSB7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IE5PUk1BTF9DTElQO1xuICB9XG4gIGVvQ2xpcCgpIHtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gRU9fQ0xJUDtcbiAgfVxuICBiZWdpblRleHQoKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggPSAwO1xuICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZID0gMDtcbiAgfVxuICBlbmRUZXh0KCkge1xuICAgIGNvbnN0IHBhdGhzID0gdGhpcy5wZW5kaW5nVGV4dFBhdGhzO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmIChwYXRocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5wYXRoLnRyYW5zZm9ybSk7XG4gICAgICBjdHgudHJhbnNsYXRlKHBhdGgueCwgcGF0aC55KTtcbiAgICAgIHBhdGguYWRkVG9QYXRoKGN0eCwgcGF0aC5mb250U2l6ZSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1RleHRQYXRocztcbiAgfVxuICBzZXRDaGFyU3BhY2luZyhzcGFjaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LmNoYXJTcGFjaW5nID0gc3BhY2luZztcbiAgfVxuICBzZXRXb3JkU3BhY2luZyhzcGFjaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LndvcmRTcGFjaW5nID0gc3BhY2luZztcbiAgfVxuICBzZXRIU2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dEhTY2FsZSA9IHNjYWxlIC8gMTAwO1xuICB9XG4gIHNldExlYWRpbmcobGVhZGluZykge1xuICAgIHRoaXMuY3VycmVudC5sZWFkaW5nID0gLWxlYWRpbmc7XG4gIH1cbiAgc2V0Rm9udChmb250UmVmTmFtZSwgc2l6ZSkge1xuICAgIGNvbnN0IGZvbnRPYmogPSB0aGlzLmNvbW1vbk9ianMuZ2V0KGZvbnRSZWZOYW1lKTtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGlmICghZm9udE9iaikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBmaW5kIGZvbnQgZm9yICR7Zm9udFJlZk5hbWV9YCk7XG4gICAgfVxuICAgIGN1cnJlbnQuZm9udE1hdHJpeCA9IGZvbnRPYmouZm9udE1hdHJpeCB8fCBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICBpZiAoY3VycmVudC5mb250TWF0cml4WzBdID09PSAwIHx8IGN1cnJlbnQuZm9udE1hdHJpeFszXSA9PT0gMCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwiSW52YWxpZCBmb250IG1hdHJpeCBmb3IgZm9udCBcIiArIGZvbnRSZWZOYW1lKTtcbiAgICB9XG4gICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICBzaXplID0gLXNpemU7XG4gICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC5mb250RGlyZWN0aW9uID0gMTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmZvbnQgPSBmb250T2JqO1xuICAgIHRoaXMuY3VycmVudC5mb250U2l6ZSA9IHNpemU7XG4gICAgaWYgKGZvbnRPYmouaXNUeXBlM0ZvbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IGZvbnRPYmoubG9hZGVkTmFtZSB8fCBcInNhbnMtc2VyaWZcIjtcbiAgICBjb25zdCB0eXBlZmFjZSA9IGZvbnRPYmouc3lzdGVtRm9udEluZm8/LmNzcyB8fCBgXCIke25hbWV9XCIsICR7Zm9udE9iai5mYWxsYmFja05hbWV9YDtcbiAgICBsZXQgYm9sZCA9IFwibm9ybWFsXCI7XG4gICAgaWYgKGZvbnRPYmouYmxhY2spIHtcbiAgICAgIGJvbGQgPSBcIjkwMFwiO1xuICAgIH0gZWxzZSBpZiAoZm9udE9iai5ib2xkKSB7XG4gICAgICBib2xkID0gXCJib2xkXCI7XG4gICAgfVxuICAgIGNvbnN0IGl0YWxpYyA9IGZvbnRPYmouaXRhbGljID8gXCJpdGFsaWNcIiA6IFwibm9ybWFsXCI7XG4gICAgbGV0IGJyb3dzZXJGb250U2l6ZSA9IHNpemU7XG4gICAgaWYgKHNpemUgPCBNSU5fRk9OVF9TSVpFKSB7XG4gICAgICBicm93c2VyRm9udFNpemUgPSBNSU5fRk9OVF9TSVpFO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA+IE1BWF9GT05UX1NJWkUpIHtcbiAgICAgIGJyb3dzZXJGb250U2l6ZSA9IE1BWF9GT05UX1NJWkU7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5mb250U2l6ZVNjYWxlID0gc2l6ZSAvIGJyb3dzZXJGb250U2l6ZTtcbiAgICB0aGlzLmN0eC5mb250ID0gYCR7aXRhbGljfSAke2JvbGR9ICR7YnJvd3NlckZvbnRTaXplfXB4ICR7dHlwZWZhY2V9YDtcbiAgfVxuICBzZXRUZXh0UmVuZGVyaW5nTW9kZShtb2RlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID0gbW9kZTtcbiAgfVxuICBzZXRUZXh0UmlzZShyaXNlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRSaXNlID0gcmlzZTtcbiAgfVxuICBtb3ZlVGV4dCh4LCB5KSB7XG4gICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggKz0geDtcbiAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSArPSB5O1xuICB9XG4gIHNldExlYWRpbmdNb3ZlVGV4dCh4LCB5KSB7XG4gICAgdGhpcy5zZXRMZWFkaW5nKC15KTtcbiAgICB0aGlzLm1vdmVUZXh0KHgsIHkpO1xuICB9XG4gIHNldFRleHRNYXRyaXgoYSwgYiwgYywgZCwgZSwgZikge1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4ID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSBNYXRoLmh5cG90KGEsIGIpO1xuICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5jdXJyZW50LmxpbmVYID0gMDtcbiAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSA9IDA7XG4gIH1cbiAgbmV4dExpbmUoKSB7XG4gICAgdGhpcy5tb3ZlVGV4dCgwLCB0aGlzLmN1cnJlbnQubGVhZGluZyk7XG4gIH1cbiAgcGFpbnRDaGFyKGNoYXJhY3RlciwgeCwgeSwgcGF0dGVyblRyYW5zZm9ybSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICBjb25zdCB0ZXh0UmVuZGVyaW5nTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGU7XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplIC8gY3VycmVudC5mb250U2l6ZVNjYWxlO1xuICAgIGNvbnN0IGZpbGxTdHJva2VNb2RlID0gdGV4dFJlbmRlcmluZ01vZGUgJiBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuICAgIGNvbnN0IGlzQWRkVG9QYXRoU2V0ID0gISEodGV4dFJlbmRlcmluZ01vZGUgJiBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5BRERfVE9fUEFUSF9GTEFHKTtcbiAgICBjb25zdCBwYXR0ZXJuRmlsbCA9IGN1cnJlbnQucGF0dGVybkZpbGwgJiYgIWZvbnQubWlzc2luZ0ZpbGU7XG4gICAgbGV0IGFkZFRvUGF0aDtcbiAgICBpZiAoZm9udC5kaXNhYmxlRm9udEZhY2UgfHwgaXNBZGRUb1BhdGhTZXQgfHwgcGF0dGVybkZpbGwpIHtcbiAgICAgIGFkZFRvUGF0aCA9IGZvbnQuZ2V0UGF0aEdlbmVyYXRvcih0aGlzLmNvbW1vbk9ianMsIGNoYXJhY3Rlcik7XG4gICAgfVxuICAgIGlmIChmb250LmRpc2FibGVGb250RmFjZSB8fCBwYXR0ZXJuRmlsbCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRUb1BhdGgoY3R4LCBmb250U2l6ZSk7XG4gICAgICBpZiAocGF0dGVyblRyYW5zZm9ybSkge1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKC4uLnBhdHRlcm5UcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3RlciwgeCwgeSk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LnN0cm9rZVRleHQoY2hhcmFjdGVyLCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQWRkVG9QYXRoU2V0KSB7XG4gICAgICBjb25zdCBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocyB8fD0gW107XG4gICAgICBwYXRocy5wdXNoKHtcbiAgICAgICAgdHJhbnNmb3JtOiAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIGFkZFRvUGF0aFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0OiBjdHhcbiAgICB9ID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZFwiLCAxMCwgMTApO1xuICAgIGN0eC5zY2FsZSgxLjUsIDEpO1xuICAgIGN0eC5maWxsVGV4dChcIklcIiwgMCwgMTApO1xuICAgIGNvbnN0IGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEwLCAxMCkuZGF0YTtcbiAgICBsZXQgZW5hYmxlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAzOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgaWYgKGRhdGFbaV0gPiAwICYmIGRhdGFbaV0gPCAyNTUpIHtcbiAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZFwiLCBlbmFibGVkKTtcbiAgfVxuICBzaG93VGV4dChnbHlwaHMpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgaWYgKGZvbnQuaXNUeXBlM0ZvbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNob3dUeXBlM1RleHQoZ2x5cGhzKTtcbiAgICB9XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuICAgIGlmIChmb250U2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm9udFNpemVTY2FsZSA9IGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICBjb25zdCBjaGFyU3BhY2luZyA9IGN1cnJlbnQuY2hhclNwYWNpbmc7XG4gICAgY29uc3Qgd29yZFNwYWNpbmcgPSBjdXJyZW50LndvcmRTcGFjaW5nO1xuICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgZ2x5cGhzTGVuZ3RoID0gZ2x5cGhzLmxlbmd0aDtcbiAgICBjb25zdCB2ZXJ0aWNhbCA9IGZvbnQudmVydGljYWw7XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IHZlcnRpY2FsID8gMSA6IC0xO1xuICAgIGNvbnN0IGRlZmF1bHRWTWV0cmljcyA9IGZvbnQuZGVmYXVsdFZNZXRyaWNzO1xuICAgIGNvbnN0IHdpZHRoQWR2YW5jZVNjYWxlID0gZm9udFNpemUgKiBjdXJyZW50LmZvbnRNYXRyaXhbMF07XG4gICAgY29uc3Qgc2ltcGxlRmlsbFRleHQgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMICYmICFmb250LmRpc2FibGVGb250RmFjZSAmJiAhY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0oLi4uY3VycmVudC50ZXh0TWF0cml4KTtcbiAgICBjdHgudHJhbnNsYXRlKGN1cnJlbnQueCwgY3VycmVudC55ICsgY3VycmVudC50ZXh0UmlzZSk7XG4gICAgaWYgKGZvbnREaXJlY3Rpb24gPiAwKSB7XG4gICAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgMSk7XG4gICAgfVxuICAgIGxldCBwYXR0ZXJuVHJhbnNmb3JtO1xuICAgIGlmIChjdXJyZW50LnBhdHRlcm5GaWxsKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgcGF0dGVybiA9IGN1cnJlbnQuZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGN0eCksIF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5GSUxMKTtcbiAgICAgIHBhdHRlcm5UcmFuc2Zvcm0gPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgICB9XG4gICAgbGV0IGxpbmVXaWR0aCA9IGN1cnJlbnQubGluZVdpZHRoO1xuICAgIGNvbnN0IHNjYWxlID0gY3VycmVudC50ZXh0TWF0cml4U2NhbGU7XG4gICAgaWYgKHNjYWxlID09PSAwIHx8IGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgY29uc3QgZmlsbFN0cm9rZU1vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuU1RST0tFIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBsaW5lV2lkdGggPSB0aGlzLmdldFNpbmdsZVBpeGVsV2lkdGgoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGluZVdpZHRoIC89IHNjYWxlO1xuICAgIH1cbiAgICBpZiAoZm9udFNpemVTY2FsZSAhPT0gMS4wKSB7XG4gICAgICBjdHguc2NhbGUoZm9udFNpemVTY2FsZSwgZm9udFNpemVTY2FsZSk7XG4gICAgICBsaW5lV2lkdGggLz0gZm9udFNpemVTY2FsZTtcbiAgICB9XG4gICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICBpZiAoZm9udC5pc0ludmFsaWRQREZqc0ZvbnQpIHtcbiAgICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgZm9yIChjb25zdCBnbHlwaCBvZiBnbHlwaHMpIHtcbiAgICAgICAgY2hhcnMucHVzaChnbHlwaC51bmljb2RlKTtcbiAgICAgICAgd2lkdGggKz0gZ2x5cGgud2lkdGg7XG4gICAgICB9XG4gICAgICBjdHguZmlsbFRleHQoY2hhcnMuam9pbihcIlwiKSwgMCwgMCk7XG4gICAgICBjdXJyZW50LnggKz0gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSAqIHRleHRIU2NhbGU7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy5jb21wb3NlKCk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgeCA9IDAsXG4gICAgICBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHNMZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICBpZiAodHlwZW9mIGdseXBoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHggKz0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN0b3JlTmVlZGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICBjb25zdCBjaGFyYWN0ZXIgPSBnbHlwaC5mb250Q2hhcjtcbiAgICAgIGNvbnN0IGFjY2VudCA9IGdseXBoLmFjY2VudDtcbiAgICAgIGxldCBzY2FsZWRYLCBzY2FsZWRZO1xuICAgICAgbGV0IHdpZHRoID0gZ2x5cGgud2lkdGg7XG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgY29uc3Qgdm1ldHJpYyA9IGdseXBoLnZtZXRyaWMgfHwgZGVmYXVsdFZNZXRyaWNzO1xuICAgICAgICBjb25zdCB2eCA9IC0oZ2x5cGgudm1ldHJpYyA/IHZtZXRyaWNbMV0gOiB3aWR0aCAqIDAuNSkgKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgY29uc3QgdnkgPSB2bWV0cmljWzJdICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIHdpZHRoID0gdm1ldHJpYyA/IC12bWV0cmljWzBdIDogd2lkdGg7XG4gICAgICAgIHNjYWxlZFggPSB2eCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIHNjYWxlZFkgPSAoeCArIHZ5KSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZWRYID0geCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIHNjYWxlZFkgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnQucmVtZWFzdXJlICYmIHdpZHRoID4gMCkge1xuICAgICAgICBjb25zdCBtZWFzdXJlZFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGNoYXJhY3Rlcikud2lkdGggKiAxMDAwIC8gZm9udFNpemUgKiBmb250U2l6ZVNjYWxlO1xuICAgICAgICBpZiAod2lkdGggPCBtZWFzdXJlZFdpZHRoICYmIHRoaXMuaXNGb250U3VicGl4ZWxBQUVuYWJsZWQpIHtcbiAgICAgICAgICBjb25zdCBjaGFyYWN0ZXJTY2FsZVggPSB3aWR0aCAvIG1lYXN1cmVkV2lkdGg7XG4gICAgICAgICAgcmVzdG9yZU5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBjdHguc2NhbGUoY2hhcmFjdGVyU2NhbGVYLCAxKTtcbiAgICAgICAgICBzY2FsZWRYIC89IGNoYXJhY3RlclNjYWxlWDtcbiAgICAgICAgfSBlbHNlIGlmICh3aWR0aCAhPT0gbWVhc3VyZWRXaWR0aCkge1xuICAgICAgICAgIHNjYWxlZFggKz0gKHdpZHRoIC0gbWVhc3VyZWRXaWR0aCkgLyAyMDAwICogZm9udFNpemUgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSAmJiAoZ2x5cGguaXNJbkZvbnQgfHwgZm9udC5taXNzaW5nRmlsZSkpIHtcbiAgICAgICAgaWYgKHNpbXBsZUZpbGxUZXh0ICYmICFhY2NlbnQpIHtcbiAgICAgICAgICBjdHguZmlsbFRleHQoY2hhcmFjdGVyLCBzY2FsZWRYLCBzY2FsZWRZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhaW50Q2hhcihjaGFyYWN0ZXIsIHNjYWxlZFgsIHNjYWxlZFksIHBhdHRlcm5UcmFuc2Zvcm0pO1xuICAgICAgICAgIGlmIChhY2NlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZEFjY2VudFggPSBzY2FsZWRYICsgZm9udFNpemUgKiBhY2NlbnQub2Zmc2V0LnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkQWNjZW50WSA9IHNjYWxlZFkgLSBmb250U2l6ZSAqIGFjY2VudC5vZmZzZXQueSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICB0aGlzLnBhaW50Q2hhcihhY2NlbnQuZm9udENoYXIsIHNjYWxlZEFjY2VudFgsIHNjYWxlZEFjY2VudFksIHBhdHRlcm5UcmFuc2Zvcm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY2hhcldpZHRoID0gdmVydGljYWwgPyB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlIC0gc3BhY2luZyAqIGZvbnREaXJlY3Rpb24gOiB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlICsgc3BhY2luZyAqIGZvbnREaXJlY3Rpb247XG4gICAgICB4ICs9IGNoYXJXaWR0aDtcbiAgICAgIGlmIChyZXN0b3JlTmVlZGVkKSB7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgY3VycmVudC55IC09IHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQueCArPSB4ICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHNob3dUeXBlM1RleHQoZ2x5cGhzKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcbiAgICBjb25zdCBmb250RGlyZWN0aW9uID0gY3VycmVudC5mb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IHNwYWNpbmdEaXIgPSBmb250LnZlcnRpY2FsID8gMSA6IC0xO1xuICAgIGNvbnN0IGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICBjb25zdCB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgY29uc3QgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgZm9udE1hdHJpeCA9IGN1cnJlbnQuZm9udE1hdHJpeCB8fCBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICBjb25zdCBnbHlwaHNMZW5ndGggPSBnbHlwaHMubGVuZ3RoO1xuICAgIGNvbnN0IGlzVGV4dEludmlzaWJsZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLklOVklTSUJMRTtcbiAgICBsZXQgaSwgZ2x5cGgsIHdpZHRoLCBzcGFjaW5nTGVuZ3RoO1xuICAgIGlmIChpc1RleHRJbnZpc2libGUgfHwgZm9udFNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zZm9ybSguLi5jdXJyZW50LnRleHRNYXRyaXgpO1xuICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkpO1xuICAgIGN0eC5zY2FsZSh0ZXh0SFNjYWxlLCBmb250RGlyZWN0aW9uKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzcGFjaW5nTGVuZ3RoID0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICB0aGlzLmN0eC50cmFuc2xhdGUoc3BhY2luZ0xlbmd0aCwgMCk7XG4gICAgICAgIGN1cnJlbnQueCArPSBzcGFjaW5nTGVuZ3RoICogdGV4dEhTY2FsZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICBjb25zdCBvcGVyYXRvckxpc3QgPSBmb250LmNoYXJQcm9jT3BlcmF0b3JMaXN0W2dseXBoLm9wZXJhdG9yTGlzdElkXTtcbiAgICAgIGlmICghb3BlcmF0b3JMaXN0KSB7XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShgVHlwZTMgY2hhcmFjdGVyIFwiJHtnbHlwaC5vcGVyYXRvckxpc3RJZH1cIiBpcyBub3QgYXZhaWxhYmxlLmApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ1R5cGUzID0gZ2x5cGg7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICBjdHguc2NhbGUoZm9udFNpemUsIGZvbnRTaXplKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSguLi5mb250TWF0cml4KTtcbiAgICAgICAgdGhpcy5leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCk7XG4gICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFtnbHlwaC53aWR0aCwgMF0sIGZvbnRNYXRyaXgpO1xuICAgICAgd2lkdGggPSB0cmFuc2Zvcm1lZFswXSAqIGZvbnRTaXplICsgc3BhY2luZztcbiAgICAgIGN0eC50cmFuc2xhdGUod2lkdGgsIDApO1xuICAgICAgY3VycmVudC54ICs9IHdpZHRoICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLnByb2Nlc3NpbmdUeXBlMyA9IG51bGw7XG4gIH1cbiAgc2V0Q2hhcldpZHRoKHhXaWR0aCwgeVdpZHRoKSB7fVxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHMoeFdpZHRoLCB5V2lkdGgsIGxseCwgbGx5LCB1cngsIHVyeSkge1xuICAgIHRoaXMuY3R4LnJlY3QobGx4LCBsbHksIHVyeCAtIGxseCwgdXJ5IC0gbGx5KTtcbiAgICB0aGlzLmN0eC5jbGlwKCk7XG4gICAgdGhpcy5lbmRQYXRoKCk7XG4gIH1cbiAgZ2V0Q29sb3JOX1BhdHRlcm4oSVIpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAoSVJbMF0gPT09IFwiVGlsaW5nUGF0dGVyblwiKSB7XG4gICAgICBjb25zdCBjb2xvciA9IElSWzFdO1xuICAgICAgY29uc3QgYmFzZVRyYW5zZm9ybSA9IHRoaXMuYmFzZVRyYW5zZm9ybSB8fCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jdHgpO1xuICAgICAgY29uc3QgY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0ge1xuICAgICAgICBjcmVhdGVDYW52YXNHcmFwaGljczogY3R4ID0+IHtcbiAgICAgICAgICByZXR1cm4gbmV3IENhbnZhc0dyYXBoaWNzKGN0eCwgdGhpcy5jb21tb25PYmpzLCB0aGlzLm9ianMsIHRoaXMuY2FudmFzRmFjdG9yeSwgdGhpcy5maWx0ZXJGYWN0b3J5LCB7XG4gICAgICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWc6IHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnLFxuICAgICAgICAgICAgbWFya2VkQ29udGVudFN0YWNrOiB0aGlzLm1hcmtlZENvbnRlbnRTdGFja1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcGF0dGVybiA9IG5ldyBfcGF0dGVybl9oZWxwZXIuVGlsaW5nUGF0dGVybihJUiwgY29sb3IsIHRoaXMuY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5fZ2V0UGF0dGVybihJUlsxXSwgSVJbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICBzZXRTdHJva2VDb2xvck4oKSB7XG4gICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gdGhpcy5nZXRDb2xvck5fUGF0dGVybihhcmd1bWVudHMpO1xuICB9XG4gIHNldEZpbGxDb2xvck4oKSB7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IHRoaXMuZ2V0Q29sb3JOX1BhdHRlcm4oYXJndW1lbnRzKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSB0cnVlO1xuICB9XG4gIHNldFN0cm9rZVJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICBjb25zdCBjb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKHIsIGcsIGIpO1xuICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gY29sb3I7XG4gIH1cbiAgc2V0RmlsbFJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICBjb25zdCBjb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKHIsIGcsIGIpO1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgfVxuICBfZ2V0UGF0dGVybihvYmpJZCwgbWF0cml4ID0gbnVsbCkge1xuICAgIGxldCBwYXR0ZXJuO1xuICAgIGlmICh0aGlzLmNhY2hlZFBhdHRlcm5zLmhhcyhvYmpJZCkpIHtcbiAgICAgIHBhdHRlcm4gPSB0aGlzLmNhY2hlZFBhdHRlcm5zLmdldChvYmpJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdHRlcm4gPSAoMCwgX3BhdHRlcm5faGVscGVyLmdldFNoYWRpbmdQYXR0ZXJuKSh0aGlzLmdldE9iamVjdChvYmpJZCkpO1xuICAgICAgdGhpcy5jYWNoZWRQYXR0ZXJucy5zZXQob2JqSWQsIHBhdHRlcm4pO1xuICAgIH1cbiAgICBpZiAobWF0cml4KSB7XG4gICAgICBwYXR0ZXJuLm1hdHJpeCA9IG1hdHJpeDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbiAgc2hhZGluZ0ZpbGwob2JqSWQpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX2dldFBhdHRlcm4ob2JqSWQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuLmdldFBhdHRlcm4oY3R4LCB0aGlzLCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGN0eCksIF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5TSEFESU5HKTtcbiAgICBjb25zdCBpbnYgPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGN0eCk7XG4gICAgaWYgKGludikge1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gY3R4LmNhbnZhcztcbiAgICAgIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSBfdXRpbC5VdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSwgaW52KTtcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KC0xZTEwLCAtMWUxMCwgMmUxMCwgMmUxMCk7XG4gICAgfVxuICAgIHRoaXMuY29tcG9zZSh0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCgpKTtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxuICBiZWdpbklubGluZUltYWdlKCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJTaG91bGQgbm90IGNhbGwgYmVnaW5JbmxpbmVJbWFnZVwiKTtcbiAgfVxuICBiZWdpbkltYWdlRGF0YSgpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiU2hvdWxkIG5vdCBjYWxsIGJlZ2luSW1hZ2VEYXRhXCIpO1xuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbihtYXRyaXgsIGJib3gpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sucHVzaCh0aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdHJpeCkgJiYgbWF0cml4Lmxlbmd0aCA9PT0gNikge1xuICAgICAgdGhpcy50cmFuc2Zvcm0oLi4ubWF0cml4KTtcbiAgICB9XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KTtcbiAgICBpZiAoYmJveCkge1xuICAgICAgY29uc3Qgd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGJib3hbM10gLSBiYm94WzFdO1xuICAgICAgdGhpcy5jdHgucmVjdChiYm94WzBdLCBiYm94WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY3VycmVudC51cGRhdGVSZWN0TWluTWF4KCgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmN0eCksIGJib3gpO1xuICAgICAgdGhpcy5jbGlwKCk7XG4gICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICB9XG4gIH1cbiAgcGFpbnRGb3JtWE9iamVjdEVuZCgpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sucG9wKCk7XG4gIH1cbiAgYmVnaW5Hcm91cChncm91cCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNhdmUoKTtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICAgIHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRDdHggPSB0aGlzLmN0eDtcbiAgICBpZiAoIWdyb3VwLmlzb2xhdGVkKSB7XG4gICAgICAoMCwgX3V0aWwuaW5mbykoXCJUT0RPOiBTdXBwb3J0IG5vbi1pc29sYXRlZCBncm91cHMuXCIpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAua25vY2tvdXQpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShcIktub2Nrb3V0IGdyb3VwcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdXJyZW50Q3R4KTtcbiAgICBpZiAoZ3JvdXAubWF0cml4KSB7XG4gICAgICBjdXJyZW50Q3R4LnRyYW5zZm9ybSguLi5ncm91cC5tYXRyaXgpO1xuICAgIH1cbiAgICBpZiAoIWdyb3VwLmJib3gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJvdW5kaW5nIGJveCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIGxldCBib3VuZHMgPSBfdXRpbC5VdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KGdyb3VwLmJib3gsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdXJyZW50Q3R4KSk7XG4gICAgY29uc3QgY2FudmFzQm91bmRzID0gWzAsIDAsIGN1cnJlbnRDdHguY2FudmFzLndpZHRoLCBjdXJyZW50Q3R4LmNhbnZhcy5oZWlnaHRdO1xuICAgIGJvdW5kcyA9IF91dGlsLlV0aWwuaW50ZXJzZWN0KGJvdW5kcywgY2FudmFzQm91bmRzKSB8fCBbMCwgMCwgMCwgMF07XG4gICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGguZmxvb3IoYm91bmRzWzBdKTtcbiAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5mbG9vcihib3VuZHNbMV0pO1xuICAgIGxldCBkcmF3bldpZHRoID0gTWF0aC5tYXgoTWF0aC5jZWlsKGJvdW5kc1syXSkgLSBvZmZzZXRYLCAxKTtcbiAgICBsZXQgZHJhd25IZWlnaHQgPSBNYXRoLm1heChNYXRoLmNlaWwoYm91bmRzWzNdKSAtIG9mZnNldFksIDEpO1xuICAgIGxldCBzY2FsZVggPSAxLFxuICAgICAgc2NhbGVZID0gMTtcbiAgICBpZiAoZHJhd25XaWR0aCA+IE1BWF9HUk9VUF9TSVpFKSB7XG4gICAgICBzY2FsZVggPSBkcmF3bldpZHRoIC8gTUFYX0dST1VQX1NJWkU7XG4gICAgICBkcmF3bldpZHRoID0gTUFYX0dST1VQX1NJWkU7XG4gICAgfVxuICAgIGlmIChkcmF3bkhlaWdodCA+IE1BWF9HUk9VUF9TSVpFKSB7XG4gICAgICBzY2FsZVkgPSBkcmF3bkhlaWdodCAvIE1BWF9HUk9VUF9TSVpFO1xuICAgICAgZHJhd25IZWlnaHQgPSBNQVhfR1JPVVBfU0laRTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LnN0YXJ0TmV3UGF0aEFuZENsaXBCb3goWzAsIDAsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0XSk7XG4gICAgbGV0IGNhY2hlSWQgPSBcImdyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcbiAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgIGNhY2hlSWQgKz0gXCJfc21hc2tfXCIgKyB0aGlzLnNtYXNrQ291bnRlcisrICUgMjtcbiAgICB9XG4gICAgY29uc3Qgc2NyYXRjaENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKGNhY2hlSWQsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICBjb25zdCBncm91cEN0eCA9IHNjcmF0Y2hDYW52YXMuY29udGV4dDtcbiAgICBncm91cEN0eC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICBncm91cEN0eC50cmFuc2xhdGUoLW9mZnNldFgsIC1vZmZzZXRZKTtcbiAgICBncm91cEN0eC50cmFuc2Zvcm0oLi4uY3VycmVudFRyYW5zZm9ybSk7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICB0aGlzLnNtYXNrU3RhY2sucHVzaCh7XG4gICAgICAgIGNhbnZhczogc2NyYXRjaENhbnZhcy5jYW52YXMsXG4gICAgICAgIGNvbnRleHQ6IGdyb3VwQ3R4LFxuICAgICAgICBvZmZzZXRYLFxuICAgICAgICBvZmZzZXRZLFxuICAgICAgICBzY2FsZVgsXG4gICAgICAgIHNjYWxlWSxcbiAgICAgICAgc3VidHlwZTogZ3JvdXAuc21hc2suc3VidHlwZSxcbiAgICAgICAgYmFja2Ryb3A6IGdyb3VwLnNtYXNrLmJhY2tkcm9wLFxuICAgICAgICB0cmFuc2Zlck1hcDogZ3JvdXAuc21hc2sudHJhbnNmZXJNYXAgfHwgbnVsbCxcbiAgICAgICAgc3RhcnRUcmFuc2Zvcm1JbnZlcnNlOiBudWxsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudEN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICBjdXJyZW50Q3R4LnRyYW5zbGF0ZShvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgIGN1cnJlbnRDdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgY3VycmVudEN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGNvcHlDdHhTdGF0ZShjdXJyZW50Q3R4LCBncm91cEN0eCk7XG4gICAgdGhpcy5jdHggPSBncm91cEN0eDtcbiAgICB0aGlzLnNldEdTdGF0ZShbW1wiQk1cIiwgXCJzb3VyY2Utb3ZlclwiXSwgW1wiY2FcIiwgMV0sIFtcIkNBXCIsIDFdXSk7XG4gICAgdGhpcy5ncm91cFN0YWNrLnB1c2goY3VycmVudEN0eCk7XG4gICAgdGhpcy5ncm91cExldmVsKys7XG4gIH1cbiAgZW5kR3JvdXAoZ3JvdXApIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ncm91cExldmVsLS07XG4gICAgY29uc3QgZ3JvdXBDdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmdyb3VwU3RhY2sucG9wKCk7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICB0aGlzLnRlbXBTTWFzayA9IHRoaXMuc21hc2tTdGFjay5wb3AoKTtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICBjb25zdCBjdXJyZW50TXR4ID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKC4uLmN1cnJlbnRNdHgpO1xuICAgICAgY29uc3QgZGlydHlCb3ggPSBfdXRpbC5VdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCBncm91cEN0eC5jYW52YXMud2lkdGgsIGdyb3VwQ3R4LmNhbnZhcy5oZWlnaHRdLCBjdXJyZW50TXR4KTtcbiAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShncm91cEN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy5jb21wb3NlKGRpcnR5Qm94KTtcbiAgICB9XG4gIH1cbiAgYmVnaW5Bbm5vdGF0aW9uKGlkLCByZWN0LCB0cmFuc2Zvcm0sIG1hdHJpeCwgaGFzT3duQ2FudmFzKSB7XG4gICAgdGhpcy4jcmVzdG9yZUluaXRpYWxTdGF0ZSgpO1xuICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgaWYgKHRoaXMuYmFzZVRyYW5zZm9ybSkge1xuICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKC4uLnRoaXMuYmFzZVRyYW5zZm9ybSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlY3QpICYmIHJlY3QubGVuZ3RoID09PSA0KSB7XG4gICAgICBjb25zdCB3aWR0aCA9IHJlY3RbMl0gLSByZWN0WzBdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gcmVjdFszXSAtIHJlY3RbMV07XG4gICAgICBpZiAoaGFzT3duQ2FudmFzICYmIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCkge1xuICAgICAgICB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm0uc2xpY2UoKTtcbiAgICAgICAgdHJhbnNmb3JtWzRdIC09IHJlY3RbMF07XG4gICAgICAgIHRyYW5zZm9ybVs1XSAtPSByZWN0WzFdO1xuICAgICAgICByZWN0ID0gcmVjdC5zbGljZSgpO1xuICAgICAgICByZWN0WzBdID0gcmVjdFsxXSA9IDA7XG4gICAgICAgIHJlY3RbMl0gPSB3aWR0aDtcbiAgICAgICAgcmVjdFszXSA9IGhlaWdodDtcbiAgICAgICAgY29uc3QgW3NjYWxlWCwgc2NhbGVZXSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUoKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB2aWV3cG9ydFNjYWxlXG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBjYW52YXNXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIHRoaXMub3V0cHV0U2NhbGVYICogdmlld3BvcnRTY2FsZSk7XG4gICAgICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiB0aGlzLm91dHB1dFNjYWxlWSAqIHZpZXdwb3J0U2NhbGUpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXMgPSB0aGlzLmNhbnZhc0ZhY3RvcnkuY3JlYXRlKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2FudmFzLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSA9IHRoaXMuYW5ub3RhdGlvbkNhbnZhcztcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwLnNldChpZCwgY2FudmFzKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIHRoaXMuY3R4ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oc2NhbGVYLCAwLCAwLCAtc2NhbGVZLCAwLCBoZWlnaHQgKiBzY2FsZVkpO1xuICAgICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMuY3R4LnJlY3QocmVjdFswXSwgcmVjdFsxXSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuY3R4LmNsaXAoKTtcbiAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3VycmVudCA9IG5ldyBDYW52YXNFeHRyYVN0YXRlKHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy50cmFuc2Zvcm0oLi4udHJhbnNmb3JtKTtcbiAgICB0aGlzLnRyYW5zZm9ybSguLi5tYXRyaXgpO1xuICB9XG4gIGVuZEFubm90YXRpb24oKSB7XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkNhbnZhcykge1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy4jZHJhd0ZpbHRlcigpO1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHg7XG4gICAgICBkZWxldGUgdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4O1xuICAgICAgZGVsZXRlIHRoaXMuYW5ub3RhdGlvbkNhbnZhcztcbiAgICB9XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0KGltZykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb3VudCA9IGltZy5jb3VudDtcbiAgICBpbWcgPSB0aGlzLmdldE9iamVjdChpbWcuZGF0YSwgaW1nKTtcbiAgICBpbWcuY291bnQgPSBjb3VudDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBnbHlwaCA9IHRoaXMucHJvY2Vzc2luZ1R5cGUzO1xuICAgIGlmIChnbHlwaCkge1xuICAgICAgaWYgKGdseXBoLmNvbXBpbGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2x5cGguY29tcGlsZWQgPSBjb21waWxlVHlwZTNHbHlwaChpbWcpO1xuICAgICAgfVxuICAgICAgaWYgKGdseXBoLmNvbXBpbGVkKSB7XG4gICAgICAgIGdseXBoLmNvbXBpbGVkKGN0eCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWFzayA9IHRoaXMuX2NyZWF0ZU1hc2tDYW52YXMoaW1nKTtcbiAgICBjb25zdCBtYXNrQ2FudmFzID0gbWFzay5jYW52YXM7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGN0eC5kcmF3SW1hZ2UobWFza0NhbnZhcywgbWFzay5vZmZzZXRYLCBtYXNrLm9mZnNldFkpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0KGltZywgc2NhbGVYLCBza2V3WCA9IDAsIHNrZXdZID0gMCwgc2NhbGVZLCBwb3NpdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW1nID0gdGhpcy5nZXRPYmplY3QoaW1nLmRhdGEsIGltZyk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCk7XG4gICAgY3R4LnRyYW5zZm9ybShzY2FsZVgsIHNrZXdYLCBza2V3WSwgc2NhbGVZLCAwLCAwKTtcbiAgICBjb25zdCBtYXNrID0gdGhpcy5fY3JlYXRlTWFza0NhbnZhcyhpbWcpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgbWFzay5vZmZzZXRYIC0gY3VycmVudFRyYW5zZm9ybVs0XSwgbWFzay5vZmZzZXRZIC0gY3VycmVudFRyYW5zZm9ybVs1XSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHRyYW5zID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0oY3VycmVudFRyYW5zZm9ybSwgW3NjYWxlWCwgc2tld1gsIHNrZXdZLCBzY2FsZVksIHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXV0pO1xuICAgICAgY29uc3QgW3gsIHldID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbMCwgMF0sIHRyYW5zKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UobWFzay5jYW52YXMsIHgsIHkpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwKGltYWdlcykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgZm9yIChjb25zdCBpbWFnZSBvZiBpbWFnZXMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdHJhbnNmb3JtXG4gICAgICB9ID0gaW1hZ2U7XG4gICAgICBjb25zdCBtYXNrQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrQ2FudmFzXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgbWFza0N0eCA9IG1hc2tDYW52YXMuY29udGV4dDtcbiAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgY29uc3QgaW1nID0gdGhpcy5nZXRPYmplY3QoZGF0YSwgaW1hZ2UpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDdHgsIGltZyk7XG4gICAgICBtYXNrQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgICBtYXNrQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihtYXNrQ3R4LCB0aGlzLCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGN0eCksIF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5GSUxMKSA6IGZpbGxDb2xvcjtcbiAgICAgIG1hc2tDdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBtYXNrQ3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgbWFza0NhbnZhcy5jYW52YXMsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIC0xLCAxLCAxKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50SW1hZ2VYT2JqZWN0KG9iaklkKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGltZ0RhdGEgPSB0aGlzLmdldE9iamVjdChvYmpJZCk7XG4gICAgaWYgKCFpbWdEYXRhKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoXCJEZXBlbmRlbnQgaW1hZ2UgaXNuJ3QgcmVhZHkgeWV0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGltZ0RhdGEpO1xuICB9XG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0KG9iaklkLCBzY2FsZVgsIHNjYWxlWSwgcG9zaXRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGltZ0RhdGEgPSB0aGlzLmdldE9iamVjdChvYmpJZCk7XG4gICAgaWYgKCFpbWdEYXRhKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoXCJEZXBlbmRlbnQgaW1hZ2UgaXNuJ3QgcmVhZHkgeWV0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgbWFwID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIG1hcC5wdXNoKHtcbiAgICAgICAgdHJhbnNmb3JtOiBbc2NhbGVYLCAwLCAwLCBzY2FsZVksIHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXV0sXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHc6IHdpZHRoLFxuICAgICAgICBoOiBoZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAoaW1nRGF0YSwgbWFwKTtcbiAgfVxuICBhcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzKGN0eCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzICE9PSBcIm5vbmVcIikge1xuICAgICAgY3R4LmZpbHRlciA9IHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHM7XG4gICAgICBjdHguZHJhd0ltYWdlKGN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgIH1cbiAgICByZXR1cm4gY3R4LmNhbnZhcztcbiAgfVxuICBhcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwKGltZ0RhdGEpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9PT0gXCJub25lXCIpIHtcbiAgICAgIHJldHVybiBpbWdEYXRhLmJpdG1hcDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYml0bWFwLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gaW1nRGF0YTtcbiAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIHRtcEN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzO1xuICAgIHRtcEN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwKTtcbiAgICB0bXBDdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgcmV0dXJuIHRtcENhbnZhcy5jYW52YXM7XG4gIH1cbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgaWYgKCFfdXRpbC5pc05vZGVKUykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmaWx0ZXJcbiAgICAgIH0gPSBjdHg7XG4gICAgICBpZiAoZmlsdGVyICE9PSBcIm5vbmVcIiAmJiBmaWx0ZXIgIT09IFwiXCIpIHtcbiAgICAgICAgY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguc2NhbGUoMSAvIHdpZHRoLCAtMSAvIGhlaWdodCk7XG4gICAgbGV0IGltZ1RvUGFpbnQ7XG4gICAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgICBpbWdUb1BhaW50ID0gdGhpcy5hcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwKGltZ0RhdGEpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgaW1nRGF0YSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8ICFpbWdEYXRhLmRhdGEpIHtcbiAgICAgIGltZ1RvUGFpbnQgPSBpbWdEYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICBwdXRCaW5hcnlJbWFnZURhdGEodG1wQ3R4LCBpbWdEYXRhKTtcbiAgICAgIGltZ1RvUGFpbnQgPSB0aGlzLmFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXModG1wQ3R4KTtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGVkID0gdGhpcy5fc2NhbGVJbWFnZShpbWdUb1BhaW50LCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGN0eCkpO1xuICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCksIGltZ0RhdGEuaW50ZXJwb2xhdGUpO1xuICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIHNjYWxlZC5pbWcsIDAsIDAsIHNjYWxlZC5wYWludFdpZHRoLCBzY2FsZWQucGFpbnRIZWlnaHQsIDAsIC1oZWlnaHQsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAoaW1nRGF0YSwgbWFwKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGxldCBpbWdUb1BhaW50O1xuICAgIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgICAgaW1nVG9QYWludCA9IGltZ0RhdGEuYml0bWFwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3ID0gaW1nRGF0YS53aWR0aDtcbiAgICAgIGNvbnN0IGggPSBpbWdEYXRhLmhlaWdodDtcbiAgICAgIGNvbnN0IHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaW5saW5lSW1hZ2VcIiwgdywgaCk7XG4gICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHB1dEJpbmFyeUltYWdlRGF0YSh0bXBDdHgsIGltZ0RhdGEpO1xuICAgICAgaW1nVG9QYWludCA9IHRoaXMuYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyh0bXBDdHgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIG1hcCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oLi4uZW50cnkudHJhbnNmb3JtKTtcbiAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBpbWdUb1BhaW50LCBlbnRyeS54LCBlbnRyeS55LCBlbnRyeS53LCBlbnRyeS5oLCAwLCAtMSwgMSwgMSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludFNvbGlkQ29sb3JJbWFnZU1hc2soKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIG1hcmtQb2ludCh0YWcpIHt9XG4gIG1hcmtQb2ludFByb3BzKHRhZywgcHJvcGVydGllcykge31cbiAgYmVnaW5NYXJrZWRDb250ZW50KHRhZykge1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGJlZ2luTWFya2VkQ29udGVudFByb3BzKHRhZywgcHJvcGVydGllcykge1xuICAgIGlmICh0YWcgPT09IFwiT0NcIikge1xuICAgICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICAgIHZpc2libGU6IHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnLmlzVmlzaWJsZShwcm9wZXJ0aWVzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRoaXMuaXNDb250ZW50VmlzaWJsZSgpO1xuICB9XG4gIGVuZE1hcmtlZENvbnRlbnQoKSB7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucG9wKCk7XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRoaXMuaXNDb250ZW50VmlzaWJsZSgpO1xuICB9XG4gIGJlZ2luQ29tcGF0KCkge31cbiAgZW5kQ29tcGF0KCkge31cbiAgY29uc3VtZVBhdGgoY2xpcEJveCkge1xuICAgIGNvbnN0IGlzRW1wdHkgPSB0aGlzLmN1cnJlbnQuaXNFbXB0eUNsaXAoKTtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgdGhpcy5jdXJyZW50LnVwZGF0ZUNsaXBGcm9tUGF0aCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIHRoaXMuY29tcG9zZShjbGlwQm94KTtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCA9PT0gRU9fQ0xJUCkge1xuICAgICAgICAgIGN0eC5jbGlwKFwiZXZlbm9kZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LnN0YXJ0TmV3UGF0aEFuZENsaXBCb3godGhpcy5jdXJyZW50LmNsaXBCb3gpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgfVxuICBnZXRTaW5nbGVQaXhlbFdpZHRoKCkge1xuICAgIGlmICghdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCkge1xuICAgICAgY29uc3QgbSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmN0eCk7XG4gICAgICBpZiAobVsxXSA9PT0gMCAmJiBtWzJdID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSAxIC8gTWF0aC5taW4oTWF0aC5hYnMobVswXSksIE1hdGguYWJzKG1bM10pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFic0RldCA9IE1hdGguYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pO1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguaHlwb3QobVswXSwgbVsyXSk7XG4gICAgICAgIGNvbnN0IG5vcm1ZID0gTWF0aC5oeXBvdChtWzFdLCBtWzNdKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IE1hdGgubWF4KG5vcm1YLCBub3JtWSkgLyBhYnNEZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoO1xuICB9XG4gIGdldFNjYWxlRm9yU3Ryb2tpbmcoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPT09IC0xKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxpbmVXaWR0aFxuICAgICAgfSA9IHRoaXMuY3VycmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYSxcbiAgICAgICAgYixcbiAgICAgICAgYyxcbiAgICAgICAgZFxuICAgICAgfSA9IHRoaXMuY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgICAgbGV0IHNjYWxlWCwgc2NhbGVZO1xuICAgICAgaWYgKGIgPT09IDAgJiYgYyA9PT0gMCkge1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguYWJzKGEpO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguYWJzKGQpO1xuICAgICAgICBpZiAobm9ybVggPT09IG5vcm1ZKSB7XG4gICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gMSAvIG5vcm1YO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRMaW5lV2lkdGggPSBub3JtWCAqIGxpbmVXaWR0aDtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IHNjYWxlZExpbmVXaWR0aCA8IDEgPyAxIC8gc2NhbGVkTGluZVdpZHRoIDogMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgc2NhbGVYID0gMSAvIG5vcm1YO1xuICAgICAgICAgIHNjYWxlWSA9IDEgLyBub3JtWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzY2FsZWRYTGluZVdpZHRoID0gbm9ybVggKiBsaW5lV2lkdGg7XG4gICAgICAgICAgY29uc3Qgc2NhbGVkWUxpbmVXaWR0aCA9IG5vcm1ZICogbGluZVdpZHRoO1xuICAgICAgICAgIHNjYWxlWCA9IHNjYWxlZFhMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZFhMaW5lV2lkdGggOiAxO1xuICAgICAgICAgIHNjYWxlWSA9IHNjYWxlZFlMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZFlMaW5lV2lkdGggOiAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhYnNEZXQgPSBNYXRoLmFicyhhICogZCAtIGIgKiBjKTtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmh5cG90KGEsIGIpO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguaHlwb3QoYywgZCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICBzY2FsZVggPSBub3JtWSAvIGFic0RldDtcbiAgICAgICAgICBzY2FsZVkgPSBub3JtWCAvIGFic0RldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBiYXNlQXJlYSA9IGxpbmVXaWR0aCAqIGFic0RldDtcbiAgICAgICAgICBzY2FsZVggPSBub3JtWSA+IGJhc2VBcmVhID8gbm9ybVkgLyBiYXNlQXJlYSA6IDE7XG4gICAgICAgICAgc2NhbGVZID0gbm9ybVggPiBiYXNlQXJlYSA/IG5vcm1YIC8gYmFzZUFyZWEgOiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gc2NhbGVYO1xuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1sxXSA9IHNjYWxlWTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmc7XG4gIH1cbiAgcmVzY2FsZUFuZFN0cm9rZShzYXZlUmVzdG9yZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxpbmVXaWR0aFxuICAgIH0gPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgW3NjYWxlWCwgc2NhbGVZXSA9IHRoaXMuZ2V0U2NhbGVGb3JTdHJva2luZygpO1xuICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGggfHwgMTtcbiAgICBpZiAoc2NhbGVYID09PSAxICYmIHNjYWxlWSA9PT0gMSkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkYXNoZXMgPSBjdHguZ2V0TGluZURhc2goKTtcbiAgICBpZiAoc2F2ZVJlc3RvcmUpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgaWYgKGRhc2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBzY2FsZSA9IE1hdGgubWF4KHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoZXMubWFwKHggPT4geCAvIHNjYWxlKSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgLz0gc2NhbGU7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgICBpZiAoc2F2ZVJlc3RvcmUpIHtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGlzQ29udGVudFZpc2libGUoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMubWFya2VkQ29udGVudFN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoIXRoaXMubWFya2VkQ29udGVudFN0YWNrW2ldLnZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZXhwb3J0cy5DYW52YXNHcmFwaGljcyA9IENhbnZhc0dyYXBoaWNzO1xuZm9yIChjb25zdCBvcCBpbiBfdXRpbC5PUFMpIHtcbiAgaWYgKENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgIENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtfdXRpbC5PUFNbb3BdXSA9IENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtvcF07XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5UaWxpbmdQYXR0ZXJuID0gZXhwb3J0cy5QYXRoVHlwZSA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0U2hhZGluZ1BhdHRlcm4gPSBnZXRTaGFkaW5nUGF0dGVybjtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xuY29uc3QgUGF0aFR5cGUgPSB7XG4gIEZJTEw6IFwiRmlsbFwiLFxuICBTVFJPS0U6IFwiU3Ryb2tlXCIsXG4gIFNIQURJTkc6IFwiU2hhZGluZ1wiXG59O1xuZXhwb3J0cy5QYXRoVHlwZSA9IFBhdGhUeXBlO1xuZnVuY3Rpb24gYXBwbHlCb3VuZGluZ0JveChjdHgsIGJib3gpIHtcbiAgaWYgKCFiYm94KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHdpZHRoID0gYmJveFsyXSAtIGJib3hbMF07XG4gIGNvbnN0IGhlaWdodCA9IGJib3hbM10gLSBiYm94WzFdO1xuICBjb25zdCByZWdpb24gPSBuZXcgUGF0aDJEKCk7XG4gIHJlZ2lvbi5yZWN0KGJib3hbMF0sIGJib3hbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICBjdHguY2xpcChyZWdpb24pO1xufVxuY2xhc3MgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VTaGFkaW5nUGF0dGVybikge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VTaGFkaW5nUGF0dGVybi5cIik7XG4gICAgfVxuICB9XG4gIGdldFBhdHRlcm4oKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgZ2V0UGF0dGVybmAgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybiBleHRlbmRzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGNvbnN0cnVjdG9yKElSKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl90eXBlID0gSVJbMV07XG4gICAgdGhpcy5fYmJveCA9IElSWzJdO1xuICAgIHRoaXMuX2NvbG9yU3RvcHMgPSBJUlszXTtcbiAgICB0aGlzLl9wMCA9IElSWzRdO1xuICAgIHRoaXMuX3AxID0gSVJbNV07XG4gICAgdGhpcy5fcjAgPSBJUls2XTtcbiAgICB0aGlzLl9yMSA9IElSWzddO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgfVxuICBfY3JlYXRlR3JhZGllbnQoY3R4KSB7XG4gICAgbGV0IGdyYWQ7XG4gICAgaWYgKHRoaXMuX3R5cGUgPT09IFwiYXhpYWxcIikge1xuICAgICAgZ3JhZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLl9wMFswXSwgdGhpcy5fcDBbMV0sIHRoaXMuX3AxWzBdLCB0aGlzLl9wMVsxXSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl90eXBlID09PSBcInJhZGlhbFwiKSB7XG4gICAgICBncmFkID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuX3AwWzBdLCB0aGlzLl9wMFsxXSwgdGhpcy5fcjAsIHRoaXMuX3AxWzBdLCB0aGlzLl9wMVsxXSwgdGhpcy5fcjEpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbG9yU3RvcCBvZiB0aGlzLl9jb2xvclN0b3BzKSB7XG4gICAgICBncmFkLmFkZENvbG9yU3RvcChjb2xvclN0b3BbMF0sIGNvbG9yU3RvcFsxXSk7XG4gICAgfVxuICAgIHJldHVybiBncmFkO1xuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAocGF0aFR5cGUgPT09IFBhdGhUeXBlLlNUUk9LRSB8fCBwYXRoVHlwZSA9PT0gUGF0aFR5cGUuRklMTCkge1xuICAgICAgY29uc3Qgb3duZXJCQm94ID0gb3duZXIuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlLCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KSkgfHwgWzAsIDAsIDAsIDBdO1xuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwob3duZXJCQm94WzJdIC0gb3duZXJCQm94WzBdKSB8fCAxO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5jZWlsKG93bmVyQkJveFszXSAtIG93bmVyQkJveFsxXSkgfHwgMTtcbiAgICAgIGNvbnN0IHRtcENhbnZhcyA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm5cIiwgd2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgdG1wQ3R4LmNhbnZhcy53aWR0aCwgdG1wQ3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgdG1wQ3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdG1wQ3R4LnJlY3QoMCwgMCwgdG1wQ3R4LmNhbnZhcy53aWR0aCwgdG1wQ3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgdG1wQ3R4LnRyYW5zbGF0ZSgtb3duZXJCQm94WzBdLCAtb3duZXJCQm94WzFdKTtcbiAgICAgIGludmVyc2UgPSBfdXRpbC5VdGlsLnRyYW5zZm9ybShpbnZlcnNlLCBbMSwgMCwgMCwgMSwgb3duZXJCQm94WzBdLCBvd25lckJCb3hbMV1dKTtcbiAgICAgIHRtcEN0eC50cmFuc2Zvcm0oLi4ub3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgdG1wQ3R4LnRyYW5zZm9ybSguLi50aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgICBhcHBseUJvdW5kaW5nQm94KHRtcEN0eCwgdGhpcy5fYmJveCk7XG4gICAgICB0bXBDdHguZmlsbFN0eWxlID0gdGhpcy5fY3JlYXRlR3JhZGllbnQodG1wQ3R4KTtcbiAgICAgIHRtcEN0eC5maWxsKCk7XG4gICAgICBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odG1wQ2FudmFzLmNhbnZhcywgXCJuby1yZXBlYXRcIik7XG4gICAgICBjb25zdCBkb21NYXRyaXggPSBuZXcgRE9NTWF0cml4KGludmVyc2UpO1xuICAgICAgcGF0dGVybi5zZXRUcmFuc2Zvcm0oZG9tTWF0cml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwbHlCb3VuZGluZ0JveChjdHgsIHRoaXMuX2Jib3gpO1xuICAgICAgcGF0dGVybiA9IHRoaXMuX2NyZWF0ZUdyYWRpZW50KGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG59XG5mdW5jdGlvbiBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcDEsIHAyLCBwMywgYzEsIGMyLCBjMykge1xuICBjb25zdCBjb29yZHMgPSBjb250ZXh0LmNvb3JkcyxcbiAgICBjb2xvcnMgPSBjb250ZXh0LmNvbG9ycztcbiAgY29uc3QgYnl0ZXMgPSBkYXRhLmRhdGEsXG4gICAgcm93U2l6ZSA9IGRhdGEud2lkdGggKiA0O1xuICBsZXQgdG1wO1xuICBpZiAoY29vcmRzW3AxICsgMV0gPiBjb29yZHNbcDIgKyAxXSkge1xuICAgIHRtcCA9IHAxO1xuICAgIHAxID0gcDI7XG4gICAgcDIgPSB0bXA7XG4gICAgdG1wID0gYzE7XG4gICAgYzEgPSBjMjtcbiAgICBjMiA9IHRtcDtcbiAgfVxuICBpZiAoY29vcmRzW3AyICsgMV0gPiBjb29yZHNbcDMgKyAxXSkge1xuICAgIHRtcCA9IHAyO1xuICAgIHAyID0gcDM7XG4gICAgcDMgPSB0bXA7XG4gICAgdG1wID0gYzI7XG4gICAgYzIgPSBjMztcbiAgICBjMyA9IHRtcDtcbiAgfVxuICBpZiAoY29vcmRzW3AxICsgMV0gPiBjb29yZHNbcDIgKyAxXSkge1xuICAgIHRtcCA9IHAxO1xuICAgIHAxID0gcDI7XG4gICAgcDIgPSB0bXA7XG4gICAgdG1wID0gYzE7XG4gICAgYzEgPSBjMjtcbiAgICBjMiA9IHRtcDtcbiAgfVxuICBjb25zdCB4MSA9IChjb29yZHNbcDFdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MSA9IChjb29yZHNbcDEgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgY29uc3QgeDIgPSAoY29vcmRzW3AyXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTIgPSAoY29vcmRzW3AyICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGNvbnN0IHgzID0gKGNvb3Jkc1twM10gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkzID0gKGNvb3Jkc1twMyArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBpZiAoeTEgPj0geTMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYzFyID0gY29sb3JzW2MxXSxcbiAgICBjMWcgPSBjb2xvcnNbYzEgKyAxXSxcbiAgICBjMWIgPSBjb2xvcnNbYzEgKyAyXTtcbiAgY29uc3QgYzJyID0gY29sb3JzW2MyXSxcbiAgICBjMmcgPSBjb2xvcnNbYzIgKyAxXSxcbiAgICBjMmIgPSBjb2xvcnNbYzIgKyAyXTtcbiAgY29uc3QgYzNyID0gY29sb3JzW2MzXSxcbiAgICBjM2cgPSBjb2xvcnNbYzMgKyAxXSxcbiAgICBjM2IgPSBjb2xvcnNbYzMgKyAyXTtcbiAgY29uc3QgbWluWSA9IE1hdGgucm91bmQoeTEpLFxuICAgIG1heFkgPSBNYXRoLnJvdW5kKHkzKTtcbiAgbGV0IHhhLCBjYXIsIGNhZywgY2FiO1xuICBsZXQgeGIsIGNiciwgY2JnLCBjYmI7XG4gIGZvciAobGV0IHkgPSBtaW5ZOyB5IDw9IG1heFk7IHkrKykge1xuICAgIGlmICh5IDwgeTIpIHtcbiAgICAgIGNvbnN0IGsgPSB5IDwgeTEgPyAwIDogKHkxIC0geSkgLyAoeTEgLSB5Mik7XG4gICAgICB4YSA9IHgxIC0gKHgxIC0geDIpICogaztcbiAgICAgIGNhciA9IGMxciAtIChjMXIgLSBjMnIpICogaztcbiAgICAgIGNhZyA9IGMxZyAtIChjMWcgLSBjMmcpICogaztcbiAgICAgIGNhYiA9IGMxYiAtIChjMWIgLSBjMmIpICogaztcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGs7XG4gICAgICBpZiAoeSA+IHkzKSB7XG4gICAgICAgIGsgPSAxO1xuICAgICAgfSBlbHNlIGlmICh5MiA9PT0geTMpIHtcbiAgICAgICAgayA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrID0gKHkyIC0geSkgLyAoeTIgLSB5Myk7XG4gICAgICB9XG4gICAgICB4YSA9IHgyIC0gKHgyIC0geDMpICogaztcbiAgICAgIGNhciA9IGMyciAtIChjMnIgLSBjM3IpICogaztcbiAgICAgIGNhZyA9IGMyZyAtIChjMmcgLSBjM2cpICogaztcbiAgICAgIGNhYiA9IGMyYiAtIChjMmIgLSBjM2IpICogaztcbiAgICB9XG4gICAgbGV0IGs7XG4gICAgaWYgKHkgPCB5MSkge1xuICAgICAgayA9IDA7XG4gICAgfSBlbHNlIGlmICh5ID4geTMpIHtcbiAgICAgIGsgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBrID0gKHkxIC0geSkgLyAoeTEgLSB5Myk7XG4gICAgfVxuICAgIHhiID0geDEgLSAoeDEgLSB4MykgKiBrO1xuICAgIGNiciA9IGMxciAtIChjMXIgLSBjM3IpICogaztcbiAgICBjYmcgPSBjMWcgLSAoYzFnIC0gYzNnKSAqIGs7XG4gICAgY2JiID0gYzFiIC0gKGMxYiAtIGMzYikgKiBrO1xuICAgIGNvbnN0IHgxXyA9IE1hdGgucm91bmQoTWF0aC5taW4oeGEsIHhiKSk7XG4gICAgY29uc3QgeDJfID0gTWF0aC5yb3VuZChNYXRoLm1heCh4YSwgeGIpKTtcbiAgICBsZXQgaiA9IHJvd1NpemUgKiB5ICsgeDFfICogNDtcbiAgICBmb3IgKGxldCB4ID0geDFfOyB4IDw9IHgyXzsgeCsrKSB7XG4gICAgICBrID0gKHhhIC0geCkgLyAoeGEgLSB4Yik7XG4gICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgayA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGsgPiAxKSB7XG4gICAgICAgIGsgPSAxO1xuICAgICAgfVxuICAgICAgYnl0ZXNbaisrXSA9IGNhciAtIChjYXIgLSBjYnIpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gY2FnIC0gKGNhZyAtIGNiZykgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSBjYWIgLSAoY2FiIC0gY2JiKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IDI1NTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdGaWd1cmUoZGF0YSwgZmlndXJlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHBzID0gZmlndXJlLmNvb3JkcztcbiAgY29uc3QgY3MgPSBmaWd1cmUuY29sb3JzO1xuICBsZXQgaSwgaWk7XG4gIHN3aXRjaCAoZmlndXJlLnR5cGUpIHtcbiAgICBjYXNlIFwibGF0dGljZVwiOlxuICAgICAgY29uc3QgdmVydGljZXNQZXJSb3cgPSBmaWd1cmUudmVydGljZXNQZXJSb3c7XG4gICAgICBjb25zdCByb3dzID0gTWF0aC5mbG9vcihwcy5sZW5ndGggLyB2ZXJ0aWNlc1BlclJvdykgLSAxO1xuICAgICAgY29uc3QgY29scyA9IHZlcnRpY2VzUGVyUm93IC0gMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgbGV0IHEgPSBpICogdmVydGljZXNQZXJSb3c7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sczsgaisrLCBxKyspIHtcbiAgICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbcV0sIHBzW3EgKyAxXSwgcHNbcSArIHZlcnRpY2VzUGVyUm93XSwgY3NbcV0sIGNzW3EgKyAxXSwgY3NbcSArIHZlcnRpY2VzUGVyUm93XSk7XG4gICAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBwc1txICsgMV0sIHBzW3EgKyB2ZXJ0aWNlc1BlclJvd10sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBjc1txICsgMV0sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvd10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidHJpYW5nbGVzXCI6XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IHBzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDMpIHtcbiAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW2ldLCBwc1tpICsgMV0sIHBzW2kgKyAyXSwgY3NbaV0sIGNzW2kgKyAxXSwgY3NbaSArIDJdKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGZpZ3VyZVwiKTtcbiAgfVxufVxuY2xhc3MgTWVzaFNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IoSVIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2Nvb3JkcyA9IElSWzJdO1xuICAgIHRoaXMuX2NvbG9ycyA9IElSWzNdO1xuICAgIHRoaXMuX2ZpZ3VyZXMgPSBJUls0XTtcbiAgICB0aGlzLl9ib3VuZHMgPSBJUls1XTtcbiAgICB0aGlzLl9iYm94ID0gSVJbN107XG4gICAgdGhpcy5fYmFja2dyb3VuZCA9IElSWzhdO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgfVxuICBfY3JlYXRlTWVzaENhbnZhcyhjb21iaW5lZFNjYWxlLCBiYWNrZ3JvdW5kQ29sb3IsIGNhY2hlZENhbnZhc2VzKSB7XG4gICAgY29uc3QgRVhQRUNURURfU0NBTEUgPSAxLjE7XG4gICAgY29uc3QgTUFYX1BBVFRFUk5fU0laRSA9IDMwMDA7XG4gICAgY29uc3QgQk9SREVSX1NJWkUgPSAyO1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmZsb29yKHRoaXMuX2JvdW5kc1swXSk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguZmxvb3IodGhpcy5fYm91bmRzWzFdKTtcbiAgICBjb25zdCBib3VuZHNXaWR0aCA9IE1hdGguY2VpbCh0aGlzLl9ib3VuZHNbMl0pIC0gb2Zmc2V0WDtcbiAgICBjb25zdCBib3VuZHNIZWlnaHQgPSBNYXRoLmNlaWwodGhpcy5fYm91bmRzWzNdKSAtIG9mZnNldFk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1pbihNYXRoLmNlaWwoTWF0aC5hYnMoYm91bmRzV2lkdGggKiBjb21iaW5lZFNjYWxlWzBdICogRVhQRUNURURfU0NBTEUpKSwgTUFYX1BBVFRFUk5fU0laRSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5taW4oTWF0aC5jZWlsKE1hdGguYWJzKGJvdW5kc0hlaWdodCAqIGNvbWJpbmVkU2NhbGVbMV0gKiBFWFBFQ1RFRF9TQ0FMRSkpLCBNQVhfUEFUVEVSTl9TSVpFKTtcbiAgICBjb25zdCBzY2FsZVggPSBib3VuZHNXaWR0aCAvIHdpZHRoO1xuICAgIGNvbnN0IHNjYWxlWSA9IGJvdW5kc0hlaWdodCAvIGhlaWdodDtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgY29vcmRzOiB0aGlzLl9jb29yZHMsXG4gICAgICBjb2xvcnM6IHRoaXMuX2NvbG9ycyxcbiAgICAgIG9mZnNldFg6IC1vZmZzZXRYLFxuICAgICAgb2Zmc2V0WTogLW9mZnNldFksXG4gICAgICBzY2FsZVg6IDEgLyBzY2FsZVgsXG4gICAgICBzY2FsZVk6IDEgLyBzY2FsZVlcbiAgICB9O1xuICAgIGNvbnN0IHBhZGRlZFdpZHRoID0gd2lkdGggKyBCT1JERVJfU0laRSAqIDI7XG4gICAgY29uc3QgcGFkZGVkSGVpZ2h0ID0gaGVpZ2h0ICsgQk9SREVSX1NJWkUgKiAyO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IGNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1lc2hcIiwgcGFkZGVkV2lkdGgsIHBhZGRlZEhlaWdodCwgZmFsc2UpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGRhdGEgPSB0bXBDdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gZGF0YS5kYXRhO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYnl0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgICBieXRlc1tpXSA9IGJhY2tncm91bmRDb2xvclswXTtcbiAgICAgICAgYnl0ZXNbaSArIDFdID0gYmFja2dyb3VuZENvbG9yWzFdO1xuICAgICAgICBieXRlc1tpICsgMl0gPSBiYWNrZ3JvdW5kQ29sb3JbMl07XG4gICAgICAgIGJ5dGVzW2kgKyAzXSA9IDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWd1cmUgb2YgdGhpcy5fZmlndXJlcykge1xuICAgICAgZHJhd0ZpZ3VyZShkYXRhLCBmaWd1cmUsIGNvbnRleHQpO1xuICAgIH1cbiAgICB0bXBDdHgucHV0SW1hZ2VEYXRhKGRhdGEsIEJPUkRFUl9TSVpFLCBCT1JERVJfU0laRSk7XG4gICAgY29uc3QgY2FudmFzID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzLFxuICAgICAgb2Zmc2V0WDogb2Zmc2V0WCAtIEJPUkRFUl9TSVpFICogc2NhbGVYLFxuICAgICAgb2Zmc2V0WTogb2Zmc2V0WSAtIEJPUkRFUl9TSVpFICogc2NhbGVZLFxuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZXG4gICAgfTtcbiAgfVxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlKSB7XG4gICAgYXBwbHlCb3VuZGluZ0JveChjdHgsIHRoaXMuX2Jib3gpO1xuICAgIGxldCBzY2FsZTtcbiAgICBpZiAocGF0aFR5cGUgPT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIHNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSgoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShvd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICBjb25zdCBtYXRyaXhTY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5tYXRyaXgpO1xuICAgICAgICBzY2FsZSA9IFtzY2FsZVswXSAqIG1hdHJpeFNjYWxlWzBdLCBzY2FsZVsxXSAqIG1hdHJpeFNjYWxlWzFdXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcyA9IHRoaXMuX2NyZWF0ZU1lc2hDYW52YXMoc2NhbGUsIHBhdGhUeXBlID09PSBQYXRoVHlwZS5TSEFESU5HID8gbnVsbCA6IHRoaXMuX2JhY2tncm91bmQsIG93bmVyLmNhY2hlZENhbnZhc2VzKTtcbiAgICBpZiAocGF0aFR5cGUgIT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ub3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSguLi50aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC50cmFuc2xhdGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFkpO1xuICAgIGN0eC5zY2FsZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVkpO1xuICAgIHJldHVybiBjdHguY3JlYXRlUGF0dGVybih0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLmNhbnZhcywgXCJuby1yZXBlYXRcIik7XG4gIH1cbn1cbmNsYXNzIER1bW15U2hhZGluZ1BhdHRlcm4gZXh0ZW5kcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBnZXRQYXR0ZXJuKCkge1xuICAgIHJldHVybiBcImhvdHBpbmtcIjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2hhZGluZ1BhdHRlcm4oSVIpIHtcbiAgc3dpdGNoIChJUlswXSkge1xuICAgIGNhc2UgXCJSYWRpYWxBeGlhbFwiOlxuICAgICAgcmV0dXJuIG5ldyBSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuKElSKTtcbiAgICBjYXNlIFwiTWVzaFwiOlxuICAgICAgcmV0dXJuIG5ldyBNZXNoU2hhZGluZ1BhdHRlcm4oSVIpO1xuICAgIGNhc2UgXCJEdW1teVwiOlxuICAgICAgcmV0dXJuIG5ldyBEdW1teVNoYWRpbmdQYXR0ZXJuKCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIElSIHR5cGU6ICR7SVJbMF19YCk7XG59XG5jb25zdCBQYWludFR5cGUgPSB7XG4gIENPTE9SRUQ6IDEsXG4gIFVOQ09MT1JFRDogMlxufTtcbmNsYXNzIFRpbGluZ1BhdHRlcm4ge1xuICBzdGF0aWMgTUFYX1BBVFRFUk5fU0laRSA9IDMwMDA7XG4gIGNvbnN0cnVjdG9yKElSLCBjb2xvciwgY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdCA9IElSWzJdO1xuICAgIHRoaXMubWF0cml4ID0gSVJbM10gfHwgWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIHRoaXMuYmJveCA9IElSWzRdO1xuICAgIHRoaXMueHN0ZXAgPSBJUls1XTtcbiAgICB0aGlzLnlzdGVwID0gSVJbNl07XG4gICAgdGhpcy5wYWludFR5cGUgPSBJUls3XTtcbiAgICB0aGlzLnRpbGluZ1R5cGUgPSBJUls4XTtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5jYW52YXNHcmFwaGljc0ZhY3RvcnkgPSBjYW52YXNHcmFwaGljc0ZhY3Rvcnk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gYmFzZVRyYW5zZm9ybTtcbiAgfVxuICBjcmVhdGVQYXR0ZXJuQ2FudmFzKG93bmVyKSB7XG4gICAgY29uc3Qgb3BlcmF0b3JMaXN0ID0gdGhpcy5vcGVyYXRvckxpc3Q7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuYmJveDtcbiAgICBjb25zdCB4c3RlcCA9IHRoaXMueHN0ZXA7XG4gICAgY29uc3QgeXN0ZXAgPSB0aGlzLnlzdGVwO1xuICAgIGNvbnN0IHBhaW50VHlwZSA9IHRoaXMucGFpbnRUeXBlO1xuICAgIGNvbnN0IHRpbGluZ1R5cGUgPSB0aGlzLnRpbGluZ1R5cGU7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIGNvbnN0IGNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IHRoaXMuY2FudmFzR3JhcGhpY3NGYWN0b3J5O1xuICAgICgwLCBfdXRpbC5pbmZvKShcIlRpbGluZ1R5cGU6IFwiICsgdGlsaW5nVHlwZSk7XG4gICAgY29uc3QgeDAgPSBiYm94WzBdLFxuICAgICAgeTAgPSBiYm94WzFdLFxuICAgICAgeDEgPSBiYm94WzJdLFxuICAgICAgeTEgPSBiYm94WzNdO1xuICAgIGNvbnN0IG1hdHJpeFNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0aGlzLm1hdHJpeCk7XG4gICAgY29uc3QgY3VyTWF0cml4U2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMuYmFzZVRyYW5zZm9ybSk7XG4gICAgY29uc3QgY29tYmluZWRTY2FsZSA9IFttYXRyaXhTY2FsZVswXSAqIGN1ck1hdHJpeFNjYWxlWzBdLCBtYXRyaXhTY2FsZVsxXSAqIGN1ck1hdHJpeFNjYWxlWzFdXTtcbiAgICBjb25zdCBkaW14ID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoeHN0ZXAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgY29tYmluZWRTY2FsZVswXSk7XG4gICAgY29uc3QgZGlteSA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKHlzdGVwLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0LCBjb21iaW5lZFNjYWxlWzFdKTtcbiAgICBjb25zdCB0bXBDYW52YXMgPSBvd25lci5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJwYXR0ZXJuXCIsIGRpbXguc2l6ZSwgZGlteS5zaXplLCB0cnVlKTtcbiAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBncmFwaGljcyA9IGNhbnZhc0dyYXBoaWNzRmFjdG9yeS5jcmVhdGVDYW52YXNHcmFwaGljcyh0bXBDdHgpO1xuICAgIGdyYXBoaWNzLmdyb3VwTGV2ZWwgPSBvd25lci5ncm91cExldmVsO1xuICAgIHRoaXMuc2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0KGdyYXBoaWNzLCBwYWludFR5cGUsIGNvbG9yKTtcbiAgICBsZXQgYWRqdXN0ZWRYMCA9IHgwO1xuICAgIGxldCBhZGp1c3RlZFkwID0geTA7XG4gICAgbGV0IGFkanVzdGVkWDEgPSB4MTtcbiAgICBsZXQgYWRqdXN0ZWRZMSA9IHkxO1xuICAgIGlmICh4MCA8IDApIHtcbiAgICAgIGFkanVzdGVkWDAgPSAwO1xuICAgICAgYWRqdXN0ZWRYMSArPSBNYXRoLmFicyh4MCk7XG4gICAgfVxuICAgIGlmICh5MCA8IDApIHtcbiAgICAgIGFkanVzdGVkWTAgPSAwO1xuICAgICAgYWRqdXN0ZWRZMSArPSBNYXRoLmFicyh5MCk7XG4gICAgfVxuICAgIHRtcEN0eC50cmFuc2xhdGUoLShkaW14LnNjYWxlICogYWRqdXN0ZWRYMCksIC0oZGlteS5zY2FsZSAqIGFkanVzdGVkWTApKTtcbiAgICBncmFwaGljcy50cmFuc2Zvcm0oZGlteC5zY2FsZSwgMCwgMCwgZGlteS5zY2FsZSwgMCwgMCk7XG4gICAgdG1wQ3R4LnNhdmUoKTtcbiAgICB0aGlzLmNsaXBCYm94KGdyYXBoaWNzLCBhZGp1c3RlZFgwLCBhZGp1c3RlZFkwLCBhZGp1c3RlZFgxLCBhZGp1c3RlZFkxKTtcbiAgICBncmFwaGljcy5iYXNlVHJhbnNmb3JtID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGdyYXBoaWNzLmN0eCk7XG4gICAgZ3JhcGhpY3MuZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QpO1xuICAgIGdyYXBoaWNzLmVuZERyYXdpbmcoKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzOiB0bXBDYW52YXMuY2FudmFzLFxuICAgICAgc2NhbGVYOiBkaW14LnNjYWxlLFxuICAgICAgc2NhbGVZOiBkaW15LnNjYWxlLFxuICAgICAgb2Zmc2V0WDogYWRqdXN0ZWRYMCxcbiAgICAgIG9mZnNldFk6IGFkanVzdGVkWTBcbiAgICB9O1xuICB9XG4gIGdldFNpemVBbmRTY2FsZShzdGVwLCByZWFsT3V0cHV0U2l6ZSwgc2NhbGUpIHtcbiAgICBzdGVwID0gTWF0aC5hYnMoc3RlcCk7XG4gICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgubWF4KFRpbGluZ1BhdHRlcm4uTUFYX1BBVFRFUk5fU0laRSwgcmVhbE91dHB1dFNpemUpO1xuICAgIGxldCBzaXplID0gTWF0aC5jZWlsKHN0ZXAgKiBzY2FsZSk7XG4gICAgaWYgKHNpemUgPj0gbWF4U2l6ZSkge1xuICAgICAgc2l6ZSA9IG1heFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gc2l6ZSAvIHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzY2FsZSxcbiAgICAgIHNpemVcbiAgICB9O1xuICB9XG4gIGNsaXBCYm94KGdyYXBoaWNzLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIGNvbnN0IGJib3hXaWR0aCA9IHgxIC0geDA7XG4gICAgY29uc3QgYmJveEhlaWdodCA9IHkxIC0geTA7XG4gICAgZ3JhcGhpY3MuY3R4LnJlY3QoeDAsIHkwLCBiYm94V2lkdGgsIGJib3hIZWlnaHQpO1xuICAgIGdyYXBoaWNzLmN1cnJlbnQudXBkYXRlUmVjdE1pbk1heCgoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoZ3JhcGhpY3MuY3R4KSwgW3gwLCB5MCwgeDEsIHkxXSk7XG4gICAgZ3JhcGhpY3MuY2xpcCgpO1xuICAgIGdyYXBoaWNzLmVuZFBhdGgoKTtcbiAgfVxuICBzZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQoZ3JhcGhpY3MsIHBhaW50VHlwZSwgY29sb3IpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gZ3JhcGhpY3MuY3R4LFxuICAgICAgY3VycmVudCA9IGdyYXBoaWNzLmN1cnJlbnQ7XG4gICAgc3dpdGNoIChwYWludFR5cGUpIHtcbiAgICAgIGNhc2UgUGFpbnRUeXBlLkNPTE9SRUQ6XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGU7XG4gICAgICAgIGN1cnJlbnQuZmlsbENvbG9yID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgICAgY3VycmVudC5zdHJva2VDb2xvciA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBhaW50VHlwZS5VTkNPTE9SRUQ6XG4gICAgICAgIGNvbnN0IGNzc0NvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY3NzQ29sb3I7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjc3NDb2xvcjtcbiAgICAgICAgY3VycmVudC5maWxsQ29sb3IgPSBjc3NDb2xvcjtcbiAgICAgICAgY3VycmVudC5zdHJva2VDb2xvciA9IGNzc0NvbG9yO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBfdXRpbC5Gb3JtYXRFcnJvcihgVW5zdXBwb3J0ZWQgcGFpbnQgdHlwZTogJHtwYWludFR5cGV9YCk7XG4gICAgfVxuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBsZXQgbWF0cml4ID0gaW52ZXJzZTtcbiAgICBpZiAocGF0aFR5cGUgIT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIG1hdHJpeCA9IF91dGlsLlV0aWwudHJhbnNmb3JtKG1hdHJpeCwgb3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgbWF0cml4ID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0obWF0cml4LCB0aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRlbXBvcmFyeVBhdHRlcm5DYW52YXMgPSB0aGlzLmNyZWF0ZVBhdHRlcm5DYW52YXMob3duZXIpO1xuICAgIGxldCBkb21NYXRyaXggPSBuZXcgRE9NTWF0cml4KG1hdHJpeCk7XG4gICAgZG9tTWF0cml4ID0gZG9tTWF0cml4LnRyYW5zbGF0ZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WSk7XG4gICAgZG9tTWF0cml4ID0gZG9tTWF0cml4LnNjYWxlKDEgLyB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWCwgMSAvIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVZKTtcbiAgICBjb25zdCBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5jYW52YXMsIFwicmVwZWF0XCIpO1xuICAgIHBhdHRlcm4uc2V0VHJhbnNmb3JtKGRvbU1hdHJpeCk7XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbn1cbmV4cG9ydHMuVGlsaW5nUGF0dGVybiA9IFRpbGluZ1BhdHRlcm47XG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEgPSBjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQTtcbmV4cG9ydHMuY29udmVydFRvUkdCQSA9IGNvbnZlcnRUb1JHQkE7XG5leHBvcnRzLmdyYXlUb1JHQkEgPSBncmF5VG9SR0JBO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbmZ1bmN0aW9uIGNvbnZlcnRUb1JHQkEocGFyYW1zKSB7XG4gIHN3aXRjaCAocGFyYW1zLmtpbmQpIHtcbiAgICBjYXNlIF91dGlsLkltYWdlS2luZC5HUkFZU0NBTEVfMUJQUDpcbiAgICAgIHJldHVybiBjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQShwYXJhbXMpO1xuICAgIGNhc2UgX3V0aWwuSW1hZ2VLaW5kLlJHQl8yNEJQUDpcbiAgICAgIHJldHVybiBjb252ZXJ0UkdCVG9SR0JBKHBhcmFtcyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQSh7XG4gIHNyYyxcbiAgc3JjUG9zID0gMCxcbiAgZGVzdCxcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgbm9uQmxhY2tDb2xvciA9IDB4ZmZmZmZmZmYsXG4gIGludmVyc2VEZWNvZGUgPSBmYWxzZVxufSkge1xuICBjb25zdCBibGFjayA9IF91dGlsLkZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuID8gMHhmZjAwMDAwMCA6IDB4MDAwMDAwZmY7XG4gIGNvbnN0IFt6ZXJvTWFwcGluZywgb25lTWFwcGluZ10gPSBpbnZlcnNlRGVjb2RlID8gW25vbkJsYWNrQ29sb3IsIGJsYWNrXSA6IFtibGFjaywgbm9uQmxhY2tDb2xvcl07XG4gIGNvbnN0IHdpZHRoSW5Tb3VyY2UgPSB3aWR0aCA+PiAzO1xuICBjb25zdCB3aWR0aFJlbWFpbmRlciA9IHdpZHRoICYgNztcbiAgY29uc3Qgc3JjTGVuZ3RoID0gc3JjLmxlbmd0aDtcbiAgZGVzdCA9IG5ldyBVaW50MzJBcnJheShkZXN0LmJ1ZmZlcik7XG4gIGxldCBkZXN0UG9zID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgIGZvciAoY29uc3QgbWF4ID0gc3JjUG9zICsgd2lkdGhJblNvdXJjZTsgc3JjUG9zIDwgbWF4OyBzcmNQb3MrKykge1xuICAgICAgY29uc3QgZWxlbSA9IHNyY1BvcyA8IHNyY0xlbmd0aCA/IHNyY1tzcmNQb3NdIDogMjU1O1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgIH1cbiAgICBpZiAod2lkdGhSZW1haW5kZXIgPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBlbGVtID0gc3JjUG9zIDwgc3JjTGVuZ3RoID8gc3JjW3NyY1BvcysrXSA6IDI1NTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoUmVtYWluZGVyOyBqKyspIHtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAxIDw8IDcgLSBqID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNyY1BvcyxcbiAgICBkZXN0UG9zXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0UkdCVG9SR0JBKHtcbiAgc3JjLFxuICBzcmNQb3MgPSAwLFxuICBkZXN0LFxuICBkZXN0UG9zID0gMCxcbiAgd2lkdGgsXG4gIGhlaWdodFxufSkge1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGxlbjMyID0gc3JjLmxlbmd0aCA+PiAyO1xuICBjb25zdCBzcmMzMiA9IG5ldyBVaW50MzJBcnJheShzcmMuYnVmZmVyLCBzcmNQb3MsIGxlbjMyKTtcbiAgaWYgKF91dGlsLkZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuKSB7XG4gICAgZm9yICg7IGkgPCBsZW4zMiAtIDI7IGkgKz0gMywgZGVzdFBvcyArPSA0KSB7XG4gICAgICBjb25zdCBzMSA9IHNyYzMyW2ldO1xuICAgICAgY29uc3QgczIgPSBzcmMzMltpICsgMV07XG4gICAgICBjb25zdCBzMyA9IHNyYzMyW2kgKyAyXTtcbiAgICAgIGRlc3RbZGVzdFBvc10gPSBzMSB8IDB4ZmYwMDAwMDA7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAxXSA9IHMxID4+PiAyNCB8IHMyIDw8IDggfCAweGZmMDAwMDAwO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMl0gPSBzMiA+Pj4gMTYgfCBzMyA8PCAxNiB8IDB4ZmYwMDAwMDA7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAzXSA9IHMzID4+PiA4IHwgMHhmZjAwMDAwMDtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGkgKiA0LCBqaiA9IHNyYy5sZW5ndGg7IGogPCBqajsgaiArPSAzKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbal0gfCBzcmNbaiArIDFdIDw8IDggfCBzcmNbaiArIDJdIDw8IDE2IHwgMHhmZjAwMDAwMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICg7IGkgPCBsZW4zMiAtIDI7IGkgKz0gMywgZGVzdFBvcyArPSA0KSB7XG4gICAgICBjb25zdCBzMSA9IHNyYzMyW2ldO1xuICAgICAgY29uc3QgczIgPSBzcmMzMltpICsgMV07XG4gICAgICBjb25zdCBzMyA9IHNyYzMyW2kgKyAyXTtcbiAgICAgIGRlc3RbZGVzdFBvc10gPSBzMSB8IDB4ZmY7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAxXSA9IHMxIDw8IDI0IHwgczIgPj4+IDggfCAweGZmO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMl0gPSBzMiA8PCAxNiB8IHMzID4+PiAxNiB8IDB4ZmY7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAzXSA9IHMzIDw8IDggfCAweGZmO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaSAqIDQsIGpqID0gc3JjLmxlbmd0aDsgaiA8IGpqOyBqICs9IDMpIHtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tqXSA8PCAyNCB8IHNyY1tqICsgMV0gPDwgMTYgfCBzcmNbaiArIDJdIDw8IDggfCAweGZmO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNyY1BvcyxcbiAgICBkZXN0UG9zXG4gIH07XG59XG5mdW5jdGlvbiBncmF5VG9SR0JBKHNyYywgZGVzdCkge1xuICBpZiAoX3V0aWwuRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgZGVzdFtpXSA9IHNyY1tpXSAqIDB4MTAxMDEgfCAweGZmMDAwMDAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgZGVzdFtpXSA9IHNyY1tpXSAqIDB4MTAxMDEwMCB8IDB4MDAwMDAwZmY7XG4gICAgfVxuICB9XG59XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuR2xvYmFsV29ya2VyT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IEdsb2JhbFdvcmtlck9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZXhwb3J0cy5HbG9iYWxXb3JrZXJPcHRpb25zID0gR2xvYmFsV29ya2VyT3B0aW9ucztcbkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydCA9IG51bGw7XG5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYyA9IFwiXCI7XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuTWVzc2FnZUhhbmRsZXIgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuY29uc3QgQ2FsbGJhY2tLaW5kID0ge1xuICBVTktOT1dOOiAwLFxuICBEQVRBOiAxLFxuICBFUlJPUjogMlxufTtcbmNvbnN0IFN0cmVhbUtpbmQgPSB7XG4gIFVOS05PV046IDAsXG4gIENBTkNFTDogMSxcbiAgQ0FOQ0VMX0NPTVBMRVRFOiAyLFxuICBDTE9TRTogMyxcbiAgRU5RVUVVRTogNCxcbiAgRVJST1I6IDUsXG4gIFBVTEw6IDYsXG4gIFBVTExfQ09NUExFVEU6IDcsXG4gIFNUQVJUX0NPTVBMRVRFOiA4XG59O1xuZnVuY3Rpb24gd3JhcFJlYXNvbihyZWFzb24pIHtcbiAgaWYgKCEocmVhc29uIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIHJlYXNvbiA9PT0gXCJvYmplY3RcIiAmJiByZWFzb24gIT09IG51bGwpKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKSgnd3JhcFJlYXNvbjogRXhwZWN0ZWQgXCJyZWFzb25cIiB0byBiZSBhIChwb3NzaWJseSBjbG9uZWQpIEVycm9yLicpO1xuICB9XG4gIHN3aXRjaCAocmVhc29uLm5hbWUpIHtcbiAgICBjYXNlIFwiQWJvcnRFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UpO1xuICAgIGNhc2UgXCJNaXNzaW5nUERGRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UpO1xuICAgIGNhc2UgXCJQYXNzd29yZEV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5QYXNzd29yZEV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSwgcmVhc29uLmNvZGUpO1xuICAgIGNhc2UgXCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24uc3RhdHVzKTtcbiAgICBjYXNlIFwiVW5rbm93bkVycm9yRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsLlVua25vd25FcnJvckV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSwgcmVhc29uLmRldGFpbHMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbmV3IF91dGlsLlVua25vd25FcnJvckV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSwgcmVhc29uLnRvU3RyaW5nKCkpO1xuICB9XG59XG5jbGFzcyBNZXNzYWdlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZU5hbWUsIHRhcmdldE5hbWUsIGNvbU9iaikge1xuICAgIHRoaXMuc291cmNlTmFtZSA9IHNvdXJjZU5hbWU7XG4gICAgdGhpcy50YXJnZXROYW1lID0gdGFyZ2V0TmFtZTtcbiAgICB0aGlzLmNvbU9iaiA9IGNvbU9iajtcbiAgICB0aGlzLmNhbGxiYWNrSWQgPSAxO1xuICAgIHRoaXMuc3RyZWFtSWQgPSAxO1xuICAgIHRoaXMuc3RyZWFtU2lua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYWN0aW9uSGFuZGxlciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fb25Db21PYmpPbk1lc3NhZ2UgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgIGlmIChkYXRhLnRhcmdldE5hbWUgIT09IHRoaXMuc291cmNlTmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5zdHJlYW0pIHtcbiAgICAgICAgdGhpcy4jcHJvY2Vzc1N0cmVhbU1lc3NhZ2UoZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrSWQgPSBkYXRhLmNhbGxiYWNrSWQ7XG4gICAgICAgIGNvbnN0IGNhcGFiaWxpdHkgPSB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdO1xuICAgICAgICBpZiAoIWNhcGFiaWxpdHkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXNvbHZlIGNhbGxiYWNrICR7Y2FsbGJhY2tJZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXTtcbiAgICAgICAgaWYgKGRhdGEuY2FsbGJhY2sgPT09IENhbGxiYWNrS2luZC5EQVRBKSB7XG4gICAgICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlKGRhdGEuZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5jYWxsYmFjayA9PT0gQ2FsbGJhY2tLaW5kLkVSUk9SKSB7XG4gICAgICAgICAgY2FwYWJpbGl0eS5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2FsbGJhY2sgY2FzZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFjdGlvbkhhbmRsZXJbZGF0YS5hY3Rpb25dO1xuICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGFjdGlvbiBmcm9tIHdvcmtlcjogJHtkYXRhLmFjdGlvbn1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmNhbGxiYWNrSWQpIHtcbiAgICAgICAgY29uc3QgY2JTb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lO1xuICAgICAgICBjb25zdCBjYlRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWU7XG4gICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZShhY3Rpb24oZGF0YS5kYXRhKSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lOiBjYlNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lOiBjYlRhcmdldE5hbWUsXG4gICAgICAgICAgICBjYWxsYmFjazogQ2FsbGJhY2tLaW5kLkRBVEEsXG4gICAgICAgICAgICBjYWxsYmFja0lkOiBkYXRhLmNhbGxiYWNrSWQsXG4gICAgICAgICAgICBkYXRhOiByZXN1bHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lOiBjYlNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lOiBjYlRhcmdldE5hbWUsXG4gICAgICAgICAgICBjYWxsYmFjazogQ2FsbGJhY2tLaW5kLkVSUk9SLFxuICAgICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnN0cmVhbUlkKSB7XG4gICAgICAgIHRoaXMuI2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFjdGlvbihkYXRhLmRhdGEpO1xuICAgIH07XG4gICAgY29tT2JqLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX29uQ29tT2JqT25NZXNzYWdlKTtcbiAgfVxuICBvbihhY3Rpb25OYW1lLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgYWggPSB0aGlzLmFjdGlvbkhhbmRsZXI7XG4gICAgaWYgKGFoW2FjdGlvbk5hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIGFscmVhZHkgYW4gYWN0aW9uTmFtZSBjYWxsZWQgXCIke2FjdGlvbk5hbWV9XCJgKTtcbiAgICB9XG4gICAgYWhbYWN0aW9uTmFtZV0gPSBoYW5kbGVyO1xuICB9XG4gIHNlbmQoYWN0aW9uTmFtZSwgZGF0YSwgdHJhbnNmZXJzKSB7XG4gICAgdGhpcy5jb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgc291cmNlTmFtZTogdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZTogdGhpcy50YXJnZXROYW1lLFxuICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgZGF0YVxuICAgIH0sIHRyYW5zZmVycyk7XG4gIH1cbiAgc2VuZFdpdGhQcm9taXNlKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xuICAgIGNvbnN0IGNhbGxiYWNrSWQgPSB0aGlzLmNhbGxiYWNrSWQrKztcbiAgICBjb25zdCBjYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXSA9IGNhcGFiaWxpdHk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZTogdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lOiB0aGlzLnRhcmdldE5hbWUsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgICAgY2FsbGJhY2tJZCxcbiAgICAgICAgZGF0YVxuICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgY2FwYWJpbGl0eS5yZWplY3QoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHNlbmRXaXRoU3RyZWFtKGFjdGlvbk5hbWUsIGRhdGEsIHF1ZXVlaW5nU3RyYXRlZ3ksIHRyYW5zZmVycykge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gdGhpcy5zdHJlYW1JZCsrLFxuICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWUgPSB0aGlzLnRhcmdldE5hbWUsXG4gICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBjb250cm9sbGVyID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdID0ge1xuICAgICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgICAgc3RhcnRDYWxsOiBzdGFydENhcGFiaWxpdHksXG4gICAgICAgICAgcHVsbENhbGw6IG51bGwsXG4gICAgICAgICAgY2FuY2VsQ2FsbDogbnVsbCxcbiAgICAgICAgICBpc0Nsb3NlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgZGVzaXJlZFNpemU6IGNvbnRyb2xsZXIuZGVzaXJlZFNpemVcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIHB1bGw6IGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBjb25zdCBwdWxsQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5wdWxsQ2FsbCA9IHB1bGxDYXBhYmlsaXR5O1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTCxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICBkZXNpcmVkU2l6ZTogY29udHJvbGxlci5kZXNpcmVkU2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHB1bGxDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9LFxuICAgICAgY2FuY2VsOiByZWFzb24gPT4ge1xuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KShyZWFzb24gaW5zdGFuY2VvZiBFcnJvciwgXCJjYW5jZWwgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uXCIpO1xuICAgICAgICBjb25zdCBjYW5jZWxDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmNhbmNlbENhbGwgPSBjYW5jZWxDYXBhYmlsaXR5O1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUwsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYW5jZWxDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9XG4gICAgfSwgcXVldWVpbmdTdHJhdGVneSk7XG4gIH1cbiAgI2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSkge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gZGF0YS5zdHJlYW1JZCxcbiAgICAgIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lLFxuICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMsXG4gICAgICBhY3Rpb24gPSB0aGlzLmFjdGlvbkhhbmRsZXJbZGF0YS5hY3Rpb25dO1xuICAgIGNvbnN0IHN0cmVhbVNpbmsgPSB7XG4gICAgICBlbnF1ZXVlKGNodW5rLCBzaXplID0gMSwgdHJhbnNmZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3REZXNpcmVkU2l6ZSA9IHRoaXMuZGVzaXJlZFNpemU7XG4gICAgICAgIHRoaXMuZGVzaXJlZFNpemUgLT0gc2l6ZTtcbiAgICAgICAgaWYgKGxhc3REZXNpcmVkU2l6ZSA+IDAgJiYgdGhpcy5kZXNpcmVkU2l6ZSA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5zaW5rQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgICAgIHRoaXMucmVhZHkgPSB0aGlzLnNpbmtDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVOUVVFVUUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgY2h1bmtcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgIH0sXG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DTE9TRSxcbiAgICAgICAgICBzdHJlYW1JZFxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIHNlbGYuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgICAgfSxcbiAgICAgIGVycm9yKHJlYXNvbikge1xuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KShyZWFzb24gaW5zdGFuY2VvZiBFcnJvciwgXCJlcnJvciBtdXN0IGhhdmUgYSB2YWxpZCByZWFzb25cIik7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuRVJST1IsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2lua0NhcGFiaWxpdHk6IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpLFxuICAgICAgb25QdWxsOiBudWxsLFxuICAgICAgb25DYW5jZWw6IG51bGwsXG4gICAgICBpc0NhbmNlbGxlZDogZmFsc2UsXG4gICAgICBkZXNpcmVkU2l6ZTogZGF0YS5kZXNpcmVkU2l6ZSxcbiAgICAgIHJlYWR5OiBudWxsXG4gICAgfTtcbiAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICBzdHJlYW1TaW5rLnJlYWR5ID0gc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdID0gc3RyZWFtU2luaztcbiAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZShhY3Rpb24oZGF0YS5kYXRhLCBzdHJlYW1TaW5rKSk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEUsXG4gICAgICAgIHN0cmVhbUlkLFxuICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEUsXG4gICAgICAgIHN0cmVhbUlkLFxuICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgI3Byb2Nlc3NTdHJlYW1NZXNzYWdlKGRhdGEpIHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IGRhdGEuc3RyZWFtSWQsXG4gICAgICBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZSxcbiAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXSxcbiAgICAgIHN0cmVhbVNpbmsgPSB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICBzd2l0Y2ggKGRhdGEuc3RyZWFtKSB7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnN0YXJ0Q2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFOlxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5wdWxsQ2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5wdWxsQ2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLlBVTEw6XG4gICAgICAgIGlmICghc3RyZWFtU2luaykge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbVNpbmsuZGVzaXJlZFNpemUgPD0gMCAmJiBkYXRhLmRlc2lyZWRTaXplID4gMCkge1xuICAgICAgICAgIHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbVNpbmsuZGVzaXJlZFNpemUgPSBkYXRhLmRlc2lyZWRTaXplO1xuICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoc3RyZWFtU2luay5vblB1bGw/LigpKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuRU5RVUVVRTpcbiAgICAgICAgKDAsIF91dGlsLmFzc2VydCkoc3RyZWFtQ29udHJvbGxlciwgXCJlbnF1ZXVlIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBpZiAoc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY29udHJvbGxlci5lbnF1ZXVlKGRhdGEuY2h1bmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DTE9TRTpcbiAgICAgICAgKDAsIF91dGlsLmFzc2VydCkoc3RyZWFtQ29udHJvbGxlciwgXCJjbG9zZSBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgaWYgKHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5FUlJPUjpcbiAgICAgICAgKDAsIF91dGlsLmFzc2VydCkoc3RyZWFtQ29udHJvbGxlciwgXCJlcnJvciBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jb250cm9sbGVyLmVycm9yKHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTDpcbiAgICAgICAgaWYgKCFzdHJlYW1TaW5rKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKHN0cmVhbVNpbmsub25DYW5jZWw/Lih3cmFwUmVhc29uKGRhdGEucmVhc29uKSkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICBzdHJlYW1TaW5rLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgc3RyZWFtIGNhc2VcIik7XG4gICAgfVxuICB9XG4gIGFzeW5jICNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFtzdHJlYW1Db250cm9sbGVyLnN0YXJ0Q2FsbD8ucHJvbWlzZSwgc3RyZWFtQ29udHJvbGxlci5wdWxsQ2FsbD8ucHJvbWlzZSwgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsPy5wcm9taXNlXSk7XG4gICAgZGVsZXRlIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jb21PYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25Db21PYmpPbk1lc3NhZ2UpO1xuICB9XG59XG5leHBvcnRzLk1lc3NhZ2VIYW5kbGVyID0gTWVzc2FnZUhhbmRsZXI7XG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuTWV0YWRhdGEgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuY2xhc3MgTWV0YWRhdGEge1xuICAjbWV0YWRhdGFNYXA7XG4gICNkYXRhO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGFyc2VkRGF0YSxcbiAgICByYXdEYXRhXG4gIH0pIHtcbiAgICB0aGlzLiNtZXRhZGF0YU1hcCA9IHBhcnNlZERhdGE7XG4gICAgdGhpcy4jZGF0YSA9IHJhd0RhdGE7XG4gIH1cbiAgZ2V0UmF3KCkge1xuICAgIHJldHVybiB0aGlzLiNkYXRhO1xuICB9XG4gIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuI21ldGFkYXRhTWFwLmdldChuYW1lKSA/PyBudWxsO1xuICB9XG4gIGdldEFsbCgpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLm9iamVjdEZyb21NYXApKHRoaXMuI21ldGFkYXRhTWFwKTtcbiAgfVxuICBoYXMobmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNtZXRhZGF0YU1hcC5oYXMobmFtZSk7XG4gIH1cbn1cbmV4cG9ydHMuTWV0YWRhdGEgPSBNZXRhZGF0YTtcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5PcHRpb25hbENvbnRlbnRDb25maWcgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9tdXJtdXJoYXNoID0gX193X3BkZmpzX3JlcXVpcmVfXyg4KTtcbmNvbnN0IElOVEVSTkFMID0gU3ltYm9sKFwiSU5URVJOQUxcIik7XG5jbGFzcyBPcHRpb25hbENvbnRlbnRHcm91cCB7XG4gICN2aXNpYmxlID0gdHJ1ZTtcbiAgY29uc3RydWN0b3IobmFtZSwgaW50ZW50KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmludGVudCA9IGludGVudDtcbiAgfVxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jdmlzaWJsZTtcbiAgfVxuICBfc2V0VmlzaWJsZShpbnRlcm5hbCwgdmlzaWJsZSkge1xuICAgIGlmIChpbnRlcm5hbCAhPT0gSU5URVJOQUwpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJJbnRlcm5hbCBtZXRob2QgYF9zZXRWaXNpYmxlYCBjYWxsZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLiN2aXNpYmxlID0gdmlzaWJsZTtcbiAgfVxufVxuY2xhc3MgT3B0aW9uYWxDb250ZW50Q29uZmlnIHtcbiAgI2NhY2hlZEdldEhhc2ggPSBudWxsO1xuICAjZ3JvdXBzID0gbmV3IE1hcCgpO1xuICAjaW5pdGlhbEhhc2ggPSBudWxsO1xuICAjb3JkZXIgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICB0aGlzLmNyZWF0b3IgPSBudWxsO1xuICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcbiAgICB0aGlzLmNyZWF0b3IgPSBkYXRhLmNyZWF0b3I7XG4gICAgdGhpcy4jb3JkZXIgPSBkYXRhLm9yZGVyO1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgZGF0YS5ncm91cHMpIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5zZXQoZ3JvdXAuaWQsIG5ldyBPcHRpb25hbENvbnRlbnRHcm91cChncm91cC5uYW1lLCBncm91cC5pbnRlbnQpKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuYmFzZVN0YXRlID09PSBcIk9GRlwiKSB7XG4gICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHRoaXMuI2dyb3Vwcy52YWx1ZXMoKSkge1xuICAgICAgICBncm91cC5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9uIG9mIGRhdGEub24pIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5nZXQob24pLl9zZXRWaXNpYmxlKElOVEVSTkFMLCB0cnVlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBvZmYgb2YgZGF0YS5vZmYpIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5nZXQob2ZmKS5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLiNpbml0aWFsSGFzaCA9IHRoaXMuZ2V0SGFzaCgpO1xuICB9XG4gICNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGFycmF5KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgb3BlcmF0b3IgPSBhcnJheVswXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaV07XG4gICAgICBsZXQgc3RhdGU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgICAgICBzdGF0ZSA9IHRoaXMuI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI2dyb3Vwcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgc3RhdGUgPSB0aGlzLiNncm91cHMuZ2V0KGVsZW1lbnQpLnZpc2libGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2VsZW1lbnR9YCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlIFwiQW5kXCI6XG4gICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk9yXCI6XG4gICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJOb3RcIjpcbiAgICAgICAgICByZXR1cm4gIXN0YXRlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiQW5kXCI7XG4gIH1cbiAgaXNWaXNpYmxlKGdyb3VwKSB7XG4gICAgaWYgKHRoaXMuI2dyb3Vwcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwiT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZGVmaW5lZC5cIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLnR5cGUgPT09IFwiT0NHXCIpIHtcbiAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhncm91cC5pZCkpIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtncm91cC5pZH1gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jZ3JvdXBzLmdldChncm91cC5pZCkudmlzaWJsZTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiT0NNRFwiKSB7XG4gICAgICBpZiAoZ3JvdXAuZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy4jZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbihncm91cC5leHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICAgIGlmICghZ3JvdXAucG9saWN5IHx8IGdyb3VwLnBvbGljeSA9PT0gXCJBbnlPblwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFsbE9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAoMCwgX3V0aWwud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFueU9mZlwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPZmZcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAoMCwgX3V0aWwud2FybikoYFVua25vd24gb3B0aW9uYWwgY29udGVudCBwb2xpY3kgJHtncm91cC5wb2xpY3l9LmApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgICgwLCBfdXRpbC53YXJuKShgVW5rbm93biBncm91cCB0eXBlICR7Z3JvdXAudHlwZX0uYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2V0VmlzaWJpbGl0eShpZCwgdmlzaWJsZSA9IHRydWUpIHtcbiAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNncm91cHMuZ2V0KGlkKS5fc2V0VmlzaWJsZShJTlRFUk5BTCwgISF2aXNpYmxlKTtcbiAgICB0aGlzLiNjYWNoZWRHZXRIYXNoID0gbnVsbDtcbiAgfVxuICBnZXQgaGFzSW5pdGlhbFZpc2liaWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2luaXRpYWxIYXNoID09PSBudWxsIHx8IHRoaXMuZ2V0SGFzaCgpID09PSB0aGlzLiNpbml0aWFsSGFzaDtcbiAgfVxuICBnZXRPcmRlcigpIHtcbiAgICBpZiAoIXRoaXMuI2dyb3Vwcy5zaXplKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuI29yZGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy4jb3JkZXIuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIFsuLi50aGlzLiNncm91cHMua2V5cygpXTtcbiAgfVxuICBnZXRHcm91cHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dyb3Vwcy5zaXplID4gMCA/ICgwLCBfdXRpbC5vYmplY3RGcm9tTWFwKSh0aGlzLiNncm91cHMpIDogbnVsbDtcbiAgfVxuICBnZXRHcm91cChpZCkge1xuICAgIHJldHVybiB0aGlzLiNncm91cHMuZ2V0KGlkKSB8fCBudWxsO1xuICB9XG4gIGdldEhhc2goKSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZEdldEhhc2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLiNjYWNoZWRHZXRIYXNoO1xuICAgIH1cbiAgICBjb25zdCBoYXNoID0gbmV3IF9tdXJtdXJoYXNoLk11cm11ckhhc2gzXzY0KCk7XG4gICAgZm9yIChjb25zdCBbaWQsIGdyb3VwXSBvZiB0aGlzLiNncm91cHMpIHtcbiAgICAgIGhhc2gudXBkYXRlKGAke2lkfToke2dyb3VwLnZpc2libGV9YCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNjYWNoZWRHZXRIYXNoID0gaGFzaC5oZXhkaWdlc3QoKTtcbiAgfVxufVxuZXhwb3J0cy5PcHRpb25hbENvbnRlbnRDb25maWcgPSBPcHRpb25hbENvbnRlbnRDb25maWc7XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuUERGRGF0YVRyYW5zcG9ydFN0cmVhbSA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBsZW5ndGgsXG4gICAgaW5pdGlhbERhdGEsXG4gICAgcHJvZ3Jlc3NpdmVEb25lID0gZmFsc2UsXG4gICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBudWxsLFxuICAgIGRpc2FibGVSYW5nZSA9IGZhbHNlLFxuICAgIGRpc2FibGVTdHJlYW0gPSBmYWxzZVxuICB9LCBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQpIHtcbiAgICAoMCwgX3V0aWwuYXNzZXJ0KShwZGZEYXRhUmFuZ2VUcmFuc3BvcnQsICdQREZEYXRhVHJhbnNwb3J0U3RyZWFtIC0gbWlzc2luZyByZXF1aXJlZCBcInBkZkRhdGFSYW5nZVRyYW5zcG9ydFwiIGFyZ3VtZW50LicpO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSA9IHByb2dyZXNzaXZlRG9uZTtcbiAgICB0aGlzLl9jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lO1xuICAgIGlmIChpbml0aWFsRGF0YT8ubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYnVmZmVyID0gaW5pdGlhbERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGluaXRpYWxEYXRhLmJ5dGVMZW5ndGggPT09IGluaXRpYWxEYXRhLmJ1ZmZlci5ieXRlTGVuZ3RoID8gaW5pdGlhbERhdGEuYnVmZmVyIDogbmV3IFVpbnQ4QXJyYXkoaW5pdGlhbERhdGEpLmJ1ZmZlcjtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGJ1ZmZlcik7XG4gICAgfVxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydCA9IHBkZkRhdGFSYW5nZVRyYW5zcG9ydDtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFkaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhZGlzYWJsZVJhbmdlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVhZGVycyA9IFtdO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRSYW5nZUxpc3RlbmVyKChiZWdpbiwgY2h1bmspID0+IHtcbiAgICAgIHRoaXMuX29uUmVjZWl2ZURhdGEoe1xuICAgICAgICBiZWdpbixcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc0xpc3RlbmVyKChsb2FkZWQsIHRvdGFsKSA9PiB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzKHtcbiAgICAgICAgbG9hZGVkLFxuICAgICAgICB0b3RhbFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyKGNodW5rID0+IHtcbiAgICAgIHRoaXMuX29uUmVjZWl2ZURhdGEoe1xuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIHRoaXMuX29uUHJvZ3Jlc3NpdmVEb25lKCk7XG4gICAgfSk7XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LnRyYW5zcG9ydFJlYWR5KCk7XG4gIH1cbiAgX29uUmVjZWl2ZURhdGEoe1xuICAgIGJlZ2luLFxuICAgIGNodW5rXG4gIH0pIHtcbiAgICBjb25zdCBidWZmZXIgPSBjaHVuayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgY2h1bmsuYnl0ZUxlbmd0aCA9PT0gY2h1bmsuYnVmZmVyLmJ5dGVMZW5ndGggPyBjaHVuay5idWZmZXIgOiBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgIGlmIChiZWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIpIHtcbiAgICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIuX2VucXVldWUoYnVmZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZvdW5kID0gdGhpcy5fcmFuZ2VSZWFkZXJzLnNvbWUoZnVuY3Rpb24gKHJhbmdlUmVhZGVyKSB7XG4gICAgICAgIGlmIChyYW5nZVJlYWRlci5fYmVnaW4gIT09IGJlZ2luKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlUmVhZGVyLl9lbnF1ZXVlKGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgICAoMCwgX3V0aWwuYXNzZXJ0KShmb3VuZCwgXCJfb25SZWNlaXZlRGF0YSAtIG5vIGBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXJgIGluc3RhbmNlIGZvdW5kLlwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgaWYgKGV2dC50b3RhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlYWRlcnNbMF0/Lm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfb25Qcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LnByb2dyZXNzaXZlRG9uZSgpO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSA9IHRydWU7XG4gIH1cbiAgX3JlbW92ZVJhbmdlUmVhZGVyKHJlYWRlcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9yYW5nZVJlYWRlcnMuaW5kZXhPZihyZWFkZXIpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVhZGVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkRhdGFUcmFuc3BvcnRTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgY29uc3QgcXVldWVkQ2h1bmtzID0gdGhpcy5fcXVldWVkQ2h1bmtzO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IG51bGw7XG4gICAgcmV0dXJuIG5ldyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyKHRoaXMsIHF1ZXVlZENodW5rcywgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lLCB0aGlzLl9jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSk7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZShiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWJvcnQoKTtcbiAgfVxufVxuZXhwb3J0cy5QREZEYXRhVHJhbnNwb3J0U3RyZWFtID0gUERGRGF0YVRyYW5zcG9ydFN0cmVhbTtcbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHF1ZXVlZENodW5rcywgcHJvZ3Jlc3NpdmVEb25lID0gZmFsc2UsIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gbnVsbCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9kb25lID0gcHJvZ3Jlc3NpdmVEb25lIHx8IGZhbHNlO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gKDAsIF9kaXNwbGF5X3V0aWxzLmlzUGRmRmlsZSkoY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUpID8gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgOiBudWxsO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IHF1ZXVlZENodW5rcyB8fCBbXTtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgdGhpcy5fcXVldWVkQ2h1bmtzKSB7XG4gICAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9oZWFkZXJzUmVhZHkgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBzdHJlYW0uX2Z1bGxSZXF1ZXN0UmVhZGVyID0gdGhpcztcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9lbnF1ZXVlKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzLnB1c2goY2h1bmspO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzUmVhZHk7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rcy5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICBwcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gIH1cbn1cbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9iZWdpbiA9IGJlZ2luO1xuICAgIHRoaXMuX2VuZCA9IGVuZDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBfZW5xdWV1ZShjaHVuaykge1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gY2h1bms7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RzQ2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICByZXF1ZXN0c0NhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICB0aGlzLl9zdHJlYW0uX3JlbW92ZVJhbmdlUmVhZGVyKHRoaXMpO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmspIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3N0cmVhbS5fcmVtb3ZlUmFuZ2VSZWFkZXIodGhpcyk7XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5QREZGZXRjaFN0cmVhbSA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX25ldHdvcmtfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIwKTtcbjtcbmZ1bmN0aW9uIGNyZWF0ZUZldGNoT3B0aW9ucyhoZWFkZXJzLCB3aXRoQ3JlZGVudGlhbHMsIGFib3J0Q29udHJvbGxlcikge1xuICByZXR1cm4ge1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBoZWFkZXJzLFxuICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICBjcmVkZW50aWFsczogd2l0aENyZWRlbnRpYWxzID8gXCJpbmNsdWRlXCIgOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgcmVkaXJlY3Q6IFwiZm9sbG93XCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcnMoaHR0cEhlYWRlcnMpIHtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGZvciAoY29uc3QgcHJvcGVydHkgaW4gaHR0cEhlYWRlcnMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGh0dHBIZWFkZXJzW3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGhlYWRlcnMuYXBwZW5kKHByb3BlcnR5LCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5mdW5jdGlvbiBnZXRBcnJheUJ1ZmZlcih2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gdmFsLmJ1ZmZlcjtcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gICgwLCBfdXRpbC53YXJuKShgZ2V0QXJyYXlCdWZmZXIgLSB1bmV4cGVjdGVkIGRhdGEgZm9ybWF0OiAke3ZhbH1gKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbCkuYnVmZmVyO1xufVxuY2xhc3MgUERGRmV0Y2hTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmlzSHR0cCA9IC9eaHR0cHM/Oi9pLnRlc3Qoc291cmNlLnVybCk7XG4gICAgdGhpcy5odHRwSGVhZGVycyA9IHRoaXMuaXNIdHRwICYmIHNvdXJjZS5odHRwSGVhZGVycyB8fCB7fTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG4gIGdldCBfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uX2xvYWRlZCA/PyAwO1xuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkZldGNoU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbmV3IFBERkZldGNoU3RyZWFtUmVhZGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLlBERkZldGNoU3RyZWFtID0gUERGRmV0Y2hTdHJlYW07XG5jbGFzcyBQREZGZXRjaFN0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gc291cmNlLndpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVJhbmdlO1xuICAgIHRoaXMuX2hlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuX3N0cmVhbS5odHRwSGVhZGVycyk7XG4gICAgY29uc3QgdXJsID0gc291cmNlLnVybDtcbiAgICBmZXRjaCh1cmwsIGNyZWF0ZUZldGNoT3B0aW9ucyh0aGlzLl9oZWFkZXJzLCB0aGlzLl93aXRoQ3JlZGVudGlhbHMsIHRoaXMuX2Fib3J0Q29udHJvbGxlcikpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKCEoMCwgX25ldHdvcmtfdXRpbHMudmFsaWRhdGVSZXNwb25zZVN0YXR1cykocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyAoMCwgX25ldHdvcmtfdXRpbHMuY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcikocmVzcG9uc2Uuc3RhdHVzLCB1cmwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIGNvbnN0IGdldFJlc3BvbnNlSGVhZGVyID0gbmFtZSA9PiB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5oZWFkZXJzLmdldChuYW1lKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyxcbiAgICAgICAgc3VnZ2VzdGVkTGVuZ3RoXG4gICAgICB9ID0gKDAsIF9uZXR3b3JrX3V0aWxzLnZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKSh7XG4gICAgICAgIGdldFJlc3BvbnNlSGVhZGVyLFxuICAgICAgICBpc0h0dHA6IHRoaXMuX3N0cmVhbS5pc0h0dHAsXG4gICAgICAgIHJhbmdlQ2h1bmtTaXplOiB0aGlzLl9yYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgZGlzYWJsZVJhbmdlOiB0aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGFsbG93UmFuZ2VSZXF1ZXN0cztcbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdWdnZXN0ZWRMZW5ndGggfHwgdGhpcy5fY29udGVudExlbmd0aDtcbiAgICAgIHRoaXMuX2ZpbGVuYW1lID0gKDAsIF9uZXR3b3JrX3V0aWxzLmV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIpKGdldFJlc3BvbnNlSGVhZGVyKTtcbiAgICAgIGlmICghdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgJiYgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgICB0aGlzLmNhbmNlbChuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24oXCJTdHJlYW1pbmcgaXMgZGlzYWJsZWQuXCIpKTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaCh0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZG9uZVxuICAgIH0gPSBhd2FpdCB0aGlzLl9yZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWQsXG4gICAgICB0b3RhbDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZ2V0QXJyYXlCdWZmZXIodmFsdWUpLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9yZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IHNvdXJjZS53aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5faGVhZGVycyA9IGNyZWF0ZUhlYWRlcnModGhpcy5fc3RyZWFtLmh0dHBIZWFkZXJzKTtcbiAgICB0aGlzLl9oZWFkZXJzLmFwcGVuZChcIlJhbmdlXCIsIGBieXRlcz0ke2JlZ2lufS0ke2VuZCAtIDF9YCk7XG4gICAgY29uc3QgdXJsID0gc291cmNlLnVybDtcbiAgICBmZXRjaCh1cmwsIGNyZWF0ZUZldGNoT3B0aW9ucyh0aGlzLl9oZWFkZXJzLCB0aGlzLl93aXRoQ3JlZGVudGlhbHMsIHRoaXMuX2Fib3J0Q29udHJvbGxlcikpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKCEoMCwgX25ldHdvcmtfdXRpbHMudmFsaWRhdGVSZXNwb25zZVN0YXR1cykocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyAoMCwgX25ldHdvcmtfdXRpbHMuY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcikocmVzcG9uc2Uuc3RhdHVzLCB1cmwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5fcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICB9KS5jYXRjaCh0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBkb25lXG4gICAgfSA9IGF3YWl0IHRoaXMuX3JlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZ2V0QXJyYXlCdWZmZXIodmFsdWUpLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9yZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvciA9IGNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3I7XG5leHBvcnRzLmV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIgPSBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyO1xuZXhwb3J0cy52YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyA9IHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzO1xuZXhwb3J0cy52YWxpZGF0ZVJlc3BvbnNlU3RhdHVzID0gdmFsaWRhdGVSZXNwb25zZVN0YXR1cztcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2NvbnRlbnRfZGlzcG9zaXRpb24gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG5mdW5jdGlvbiB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyh7XG4gIGdldFJlc3BvbnNlSGVhZGVyLFxuICBpc0h0dHAsXG4gIHJhbmdlQ2h1bmtTaXplLFxuICBkaXNhYmxlUmFuZ2Vcbn0pIHtcbiAgY29uc3QgcmV0dXJuVmFsdWVzID0ge1xuICAgIGFsbG93UmFuZ2VSZXF1ZXN0czogZmFsc2UsXG4gICAgc3VnZ2VzdGVkTGVuZ3RoOiB1bmRlZmluZWRcbiAgfTtcbiAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LUxlbmd0aFwiKSwgMTApO1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIobGVuZ3RoKSkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgcmV0dXJuVmFsdWVzLnN1Z2dlc3RlZExlbmd0aCA9IGxlbmd0aDtcbiAgaWYgKGxlbmd0aCA8PSAyICogcmFuZ2VDaHVua1NpemUpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGlmIChkaXNhYmxlUmFuZ2UgfHwgIWlzSHR0cCkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgaWYgKGdldFJlc3BvbnNlSGVhZGVyKFwiQWNjZXB0LVJhbmdlc1wiKSAhPT0gXCJieXRlc1wiKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICBjb25zdCBjb250ZW50RW5jb2RpbmcgPSBnZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtRW5jb2RpbmdcIikgfHwgXCJpZGVudGl0eVwiO1xuICBpZiAoY29udGVudEVuY29kaW5nICE9PSBcImlkZW50aXR5XCIpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIHJldHVyblZhbHVlcy5hbGxvd1JhbmdlUmVxdWVzdHMgPSB0cnVlO1xuICByZXR1cm4gcmV0dXJuVmFsdWVzO1xufVxuZnVuY3Rpb24gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihnZXRSZXNwb25zZUhlYWRlcikge1xuICBjb25zdCBjb250ZW50RGlzcG9zaXRpb24gPSBnZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtRGlzcG9zaXRpb25cIik7XG4gIGlmIChjb250ZW50RGlzcG9zaXRpb24pIHtcbiAgICBsZXQgZmlsZW5hbWUgPSAoMCwgX2NvbnRlbnRfZGlzcG9zaXRpb24uZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKShjb250ZW50RGlzcG9zaXRpb24pO1xuICAgIGlmIChmaWxlbmFtZS5pbmNsdWRlcyhcIiVcIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbGVuYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KGZpbGVuYW1lKTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gICAgaWYgKCgwLCBfZGlzcGxheV91dGlscy5pc1BkZkZpbGUpKGZpbGVuYW1lKSkge1xuICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3Ioc3RhdHVzLCB1cmwpIHtcbiAgaWYgKHN0YXR1cyA9PT0gNDA0IHx8IHN0YXR1cyA9PT0gMCAmJiB1cmwuc3RhcnRzV2l0aChcImZpbGU6XCIpKSB7XG4gICAgcmV0dXJuIG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKCdNaXNzaW5nIFBERiBcIicgKyB1cmwgKyAnXCIuJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBfdXRpbC5VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24oYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlICgke3N0YXR1c30pIHdoaWxlIHJldHJpZXZpbmcgUERGIFwiJHt1cmx9XCIuYCwgc3RhdHVzKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmVzcG9uc2VTdGF0dXMoc3RhdHVzKSB7XG4gIHJldHVybiBzdGF0dXMgPT09IDIwMCB8fCBzdGF0dXMgPT09IDIwNjtcbn1cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5nZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIgPSBnZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXI7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKGNvbnRlbnREaXNwb3NpdGlvbikge1xuICBsZXQgbmVlZHNFbmNvZGluZ0ZpeHVwID0gdHJ1ZTtcbiAgbGV0IHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVxcXFwqXCIsIFwiaVwiKS5leGVjKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICB0bXAgPSB0bXBbMV07XG4gICAgbGV0IGZpbGVuYW1lID0gcmZjMjYxNnVucXVvdGUodG1wKTtcbiAgICBmaWxlbmFtZSA9IHVuZXNjYXBlKGZpbGVuYW1lKTtcbiAgICBmaWxlbmFtZSA9IHJmYzU5ODdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZShmaWxlbmFtZSk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIHRtcCA9IHJmYzIyMzFnZXRwYXJhbShjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgY29uc3QgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKHRtcCk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVwiLCBcImlcIikuZXhlYyhjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgdG1wID0gdG1wWzFdO1xuICAgIGxldCBmaWxlbmFtZSA9IHJmYzI2MTZ1bnF1b3RlKHRtcCk7XG4gICAgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9QYXJhbVJlZ0V4cChhdHRyaWJ1dGVQYXR0ZXJuLCBmbGFncykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86Xnw7KVxcXFxzKlwiICsgYXR0cmlidXRlUGF0dGVybiArIFwiXFxcXHMqPVxcXFxzKlwiICsgXCIoXCIgKyAnW15cIjtcXFxcc11bXjtcXFxcc10qJyArIFwifFwiICsgJ1wiKD86W15cIlxcXFxcXFxcXXxcXFxcXFxcXFwiPykrXCI/JyArIFwiKVwiLCBmbGFncyk7XG4gIH1cbiAgZnVuY3Rpb24gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpIHtcbiAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgIGlmICghL15bXFx4MDAtXFx4RkZdKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcsIHtcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gKDAsIF91dGlsLnN0cmluZ1RvQnl0ZXMpKHZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShidWZmZXIpO1xuICAgICAgICBuZWVkc0VuY29kaW5nRml4dXAgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGZpeHVwRW5jb2RpbmcodmFsdWUpIHtcbiAgICBpZiAobmVlZHNFbmNvZGluZ0ZpeHVwICYmIC9bXFx4ODAtXFx4ZmZdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB0ZXh0ZGVjb2RlKFwidXRmLThcIiwgdmFsdWUpO1xuICAgICAgaWYgKG5lZWRzRW5jb2RpbmdGaXh1cCkge1xuICAgICAgICB2YWx1ZSA9IHRleHRkZWNvZGUoXCJpc28tODg1OS0xXCIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzIyMzFnZXRwYXJhbShjb250ZW50RGlzcG9zaXRpb25TdHIpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgbGV0IG1hdGNoO1xuICAgIGNvbnN0IGl0ZXIgPSB0b1BhcmFtUmVnRXhwKFwiZmlsZW5hbWVcXFxcKigoPyEwXFxcXGQpXFxcXGQrKShcXFxcKj8pXCIsIFwiaWdcIik7XG4gICAgd2hpbGUgKChtYXRjaCA9IGl0ZXIuZXhlYyhjb250ZW50RGlzcG9zaXRpb25TdHIpKSAhPT0gbnVsbCkge1xuICAgICAgbGV0IFssIG4sIHF1b3QsIHBhcnRdID0gbWF0Y2g7XG4gICAgICBuID0gcGFyc2VJbnQobiwgMTApO1xuICAgICAgaWYgKG4gaW4gbWF0Y2hlcykge1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbWF0Y2hlc1tuXSA9IFtxdW90LCBwYXJ0XTtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IG1hdGNoZXMubGVuZ3RoOyArK24pIHtcbiAgICAgIGlmICghKG4gaW4gbWF0Y2hlcykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsZXQgW3F1b3QsIHBhcnRdID0gbWF0Y2hlc1tuXTtcbiAgICAgIHBhcnQgPSByZmMyNjE2dW5xdW90ZShwYXJ0KTtcbiAgICAgIGlmIChxdW90KSB7XG4gICAgICAgIHBhcnQgPSB1bmVzY2FwZShwYXJ0KTtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBwYXJ0ID0gcmZjNTk4N2RlY29kZShwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gcmZjMjYxNnVucXVvdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnXCInKSkge1xuICAgICAgY29uc3QgcGFydHMgPSB2YWx1ZS5zbGljZSgxKS5zcGxpdCgnXFxcXFwiJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHF1b3RpbmRleCA9IHBhcnRzW2ldLmluZGV4T2YoJ1wiJyk7XG4gICAgICAgIGlmIChxdW90aW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgcGFydHNbaV0gPSBwYXJ0c1tpXS5zbGljZSgwLCBxdW90aW5kZXgpO1xuICAgICAgICAgIHBhcnRzLmxlbmd0aCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0ucmVwbGFjZUFsbCgvXFxcXCguKS9nLCBcIiQxXCIpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBwYXJ0cy5qb2luKCdcIicpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcmZjNTk4N2RlY29kZShleHR2YWx1ZSkge1xuICAgIGNvbnN0IGVuY29kaW5nZW5kID0gZXh0dmFsdWUuaW5kZXhPZihcIidcIik7XG4gICAgaWYgKGVuY29kaW5nZW5kID09PSAtMSkge1xuICAgICAgcmV0dXJuIGV4dHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGluZyA9IGV4dHZhbHVlLnNsaWNlKDAsIGVuY29kaW5nZW5kKTtcbiAgICBjb25zdCBsYW5ndmFsdWUgPSBleHR2YWx1ZS5zbGljZShlbmNvZGluZ2VuZCArIDEpO1xuICAgIGNvbnN0IHZhbHVlID0gbGFuZ3ZhbHVlLnJlcGxhY2UoL15bXiddKicvLCBcIlwiKTtcbiAgICByZXR1cm4gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzIwNDdkZWNvZGUodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlLnN0YXJ0c1dpdGgoXCI9P1wiKSB8fCAvW1xceDAwLVxceDE5XFx4ODAtXFx4ZmZdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZUFsbCgvPVxcPyhbXFx3LV0qKVxcPyhbUXFCYl0pXFw/KCg/OlteP118XFw/KD8hPSkpKilcXD89L2csIGZ1bmN0aW9uIChtYXRjaGVzLCBjaGFyc2V0LCBlbmNvZGluZywgdGV4dCkge1xuICAgICAgaWYgKGVuY29kaW5nID09PSBcInFcIiB8fCBlbmNvZGluZyA9PT0gXCJRXCIpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbChcIl9cIiwgXCIgXCIpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlQWxsKC89KFswLTlhLWZBLUZdezJ9KS9nLCBmdW5jdGlvbiAobWF0Y2gsIGhleCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleCwgMTYpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0ZXh0ZGVjb2RlKGNoYXJzZXQsIHRleHQpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGV4dCA9IGF0b2IodGV4dCk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgICByZXR1cm4gdGV4dGRlY29kZShjaGFyc2V0LCB0ZXh0KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5QREZOZXR3b3JrU3RyZWFtID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfbmV0d29ya191dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjApO1xuO1xuY29uc3QgT0tfUkVTUE9OU0UgPSAyMDA7XG5jb25zdCBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UgPSAyMDY7XG5mdW5jdGlvbiBnZXRBcnJheUJ1ZmZlcih4aHIpIHtcbiAgY29uc3QgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcmV0dXJuICgwLCBfdXRpbC5zdHJpbmdUb0J5dGVzKShkYXRhKS5idWZmZXI7XG59XG5jbGFzcyBOZXR3b3JrTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKHVybCwgYXJncyA9IHt9KSB7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5pc0h0dHAgPSAvXmh0dHBzPzovaS50ZXN0KHVybCk7XG4gICAgdGhpcy5odHRwSGVhZGVycyA9IHRoaXMuaXNIdHRwICYmIGFyZ3MuaHR0cEhlYWRlcnMgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGFyZ3Mud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuY3VyclhocklkID0gMDtcbiAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgcmVxdWVzdFJhbmdlKGJlZ2luLCBlbmQsIGxpc3RlbmVycykge1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBiZWdpbixcbiAgICAgIGVuZFxuICAgIH07XG4gICAgZm9yIChjb25zdCBwcm9wIGluIGxpc3RlbmVycykge1xuICAgICAgYXJnc1twcm9wXSA9IGxpc3RlbmVyc1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChhcmdzKTtcbiAgfVxuICByZXF1ZXN0RnVsbChsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGxpc3RlbmVycyk7XG4gIH1cbiAgcmVxdWVzdChhcmdzKSB7XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgY29uc3QgeGhySWQgPSB0aGlzLmN1cnJYaHJJZCsrO1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdID0ge1xuICAgICAgeGhyXG4gICAgfTtcbiAgICB4aHIub3BlbihcIkdFVFwiLCB0aGlzLnVybCk7XG4gICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gdGhpcy5odHRwSGVhZGVycykge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmh0dHBIZWFkZXJzW3Byb3BlcnR5XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIocHJvcGVydHksIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNIdHRwICYmIFwiYmVnaW5cIiBpbiBhcmdzICYmIFwiZW5kXCIgaW4gYXJncykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJSYW5nZVwiLCBgYnl0ZXM9JHthcmdzLmJlZ2lufS0ke2FyZ3MuZW5kIC0gMX1gKTtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9IE9LX1JFU1BPTlNFO1xuICAgIH1cbiAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgIGlmIChhcmdzLm9uRXJyb3IpIHtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBhcmdzLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICB9O1xuICAgIH1cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5vblByb2dyZXNzLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkID0gYXJncy5vbkhlYWRlcnNSZWNlaXZlZDtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUgPSBhcmdzLm9uRG9uZTtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yID0gYXJncy5vbkVycm9yO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3MgPSBhcmdzLm9uUHJvZ3Jlc3M7XG4gICAgeGhyLnNlbmQobnVsbCk7XG4gICAgcmV0dXJuIHhocklkO1xuICB9XG4gIG9uUHJvZ3Jlc3MoeGhySWQsIGV2dCkge1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVuZGluZ1JlcXVlc3Qub25Qcm9ncmVzcz8uKGV2dCk7XG4gIH1cbiAgb25TdGF0ZUNoYW5nZSh4aHJJZCwgZXZ0KSB7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgaWYgKCFwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4aHIgPSBwZW5kaW5nUmVxdWVzdC54aHI7XG4gICAgaWYgKHhoci5yZWFkeVN0YXRlID49IDIgJiYgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQpIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkKCk7XG4gICAgICBkZWxldGUgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgfVxuICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMCAmJiB0aGlzLmlzSHR0cCkge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcj8uKHhoci5zdGF0dXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4aHJTdGF0dXMgPSB4aHIuc3RhdHVzIHx8IE9LX1JFU1BPTlNFO1xuICAgIGNvbnN0IG9rX3Jlc3BvbnNlX29uX3JhbmdlX3JlcXVlc3QgPSB4aHJTdGF0dXMgPT09IE9LX1JFU1BPTlNFICYmIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID09PSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0U7XG4gICAgaWYgKCFva19yZXNwb25zZV9vbl9yYW5nZV9yZXF1ZXN0ICYmIHhoclN0YXR1cyAhPT0gcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMpIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3I/Lih4aHIuc3RhdHVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSBnZXRBcnJheUJ1ZmZlcih4aHIpO1xuICAgIGlmICh4aHJTdGF0dXMgPT09IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRSkge1xuICAgICAgY29uc3QgcmFuZ2VIZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVJhbmdlXCIpO1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IC9ieXRlcyAoXFxkKyktKFxcZCspXFwvKFxcZCspLy5leGVjKHJhbmdlSGVhZGVyKTtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSh7XG4gICAgICAgIGJlZ2luOiBwYXJzZUludChtYXRjaGVzWzFdLCAxMCksXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNodW5rKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUoe1xuICAgICAgICBiZWdpbjogMCxcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yPy4oeGhyLnN0YXR1cyk7XG4gICAgfVxuICB9XG4gIGdldFJlcXVlc3RYaHIoeGhySWQpIHtcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdLnhocjtcbiAgfVxuICBpc1BlbmRpbmdSZXF1ZXN0KHhocklkKSB7XG4gICAgcmV0dXJuIHhocklkIGluIHRoaXMucGVuZGluZ1JlcXVlc3RzO1xuICB9XG4gIGFib3J0UmVxdWVzdCh4aHJJZCkge1xuICAgIGNvbnN0IHhociA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXS54aHI7XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICB4aHIuYWJvcnQoKTtcbiAgfVxufVxuY2xhc3MgUERGTmV0d29ya1N0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbmV3IE5ldHdvcmtNYW5hZ2VyKHNvdXJjZS51cmwsIHtcbiAgICAgIGh0dHBIZWFkZXJzOiBzb3VyY2UuaHR0cEhlYWRlcnMsXG4gICAgICB3aXRoQ3JlZGVudGlhbHM6IHNvdXJjZS53aXRoQ3JlZGVudGlhbHNcbiAgICB9KTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG4gIF9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZChyZWFkZXIpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5pbmRleE9mKHJlYWRlcik7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyKHRoaXMuX21hbmFnZXIsIHRoaXMuX3NvdXJjZSk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlcih0aGlzLl9tYW5hZ2VyLCBiZWdpbiwgZW5kKTtcbiAgICByZWFkZXIub25DbG9zZWQgPSB0aGlzLl9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuUERGTmV0d29ya1N0cmVhbSA9IFBERk5ldHdvcmtTdHJlYW07XG5jbGFzcyBQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBzb3VyY2UpIHtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgb25IZWFkZXJzUmVjZWl2ZWQ6IHRoaXMuX29uSGVhZGVyc1JlY2VpdmVkLmJpbmQodGhpcyksXG4gICAgICBvbkRvbmU6IHRoaXMuX29uRG9uZS5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpLFxuICAgICAgb25Qcm9ncmVzczogdGhpcy5fb25Qcm9ncmVzcy5iaW5kKHRoaXMpXG4gICAgfTtcbiAgICB0aGlzLl91cmwgPSBzb3VyY2UudXJsO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0SWQgPSBtYW5hZ2VyLnJlcXVlc3RGdWxsKGFyZ3MpO1xuICAgIHRoaXMuX2hlYWRlcnNSZWNlaXZlZENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIGlmICghdGhpcy5fcmFuZ2VDaHVua1NpemUgJiYgIXRoaXMuX2Rpc2FibGVSYW5nZSkge1xuICAgICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fY2FjaGVkQ2h1bmtzID0gW107XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgX29uSGVhZGVyc1JlY2VpdmVkKCkge1xuICAgIGNvbnN0IGZ1bGxSZXF1ZXN0WGhySWQgPSB0aGlzLl9mdWxsUmVxdWVzdElkO1xuICAgIGNvbnN0IGZ1bGxSZXF1ZXN0WGhyID0gdGhpcy5fbWFuYWdlci5nZXRSZXF1ZXN0WGhyKGZ1bGxSZXF1ZXN0WGhySWQpO1xuICAgIGNvbnN0IGdldFJlc3BvbnNlSGVhZGVyID0gbmFtZSA9PiB7XG4gICAgICByZXR1cm4gZnVsbFJlcXVlc3RYaHIuZ2V0UmVzcG9uc2VIZWFkZXIobmFtZSk7XG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBhbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICBzdWdnZXN0ZWRMZW5ndGhcbiAgICB9ID0gKDAsIF9uZXR3b3JrX3V0aWxzLnZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKSh7XG4gICAgICBnZXRSZXNwb25zZUhlYWRlcixcbiAgICAgIGlzSHR0cDogdGhpcy5fbWFuYWdlci5pc0h0dHAsXG4gICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgIH0pO1xuICAgIGlmIChhbGxvd1JhbmdlUmVxdWVzdHMpIHtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSAoMCwgX25ldHdvcmtfdXRpbHMuZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcikoZ2V0UmVzcG9uc2VIZWFkZXIpO1xuICAgIGlmICh0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdChmdWxsUmVxdWVzdFhocklkKTtcbiAgICB9XG4gICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX29uRG9uZShkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IGRhdGEuY2h1bmssXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZWRDaHVua3MucHVzaChkYXRhLmNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgaWYgKHRoaXMuX2NhY2hlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICBfb25FcnJvcihzdGF0dXMpIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9ICgwLCBfbmV0d29ya191dGlscy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKShzdGF0dXMsIHRoaXMuX3VybCk7XG4gICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eS5yZWplY3QodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgdG90YWw6IGV2dC5sZW5ndGhDb21wdXRhYmxlID8gZXZ0LnRvdGFsIDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2FjaGVkQ2h1bmtzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgaWYgKHRoaXMuX21hbmFnZXIuaXNQZW5kaW5nUmVxdWVzdCh0aGlzLl9mdWxsUmVxdWVzdElkKSkge1xuICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QodGhpcy5fZnVsbFJlcXVlc3RJZCk7XG4gICAgfVxuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgb25Eb25lOiB0aGlzLl9vbkRvbmUuYmluZCh0aGlzKSxcbiAgICAgIG9uRXJyb3I6IHRoaXMuX29uRXJyb3IuYmluZCh0aGlzKSxcbiAgICAgIG9uUHJvZ3Jlc3M6IHRoaXMuX29uUHJvZ3Jlc3MuYmluZCh0aGlzKVxuICAgIH07XG4gICAgdGhpcy5fdXJsID0gbWFuYWdlci51cmw7XG4gICAgdGhpcy5fcmVxdWVzdElkID0gbWFuYWdlci5yZXF1ZXN0UmFuZ2UoYmVnaW4sIGVuZCwgYXJncyk7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5vbkNsb3NlZCA9IG51bGw7XG4gIH1cbiAgX2Nsb3NlKCkge1xuICAgIHRoaXMub25DbG9zZWQ/Lih0aGlzKTtcbiAgfVxuICBfb25Eb25lKGRhdGEpIHtcbiAgICBjb25zdCBjaHVuayA9IGRhdGEuY2h1bms7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBjaHVuaztcbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2Nsb3NlKCk7XG4gIH1cbiAgX29uRXJyb3Ioc3RhdHVzKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSAoMCwgX25ldHdvcmtfdXRpbHMuY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcikoc3RhdHVzLCB0aGlzLl91cmwpO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICB9XG4gIF9vblByb2dyZXNzKGV2dCkge1xuICAgIGlmICghdGhpcy5pc1N0cmVhbWluZ1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3F1ZXVlZENodW5rICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rO1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICBpZiAodGhpcy5fbWFuYWdlci5pc1BlbmRpbmdSZXF1ZXN0KHRoaXMuX3JlcXVlc3RJZCkpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KHRoaXMuX3JlcXVlc3RJZCk7XG4gICAgfVxuICAgIHRoaXMuX2Nsb3NlKCk7XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5QREZOb2RlU3RyZWFtID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfbmV0d29ya191dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjApO1xuO1xuY29uc3QgZmlsZVVyaVJlZ2V4ID0gL15maWxlOlxcL1xcL1xcL1thLXpBLVpdOlxcLy87XG5mdW5jdGlvbiBwYXJzZVVybChzb3VyY2VVcmwpIHtcbiAgY29uc3QgdXJsID0gcmVxdWlyZShcInVybFwiKTtcbiAgY29uc3QgcGFyc2VkVXJsID0gdXJsLnBhcnNlKHNvdXJjZVVybCk7XG4gIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09IFwiZmlsZTpcIiB8fCBwYXJzZWRVcmwuaG9zdCkge1xuICAgIHJldHVybiBwYXJzZWRVcmw7XG4gIH1cbiAgaWYgKC9eW2Etel06Wy9cXFxcXS9pLnRlc3Qoc291cmNlVXJsKSkge1xuICAgIHJldHVybiB1cmwucGFyc2UoYGZpbGU6Ly8vJHtzb3VyY2VVcmx9YCk7XG4gIH1cbiAgaWYgKCFwYXJzZWRVcmwuaG9zdCkge1xuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9IFwiZmlsZTpcIjtcbiAgfVxuICByZXR1cm4gcGFyc2VkVXJsO1xufVxuY2xhc3MgUERGTm9kZVN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudXJsID0gcGFyc2VVcmwoc291cmNlLnVybCk7XG4gICAgdGhpcy5pc0h0dHAgPSB0aGlzLnVybC5wcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IHRoaXMudXJsLnByb3RvY29sID09PSBcImh0dHBzOlwiO1xuICAgIHRoaXMuaXNGc1VybCA9IHRoaXMudXJsLnByb3RvY29sID09PSBcImZpbGU6XCI7XG4gICAgdGhpcy5odHRwSGVhZGVycyA9IHRoaXMuaXNIdHRwICYmIHNvdXJjZS5odHRwSGVhZGVycyB8fCB7fTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG4gIGdldCBfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uX2xvYWRlZCA/PyAwO1xuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5vZGVTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSB0aGlzLmlzRnNVcmwgPyBuZXcgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlcih0aGlzKSA6IG5ldyBQREZOb2RlU3RyZWFtRnVsbFJlYWRlcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoc3RhcnQsIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2VSZWFkZXIgPSB0aGlzLmlzRnNVcmwgPyBuZXcgUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIodGhpcywgc3RhcnQsIGVuZCkgOiBuZXcgUERGTm9kZVN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIHN0YXJ0LCBlbmQpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyYW5nZVJlYWRlcik7XG4gICAgcmV0dXJuIHJhbmdlUmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLlBERk5vZGVTdHJlYW0gPSBQREZOb2RlU3RyZWFtO1xuY2xhc3MgQmFzZUZ1bGxSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICB0aGlzLl91cmwgPSBzdHJlYW0udXJsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcmVhZGFibGVTdHJlYW0ucmVhZCgpO1xuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZCxcbiAgICAgIHRvdGFsOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGJ1ZmZlcixcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveShyZWFzb24pO1xuICB9XG4gIF9lcnJvcihyZWFzb24pIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX3NldFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSByZWFkYWJsZVN0cmVhbTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcInJlYWRhYmxlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICByZWFkYWJsZVN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgIH0pO1xuICAgIGlmICghdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgJiYgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgdGhpcy5fZXJyb3IobmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKFwic3RyZWFtaW5nIGlzIGRpc2FibGVkXCIpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEJhc2VSYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3VybCA9IHN0cmVhbS51cmw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSB0aGlzLl9yZWFkYWJsZVN0cmVhbS5yZWFkKCk7XG4gICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgcmV0dXJuIHRoaXMucmVhZCgpO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkXG4gICAgfSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGJ1ZmZlcixcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveShyZWFzb24pO1xuICB9XG4gIF9lcnJvcihyZWFzb24pIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX3NldFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSByZWFkYWJsZVN0cmVhbTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcInJlYWRhYmxlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICByZWFkYWJsZVN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveSh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0T3B0aW9ucyhwYXJzZWRVcmwsIGhlYWRlcnMpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogcGFyc2VkVXJsLnByb3RvY29sLFxuICAgIGF1dGg6IHBhcnNlZFVybC5hdXRoLFxuICAgIGhvc3Q6IHBhcnNlZFVybC5ob3N0bmFtZSxcbiAgICBwb3J0OiBwYXJzZWRVcmwucG9ydCxcbiAgICBwYXRoOiBwYXJzZWRVcmwucGF0aCxcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVyc1xuICB9O1xufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZ1bGxSZWFkZXIgZXh0ZW5kcyBCYXNlRnVsbFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHN1cGVyKHN0cmVhbSk7XG4gICAgY29uc3QgaGFuZGxlUmVzcG9uc2UgPSByZXNwb25zZSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24oYE1pc3NpbmcgUERGIFwiJHt0aGlzLl91cmx9XCIuYCk7XG4gICAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIHRoaXMuX3NldFJlYWRhYmxlU3RyZWFtKHJlc3BvbnNlKTtcbiAgICAgIGNvbnN0IGdldFJlc3BvbnNlSGVhZGVyID0gbmFtZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0cmVhbS5oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICB9O1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgICAgfSA9ICgwLCBfbmV0d29ya191dGlscy52YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcykoe1xuICAgICAgICBnZXRSZXNwb25zZUhlYWRlcixcbiAgICAgICAgaXNIdHRwOiBzdHJlYW0uaXNIdHRwLFxuICAgICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICAgIGRpc2FibGVSYW5nZTogdGhpcy5fZGlzYWJsZVJhbmdlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBhbGxvd1JhbmdlUmVxdWVzdHM7XG4gICAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgICB0aGlzLl9maWxlbmFtZSA9ICgwLCBfbmV0d29ya191dGlscy5leHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKShnZXRSZXNwb25zZUhlYWRlcik7XG4gICAgfTtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5fdXJsLnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcbiAgICAgIGNvbnN0IGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBodHRwLnJlcXVlc3QoY3JlYXRlUmVxdWVzdE9wdGlvbnModGhpcy5fdXJsLCBzdHJlYW0uaHR0cEhlYWRlcnMpLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGh0dHBzID0gcmVxdWlyZShcImh0dHBzXCIpO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IGh0dHBzLnJlcXVlc3QoY3JlYXRlUmVxdWVzdE9wdGlvbnModGhpcy5fdXJsLCBzdHJlYW0uaHR0cEhlYWRlcnMpLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3Qub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICB9KTtcbiAgICB0aGlzLl9yZXF1ZXN0LmVuZCgpO1xuICB9XG59XG5jbGFzcyBQREZOb2RlU3RyZWFtUmFuZ2VSZWFkZXIgZXh0ZW5kcyBCYXNlUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHN0YXJ0LCBlbmQpIHtcbiAgICBzdXBlcihzdHJlYW0pO1xuICAgIHRoaXMuX2h0dHBIZWFkZXJzID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBzdHJlYW0uaHR0cEhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gc3RyZWFtLmh0dHBIZWFkZXJzW3Byb3BlcnR5XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5faHR0cEhlYWRlcnNbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfVxuICAgIHRoaXMuX2h0dHBIZWFkZXJzLlJhbmdlID0gYGJ5dGVzPSR7c3RhcnR9LSR7ZW5kIC0gMX1gO1xuICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gcmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKGBNaXNzaW5nIFBERiBcIiR7dGhpcy5fdXJsfVwiLmApO1xuICAgICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShyZXNwb25zZSk7XG4gICAgfTtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5fdXJsLnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcbiAgICAgIGNvbnN0IGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBodHRwLnJlcXVlc3QoY3JlYXRlUmVxdWVzdE9wdGlvbnModGhpcy5fdXJsLCB0aGlzLl9odHRwSGVhZGVycyksIGhhbmRsZVJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaHR0cHMgPSByZXF1aXJlKFwiaHR0cHNcIik7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gaHR0cHMucmVxdWVzdChjcmVhdGVSZXF1ZXN0T3B0aW9ucyh0aGlzLl91cmwsIHRoaXMuX2h0dHBIZWFkZXJzKSwgaGFuZGxlUmVzcG9uc2UpO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgIH0pO1xuICAgIHRoaXMuX3JlcXVlc3QuZW5kKCk7XG4gIH1cbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIgZXh0ZW5kcyBCYXNlRnVsbFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHN1cGVyKHN0cmVhbSk7XG4gICAgbGV0IHBhdGggPSBkZWNvZGVVUklDb21wb25lbnQodGhpcy5fdXJsLnBhdGgpO1xuICAgIGlmIChmaWxlVXJpUmVnZXgudGVzdCh0aGlzLl91cmwuaHJlZikpIHtcbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC8vLCBcIlwiKTtcbiAgICB9XG4gICAgY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgZnMubHN0YXQocGF0aCwgKGVycm9yLCBzdGF0KSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKGBNaXNzaW5nIFBERiBcIiR7cGF0aH1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3RhdC5zaXplO1xuICAgICAgdGhpcy5fc2V0UmVhZGFibGVTdHJlYW0oZnMuY3JlYXRlUmVhZFN0cmVhbShwYXRoKSk7XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyIGV4dGVuZHMgQmFzZVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBzdGFydCwgZW5kKSB7XG4gICAgc3VwZXIoc3RyZWFtKTtcbiAgICBsZXQgcGF0aCA9IGRlY29kZVVSSUNvbXBvbmVudCh0aGlzLl91cmwucGF0aCk7XG4gICAgaWYgKGZpbGVVcmlSZWdleC50ZXN0KHRoaXMuX3VybC5ocmVmKSkge1xuICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLy8sIFwiXCIpO1xuICAgIH1cbiAgICBjb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGgsIHtcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kOiBlbmQgLSAxXG4gICAgfSkpO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuU1ZHR3JhcGhpY3MgPSB2b2lkIDA7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbjtcbmNvbnN0IFNWR19ERUZBVUxUUyA9IHtcbiAgZm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxuICBmaWxsQ29sb3I6IFwiIzAwMDAwMFwiXG59O1xuY29uc3QgWE1MX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIjtcbmNvbnN0IFhMSU5LX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI7XG5jb25zdCBMSU5FX0NBUF9TVFlMRVMgPSBbXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIl07XG5jb25zdCBMSU5FX0pPSU5fU1RZTEVTID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuY29uc3QgY3JlYXRlT2JqZWN0VVJMID0gZnVuY3Rpb24gKGRhdGEsIGNvbnRlbnRUeXBlID0gXCJcIiwgZm9yY2VEYXRhU2NoZW1hID0gZmFsc2UpIHtcbiAgaWYgKFVSTC5jcmVhdGVPYmplY3RVUkwgJiYgdHlwZW9mIEJsb2IgIT09IFwidW5kZWZpbmVkXCIgJiYgIWZvcmNlRGF0YVNjaGVtYSkge1xuICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtkYXRhXSwge1xuICAgICAgdHlwZTogY29udGVudFR5cGVcbiAgICB9KSk7XG4gIH1cbiAgY29uc3QgZGlnaXRzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuICBsZXQgYnVmZmVyID0gYGRhdGE6JHtjb250ZW50VHlwZX07YmFzZTY0LGA7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGRhdGEubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMykge1xuICAgIGNvbnN0IGIxID0gZGF0YVtpXSAmIDB4ZmY7XG4gICAgY29uc3QgYjIgPSBkYXRhW2kgKyAxXSAmIDB4ZmY7XG4gICAgY29uc3QgYjMgPSBkYXRhW2kgKyAyXSAmIDB4ZmY7XG4gICAgY29uc3QgZDEgPSBiMSA+PiAyLFxuICAgICAgZDIgPSAoYjEgJiAzKSA8PCA0IHwgYjIgPj4gNDtcbiAgICBjb25zdCBkMyA9IGkgKyAxIDwgaWkgPyAoYjIgJiAweGYpIDw8IDIgfCBiMyA+PiA2IDogNjQ7XG4gICAgY29uc3QgZDQgPSBpICsgMiA8IGlpID8gYjMgJiAweDNmIDogNjQ7XG4gICAgYnVmZmVyICs9IGRpZ2l0c1tkMV0gKyBkaWdpdHNbZDJdICsgZGlnaXRzW2QzXSArIGRpZ2l0c1tkNF07XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5jb25zdCBjb252ZXJ0SW1nRGF0YVRvUG5nID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBQTkdfSEVBREVSID0gbmV3IFVpbnQ4QXJyYXkoWzB4ODksIDB4NTAsIDB4NGUsIDB4NDcsIDB4MGQsIDB4MGEsIDB4MWEsIDB4MGFdKTtcbiAgY29uc3QgQ0hVTktfV1JBUFBFUl9TSVpFID0gMTI7XG4gIGNvbnN0IGNyY1RhYmxlID0gbmV3IEludDMyQXJyYXkoMjU2KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgIGxldCBjID0gaTtcbiAgICBmb3IgKGxldCBoID0gMDsgaCA8IDg7IGgrKykge1xuICAgICAgYyA9IGMgJiAxID8gMHhlZGI4ODMyMCBeIGMgPj4gMSAmIDB4N2ZmZmZmZmYgOiBjID4+IDEgJiAweDdmZmZmZmZmO1xuICAgIH1cbiAgICBjcmNUYWJsZVtpXSA9IGM7XG4gIH1cbiAgZnVuY3Rpb24gY3JjMzIoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgIGxldCBjcmMgPSAtMTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgYSA9IChjcmMgXiBkYXRhW2ldKSAmIDB4ZmY7XG4gICAgICBjb25zdCBiID0gY3JjVGFibGVbYV07XG4gICAgICBjcmMgPSBjcmMgPj4+IDggXiBiO1xuICAgIH1cbiAgICByZXR1cm4gY3JjIF4gLTE7XG4gIH1cbiAgZnVuY3Rpb24gd3JpdGVQbmdDaHVuayh0eXBlLCBib2R5LCBkYXRhLCBvZmZzZXQpIHtcbiAgICBsZXQgcCA9IG9mZnNldDtcbiAgICBjb25zdCBsZW4gPSBib2R5Lmxlbmd0aDtcbiAgICBkYXRhW3BdID0gbGVuID4+IDI0ICYgMHhmZjtcbiAgICBkYXRhW3AgKyAxXSA9IGxlbiA+PiAxNiAmIDB4ZmY7XG4gICAgZGF0YVtwICsgMl0gPSBsZW4gPj4gOCAmIDB4ZmY7XG4gICAgZGF0YVtwICsgM10gPSBsZW4gJiAweGZmO1xuICAgIHAgKz0gNDtcbiAgICBkYXRhW3BdID0gdHlwZS5jaGFyQ29kZUF0KDApICYgMHhmZjtcbiAgICBkYXRhW3AgKyAxXSA9IHR5cGUuY2hhckNvZGVBdCgxKSAmIDB4ZmY7XG4gICAgZGF0YVtwICsgMl0gPSB0eXBlLmNoYXJDb2RlQXQoMikgJiAweGZmO1xuICAgIGRhdGFbcCArIDNdID0gdHlwZS5jaGFyQ29kZUF0KDMpICYgMHhmZjtcbiAgICBwICs9IDQ7XG4gICAgZGF0YS5zZXQoYm9keSwgcCk7XG4gICAgcCArPSBib2R5Lmxlbmd0aDtcbiAgICBjb25zdCBjcmMgPSBjcmMzMihkYXRhLCBvZmZzZXQgKyA0LCBwKTtcbiAgICBkYXRhW3BdID0gY3JjID4+IDI0ICYgMHhmZjtcbiAgICBkYXRhW3AgKyAxXSA9IGNyYyA+PiAxNiAmIDB4ZmY7XG4gICAgZGF0YVtwICsgMl0gPSBjcmMgPj4gOCAmIDB4ZmY7XG4gICAgZGF0YVtwICsgM10gPSBjcmMgJiAweGZmO1xuICB9XG4gIGZ1bmN0aW9uIGFkbGVyMzIoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgIGxldCBhID0gMTtcbiAgICBsZXQgYiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIGEgPSAoYSArIChkYXRhW2ldICYgMHhmZikpICUgNjU1MjE7XG4gICAgICBiID0gKGIgKyBhKSAlIDY1NTIxO1xuICAgIH1cbiAgICByZXR1cm4gYiA8PCAxNiB8IGE7XG4gIH1cbiAgZnVuY3Rpb24gZGVmbGF0ZVN5bmMobGl0ZXJhbHMpIHtcbiAgICBpZiAoIV91dGlsLmlzTm9kZUpTKSB7XG4gICAgICByZXR1cm4gZGVmbGF0ZVN5bmNVbmNvbXByZXNzZWQobGl0ZXJhbHMpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgaW5wdXQgPSBwYXJzZUludChwcm9jZXNzLnZlcnNpb25zLm5vZGUpID49IDggPyBsaXRlcmFscyA6IEJ1ZmZlci5mcm9tKGxpdGVyYWxzKTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IHJlcXVpcmUoXCJ6bGliXCIpLmRlZmxhdGVTeW5jKGlucHV0LCB7XG4gICAgICAgIGxldmVsOiA5XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvdXRwdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gb3V0cHV0IDogbmV3IFVpbnQ4QXJyYXkob3V0cHV0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoXCJOb3QgY29tcHJlc3NpbmcgUE5HIGJlY2F1c2UgemxpYi5kZWZsYXRlU3luYyBpcyB1bmF2YWlsYWJsZTogXCIgKyBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmxhdGVTeW5jVW5jb21wcmVzc2VkKGxpdGVyYWxzKTtcbiAgfVxuICBmdW5jdGlvbiBkZWZsYXRlU3luY1VuY29tcHJlc3NlZChsaXRlcmFscykge1xuICAgIGxldCBsZW4gPSBsaXRlcmFscy5sZW5ndGg7XG4gICAgY29uc3QgbWF4QmxvY2tMZW5ndGggPSAweGZmZmY7XG4gICAgY29uc3QgZGVmbGF0ZUJsb2NrcyA9IE1hdGguY2VpbChsZW4gLyBtYXhCbG9ja0xlbmd0aCk7XG4gICAgY29uc3QgaWRhdCA9IG5ldyBVaW50OEFycmF5KDIgKyBsZW4gKyBkZWZsYXRlQmxvY2tzICogNSArIDQpO1xuICAgIGxldCBwaSA9IDA7XG4gICAgaWRhdFtwaSsrXSA9IDB4Nzg7XG4gICAgaWRhdFtwaSsrXSA9IDB4OWM7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgd2hpbGUgKGxlbiA+IG1heEJsb2NrTGVuZ3RoKSB7XG4gICAgICBpZGF0W3BpKytdID0gMHgwMDtcbiAgICAgIGlkYXRbcGkrK10gPSAweGZmO1xuICAgICAgaWRhdFtwaSsrXSA9IDB4ZmY7XG4gICAgICBpZGF0W3BpKytdID0gMHgwMDtcbiAgICAgIGlkYXRbcGkrK10gPSAweDAwO1xuICAgICAgaWRhdC5zZXQobGl0ZXJhbHMuc3ViYXJyYXkocG9zLCBwb3MgKyBtYXhCbG9ja0xlbmd0aCksIHBpKTtcbiAgICAgIHBpICs9IG1heEJsb2NrTGVuZ3RoO1xuICAgICAgcG9zICs9IG1heEJsb2NrTGVuZ3RoO1xuICAgICAgbGVuIC09IG1heEJsb2NrTGVuZ3RoO1xuICAgIH1cbiAgICBpZGF0W3BpKytdID0gMHgwMTtcbiAgICBpZGF0W3BpKytdID0gbGVuICYgMHhmZjtcbiAgICBpZGF0W3BpKytdID0gbGVuID4+IDggJiAweGZmO1xuICAgIGlkYXRbcGkrK10gPSB+bGVuICYgMHhmZmZmICYgMHhmZjtcbiAgICBpZGF0W3BpKytdID0gKH5sZW4gJiAweGZmZmYpID4+IDggJiAweGZmO1xuICAgIGlkYXQuc2V0KGxpdGVyYWxzLnN1YmFycmF5KHBvcyksIHBpKTtcbiAgICBwaSArPSBsaXRlcmFscy5sZW5ndGggLSBwb3M7XG4gICAgY29uc3QgYWRsZXIgPSBhZGxlcjMyKGxpdGVyYWxzLCAwLCBsaXRlcmFscy5sZW5ndGgpO1xuICAgIGlkYXRbcGkrK10gPSBhZGxlciA+PiAyNCAmIDB4ZmY7XG4gICAgaWRhdFtwaSsrXSA9IGFkbGVyID4+IDE2ICYgMHhmZjtcbiAgICBpZGF0W3BpKytdID0gYWRsZXIgPj4gOCAmIDB4ZmY7XG4gICAgaWRhdFtwaSsrXSA9IGFkbGVyICYgMHhmZjtcbiAgICByZXR1cm4gaWRhdDtcbiAgfVxuICBmdW5jdGlvbiBlbmNvZGUoaW1nRGF0YSwga2luZCwgZm9yY2VEYXRhU2NoZW1hLCBpc01hc2spIHtcbiAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgbGV0IGJpdERlcHRoLCBjb2xvclR5cGUsIGxpbmVTaXplO1xuICAgIGNvbnN0IGJ5dGVzID0gaW1nRGF0YS5kYXRhO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBfdXRpbC5JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFA6XG4gICAgICAgIGNvbG9yVHlwZSA9IDA7XG4gICAgICAgIGJpdERlcHRoID0gMTtcbiAgICAgICAgbGluZVNpemUgPSB3aWR0aCArIDcgPj4gMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF91dGlsLkltYWdlS2luZC5SR0JfMjRCUFA6XG4gICAgICAgIGNvbG9yVHlwZSA9IDI7XG4gICAgICAgIGJpdERlcHRoID0gODtcbiAgICAgICAgbGluZVNpemUgPSB3aWR0aCAqIDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5JbWFnZUtpbmQuUkdCQV8zMkJQUDpcbiAgICAgICAgY29sb3JUeXBlID0gNjtcbiAgICAgICAgYml0RGVwdGggPSA4O1xuICAgICAgICBsaW5lU2l6ZSA9IHdpZHRoICogNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdFwiKTtcbiAgICB9XG4gICAgY29uc3QgbGl0ZXJhbHMgPSBuZXcgVWludDhBcnJheSgoMSArIGxpbmVTaXplKSAqIGhlaWdodCk7XG4gICAgbGV0IG9mZnNldExpdGVyYWxzID0gMCxcbiAgICAgIG9mZnNldEJ5dGVzID0gMDtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICBsaXRlcmFsc1tvZmZzZXRMaXRlcmFscysrXSA9IDA7XG4gICAgICBsaXRlcmFscy5zZXQoYnl0ZXMuc3ViYXJyYXkob2Zmc2V0Qnl0ZXMsIG9mZnNldEJ5dGVzICsgbGluZVNpemUpLCBvZmZzZXRMaXRlcmFscyk7XG4gICAgICBvZmZzZXRCeXRlcyArPSBsaW5lU2l6ZTtcbiAgICAgIG9mZnNldExpdGVyYWxzICs9IGxpbmVTaXplO1xuICAgIH1cbiAgICBpZiAoa2luZCA9PT0gX3V0aWwuSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQICYmIGlzTWFzaykge1xuICAgICAgb2Zmc2V0TGl0ZXJhbHMgPSAwO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBvZmZzZXRMaXRlcmFscysrO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVTaXplOyBpKyspIHtcbiAgICAgICAgICBsaXRlcmFsc1tvZmZzZXRMaXRlcmFscysrXSBePSAweGZmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGloZHIgPSBuZXcgVWludDhBcnJheShbd2lkdGggPj4gMjQgJiAweGZmLCB3aWR0aCA+PiAxNiAmIDB4ZmYsIHdpZHRoID4+IDggJiAweGZmLCB3aWR0aCAmIDB4ZmYsIGhlaWdodCA+PiAyNCAmIDB4ZmYsIGhlaWdodCA+PiAxNiAmIDB4ZmYsIGhlaWdodCA+PiA4ICYgMHhmZiwgaGVpZ2h0ICYgMHhmZiwgYml0RGVwdGgsIGNvbG9yVHlwZSwgMHgwMCwgMHgwMCwgMHgwMF0pO1xuICAgIGNvbnN0IGlkYXQgPSBkZWZsYXRlU3luYyhsaXRlcmFscyk7XG4gICAgY29uc3QgcG5nTGVuZ3RoID0gUE5HX0hFQURFUi5sZW5ndGggKyBDSFVOS19XUkFQUEVSX1NJWkUgKiAzICsgaWhkci5sZW5ndGggKyBpZGF0Lmxlbmd0aDtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkocG5nTGVuZ3RoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBkYXRhLnNldChQTkdfSEVBREVSLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBQTkdfSEVBREVSLmxlbmd0aDtcbiAgICB3cml0ZVBuZ0NodW5rKFwiSUhEUlwiLCBpaGRyLCBkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBDSFVOS19XUkFQUEVSX1NJWkUgKyBpaGRyLmxlbmd0aDtcbiAgICB3cml0ZVBuZ0NodW5rKFwiSURBVEFcIiwgaWRhdCwgZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gQ0hVTktfV1JBUFBFUl9TSVpFICsgaWRhdC5sZW5ndGg7XG4gICAgd3JpdGVQbmdDaHVuayhcIklFTkRcIiwgbmV3IFVpbnQ4QXJyYXkoMCksIGRhdGEsIG9mZnNldCk7XG4gICAgcmV0dXJuIGNyZWF0ZU9iamVjdFVSTChkYXRhLCBcImltYWdlL3BuZ1wiLCBmb3JjZURhdGFTY2hlbWEpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBjb252ZXJ0SW1nRGF0YVRvUG5nKGltZ0RhdGEsIGZvcmNlRGF0YVNjaGVtYSwgaXNNYXNrKSB7XG4gICAgY29uc3Qga2luZCA9IGltZ0RhdGEua2luZCA9PT0gdW5kZWZpbmVkID8gX3V0aWwuSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQIDogaW1nRGF0YS5raW5kO1xuICAgIHJldHVybiBlbmNvZGUoaW1nRGF0YSwga2luZCwgZm9yY2VEYXRhU2NoZW1hLCBpc01hc2spO1xuICB9O1xufSgpO1xuY2xhc3MgU1ZHRXh0cmFTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZm9udFNpemVTY2FsZSA9IDE7XG4gICAgdGhpcy5mb250V2VpZ2h0ID0gU1ZHX0RFRkFVTFRTLmZvbnRXZWlnaHQ7XG4gICAgdGhpcy5mb250U2l6ZSA9IDA7XG4gICAgdGhpcy50ZXh0TWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMuZm9udE1hdHJpeCA9IF91dGlsLkZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMubGVhZGluZyA9IDA7XG4gICAgdGhpcy50ZXh0UmVuZGVyaW5nTW9kZSA9IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTEw7XG4gICAgdGhpcy50ZXh0TWF0cml4U2NhbGUgPSAxO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLmxpbmVYID0gMDtcbiAgICB0aGlzLmxpbmVZID0gMDtcbiAgICB0aGlzLmNoYXJTcGFjaW5nID0gMDtcbiAgICB0aGlzLndvcmRTcGFjaW5nID0gMDtcbiAgICB0aGlzLnRleHRIU2NhbGUgPSAxO1xuICAgIHRoaXMudGV4dFJpc2UgPSAwO1xuICAgIHRoaXMuZmlsbENvbG9yID0gU1ZHX0RFRkFVTFRTLmZpbGxDb2xvcjtcbiAgICB0aGlzLnN0cm9rZUNvbG9yID0gXCIjMDAwMDAwXCI7XG4gICAgdGhpcy5maWxsQWxwaGEgPSAxO1xuICAgIHRoaXMuc3Ryb2tlQWxwaGEgPSAxO1xuICAgIHRoaXMubGluZVdpZHRoID0gMTtcbiAgICB0aGlzLmxpbmVKb2luID0gXCJcIjtcbiAgICB0aGlzLmxpbmVDYXAgPSBcIlwiO1xuICAgIHRoaXMubWl0ZXJMaW1pdCA9IDA7XG4gICAgdGhpcy5kYXNoQXJyYXkgPSBbXTtcbiAgICB0aGlzLmRhc2hQaGFzZSA9IDA7XG4gICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBbXTtcbiAgICB0aGlzLmFjdGl2ZUNsaXBVcmwgPSBudWxsO1xuICAgIHRoaXMuY2xpcEdyb3VwID0gbnVsbDtcbiAgICB0aGlzLm1hc2tJZCA9IFwiXCI7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gIH1cbiAgc2V0Q3VycmVudFBvaW50KHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9wTGlzdFRvVHJlZShvcExpc3QpIHtcbiAgbGV0IG9wVHJlZSA9IFtdO1xuICBjb25zdCB0bXAgPSBbXTtcbiAgZm9yIChjb25zdCBvcExpc3RFbGVtZW50IG9mIG9wTGlzdCkge1xuICAgIGlmIChvcExpc3RFbGVtZW50LmZuID09PSBcInNhdmVcIikge1xuICAgICAgb3BUcmVlLnB1c2goe1xuICAgICAgICBmbklkOiA5MixcbiAgICAgICAgZm46IFwiZ3JvdXBcIixcbiAgICAgICAgaXRlbXM6IFtdXG4gICAgICB9KTtcbiAgICAgIHRtcC5wdXNoKG9wVHJlZSk7XG4gICAgICBvcFRyZWUgPSBvcFRyZWUuYXQoLTEpLml0ZW1zO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChvcExpc3RFbGVtZW50LmZuID09PSBcInJlc3RvcmVcIikge1xuICAgICAgb3BUcmVlID0gdG1wLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcFRyZWUucHVzaChvcExpc3RFbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wVHJlZTtcbn1cbmZ1bmN0aW9uIHBmKHZhbHVlKSB7XG4gIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGNvbnN0IHMgPSB2YWx1ZS50b0ZpeGVkKDEwKTtcbiAgbGV0IGkgPSBzLmxlbmd0aCAtIDE7XG4gIGlmIChzW2ldICE9PSBcIjBcIikge1xuICAgIHJldHVybiBzO1xuICB9XG4gIGRvIHtcbiAgICBpLS07XG4gIH0gd2hpbGUgKHNbaV0gPT09IFwiMFwiKTtcbiAgcmV0dXJuIHMuc3Vic3RyaW5nKDAsIHNbaV0gPT09IFwiLlwiID8gaSA6IGkgKyAxKTtcbn1cbmZ1bmN0aW9uIHBtKG0pIHtcbiAgaWYgKG1bNF0gPT09IDAgJiYgbVs1XSA9PT0gMCkge1xuICAgIGlmIChtWzFdID09PSAwICYmIG1bMl0gPT09IDApIHtcbiAgICAgIGlmIChtWzBdID09PSAxICYmIG1bM10gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYHNjYWxlKCR7cGYobVswXSl9ICR7cGYobVszXSl9KWA7XG4gICAgfVxuICAgIGlmIChtWzBdID09PSBtWzNdICYmIG1bMV0gPT09IC1tWzJdKSB7XG4gICAgICBjb25zdCBhID0gTWF0aC5hY29zKG1bMF0pICogMTgwIC8gTWF0aC5QSTtcbiAgICAgIHJldHVybiBgcm90YXRlKCR7cGYoYSl9KWA7XG4gICAgfVxuICB9IGVsc2UgaWYgKG1bMF0gPT09IDEgJiYgbVsxXSA9PT0gMCAmJiBtWzJdID09PSAwICYmIG1bM10gPT09IDEpIHtcbiAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3BmKG1bNF0pfSAke3BmKG1bNV0pfSlgO1xuICB9XG4gIHJldHVybiBgbWF0cml4KCR7cGYobVswXSl9ICR7cGYobVsxXSl9ICR7cGYobVsyXSl9ICR7cGYobVszXSl9ICR7cGYobVs0XSl9IGAgKyBgJHtwZihtWzVdKX0pYDtcbn1cbmxldCBjbGlwQ291bnQgPSAwO1xubGV0IG1hc2tDb3VudCA9IDA7XG5sZXQgc2hhZGluZ0NvdW50ID0gMDtcbmNsYXNzIFNWR0dyYXBoaWNzIHtcbiAgY29uc3RydWN0b3IoY29tbW9uT2Jqcywgb2JqcywgZm9yY2VEYXRhU2NoZW1hID0gZmFsc2UpIHtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZGVwcmVjYXRlZCkoXCJUaGUgU1ZHIGJhY2stZW5kIGlzIG5vIGxvbmdlciBtYWludGFpbmVkIGFuZCAqbWF5KiBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXCIpO1xuICAgIHRoaXMuc3ZnRmFjdG9yeSA9IG5ldyBfZGlzcGxheV91dGlscy5ET01TVkdGYWN0b3J5KCk7XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IFNWR0V4dHJhU3RhdGUoKTtcbiAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IF91dGlsLklERU5USVRZX01BVFJJWDtcbiAgICB0aGlzLnRyYW5zZm9ybVN0YWNrID0gW107XG4gICAgdGhpcy5leHRyYVN0YWNrID0gW107XG4gICAgdGhpcy5jb21tb25PYmpzID0gY29tbW9uT2JqcztcbiAgICB0aGlzLm9ianMgPSBvYmpzO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgIHRoaXMuZW1iZWRGb250cyA9IGZhbHNlO1xuICAgIHRoaXMuZW1iZWRkZWRGb250cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5jc3NTdHlsZSA9IG51bGw7XG4gICAgdGhpcy5mb3JjZURhdGFTY2hlbWEgPSAhIWZvcmNlRGF0YVNjaGVtYTtcbiAgICB0aGlzLl9vcGVyYXRvcklkTWFwcGluZyA9IFtdO1xuICAgIGZvciAoY29uc3Qgb3AgaW4gX3V0aWwuT1BTKSB7XG4gICAgICB0aGlzLl9vcGVyYXRvcklkTWFwcGluZ1tfdXRpbC5PUFNbb3BdXSA9IG9wO1xuICAgIH1cbiAgfVxuICBnZXRPYmplY3QoZGF0YSwgZmFsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZGF0YS5zdGFydHNXaXRoKFwiZ19cIikgPyB0aGlzLmNvbW1vbk9ianMuZ2V0KGRhdGEpIDogdGhpcy5vYmpzLmdldChkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG4gIHNhdmUoKSB7XG4gICAgdGhpcy50cmFuc2Zvcm1TdGFjay5wdXNoKHRoaXMudHJhbnNmb3JtTWF0cml4KTtcbiAgICBjb25zdCBvbGQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgdGhpcy5leHRyYVN0YWNrLnB1c2gob2xkKTtcbiAgICB0aGlzLmN1cnJlbnQgPSBvbGQuY2xvbmUoKTtcbiAgfVxuICByZXN0b3JlKCkge1xuICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gdGhpcy50cmFuc2Zvcm1TdGFjay5wb3AoKTtcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmV4dHJhU3RhY2sucG9wKCk7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgdGhpcy50Z3JwID0gbnVsbDtcbiAgfVxuICBncm91cChpdGVtcykge1xuICAgIHRoaXMuc2F2ZSgpO1xuICAgIHRoaXMuZXhlY3V0ZU9wVHJlZShpdGVtcyk7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cbiAgbG9hZERlcGVuZGVuY2llcyhvcGVyYXRvckxpc3QpIHtcbiAgICBjb25zdCBmbkFycmF5ID0gb3BlcmF0b3JMaXN0LmZuQXJyYXk7XG4gICAgY29uc3QgYXJnc0FycmF5ID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmbkFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGlmIChmbkFycmF5W2ldICE9PSBfdXRpbC5PUFMuZGVwZW5kZW5jeSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgb2JqIG9mIGFyZ3NBcnJheVtpXSkge1xuICAgICAgICBjb25zdCBvYmpzUG9vbCA9IG9iai5zdGFydHNXaXRoKFwiZ19cIikgPyB0aGlzLmNvbW1vbk9ianMgOiB0aGlzLm9ianM7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBvYmpzUG9vbC5nZXQob2JqLCByZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3VycmVudC5kZXBlbmRlbmNpZXMucHVzaChwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuY3VycmVudC5kZXBlbmRlbmNpZXMpO1xuICB9XG4gIHRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtTWF0cml4ID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0odGhpcy50cmFuc2Zvcm1NYXRyaXgsIHRyYW5zZm9ybU1hdHJpeCk7XG4gICAgdGhpcy50Z3JwID0gbnVsbDtcbiAgfVxuICBnZXRTVkcob3BlcmF0b3JMaXN0LCB2aWV3cG9ydCkge1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICBjb25zdCBzdmdFbGVtZW50ID0gdGhpcy5faW5pdGlhbGl6ZSh2aWV3cG9ydCk7XG4gICAgcmV0dXJuIHRoaXMubG9hZERlcGVuZGVuY2llcyhvcGVyYXRvckxpc3QpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgICB0aGlzLmV4ZWN1dGVPcFRyZWUodGhpcy5jb252ZXJ0T3BMaXN0KG9wZXJhdG9yTGlzdCkpO1xuICAgICAgcmV0dXJuIHN2Z0VsZW1lbnQ7XG4gICAgfSk7XG4gIH1cbiAgY29udmVydE9wTGlzdChvcGVyYXRvckxpc3QpIHtcbiAgICBjb25zdCBvcGVyYXRvcklkTWFwcGluZyA9IHRoaXMuX29wZXJhdG9ySWRNYXBwaW5nO1xuICAgIGNvbnN0IGFyZ3NBcnJheSA9IG9wZXJhdG9yTGlzdC5hcmdzQXJyYXk7XG4gICAgY29uc3QgZm5BcnJheSA9IG9wZXJhdG9yTGlzdC5mbkFycmF5O1xuICAgIGNvbnN0IG9wTGlzdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGZuQXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgZm5JZCA9IGZuQXJyYXlbaV07XG4gICAgICBvcExpc3QucHVzaCh7XG4gICAgICAgIGZuSWQsXG4gICAgICAgIGZuOiBvcGVyYXRvcklkTWFwcGluZ1tmbklkXSxcbiAgICAgICAgYXJnczogYXJnc0FycmF5W2ldXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wTGlzdFRvVHJlZShvcExpc3QpO1xuICB9XG4gIGV4ZWN1dGVPcFRyZWUob3BUcmVlKSB7XG4gICAgZm9yIChjb25zdCBvcFRyZWVFbGVtZW50IG9mIG9wVHJlZSkge1xuICAgICAgY29uc3QgZm4gPSBvcFRyZWVFbGVtZW50LmZuO1xuICAgICAgY29uc3QgZm5JZCA9IG9wVHJlZUVsZW1lbnQuZm5JZDtcbiAgICAgIGNvbnN0IGFyZ3MgPSBvcFRyZWVFbGVtZW50LmFyZ3M7XG4gICAgICBzd2l0Y2ggKGZuSWQgfCAwKSB7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmJlZ2luVGV4dDpcbiAgICAgICAgICB0aGlzLmJlZ2luVGV4dCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5kZXBlbmRlbmN5OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRMZWFkaW5nOlxuICAgICAgICAgIHRoaXMuc2V0TGVhZGluZyhhcmdzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TGVhZGluZ01vdmVUZXh0OlxuICAgICAgICAgIHRoaXMuc2V0TGVhZGluZ01vdmVUZXh0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRGb250OlxuICAgICAgICAgIHRoaXMuc2V0Rm9udChhcmdzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2hvd1RleHQ6XG4gICAgICAgICAgdGhpcy5zaG93VGV4dChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2hvd1NwYWNlZFRleHQ6XG4gICAgICAgICAgdGhpcy5zaG93VGV4dChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuZW5kVGV4dDpcbiAgICAgICAgICB0aGlzLmVuZFRleHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMubW92ZVRleHQ6XG4gICAgICAgICAgdGhpcy5tb3ZlVGV4dChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0Q2hhclNwYWNpbmc6XG4gICAgICAgICAgdGhpcy5zZXRDaGFyU3BhY2luZyhhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0V29yZFNwYWNpbmc6XG4gICAgICAgICAgdGhpcy5zZXRXb3JkU3BhY2luZyhhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0SFNjYWxlOlxuICAgICAgICAgIHRoaXMuc2V0SFNjYWxlKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRUZXh0TWF0cml4OlxuICAgICAgICAgIHRoaXMuc2V0VGV4dE1hdHJpeChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0VGV4dFJpc2U6XG4gICAgICAgICAgdGhpcy5zZXRUZXh0UmlzZShhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0VGV4dFJlbmRlcmluZ01vZGU6XG4gICAgICAgICAgdGhpcy5zZXRUZXh0UmVuZGVyaW5nTW9kZShhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TGluZVdpZHRoOlxuICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRMaW5lSm9pbjpcbiAgICAgICAgICB0aGlzLnNldExpbmVKb2luKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRMaW5lQ2FwOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUNhcChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TWl0ZXJMaW1pdDpcbiAgICAgICAgICB0aGlzLnNldE1pdGVyTGltaXQoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldEZpbGxSR0JDb2xvcjpcbiAgICAgICAgICB0aGlzLnNldEZpbGxSR0JDb2xvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0U3Ryb2tlUkdCQ29sb3I6XG4gICAgICAgICAgdGhpcy5zZXRTdHJva2VSR0JDb2xvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0U3Ryb2tlQ29sb3JOOlxuICAgICAgICAgIHRoaXMuc2V0U3Ryb2tlQ29sb3JOKGFyZ3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRGaWxsQ29sb3JOOlxuICAgICAgICAgIHRoaXMuc2V0RmlsbENvbG9yTihhcmdzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2hhZGluZ0ZpbGw6XG4gICAgICAgICAgdGhpcy5zaGFkaW5nRmlsbChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0RGFzaDpcbiAgICAgICAgICB0aGlzLnNldERhc2goYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFJlbmRlcmluZ0ludGVudDpcbiAgICAgICAgICB0aGlzLnNldFJlbmRlcmluZ0ludGVudChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0RmxhdG5lc3M6XG4gICAgICAgICAgdGhpcy5zZXRGbGF0bmVzcyhhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0R1N0YXRlOlxuICAgICAgICAgIHRoaXMuc2V0R1N0YXRlKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5maWxsOlxuICAgICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5lb0ZpbGw6XG4gICAgICAgICAgdGhpcy5lb0ZpbGwoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc3Ryb2tlOlxuICAgICAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmZpbGxTdHJva2U6XG4gICAgICAgICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmVvRmlsbFN0cm9rZTpcbiAgICAgICAgICB0aGlzLmVvRmlsbFN0cm9rZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jbGlwOlxuICAgICAgICAgIHRoaXMuY2xpcChcIm5vbnplcm9cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmVvQ2xpcDpcbiAgICAgICAgICB0aGlzLmNsaXAoXCJldmVub2RkXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5wYWludFNvbGlkQ29sb3JJbWFnZU1hc2s6XG4gICAgICAgICAgdGhpcy5wYWludFNvbGlkQ29sb3JJbWFnZU1hc2soKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRJbWFnZVhPYmplY3Q6XG4gICAgICAgICAgdGhpcy5wYWludEltYWdlWE9iamVjdChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3Q6XG4gICAgICAgICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRJbWFnZU1hc2tYT2JqZWN0OlxuICAgICAgICAgIHRoaXMucGFpbnRJbWFnZU1hc2tYT2JqZWN0KGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5wYWludEZvcm1YT2JqZWN0QmVnaW46XG4gICAgICAgICAgdGhpcy5wYWludEZvcm1YT2JqZWN0QmVnaW4oYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnBhaW50Rm9ybVhPYmplY3RFbmQ6XG4gICAgICAgICAgdGhpcy5wYWludEZvcm1YT2JqZWN0RW5kKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlUGF0aDpcbiAgICAgICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jbG9zZVN0cm9rZTpcbiAgICAgICAgICB0aGlzLmNsb3NlU3Ryb2tlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlRmlsbFN0cm9rZTpcbiAgICAgICAgICB0aGlzLmNsb3NlRmlsbFN0cm9rZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jbG9zZUVPRmlsbFN0cm9rZTpcbiAgICAgICAgICB0aGlzLmNsb3NlRU9GaWxsU3Ryb2tlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLm5leHRMaW5lOlxuICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMudHJhbnNmb3JtOlxuICAgICAgICAgIHRoaXMudHJhbnNmb3JtKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jb25zdHJ1Y3RQYXRoOlxuICAgICAgICAgIHRoaXMuY29uc3RydWN0UGF0aChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuZW5kUGF0aDpcbiAgICAgICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA5MjpcbiAgICAgICAgICB0aGlzLmdyb3VwKG9wVHJlZUVsZW1lbnQuaXRlbXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgVW5pbXBsZW1lbnRlZCBvcGVyYXRvciAke2ZufWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzZXRXb3JkU3BhY2luZyh3b3JkU3BhY2luZykge1xuICAgIHRoaXMuY3VycmVudC53b3JkU3BhY2luZyA9IHdvcmRTcGFjaW5nO1xuICB9XG4gIHNldENoYXJTcGFjaW5nKGNoYXJTcGFjaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LmNoYXJTcGFjaW5nID0gY2hhclNwYWNpbmc7XG4gIH1cbiAgbmV4dExpbmUoKSB7XG4gICAgdGhpcy5tb3ZlVGV4dCgwLCB0aGlzLmN1cnJlbnQubGVhZGluZyk7XG4gIH1cbiAgc2V0VGV4dE1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjdXJyZW50LnRleHRNYXRyaXggPSBjdXJyZW50LmxpbmVNYXRyaXggPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSBNYXRoLmh5cG90KGEsIGIpO1xuICAgIGN1cnJlbnQueCA9IGN1cnJlbnQubGluZVggPSAwO1xuICAgIGN1cnJlbnQueSA9IGN1cnJlbnQubGluZVkgPSAwO1xuICAgIGN1cnJlbnQueGNvb3JkcyA9IFtdO1xuICAgIGN1cnJlbnQueWNvb3JkcyA9IFtdO1xuICAgIGN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1mYW1pbHlcIiwgY3VycmVudC5mb250RmFtaWx5KTtcbiAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1zaXplXCIsIGAke3BmKGN1cnJlbnQuZm9udFNpemUpfXB4YCk7XG4gICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgcGYoLWN1cnJlbnQueSkpO1xuICAgIGN1cnJlbnQudHh0RWxlbWVudCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnRleHRcIik7XG4gICAgY3VycmVudC50eHRFbGVtZW50LmFwcGVuZChjdXJyZW50LnRzcGFuKTtcbiAgfVxuICBiZWdpblRleHQoKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjdXJyZW50LnggPSBjdXJyZW50LmxpbmVYID0gMDtcbiAgICBjdXJyZW50LnkgPSBjdXJyZW50LmxpbmVZID0gMDtcbiAgICBjdXJyZW50LnRleHRNYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgY3VycmVudC5saW5lTWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgIGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgICBjdXJyZW50LnRzcGFuID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dHNwYW5cIik7XG4gICAgY3VycmVudC50eHRFbGVtZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dGV4dFwiKTtcbiAgICBjdXJyZW50LnR4dGdycCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgY3VycmVudC54Y29vcmRzID0gW107XG4gICAgY3VycmVudC55Y29vcmRzID0gW107XG4gIH1cbiAgbW92ZVRleHQoeCwgeSkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY3VycmVudC54ID0gY3VycmVudC5saW5lWCArPSB4O1xuICAgIGN1cnJlbnQueSA9IGN1cnJlbnQubGluZVkgKz0geTtcbiAgICBjdXJyZW50Lnhjb29yZHMgPSBbXTtcbiAgICBjdXJyZW50Lnljb29yZHMgPSBbXTtcbiAgICBjdXJyZW50LnRzcGFuID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dHNwYW5cIik7XG4gICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtZmFtaWx5XCIsIGN1cnJlbnQuZm9udEZhbWlseSk7XG4gICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtc2l6ZVwiLCBgJHtwZihjdXJyZW50LmZvbnRTaXplKX1weGApO1xuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHBmKC1jdXJyZW50LnkpKTtcbiAgfVxuICBzaG93VGV4dChnbHlwaHMpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuICAgIGlmIChmb250U2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmb250U2l6ZVNjYWxlID0gY3VycmVudC5mb250U2l6ZVNjYWxlO1xuICAgIGNvbnN0IGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICBjb25zdCB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgY29uc3QgZm9udERpcmVjdGlvbiA9IGN1cnJlbnQuZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCB2ZXJ0aWNhbCA9IGZvbnQudmVydGljYWw7XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IHZlcnRpY2FsID8gMSA6IC0xO1xuICAgIGNvbnN0IGRlZmF1bHRWTWV0cmljcyA9IGZvbnQuZGVmYXVsdFZNZXRyaWNzO1xuICAgIGNvbnN0IHdpZHRoQWR2YW5jZVNjYWxlID0gZm9udFNpemUgKiBjdXJyZW50LmZvbnRNYXRyaXhbMF07XG4gICAgbGV0IHggPSAwO1xuICAgIGZvciAoY29uc3QgZ2x5cGggb2YgZ2x5cGhzKSB7XG4gICAgICBpZiAoZ2x5cGggPT09IG51bGwpIHtcbiAgICAgICAgeCArPSBmb250RGlyZWN0aW9uICogd29yZFNwYWNpbmc7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZ2x5cGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgeCArPSBzcGFjaW5nRGlyICogZ2x5cGggKiBmb250U2l6ZSAvIDEwMDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3BhY2luZyA9IChnbHlwaC5pc1NwYWNlID8gd29yZFNwYWNpbmcgOiAwKSArIGNoYXJTcGFjaW5nO1xuICAgICAgY29uc3QgY2hhcmFjdGVyID0gZ2x5cGguZm9udENoYXI7XG4gICAgICBsZXQgc2NhbGVkWCwgc2NhbGVkWTtcbiAgICAgIGxldCB3aWR0aCA9IGdseXBoLndpZHRoO1xuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIGxldCB2eDtcbiAgICAgICAgY29uc3Qgdm1ldHJpYyA9IGdseXBoLnZtZXRyaWMgfHwgZGVmYXVsdFZNZXRyaWNzO1xuICAgICAgICB2eCA9IGdseXBoLnZtZXRyaWMgPyB2bWV0cmljWzFdIDogd2lkdGggKiAwLjU7XG4gICAgICAgIHZ4ID0gLXZ4ICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIGNvbnN0IHZ5ID0gdm1ldHJpY1syXSAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICB3aWR0aCA9IHZtZXRyaWMgPyAtdm1ldHJpY1swXSA6IHdpZHRoO1xuICAgICAgICBzY2FsZWRYID0gdnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gKHggKyB2eSkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVkWCA9IHggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChnbHlwaC5pc0luRm9udCB8fCBmb250Lm1pc3NpbmdGaWxlKSB7XG4gICAgICAgIGN1cnJlbnQueGNvb3Jkcy5wdXNoKGN1cnJlbnQueCArIHNjYWxlZFgpO1xuICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICBjdXJyZW50Lnljb29yZHMucHVzaCgtY3VycmVudC55ICsgc2NhbGVkWSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudC50c3Bhbi50ZXh0Q29udGVudCArPSBjaGFyYWN0ZXI7XG4gICAgICB9IGVsc2Uge31cbiAgICAgIGNvbnN0IGNoYXJXaWR0aCA9IHZlcnRpY2FsID8gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSAtIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uIDogd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSArIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uO1xuICAgICAgeCArPSBjaGFyV2lkdGg7XG4gICAgfVxuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIGN1cnJlbnQueGNvb3Jkcy5tYXAocGYpLmpvaW4oXCIgXCIpKTtcbiAgICBpZiAodmVydGljYWwpIHtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIGN1cnJlbnQueWNvb3Jkcy5tYXAocGYpLmpvaW4oXCIgXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgcGYoLWN1cnJlbnQueSkpO1xuICAgIH1cbiAgICBpZiAodmVydGljYWwpIHtcbiAgICAgIGN1cnJlbnQueSAtPSB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnggKz0geCAqIHRleHRIU2NhbGU7XG4gICAgfVxuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LWZhbWlseVwiLCBjdXJyZW50LmZvbnRGYW1pbHkpO1xuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LXNpemVcIiwgYCR7cGYoY3VycmVudC5mb250U2l6ZSl9cHhgKTtcbiAgICBpZiAoY3VycmVudC5mb250U3R5bGUgIT09IFNWR19ERUZBVUxUUy5mb250U3R5bGUpIHtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LXN0eWxlXCIsIGN1cnJlbnQuZm9udFN0eWxlKTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQuZm9udFdlaWdodCAhPT0gU1ZHX0RFRkFVTFRTLmZvbnRXZWlnaHQpIHtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LXdlaWdodFwiLCBjdXJyZW50LmZvbnRXZWlnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgJiBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgIGlmIChjdXJyZW50LmZpbGxDb2xvciAhPT0gU1ZHX0RFRkFVTFRTLmZpbGxDb2xvcikge1xuICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBjdXJyZW50LmZpbGxDb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudC5maWxsQWxwaGEgPCAxKSB7XG4gICAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLW9wYWNpdHlcIiwgY3VycmVudC5maWxsQWxwaGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEgpIHtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICB9XG4gICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICBjb25zdCBsaW5lV2lkdGhTY2FsZSA9IDEgLyAoY3VycmVudC50ZXh0TWF0cml4U2NhbGUgfHwgMSk7XG4gICAgICB0aGlzLl9zZXRTdHJva2VBdHRyaWJ1dGVzKGN1cnJlbnQudHNwYW4sIGxpbmVXaWR0aFNjYWxlKTtcbiAgICB9XG4gICAgbGV0IHRleHRNYXRyaXggPSBjdXJyZW50LnRleHRNYXRyaXg7XG4gICAgaWYgKGN1cnJlbnQudGV4dFJpc2UgIT09IDApIHtcbiAgICAgIHRleHRNYXRyaXggPSB0ZXh0TWF0cml4LnNsaWNlKCk7XG4gICAgICB0ZXh0TWF0cml4WzVdICs9IGN1cnJlbnQudGV4dFJpc2U7XG4gICAgfVxuICAgIGN1cnJlbnQudHh0RWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBgJHtwbSh0ZXh0TWF0cml4KX0gc2NhbGUoJHtwZih0ZXh0SFNjYWxlKX0sIC0xKWApO1xuICAgIGN1cnJlbnQudHh0RWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhYTUxfTlMsIFwieG1sOnNwYWNlXCIsIFwicHJlc2VydmVcIik7XG4gICAgY3VycmVudC50eHRFbGVtZW50LmFwcGVuZChjdXJyZW50LnRzcGFuKTtcbiAgICBjdXJyZW50LnR4dGdycC5hcHBlbmQoY3VycmVudC50eHRFbGVtZW50KTtcbiAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZChjdXJyZW50LnR4dEVsZW1lbnQpO1xuICB9XG4gIHNldExlYWRpbmdNb3ZlVGV4dCh4LCB5KSB7XG4gICAgdGhpcy5zZXRMZWFkaW5nKC15KTtcbiAgICB0aGlzLm1vdmVUZXh0KHgsIHkpO1xuICB9XG4gIGFkZEZvbnRTdHlsZShmb250T2JqKSB7XG4gICAgaWYgKCFmb250T2JqLmRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZEZvbnRTdHlsZTogTm8gZm9udCBkYXRhIGF2YWlsYWJsZSwgXCIgKyAnZW5zdXJlIHRoYXQgdGhlIFwiZm9udEV4dHJhUHJvcGVydGllc1wiIEFQSSBwYXJhbWV0ZXIgaXMgc2V0LicpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY3NzU3R5bGUpIHtcbiAgICAgIHRoaXMuY3NzU3R5bGUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpzdHlsZVwiKTtcbiAgICAgIHRoaXMuY3NzU3R5bGUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0eXBlXCIsIFwidGV4dC9jc3NcIik7XG4gICAgICB0aGlzLmRlZnMuYXBwZW5kKHRoaXMuY3NzU3R5bGUpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBjcmVhdGVPYmplY3RVUkwoZm9udE9iai5kYXRhLCBmb250T2JqLm1pbWV0eXBlLCB0aGlzLmZvcmNlRGF0YVNjaGVtYSk7XG4gICAgdGhpcy5jc3NTdHlsZS50ZXh0Q29udGVudCArPSBgQGZvbnQtZmFjZSB7IGZvbnQtZmFtaWx5OiBcIiR7Zm9udE9iai5sb2FkZWROYW1lfVwiO2AgKyBgIHNyYzogdXJsKCR7dXJsfSk7IH1cXG5gO1xuICB9XG4gIHNldEZvbnQoZGV0YWlscykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udE9iaiA9IHRoaXMuY29tbW9uT2Jqcy5nZXQoZGV0YWlsc1swXSk7XG4gICAgbGV0IHNpemUgPSBkZXRhaWxzWzFdO1xuICAgIGN1cnJlbnQuZm9udCA9IGZvbnRPYmo7XG4gICAgaWYgKHRoaXMuZW1iZWRGb250cyAmJiAhZm9udE9iai5taXNzaW5nRmlsZSAmJiAhdGhpcy5lbWJlZGRlZEZvbnRzW2ZvbnRPYmoubG9hZGVkTmFtZV0pIHtcbiAgICAgIHRoaXMuYWRkRm9udFN0eWxlKGZvbnRPYmopO1xuICAgICAgdGhpcy5lbWJlZGRlZEZvbnRzW2ZvbnRPYmoubG9hZGVkTmFtZV0gPSBmb250T2JqO1xuICAgIH1cbiAgICBjdXJyZW50LmZvbnRNYXRyaXggPSBmb250T2JqLmZvbnRNYXRyaXggfHwgX3V0aWwuRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgbGV0IGJvbGQgPSBcIm5vcm1hbFwiO1xuICAgIGlmIChmb250T2JqLmJsYWNrKSB7XG4gICAgICBib2xkID0gXCI5MDBcIjtcbiAgICB9IGVsc2UgaWYgKGZvbnRPYmouYm9sZCkge1xuICAgICAgYm9sZCA9IFwiYm9sZFwiO1xuICAgIH1cbiAgICBjb25zdCBpdGFsaWMgPSBmb250T2JqLml0YWxpYyA/IFwiaXRhbGljXCIgOiBcIm5vcm1hbFwiO1xuICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgc2l6ZSA9IC1zaXplO1xuICAgICAgY3VycmVudC5mb250RGlyZWN0aW9uID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IDE7XG4gICAgfVxuICAgIGN1cnJlbnQuZm9udFNpemUgPSBzaXplO1xuICAgIGN1cnJlbnQuZm9udEZhbWlseSA9IGZvbnRPYmoubG9hZGVkTmFtZTtcbiAgICBjdXJyZW50LmZvbnRXZWlnaHQgPSBib2xkO1xuICAgIGN1cnJlbnQuZm9udFN0eWxlID0gaXRhbGljO1xuICAgIGN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtY3VycmVudC55KSk7XG4gICAgY3VycmVudC54Y29vcmRzID0gW107XG4gICAgY3VycmVudC55Y29vcmRzID0gW107XG4gIH1cbiAgZW5kVGV4dCgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGlmIChjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEhfRkxBRyAmJiBjdXJyZW50LnR4dEVsZW1lbnQ/Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgY3VycmVudC5lbGVtZW50ID0gY3VycmVudC50eHRFbGVtZW50O1xuICAgICAgdGhpcy5jbGlwKFwibm9uemVyb1wiKTtcbiAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgIH1cbiAgfVxuICBzZXRMaW5lV2lkdGgod2lkdGgpIHtcbiAgICBpZiAod2lkdGggPiAwKSB7XG4gICAgICB0aGlzLmN1cnJlbnQubGluZVdpZHRoID0gd2lkdGg7XG4gICAgfVxuICB9XG4gIHNldExpbmVDYXAoc3R5bGUpIHtcbiAgICB0aGlzLmN1cnJlbnQubGluZUNhcCA9IExJTkVfQ0FQX1NUWUxFU1tzdHlsZV07XG4gIH1cbiAgc2V0TGluZUpvaW4oc3R5bGUpIHtcbiAgICB0aGlzLmN1cnJlbnQubGluZUpvaW4gPSBMSU5FX0pPSU5fU1RZTEVTW3N0eWxlXTtcbiAgfVxuICBzZXRNaXRlckxpbWl0KGxpbWl0KSB7XG4gICAgdGhpcy5jdXJyZW50Lm1pdGVyTGltaXQgPSBsaW1pdDtcbiAgfVxuICBzZXRTdHJva2VBbHBoYShzdHJva2VBbHBoYSkge1xuICAgIHRoaXMuY3VycmVudC5zdHJva2VBbHBoYSA9IHN0cm9rZUFscGhhO1xuICB9XG4gIHNldFN0cm9rZVJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcbiAgfVxuICBzZXRGaWxsQWxwaGEoZmlsbEFscGhhKSB7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxBbHBoYSA9IGZpbGxBbHBoYTtcbiAgfVxuICBzZXRGaWxsUkdCQ29sb3IociwgZywgYikge1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcbiAgICB0aGlzLmN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICB0aGlzLmN1cnJlbnQueGNvb3JkcyA9IFtdO1xuICAgIHRoaXMuY3VycmVudC55Y29vcmRzID0gW107XG4gIH1cbiAgc2V0U3Ryb2tlQ29sb3JOKGFyZ3MpIHtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSB0aGlzLl9tYWtlQ29sb3JOX1BhdHRlcm4oYXJncyk7XG4gIH1cbiAgc2V0RmlsbENvbG9yTihhcmdzKSB7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IHRoaXMuX21ha2VDb2xvck5fUGF0dGVybihhcmdzKTtcbiAgfVxuICBzaGFkaW5nRmlsbChhcmdzKSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy52aWV3cG9ydDtcbiAgICBjb25zdCBpbnYgPSBfdXRpbC5VdGlsLmludmVyc2VUcmFuc2Zvcm0odGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuICAgIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSBfdXRpbC5VdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSwgaW52KTtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCB4MCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgeTApO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCB4MSAtIHgwKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHkxIC0geTApO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIHRoaXMuX21ha2VTaGFkaW5nUGF0dGVybihhcmdzKSk7XG4gICAgaWYgKHRoaXMuY3VycmVudC5maWxsQWxwaGEgPCAxKSB7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbC1vcGFjaXR5XCIsIHRoaXMuY3VycmVudC5maWxsQWxwaGEpO1xuICAgIH1cbiAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZChyZWN0KTtcbiAgfVxuICBfbWFrZUNvbG9yTl9QYXR0ZXJuKGFyZ3MpIHtcbiAgICBpZiAoYXJnc1swXSA9PT0gXCJUaWxpbmdQYXR0ZXJuXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYWtlVGlsaW5nUGF0dGVybihhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTaGFkaW5nUGF0dGVybihhcmdzKTtcbiAgfVxuICBfbWFrZVRpbGluZ1BhdHRlcm4oYXJncykge1xuICAgIGNvbnN0IGNvbG9yID0gYXJnc1sxXTtcbiAgICBjb25zdCBvcGVyYXRvckxpc3QgPSBhcmdzWzJdO1xuICAgIGNvbnN0IG1hdHJpeCA9IGFyZ3NbM10gfHwgX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSBhcmdzWzRdO1xuICAgIGNvbnN0IHhzdGVwID0gYXJnc1s1XTtcbiAgICBjb25zdCB5c3RlcCA9IGFyZ3NbNl07XG4gICAgY29uc3QgcGFpbnRUeXBlID0gYXJnc1s3XTtcbiAgICBjb25zdCB0aWxpbmdJZCA9IGBzaGFkaW5nJHtzaGFkaW5nQ291bnQrK31gO1xuICAgIGNvbnN0IFt0eDAsIHR5MCwgdHgxLCB0eTFdID0gX3V0aWwuVXRpbC5ub3JtYWxpemVSZWN0KFsuLi5fdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt4MCwgeTBdLCBtYXRyaXgpLCAuLi5fdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt4MSwgeTFdLCBtYXRyaXgpXSk7XG4gICAgY29uc3QgW3hzY2FsZSwgeXNjYWxlXSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUobWF0cml4KTtcbiAgICBjb25zdCB0eHN0ZXAgPSB4c3RlcCAqIHhzY2FsZTtcbiAgICBjb25zdCB0eXN0ZXAgPSB5c3RlcCAqIHlzY2FsZTtcbiAgICBjb25zdCB0aWxpbmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpwYXR0ZXJuXCIpO1xuICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIHRpbGluZ0lkKTtcbiAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJwYXR0ZXJuVW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKTtcbiAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCB0eHN0ZXApO1xuICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCB0eXN0ZXApO1xuICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgYCR7dHgwfWApO1xuICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgYCR7dHkwfWApO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnO1xuICAgIGNvbnN0IHRyYW5zZm9ybU1hdHJpeCA9IHRoaXMudHJhbnNmb3JtTWF0cml4O1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3I7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUodHgxIC0gdHgwLCB0eTEgLSB0eTApO1xuICAgIHRoaXMuc3ZnID0gYmJveDtcbiAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IG1hdHJpeDtcbiAgICBpZiAocGFpbnRUeXBlID09PSAyKSB7XG4gICAgICBjb25zdCBjc3NDb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKC4uLmNvbG9yKTtcbiAgICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBjc3NDb2xvcjtcbiAgICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IGNzc0NvbG9yO1xuICAgIH1cbiAgICB0aGlzLmV4ZWN1dGVPcFRyZWUodGhpcy5jb252ZXJ0T3BMaXN0KG9wZXJhdG9yTGlzdCkpO1xuICAgIHRoaXMuc3ZnID0gc3ZnO1xuICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gdHJhbnNmb3JtTWF0cml4O1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBmaWxsQ29sb3I7XG4gICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gc3Ryb2tlQ29sb3I7XG4gICAgdGlsaW5nLmFwcGVuZChiYm94LmNoaWxkTm9kZXNbMF0pO1xuICAgIHRoaXMuZGVmcy5hcHBlbmQodGlsaW5nKTtcbiAgICByZXR1cm4gYHVybCgjJHt0aWxpbmdJZH0pYDtcbiAgfVxuICBfbWFrZVNoYWRpbmdQYXR0ZXJuKGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGFyZ3MgPSB0aGlzLm9ianMuZ2V0KGFyZ3MpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFyZ3NbMF0pIHtcbiAgICAgIGNhc2UgXCJSYWRpYWxBeGlhbFwiOlxuICAgICAgICBjb25zdCBzaGFkaW5nSWQgPSBgc2hhZGluZyR7c2hhZGluZ0NvdW50Kyt9YDtcbiAgICAgICAgY29uc3QgY29sb3JTdG9wcyA9IGFyZ3NbM107XG4gICAgICAgIGxldCBncmFkaWVudDtcbiAgICAgICAgc3dpdGNoIChhcmdzWzFdKSB7XG4gICAgICAgICAgY2FzZSBcImF4aWFsXCI6XG4gICAgICAgICAgICBjb25zdCBwb2ludDAgPSBhcmdzWzRdO1xuICAgICAgICAgICAgY29uc3QgcG9pbnQxID0gYXJnc1s1XTtcbiAgICAgICAgICAgIGdyYWRpZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6bGluZWFyR3JhZGllbnRcIik7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIHNoYWRpbmdJZCk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImdyYWRpZW50VW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieDFcIiwgcG9pbnQwWzBdKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieTFcIiwgcG9pbnQwWzFdKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieDJcIiwgcG9pbnQxWzBdKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieTJcIiwgcG9pbnQxWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJyYWRpYWxcIjpcbiAgICAgICAgICAgIGNvbnN0IGZvY2FsUG9pbnQgPSBhcmdzWzRdO1xuICAgICAgICAgICAgY29uc3QgY2lyY2xlUG9pbnQgPSBhcmdzWzVdO1xuICAgICAgICAgICAgY29uc3QgZm9jYWxSYWRpdXMgPSBhcmdzWzZdO1xuICAgICAgICAgICAgY29uc3QgY2lyY2xlUmFkaXVzID0gYXJnc1s3XTtcbiAgICAgICAgICAgIGdyYWRpZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmFkaWFsR3JhZGllbnRcIik7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIHNoYWRpbmdJZCk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImdyYWRpZW50VW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3hcIiwgY2lyY2xlUG9pbnRbMF0pO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjeVwiLCBjaXJjbGVQb2ludFsxXSk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInJcIiwgY2lyY2xlUmFkaXVzKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZnhcIiwgZm9jYWxQb2ludFswXSk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZ5XCIsIGZvY2FsUG9pbnRbMV0pO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmclwiLCBmb2NhbFJhZGl1cyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFJhZGlhbEF4aWFsIHR5cGU6ICR7YXJnc1sxXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNvbG9yU3RvcCBvZiBjb2xvclN0b3BzKSB7XG4gICAgICAgICAgY29uc3Qgc3RvcCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnN0b3BcIik7XG4gICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIm9mZnNldFwiLCBjb2xvclN0b3BbMF0pO1xuICAgICAgICAgIHN0b3Auc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdG9wLWNvbG9yXCIsIGNvbG9yU3RvcFsxXSk7XG4gICAgICAgICAgZ3JhZGllbnQuYXBwZW5kKHN0b3ApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVmcy5hcHBlbmQoZ3JhZGllbnQpO1xuICAgICAgICByZXR1cm4gYHVybCgjJHtzaGFkaW5nSWR9KWA7XG4gICAgICBjYXNlIFwiTWVzaFwiOlxuICAgICAgICAoMCwgX3V0aWwud2FybikoXCJVbmltcGxlbWVudGVkIHBhdHRlcm4gTWVzaFwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIFwiRHVtbXlcIjpcbiAgICAgICAgcmV0dXJuIFwiaG90cGlua1wiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIElSIHR5cGU6ICR7YXJnc1swXX1gKTtcbiAgICB9XG4gIH1cbiAgc2V0RGFzaChkYXNoQXJyYXksIGRhc2hQaGFzZSkge1xuICAgIHRoaXMuY3VycmVudC5kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG4gICAgdGhpcy5jdXJyZW50LmRhc2hQaGFzZSA9IGRhc2hQaGFzZTtcbiAgfVxuICBjb25zdHJ1Y3RQYXRoKG9wcywgYXJncykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgbGV0IHggPSBjdXJyZW50LngsXG4gICAgICB5ID0gY3VycmVudC55O1xuICAgIGxldCBkID0gW107XG4gICAgbGV0IGogPSAwO1xuICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICBzd2l0Y2ggKG9wIHwgMCkge1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5yZWN0YW5nbGU6XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gYXJnc1tqKytdO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCB4dyA9IHggKyB3aWR0aDtcbiAgICAgICAgICBjb25zdCB5aCA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgZC5wdXNoKFwiTVwiLCBwZih4KSwgcGYoeSksIFwiTFwiLCBwZih4dyksIHBmKHkpLCBcIkxcIiwgcGYoeHcpLCBwZih5aCksIFwiTFwiLCBwZih4KSwgcGYoeWgpLCBcIlpcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLm1vdmVUbzpcbiAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgZC5wdXNoKFwiTVwiLCBwZih4KSwgcGYoeSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5saW5lVG86XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGQucHVzaChcIkxcIiwgcGYoeCksIHBmKHkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzpcbiAgICAgICAgICB4ID0gYXJnc1tqICsgNF07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDVdO1xuICAgICAgICAgIGQucHVzaChcIkNcIiwgcGYoYXJnc1tqXSksIHBmKGFyZ3NbaiArIDFdKSwgcGYoYXJnc1tqICsgMl0pLCBwZihhcmdzW2ogKyAzXSksIHBmKHgpLCBwZih5KSk7XG4gICAgICAgICAgaiArPSA2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvMjpcbiAgICAgICAgICBkLnB1c2goXCJDXCIsIHBmKHgpLCBwZih5KSwgcGYoYXJnc1tqXSksIHBmKGFyZ3NbaiArIDFdKSwgcGYoYXJnc1tqICsgMl0pLCBwZihhcmdzW2ogKyAzXSkpO1xuICAgICAgICAgIHggPSBhcmdzW2ogKyAyXTtcbiAgICAgICAgICB5ID0gYXJnc1tqICsgM107XG4gICAgICAgICAgaiArPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvMzpcbiAgICAgICAgICB4ID0gYXJnc1tqICsgMl07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDNdO1xuICAgICAgICAgIGQucHVzaChcIkNcIiwgcGYoYXJnc1tqXSksIHBmKGFyZ3NbaiArIDFdKSwgcGYoeCksIHBmKHkpLCBwZih4KSwgcGYoeSkpO1xuICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VQYXRoOlxuICAgICAgICAgIGQucHVzaChcIlpcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGQgPSBkLmpvaW4oXCIgXCIpO1xuICAgIGlmIChjdXJyZW50LnBhdGggJiYgb3BzLmxlbmd0aCA+IDAgJiYgb3BzWzBdICE9PSBfdXRpbC5PUFMucmVjdGFuZ2xlICYmIG9wc1swXSAhPT0gX3V0aWwuT1BTLm1vdmVUbykge1xuICAgICAgZCA9IGN1cnJlbnQucGF0aC5nZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRcIikgKyBkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnBhdGggPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpwYXRoXCIpO1xuICAgICAgdGhpcy5fZW5zdXJlVHJhbnNmb3JtR3JvdXAoKS5hcHBlbmQoY3VycmVudC5wYXRoKTtcbiAgICB9XG4gICAgY3VycmVudC5wYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBkKTtcbiAgICBjdXJyZW50LnBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICBjdXJyZW50LmVsZW1lbnQgPSBjdXJyZW50LnBhdGg7XG4gICAgY3VycmVudC5zZXRDdXJyZW50UG9pbnQoeCwgeSk7XG4gIH1cbiAgZW5kUGF0aCgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGN1cnJlbnQucGF0aCA9IG51bGw7XG4gICAgaWYgKCF0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY3VycmVudC5lbGVtZW50KSB7XG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2xpcElkID0gYGNsaXBwYXRoJHtjbGlwQ291bnQrK31gO1xuICAgIGNvbnN0IGNsaXBQYXRoID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Y2xpcFBhdGhcIik7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiLCBjbGlwSWQpO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIHBtKHRoaXMudHJhbnNmb3JtTWF0cml4KSk7XG4gICAgY29uc3QgY2xpcEVsZW1lbnQgPSBjdXJyZW50LmVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwID09PSBcImV2ZW5vZGRcIikge1xuICAgICAgY2xpcEVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGlwLXJ1bGVcIiwgXCJldmVub2RkXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGlwRWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsaXAtcnVsZVwiLCBcIm5vbnplcm9cIik7XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIGNsaXBQYXRoLmFwcGVuZChjbGlwRWxlbWVudCk7XG4gICAgdGhpcy5kZWZzLmFwcGVuZChjbGlwUGF0aCk7XG4gICAgaWYgKGN1cnJlbnQuYWN0aXZlQ2xpcFVybCkge1xuICAgICAgY3VycmVudC5jbGlwR3JvdXAgPSBudWxsO1xuICAgICAgZm9yIChjb25zdCBwcmV2IG9mIHRoaXMuZXh0cmFTdGFjaykge1xuICAgICAgICBwcmV2LmNsaXBHcm91cCA9IG51bGw7XG4gICAgICB9XG4gICAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsaXAtcGF0aFwiLCBjdXJyZW50LmFjdGl2ZUNsaXBVcmwpO1xuICAgIH1cbiAgICBjdXJyZW50LmFjdGl2ZUNsaXBVcmwgPSBgdXJsKCMke2NsaXBJZH0pYDtcbiAgICB0aGlzLnRncnAgPSBudWxsO1xuICB9XG4gIGNsaXAodHlwZSkge1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSB0eXBlO1xuICB9XG4gIGNsb3NlUGF0aCgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGlmIChjdXJyZW50LnBhdGgpIHtcbiAgICAgIGNvbnN0IGQgPSBgJHtjdXJyZW50LnBhdGguZ2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIpfVpgO1xuICAgICAgY3VycmVudC5wYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBkKTtcbiAgICB9XG4gIH1cbiAgc2V0TGVhZGluZyhsZWFkaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LmxlYWRpbmcgPSAtbGVhZGluZztcbiAgfVxuICBzZXRUZXh0UmlzZSh0ZXh0UmlzZSkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0UmlzZSA9IHRleHRSaXNlO1xuICB9XG4gIHNldFRleHRSZW5kZXJpbmdNb2RlKHRleHRSZW5kZXJpbmdNb2RlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID0gdGV4dFJlbmRlcmluZ01vZGU7XG4gIH1cbiAgc2V0SFNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRIU2NhbGUgPSBzY2FsZSAvIDEwMDtcbiAgfVxuICBzZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50KSB7fVxuICBzZXRGbGF0bmVzcyhmbGF0bmVzcykge31cbiAgc2V0R1N0YXRlKHN0YXRlcykge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHN0YXRlcykge1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcIkxXXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lV2lkdGgodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTENcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVDYXAodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTEpcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVKb2luKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1MXCI6XG4gICAgICAgICAgdGhpcy5zZXRNaXRlckxpbWl0KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICB0aGlzLnNldERhc2godmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlJJXCI6XG4gICAgICAgICAgdGhpcy5zZXRSZW5kZXJpbmdJbnRlbnQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRkxcIjpcbiAgICAgICAgICB0aGlzLnNldEZsYXRuZXNzKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZvbnRcIjpcbiAgICAgICAgICB0aGlzLnNldEZvbnQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ0FcIjpcbiAgICAgICAgICB0aGlzLnNldFN0cm9rZUFscGhhKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhXCI6XG4gICAgICAgICAgdGhpcy5zZXRGaWxsQWxwaGEodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgVW5pbXBsZW1lbnRlZCBncmFwaGljIHN0YXRlIG9wZXJhdG9yICR7a2V5fWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaWxsKCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJlbnQuZWxlbWVudCkge1xuICAgICAgY3VycmVudC5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBjdXJyZW50LmZpbGxDb2xvcik7XG4gICAgICBjdXJyZW50LmVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLW9wYWNpdHlcIiwgY3VycmVudC5maWxsQWxwaGEpO1xuICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgfVxuICB9XG4gIHN0cm9rZSgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGlmIChjdXJyZW50LmVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0cm9rZUF0dHJpYnV0ZXMoY3VycmVudC5lbGVtZW50KTtcbiAgICAgIGN1cnJlbnQuZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgfVxuICB9XG4gIF9zZXRTdHJva2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGxpbmVXaWR0aFNjYWxlID0gMSkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgbGV0IGRhc2hBcnJheSA9IGN1cnJlbnQuZGFzaEFycmF5O1xuICAgIGlmIChsaW5lV2lkdGhTY2FsZSAhPT0gMSAmJiBkYXNoQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgZGFzaEFycmF5ID0gZGFzaEFycmF5Lm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGxpbmVXaWR0aFNjYWxlICogdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZVwiLCBjdXJyZW50LnN0cm9rZUNvbG9yKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLW9wYWNpdHlcIiwgY3VycmVudC5zdHJva2VBbHBoYSk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS1taXRlcmxpbWl0XCIsIHBmKGN1cnJlbnQubWl0ZXJMaW1pdCkpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2UtbGluZWNhcFwiLCBjdXJyZW50LmxpbmVDYXApO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2UtbGluZWpvaW5cIiwgY3VycmVudC5saW5lSm9pbik7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS13aWR0aFwiLCBwZihsaW5lV2lkdGhTY2FsZSAqIGN1cnJlbnQubGluZVdpZHRoKSArIFwicHhcIik7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS1kYXNoYXJyYXlcIiwgZGFzaEFycmF5Lm1hcChwZikuam9pbihcIiBcIikpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2UtZGFzaG9mZnNldFwiLCBwZihsaW5lV2lkdGhTY2FsZSAqIGN1cnJlbnQuZGFzaFBoYXNlKSArIFwicHhcIik7XG4gIH1cbiAgZW9GaWxsKCkge1xuICAgIHRoaXMuY3VycmVudC5lbGVtZW50Py5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGwtcnVsZVwiLCBcImV2ZW5vZGRcIik7XG4gICAgdGhpcy5maWxsKCk7XG4gIH1cbiAgZmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLnN0cm9rZSgpO1xuICAgIHRoaXMuZmlsbCgpO1xuICB9XG4gIGVvRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLmN1cnJlbnQuZWxlbWVudD8uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLXJ1bGVcIiwgXCJldmVub2RkXCIpO1xuICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICB9XG4gIGNsb3NlU3Ryb2tlKCkge1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5zdHJva2UoKTtcbiAgfVxuICBjbG9zZUZpbGxTdHJva2UoKSB7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgfVxuICBjbG9zZUVPRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuZW9GaWxsU3Ryb2tlKCk7XG4gIH1cbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrKCkge1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIFwiMFwiKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBcIjBcIik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIFwiMXB4XCIpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgXCIxcHhcIik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgdGhpcy5jdXJyZW50LmZpbGxDb2xvcik7XG4gICAgdGhpcy5fZW5zdXJlVHJhbnNmb3JtR3JvdXAoKS5hcHBlbmQocmVjdCk7XG4gIH1cbiAgcGFpbnRJbWFnZVhPYmplY3Qob2JqSWQpIHtcbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3Qob2JqSWQpO1xuICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKGBEZXBlbmRlbnQgaW1hZ2Ugd2l0aCBvYmplY3QgSUQgJHtvYmpJZH0gaXMgbm90IHJlYWR5IHlldGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGltZ0RhdGEpO1xuICB9XG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGltZ0RhdGEsIG1hc2spIHtcbiAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgaW1nU3JjID0gY29udmVydEltZ0RhdGFUb1BuZyhpbWdEYXRhLCB0aGlzLmZvcmNlRGF0YVNjaGVtYSwgISFtYXNrKTtcbiAgICBjb25zdCBjbGlwcmVjdCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIFwiMFwiKTtcbiAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgXCIwXCIpO1xuICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgcGYod2lkdGgpKTtcbiAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBwZihoZWlnaHQpKTtcbiAgICB0aGlzLmN1cnJlbnQuZWxlbWVudCA9IGNsaXByZWN0O1xuICAgIHRoaXMuY2xpcChcIm5vbnplcm9cIik7XG4gICAgY29uc3QgaW1nRWwgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzppbWFnZVwiKTtcbiAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhYTElOS19OUywgXCJ4bGluazpocmVmXCIsIGltZ1NyYyk7XG4gICAgaW1nRWwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIFwiMFwiKTtcbiAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgcGYoLWhlaWdodCkpO1xuICAgIGltZ0VsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgcGYod2lkdGgpICsgXCJweFwiKTtcbiAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBwZihoZWlnaHQpICsgXCJweFwiKTtcbiAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBgc2NhbGUoJHtwZigxIC8gd2lkdGgpfSAke3BmKC0xIC8gaGVpZ2h0KX0pYCk7XG4gICAgaWYgKG1hc2spIHtcbiAgICAgIG1hc2suYXBwZW5kKGltZ0VsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZW5zdXJlVHJhbnNmb3JtR3JvdXAoKS5hcHBlbmQoaW1nRWwpO1xuICAgIH1cbiAgfVxuICBwYWludEltYWdlTWFza1hPYmplY3QoaW1nKSB7XG4gICAgY29uc3QgaW1nRGF0YSA9IHRoaXMuZ2V0T2JqZWN0KGltZy5kYXRhLCBpbWcpO1xuICAgIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwicGFpbnRJbWFnZU1hc2tYT2JqZWN0OiBJbWFnZUJpdG1hcCBzdXBwb3J0IGlzIG5vdCBpbXBsZW1lbnRlZCwgXCIgKyBcImVuc3VyZSB0aGF0IHRoZSBgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWRgIEFQSSBwYXJhbWV0ZXIgaXMgZGlzYWJsZWQuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBmaWxsQ29sb3IgPSBjdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjdXJyZW50Lm1hc2tJZCA9IGBtYXNrJHttYXNrQ291bnQrK31gO1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzptYXNrXCIpO1xuICAgIG1hc2suc2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiLCBjdXJyZW50Lm1hc2tJZCk7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgXCIwXCIpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIFwiMFwiKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgcGYod2lkdGgpKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHBmKGhlaWdodCkpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIGZpbGxDb2xvcik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIm1hc2tcIiwgYHVybCgjJHtjdXJyZW50Lm1hc2tJZH0pYCk7XG4gICAgdGhpcy5kZWZzLmFwcGVuZChtYXNrKTtcbiAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZChyZWN0KTtcbiAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGltZ0RhdGEsIG1hc2spO1xuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbihtYXRyaXgsIGJib3gpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRyaXgpICYmIG1hdHJpeC5sZW5ndGggPT09IDYpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKG1hdHJpeFswXSwgbWF0cml4WzFdLCBtYXRyaXhbMl0sIG1hdHJpeFszXSwgbWF0cml4WzRdLCBtYXRyaXhbNV0pO1xuICAgIH1cbiAgICBpZiAoYmJveCkge1xuICAgICAgY29uc3Qgd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGJib3hbM10gLSBiYm94WzFdO1xuICAgICAgY29uc3QgY2xpcHJlY3QgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIGJib3hbMF0pO1xuICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIGJib3hbMV0pO1xuICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBwZih3aWR0aCkpO1xuICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgcGYoaGVpZ2h0KSk7XG4gICAgICB0aGlzLmN1cnJlbnQuZWxlbWVudCA9IGNsaXByZWN0O1xuICAgICAgdGhpcy5jbGlwKFwibm9uemVyb1wiKTtcbiAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgIH1cbiAgfVxuICBwYWludEZvcm1YT2JqZWN0RW5kKCkge31cbiAgX2luaXRpYWxpemUodmlld3BvcnQpIHtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHZpZXdwb3J0LndpZHRoLCB2aWV3cG9ydC5oZWlnaHQpO1xuICAgIGNvbnN0IGRlZmluaXRpb25zID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6ZGVmc1wiKTtcbiAgICBzdmcuYXBwZW5kKGRlZmluaXRpb25zKTtcbiAgICB0aGlzLmRlZnMgPSBkZWZpbml0aW9ucztcbiAgICBjb25zdCByb290R3JvdXAgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpnXCIpO1xuICAgIHJvb3RHcm91cC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBwbSh2aWV3cG9ydC50cmFuc2Zvcm0pKTtcbiAgICBzdmcuYXBwZW5kKHJvb3RHcm91cCk7XG4gICAgdGhpcy5zdmcgPSByb290R3JvdXA7XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuICBfZW5zdXJlQ2xpcEdyb3VwKCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50LmNsaXBHcm91cCkge1xuICAgICAgY29uc3QgY2xpcEdyb3VwID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Z1wiKTtcbiAgICAgIGNsaXBHcm91cC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsaXAtcGF0aFwiLCB0aGlzLmN1cnJlbnQuYWN0aXZlQ2xpcFVybCk7XG4gICAgICB0aGlzLnN2Zy5hcHBlbmQoY2xpcEdyb3VwKTtcbiAgICAgIHRoaXMuY3VycmVudC5jbGlwR3JvdXAgPSBjbGlwR3JvdXA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1cnJlbnQuY2xpcEdyb3VwO1xuICB9XG4gIF9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpIHtcbiAgICBpZiAoIXRoaXMudGdycCkge1xuICAgICAgdGhpcy50Z3JwID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Z1wiKTtcbiAgICAgIHRoaXMudGdycC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBwbSh0aGlzLnRyYW5zZm9ybU1hdHJpeCkpO1xuICAgICAgaWYgKHRoaXMuY3VycmVudC5hY3RpdmVDbGlwVXJsKSB7XG4gICAgICAgIHRoaXMuX2Vuc3VyZUNsaXBHcm91cCgpLmFwcGVuZCh0aGlzLnRncnApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdmcuYXBwZW5kKHRoaXMudGdycCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRncnA7XG4gIH1cbn1cbmV4cG9ydHMuU1ZHR3JhcGhpY3MgPSBTVkdHcmFwaGljcztcblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5YZmFUZXh0ID0gdm9pZCAwO1xuY2xhc3MgWGZhVGV4dCB7XG4gIHN0YXRpYyB0ZXh0Q29udGVudCh4ZmEpIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIGl0ZW1zLFxuICAgICAgc3R5bGVzOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcbiAgICBmdW5jdGlvbiB3YWxrKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3RyID0gbnVsbDtcbiAgICAgIGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICBpZiAobmFtZSA9PT0gXCIjdGV4dFwiKSB7XG4gICAgICAgIHN0ciA9IG5vZGUudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKCFYZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKG5vZGU/LmF0dHJpYnV0ZXM/LnRleHRDb250ZW50KSB7XG4gICAgICAgIHN0ciA9IG5vZGUuYXR0cmlidXRlcy50ZXh0Q29udGVudDtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgICBzdHIgPSBub2RlLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0ciAhPT0gbnVsbCkge1xuICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICBzdHJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHdhbGsoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICB3YWxrKHhmYSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICBzdGF0aWMgc2hvdWxkQnVpbGRUZXh0KG5hbWUpIHtcbiAgICByZXR1cm4gIShuYW1lID09PSBcInRleHRhcmVhXCIgfHwgbmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwib3B0aW9uXCIgfHwgbmFtZSA9PT0gXCJzZWxlY3RcIik7XG4gIH1cbn1cbmV4cG9ydHMuWGZhVGV4dCA9IFhmYVRleHQ7XG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuVGV4dExheWVyUmVuZGVyVGFzayA9IHZvaWQgMDtcbmV4cG9ydHMucmVuZGVyVGV4dExheWVyID0gcmVuZGVyVGV4dExheWVyO1xuZXhwb3J0cy51cGRhdGVUZXh0TGF5ZXIgPSB1cGRhdGVUZXh0TGF5ZXI7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbmNvbnN0IE1BWF9URVhUX0RJVlNfVE9fUkVOREVSID0gMTAwMDAwO1xuY29uc3QgREVGQVVMVF9GT05UX1NJWkUgPSAzMDtcbmNvbnN0IERFRkFVTFRfRk9OVF9BU0NFTlQgPSAwLjg7XG5jb25zdCBhc2NlbnRDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldEN0eChzaXplLCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCkge1xuICBsZXQgY3R4O1xuICBpZiAoaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgJiYgX3V0aWwuRmVhdHVyZVRlc3QuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpIHtcbiAgICBjdHggPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHNpemUsIHNpemUpLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICBhbHBoYTogZmFsc2VcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSBzaXplO1xuICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgYWxwaGE6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGN0eDtcbn1cbmZ1bmN0aW9uIGdldEFzY2VudChmb250RmFtaWx5LCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCkge1xuICBjb25zdCBjYWNoZWRBc2NlbnQgPSBhc2NlbnRDYWNoZS5nZXQoZm9udEZhbWlseSk7XG4gIGlmIChjYWNoZWRBc2NlbnQpIHtcbiAgICByZXR1cm4gY2FjaGVkQXNjZW50O1xuICB9XG4gIGNvbnN0IGN0eCA9IGdldEN0eChERUZBVUxUX0ZPTlRfU0laRSwgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpO1xuICBjdHguZm9udCA9IGAke0RFRkFVTFRfRk9OVF9TSVpFfXB4ICR7Zm9udEZhbWlseX1gO1xuICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KFwiXCIpO1xuICBsZXQgYXNjZW50ID0gbWV0cmljcy5mb250Qm91bmRpbmdCb3hBc2NlbnQ7XG4gIGxldCBkZXNjZW50ID0gTWF0aC5hYnMobWV0cmljcy5mb250Qm91bmRpbmdCb3hEZXNjZW50KTtcbiAgaWYgKGFzY2VudCkge1xuICAgIGNvbnN0IHJhdGlvID0gYXNjZW50IC8gKGFzY2VudCArIGRlc2NlbnQpO1xuICAgIGFzY2VudENhY2hlLnNldChmb250RmFtaWx5LCByYXRpbyk7XG4gICAgY3R4LmNhbnZhcy53aWR0aCA9IGN0eC5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICByZXR1cm4gcmF0aW87XG4gIH1cbiAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZWRcIjtcbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBERUZBVUxUX0ZPTlRfU0laRSwgREVGQVVMVF9GT05UX1NJWkUpO1xuICBjdHguc3Ryb2tlVGV4dChcImdcIiwgMCwgMCk7XG4gIGxldCBwaXhlbHMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIERFRkFVTFRfRk9OVF9TSVpFLCBERUZBVUxUX0ZPTlRfU0laRSkuZGF0YTtcbiAgZGVzY2VudCA9IDA7XG4gIGZvciAobGV0IGkgPSBwaXhlbHMubGVuZ3RoIC0gMSAtIDM7IGkgPj0gMDsgaSAtPSA0KSB7XG4gICAgaWYgKHBpeGVsc1tpXSA+IDApIHtcbiAgICAgIGRlc2NlbnQgPSBNYXRoLmNlaWwoaSAvIDQgLyBERUZBVUxUX0ZPTlRfU0laRSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBERUZBVUxUX0ZPTlRfU0laRSwgREVGQVVMVF9GT05UX1NJWkUpO1xuICBjdHguc3Ryb2tlVGV4dChcIkFcIiwgMCwgREVGQVVMVF9GT05UX1NJWkUpO1xuICBwaXhlbHMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIERFRkFVTFRfRk9OVF9TSVpFLCBERUZBVUxUX0ZPTlRfU0laRSkuZGF0YTtcbiAgYXNjZW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gcGl4ZWxzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDQpIHtcbiAgICBpZiAocGl4ZWxzW2ldID4gMCkge1xuICAgICAgYXNjZW50ID0gREVGQVVMVF9GT05UX1NJWkUgLSBNYXRoLmZsb29yKGkgLyA0IC8gREVGQVVMVF9GT05UX1NJWkUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGN0eC5jYW52YXMud2lkdGggPSBjdHguY2FudmFzLmhlaWdodCA9IDA7XG4gIGlmIChhc2NlbnQpIHtcbiAgICBjb25zdCByYXRpbyA9IGFzY2VudCAvIChhc2NlbnQgKyBkZXNjZW50KTtcbiAgICBhc2NlbnRDYWNoZS5zZXQoZm9udEZhbWlseSwgcmF0aW8pO1xuICAgIHJldHVybiByYXRpbztcbiAgfVxuICBhc2NlbnRDYWNoZS5zZXQoZm9udEZhbWlseSwgREVGQVVMVF9GT05UX0FTQ0VOVCk7XG4gIHJldHVybiBERUZBVUxUX0ZPTlRfQVNDRU5UO1xufVxuZnVuY3Rpb24gYXBwZW5kVGV4dCh0YXNrLCBnZW9tLCBzdHlsZXMpIHtcbiAgY29uc3QgdGV4dERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICBjb25zdCB0ZXh0RGl2UHJvcGVydGllcyA9IHtcbiAgICBhbmdsZTogMCxcbiAgICBjYW52YXNXaWR0aDogMCxcbiAgICBoYXNUZXh0OiBnZW9tLnN0ciAhPT0gXCJcIixcbiAgICBoYXNFT0w6IGdlb20uaGFzRU9MLFxuICAgIGZvbnRTaXplOiAwXG4gIH07XG4gIHRhc2suX3RleHREaXZzLnB1c2godGV4dERpdik7XG4gIGNvbnN0IHR4ID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0odGFzay5fdHJhbnNmb3JtLCBnZW9tLnRyYW5zZm9ybSk7XG4gIGxldCBhbmdsZSA9IE1hdGguYXRhbjIodHhbMV0sIHR4WzBdKTtcbiAgY29uc3Qgc3R5bGUgPSBzdHlsZXNbZ2VvbS5mb250TmFtZV07XG4gIGlmIChzdHlsZS52ZXJ0aWNhbCkge1xuICAgIGFuZ2xlICs9IE1hdGguUEkgLyAyO1xuICB9XG4gIGNvbnN0IGZvbnRIZWlnaHQgPSBNYXRoLmh5cG90KHR4WzJdLCB0eFszXSk7XG4gIGNvbnN0IGZvbnRBc2NlbnQgPSBmb250SGVpZ2h0ICogZ2V0QXNjZW50KHN0eWxlLmZvbnRGYW1pbHksIHRhc2suX2lzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKTtcbiAgbGV0IGxlZnQsIHRvcDtcbiAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgbGVmdCA9IHR4WzRdO1xuICAgIHRvcCA9IHR4WzVdIC0gZm9udEFzY2VudDtcbiAgfSBlbHNlIHtcbiAgICBsZWZ0ID0gdHhbNF0gKyBmb250QXNjZW50ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgIHRvcCA9IHR4WzVdIC0gZm9udEFzY2VudCAqIE1hdGguY29zKGFuZ2xlKTtcbiAgfVxuICBjb25zdCBzY2FsZUZhY3RvclN0ciA9IFwiY2FsYyh2YXIoLS1zY2FsZS1mYWN0b3IpKlwiO1xuICBjb25zdCBkaXZTdHlsZSA9IHRleHREaXYuc3R5bGU7XG4gIGlmICh0YXNrLl9jb250YWluZXIgPT09IHRhc2suX3Jvb3RDb250YWluZXIpIHtcbiAgICBkaXZTdHlsZS5sZWZ0ID0gYCR7KDEwMCAqIGxlZnQgLyB0YXNrLl9wYWdlV2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgZGl2U3R5bGUudG9wID0gYCR7KDEwMCAqIHRvcCAvIHRhc2suX3BhZ2VIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gIH0gZWxzZSB7XG4gICAgZGl2U3R5bGUubGVmdCA9IGAke3NjYWxlRmFjdG9yU3RyfSR7bGVmdC50b0ZpeGVkKDIpfXB4KWA7XG4gICAgZGl2U3R5bGUudG9wID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHt0b3AudG9GaXhlZCgyKX1weClgO1xuICB9XG4gIGRpdlN0eWxlLmZvbnRTaXplID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHtmb250SGVpZ2h0LnRvRml4ZWQoMil9cHgpYDtcbiAgZGl2U3R5bGUuZm9udEZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHk7XG4gIHRleHREaXZQcm9wZXJ0aWVzLmZvbnRTaXplID0gZm9udEhlaWdodDtcbiAgdGV4dERpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuICB0ZXh0RGl2LnRleHRDb250ZW50ID0gZ2VvbS5zdHI7XG4gIHRleHREaXYuZGlyID0gZ2VvbS5kaXI7XG4gIGlmICh0YXNrLl9mb250SW5zcGVjdG9yRW5hYmxlZCkge1xuICAgIHRleHREaXYuZGF0YXNldC5mb250TmFtZSA9IGdlb20uZm9udE5hbWU7XG4gIH1cbiAgaWYgKGFuZ2xlICE9PSAwKSB7XG4gICAgdGV4dERpdlByb3BlcnRpZXMuYW5nbGUgPSBhbmdsZSAqICgxODAgLyBNYXRoLlBJKTtcbiAgfVxuICBsZXQgc2hvdWxkU2NhbGVUZXh0ID0gZmFsc2U7XG4gIGlmIChnZW9tLnN0ci5sZW5ndGggPiAxKSB7XG4gICAgc2hvdWxkU2NhbGVUZXh0ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChnZW9tLnN0ciAhPT0gXCIgXCIgJiYgZ2VvbS50cmFuc2Zvcm1bMF0gIT09IGdlb20udHJhbnNmb3JtWzNdKSB7XG4gICAgY29uc3QgYWJzU2NhbGVYID0gTWF0aC5hYnMoZ2VvbS50cmFuc2Zvcm1bMF0pLFxuICAgICAgYWJzU2NhbGVZID0gTWF0aC5hYnMoZ2VvbS50cmFuc2Zvcm1bM10pO1xuICAgIGlmIChhYnNTY2FsZVggIT09IGFic1NjYWxlWSAmJiBNYXRoLm1heChhYnNTY2FsZVgsIGFic1NjYWxlWSkgLyBNYXRoLm1pbihhYnNTY2FsZVgsIGFic1NjYWxlWSkgPiAxLjUpIHtcbiAgICAgIHNob3VsZFNjYWxlVGV4dCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChzaG91bGRTY2FsZVRleHQpIHtcbiAgICB0ZXh0RGl2UHJvcGVydGllcy5jYW52YXNXaWR0aCA9IHN0eWxlLnZlcnRpY2FsID8gZ2VvbS5oZWlnaHQgOiBnZW9tLndpZHRoO1xuICB9XG4gIHRhc2suX3RleHREaXZQcm9wZXJ0aWVzLnNldCh0ZXh0RGl2LCB0ZXh0RGl2UHJvcGVydGllcyk7XG4gIGlmICh0YXNrLl9pc1JlYWRhYmxlU3RyZWFtKSB7XG4gICAgdGFzay5fbGF5b3V0VGV4dCh0ZXh0RGl2KTtcbiAgfVxufVxuZnVuY3Rpb24gbGF5b3V0KHBhcmFtcykge1xuICBjb25zdCB7XG4gICAgZGl2LFxuICAgIHNjYWxlLFxuICAgIHByb3BlcnRpZXMsXG4gICAgY3R4LFxuICAgIHByZXZGb250U2l6ZSxcbiAgICBwcmV2Rm9udEZhbWlseVxuICB9ID0gcGFyYW1zO1xuICBjb25zdCB7XG4gICAgc3R5bGVcbiAgfSA9IGRpdjtcbiAgbGV0IHRyYW5zZm9ybSA9IFwiXCI7XG4gIGlmIChwcm9wZXJ0aWVzLmNhbnZhc1dpZHRoICE9PSAwICYmIHByb3BlcnRpZXMuaGFzVGV4dCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZvbnRGYW1pbHlcbiAgICB9ID0gc3R5bGU7XG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzV2lkdGgsXG4gICAgICBmb250U2l6ZVxuICAgIH0gPSBwcm9wZXJ0aWVzO1xuICAgIGlmIChwcmV2Rm9udFNpemUgIT09IGZvbnRTaXplIHx8IHByZXZGb250RmFtaWx5ICE9PSBmb250RmFtaWx5KSB7XG4gICAgICBjdHguZm9udCA9IGAke2ZvbnRTaXplICogc2NhbGV9cHggJHtmb250RmFtaWx5fWA7XG4gICAgICBwYXJhbXMucHJldkZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICBwYXJhbXMucHJldkZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB3aWR0aFxuICAgIH0gPSBjdHgubWVhc3VyZVRleHQoZGl2LnRleHRDb250ZW50KTtcbiAgICBpZiAod2lkdGggPiAwKSB7XG4gICAgICB0cmFuc2Zvcm0gPSBgc2NhbGVYKCR7Y2FudmFzV2lkdGggKiBzY2FsZSAvIHdpZHRofSlgO1xuICAgIH1cbiAgfVxuICBpZiAocHJvcGVydGllcy5hbmdsZSAhPT0gMCkge1xuICAgIHRyYW5zZm9ybSA9IGByb3RhdGUoJHtwcm9wZXJ0aWVzLmFuZ2xlfWRlZykgJHt0cmFuc2Zvcm19YDtcbiAgfVxuICBpZiAodHJhbnNmb3JtLmxlbmd0aCA+IDApIHtcbiAgICBzdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbmRlcih0YXNrKSB7XG4gIGlmICh0YXNrLl9jYW5jZWxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0ZXh0RGl2cyA9IHRhc2suX3RleHREaXZzO1xuICBjb25zdCBjYXBhYmlsaXR5ID0gdGFzay5fY2FwYWJpbGl0eTtcbiAgY29uc3QgdGV4dERpdnNMZW5ndGggPSB0ZXh0RGl2cy5sZW5ndGg7XG4gIGlmICh0ZXh0RGl2c0xlbmd0aCA+IE1BWF9URVhUX0RJVlNfVE9fUkVOREVSKSB7XG4gICAgY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghdGFzay5faXNSZWFkYWJsZVN0cmVhbSkge1xuICAgIGZvciAoY29uc3QgdGV4dERpdiBvZiB0ZXh0RGl2cykge1xuICAgICAgdGFzay5fbGF5b3V0VGV4dCh0ZXh0RGl2KTtcbiAgICB9XG4gIH1cbiAgY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG59XG5jbGFzcyBUZXh0TGF5ZXJSZW5kZXJUYXNrIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRleHRDb250ZW50U291cmNlLFxuICAgIGNvbnRhaW5lcixcbiAgICB2aWV3cG9ydCxcbiAgICB0ZXh0RGl2cyxcbiAgICB0ZXh0RGl2UHJvcGVydGllcyxcbiAgICB0ZXh0Q29udGVudEl0ZW1zU3RyLFxuICAgIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkXG4gIH0pIHtcbiAgICB0aGlzLl90ZXh0Q29udGVudFNvdXJjZSA9IHRleHRDb250ZW50U291cmNlO1xuICAgIHRoaXMuX2lzUmVhZGFibGVTdHJlYW0gPSB0ZXh0Q29udGVudFNvdXJjZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IHRoaXMuX3Jvb3RDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5fdGV4dERpdnMgPSB0ZXh0RGl2cyB8fCBbXTtcbiAgICB0aGlzLl90ZXh0Q29udGVudEl0ZW1zU3RyID0gdGV4dENvbnRlbnRJdGVtc1N0ciB8fCBbXTtcbiAgICB0aGlzLl9pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA9IGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkO1xuICAgIHRoaXMuX2ZvbnRJbnNwZWN0b3JFbmFibGVkID0gISFnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3I/LmVuYWJsZWQ7XG4gICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl90ZXh0RGl2UHJvcGVydGllcyA9IHRleHREaXZQcm9wZXJ0aWVzIHx8IG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5fY2FuY2VsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5fbGF5b3V0VGV4dFBhcmFtcyA9IHtcbiAgICAgIHByZXZGb250U2l6ZTogbnVsbCxcbiAgICAgIHByZXZGb250RmFtaWx5OiBudWxsLFxuICAgICAgZGl2OiBudWxsLFxuICAgICAgc2NhbGU6IHZpZXdwb3J0LnNjYWxlICogKGdsb2JhbFRoaXMuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSxcbiAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICBjdHg6IGdldEN0eCgwLCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZClcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZXG4gICAgfSA9IHZpZXdwb3J0LnJhd0RpbXM7XG4gICAgdGhpcy5fdHJhbnNmb3JtID0gWzEsIDAsIDAsIC0xLCAtcGFnZVgsIHBhZ2VZICsgcGFnZUhlaWdodF07XG4gICAgdGhpcy5fcGFnZVdpZHRoID0gcGFnZVdpZHRoO1xuICAgIHRoaXMuX3BhZ2VIZWlnaHQgPSBwYWdlSGVpZ2h0O1xuICAgICgwLCBfZGlzcGxheV91dGlscy5zZXRMYXllckRpbWVuc2lvbnMpKGNvbnRhaW5lciwgdmlld3BvcnQpO1xuICAgIHRoaXMuX2NhcGFiaWxpdHkucHJvbWlzZS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMuX2xheW91dFRleHRQYXJhbXMgPSBudWxsO1xuICAgIH0pLmNhdGNoKCgpID0+IHt9KTtcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLl9jYW5jZWxlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuX3JlYWRlcikge1xuICAgICAgdGhpcy5fcmVhZGVyLmNhbmNlbChuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24oXCJUZXh0TGF5ZXIgdGFzayBjYW5jZWxsZWQuXCIpKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9jYXBhYmlsaXR5LnJlamVjdChuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24oXCJUZXh0TGF5ZXIgdGFzayBjYW5jZWxsZWQuXCIpKTtcbiAgfVxuICBfcHJvY2Vzc0l0ZW1zKGl0ZW1zLCBzdHlsZUNhY2hlKSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBpZiAoaXRlbS5zdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcImJlZ2luTWFya2VkQ29udGVudFByb3BzXCIgfHwgaXRlbS50eXBlID09PSBcImJlZ2luTWFya2VkQ29udGVudFwiKSB7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFya2VkQ29udGVudFwiKTtcbiAgICAgICAgICBpZiAoaXRlbS5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImlkXCIsIGAke2l0ZW0uaWR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudC5hcHBlbmQodGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09IFwiZW5kTWFya2VkQ29udGVudFwiKSB7XG4gICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLl90ZXh0Q29udGVudEl0ZW1zU3RyLnB1c2goaXRlbS5zdHIpO1xuICAgICAgYXBwZW5kVGV4dCh0aGlzLCBpdGVtLCBzdHlsZUNhY2hlKTtcbiAgICB9XG4gIH1cbiAgX2xheW91dFRleHQodGV4dERpdikge1xuICAgIGNvbnN0IHRleHREaXZQcm9wZXJ0aWVzID0gdGhpcy5fbGF5b3V0VGV4dFBhcmFtcy5wcm9wZXJ0aWVzID0gdGhpcy5fdGV4dERpdlByb3BlcnRpZXMuZ2V0KHRleHREaXYpO1xuICAgIHRoaXMuX2xheW91dFRleHRQYXJhbXMuZGl2ID0gdGV4dERpdjtcbiAgICBsYXlvdXQodGhpcy5fbGF5b3V0VGV4dFBhcmFtcyk7XG4gICAgaWYgKHRleHREaXZQcm9wZXJ0aWVzLmhhc1RleHQpIHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmQodGV4dERpdik7XG4gICAgfVxuICAgIGlmICh0ZXh0RGl2UHJvcGVydGllcy5oYXNFT0wpIHtcbiAgICAgIGNvbnN0IGJyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xuICAgICAgYnIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmQoYnIpO1xuICAgIH1cbiAgfVxuICBfcmVuZGVyKCkge1xuICAgIGNvbnN0IGNhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICBsZXQgc3R5bGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKHRoaXMuX2lzUmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3JlYWRlci5yZWFkKCkudGhlbigoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkgPT4ge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZUNhY2hlLCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgICAgIHRoaXMuX3Byb2Nlc3NJdGVtcyh2YWx1ZS5pdGVtcywgc3R5bGVDYWNoZSk7XG4gICAgICAgICAgcHVtcCgpO1xuICAgICAgICB9LCBjYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fcmVhZGVyID0gdGhpcy5fdGV4dENvbnRlbnRTb3VyY2UuZ2V0UmVhZGVyKCk7XG4gICAgICBwdW1wKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl90ZXh0Q29udGVudFNvdXJjZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpdGVtcyxcbiAgICAgICAgc3R5bGVzXG4gICAgICB9ID0gdGhpcy5fdGV4dENvbnRlbnRTb3VyY2U7XG4gICAgICB0aGlzLl9wcm9jZXNzSXRlbXMoaXRlbXMsIHN0eWxlcyk7XG4gICAgICBjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBcInRleHRDb250ZW50U291cmNlXCIgcGFyYW1ldGVyIHNwZWNpZmllZC4nKTtcbiAgICB9XG4gICAgY2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgc3R5bGVDYWNoZSA9IG51bGw7XG4gICAgICByZW5kZXIodGhpcyk7XG4gICAgfSwgdGhpcy5fY2FwYWJpbGl0eS5yZWplY3QpO1xuICB9XG59XG5leHBvcnRzLlRleHRMYXllclJlbmRlclRhc2sgPSBUZXh0TGF5ZXJSZW5kZXJUYXNrO1xuZnVuY3Rpb24gcmVuZGVyVGV4dExheWVyKHBhcmFtcykge1xuICBpZiAoIXBhcmFtcy50ZXh0Q29udGVudFNvdXJjZSAmJiAocGFyYW1zLnRleHRDb250ZW50IHx8IHBhcmFtcy50ZXh0Q29udGVudFN0cmVhbSkpIHtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZGVwcmVjYXRlZCkoXCJUaGUgVGV4dExheWVyUmVuZGVyIGB0ZXh0Q29udGVudGAvYHRleHRDb250ZW50U3RyZWFtYCBwYXJhbWV0ZXJzIFwiICsgXCJ3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZSwgcGxlYXNlIHVzZSBgdGV4dENvbnRlbnRTb3VyY2VgIGluc3RlYWQuXCIpO1xuICAgIHBhcmFtcy50ZXh0Q29udGVudFNvdXJjZSA9IHBhcmFtcy50ZXh0Q29udGVudCB8fCBwYXJhbXMudGV4dENvbnRlbnRTdHJlYW07XG4gIH1cbiAgY29uc3Qge1xuICAgIGNvbnRhaW5lcixcbiAgICB2aWV3cG9ydFxuICB9ID0gcGFyYW1zO1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgY29uc3QgdmlzaWJpbGl0eSA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJ2aXNpYmlsaXR5XCIpO1xuICBjb25zdCBzY2FsZUZhY3RvciA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tc2NhbGUtZmFjdG9yXCIpKTtcbiAgaWYgKHZpc2liaWxpdHkgPT09IFwidmlzaWJsZVwiICYmICghc2NhbGVGYWN0b3IgfHwgTWF0aC5hYnMoc2NhbGVGYWN0b3IgLSB2aWV3cG9ydC5zY2FsZSkgPiAxZS01KSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgYC0tc2NhbGUtZmFjdG9yYCBDU1MtdmFyaWFibGUgbXVzdCBiZSBzZXQsIFwiICsgXCJ0byB0aGUgc2FtZSB2YWx1ZSBhcyBgdmlld3BvcnQuc2NhbGVgLCBcIiArIFwiZWl0aGVyIG9uIHRoZSBgY29udGFpbmVyYC1lbGVtZW50IGl0c2VsZiBvciBoaWdoZXIgdXAgaW4gdGhlIERPTS5cIik7XG4gIH1cbiAgY29uc3QgdGFzayA9IG5ldyBUZXh0TGF5ZXJSZW5kZXJUYXNrKHBhcmFtcyk7XG4gIHRhc2suX3JlbmRlcigpO1xuICByZXR1cm4gdGFzaztcbn1cbmZ1bmN0aW9uIHVwZGF0ZVRleHRMYXllcih7XG4gIGNvbnRhaW5lcixcbiAgdmlld3BvcnQsXG4gIHRleHREaXZzLFxuICB0ZXh0RGl2UHJvcGVydGllcyxcbiAgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQsXG4gIG11c3RSb3RhdGUgPSB0cnVlLFxuICBtdXN0UmVzY2FsZSA9IHRydWVcbn0pIHtcbiAgaWYgKG11c3RSb3RhdGUpIHtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuc2V0TGF5ZXJEaW1lbnNpb25zKShjb250YWluZXIsIHtcbiAgICAgIHJvdGF0aW9uOiB2aWV3cG9ydC5yb3RhdGlvblxuICAgIH0pO1xuICB9XG4gIGlmIChtdXN0UmVzY2FsZSkge1xuICAgIGNvbnN0IGN0eCA9IGdldEN0eCgwLCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCk7XG4gICAgY29uc3Qgc2NhbGUgPSB2aWV3cG9ydC5zY2FsZSAqIChnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgcHJldkZvbnRTaXplOiBudWxsLFxuICAgICAgcHJldkZvbnRGYW1pbHk6IG51bGwsXG4gICAgICBkaXY6IG51bGwsXG4gICAgICBzY2FsZSxcbiAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICBjdHhcbiAgICB9O1xuICAgIGZvciAoY29uc3QgZGl2IG9mIHRleHREaXZzKSB7XG4gICAgICBwYXJhbXMucHJvcGVydGllcyA9IHRleHREaXZQcm9wZXJ0aWVzLmdldChkaXYpO1xuICAgICAgcGFyYW1zLmRpdiA9IGRpdjtcbiAgICAgIGxheW91dChwYXJhbXMpO1xuICAgIH1cbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkFubm90YXRpb25FZGl0b3JMYXllciA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2VkaXRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG52YXIgX2ZyZWV0ZXh0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyOCk7XG52YXIgX2luayA9IF9fd19wZGZqc19yZXF1aXJlX18oMzMpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbnZhciBfc3RhbXAgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM0KTtcbmNsYXNzIEFubm90YXRpb25FZGl0b3JMYXllciB7XG4gICNhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgI2FsbG93Q2xpY2sgPSBmYWxzZTtcbiAgI2Fubm90YXRpb25MYXllciA9IG51bGw7XG4gICNib3VuZFBvaW50ZXJ1cCA9IHRoaXMucG9pbnRlcnVwLmJpbmQodGhpcyk7XG4gICNib3VuZFBvaW50ZXJkb3duID0gdGhpcy5wb2ludGVyZG93bi5iaW5kKHRoaXMpO1xuICAjZWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICNpc0NsZWFuaW5nVXAgPSBmYWxzZTtcbiAgI2lzRGlzYWJsaW5nID0gZmFsc2U7XG4gICN1aU1hbmFnZXI7XG4gIHN0YXRpYyBfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVpTWFuYWdlcixcbiAgICBwYWdlSW5kZXgsXG4gICAgZGl2LFxuICAgIGFjY2Vzc2liaWxpdHlNYW5hZ2VyLFxuICAgIGFubm90YXRpb25MYXllcixcbiAgICB2aWV3cG9ydCxcbiAgICBsMTBuXG4gIH0pIHtcbiAgICBjb25zdCBlZGl0b3JUeXBlcyA9IFtfZnJlZXRleHQuRnJlZVRleHRFZGl0b3IsIF9pbmsuSW5rRWRpdG9yLCBfc3RhbXAuU3RhbXBFZGl0b3JdO1xuICAgIGlmICghQW5ub3RhdGlvbkVkaXRvckxheWVyLl9pbml0aWFsaXplZCkge1xuICAgICAgQW5ub3RhdGlvbkVkaXRvckxheWVyLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgZWRpdG9yVHlwZS5pbml0aWFsaXplKGwxMG4pO1xuICAgICAgfVxuICAgIH1cbiAgICB1aU1hbmFnZXIucmVnaXN0ZXJFZGl0b3JUeXBlcyhlZGl0b3JUeXBlcyk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICAgIHRoaXMucGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gYWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4gICAgdGhpcy4jYW5ub3RhdGlvbkxheWVyID0gYW5ub3RhdGlvbkxheWVyO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkTGF5ZXIodGhpcyk7XG4gIH1cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VkaXRvcnMuc2l6ZSA9PT0gMDtcbiAgfVxuICB1cGRhdGVUb29sYmFyKG1vZGUpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudXBkYXRlVG9vbGJhcihtb2RlKTtcbiAgfVxuICB1cGRhdGVNb2RlKG1vZGUgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpKSB7XG4gICAgdGhpcy4jY2xlYW51cCgpO1xuICAgIGlmIChtb2RlID09PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkspIHtcbiAgICAgIHRoaXMuYWRkSW5rRWRpdG9ySWZOZWVkZWQoZmFsc2UpO1xuICAgICAgdGhpcy5kaXNhYmxlQ2xpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmFibGVDbGljaygpO1xuICAgIH1cbiAgICBpZiAobW9kZSAhPT0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSkge1xuICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImZyZWVUZXh0RWRpdGluZ1wiLCBtb2RlID09PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVCk7XG4gICAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiaW5rRWRpdGluZ1wiLCBtb2RlID09PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkspO1xuICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcInN0YW1wRWRpdGluZ1wiLCBtb2RlID09PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCk7XG4gICAgICB0aGlzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYWRkSW5rRWRpdG9ySWZOZWVkZWQoaXNDb21taXR0aW5nKSB7XG4gICAgaWYgKCFpc0NvbW1pdHRpbmcgJiYgdGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSAhPT0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNDb21taXR0aW5nKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgZWRpdG9yLnNldEluQmFja2dyb3VuZCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVBbmRBZGROZXdFZGl0b3Ioe1xuICAgICAgb2Zmc2V0WDogMCxcbiAgICAgIG9mZnNldFk6IDBcbiAgICB9LCBmYWxzZSk7XG4gICAgZWRpdG9yLnNldEluQmFja2dyb3VuZCgpO1xuICB9XG4gIHNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0RWRpdGluZ1N0YXRlKGlzRWRpdGluZyk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZENvbW1hbmRzKHBhcmFtcyk7XG4gIH1cbiAgZW5hYmxlKCkge1xuICAgIHRoaXMuZGl2LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICBjb25zdCBhbm5vdGF0aW9uRWxlbWVudElkcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBlZGl0b3IuZW5hYmxlRWRpdGluZygpO1xuICAgICAgaWYgKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICAgIGFubm90YXRpb25FbGVtZW50SWRzLmFkZChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy4jYW5ub3RhdGlvbkxheWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRhYmxlcyA9IHRoaXMuI2Fubm90YXRpb25MYXllci5nZXRFZGl0YWJsZUFubm90YXRpb25zKCk7XG4gICAgZm9yIChjb25zdCBlZGl0YWJsZSBvZiBlZGl0YWJsZXMpIHtcbiAgICAgIGVkaXRhYmxlLmhpZGUoKTtcbiAgICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdGFibGUuZGF0YS5pZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoYW5ub3RhdGlvbkVsZW1lbnRJZHMuaGFzKGVkaXRhYmxlLmRhdGEuaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5kZXNlcmlhbGl6ZShlZGl0YWJsZSk7XG4gICAgICBpZiAoIWVkaXRvcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgICBlZGl0b3IuZW5hYmxlRWRpdGluZygpO1xuICAgIH1cbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuI2lzRGlzYWJsaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRpdi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgY29uc3QgaGlkZGVuQW5ub3RhdGlvbklkcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBlZGl0b3IuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICAgIGlmICghZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgfHwgZWRpdG9yLnNlcmlhbGl6ZSgpICE9PSBudWxsKSB7XG4gICAgICAgIGhpZGRlbkFubm90YXRpb25JZHMuYWRkKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLmdldEVkaXRhYmxlQW5ub3RhdGlvbihlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk/LnNob3coKTtcbiAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2Fubm90YXRpb25MYXllcikge1xuICAgICAgY29uc3QgZWRpdGFibGVzID0gdGhpcy4jYW5ub3RhdGlvbkxheWVyLmdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdGFibGUgb2YgZWRpdGFibGVzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gZWRpdGFibGUuZGF0YTtcbiAgICAgICAgaWYgKGhpZGRlbkFubm90YXRpb25JZHMuaGFzKGlkKSB8fCB0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoaWQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdGFibGUuc2hvdygpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgdGhpcy5kaXYuaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy4jaXNEaXNhYmxpbmcgPSBmYWxzZTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jYW5ub3RhdGlvbkxheWVyPy5nZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHx8IG51bGw7XG4gIH1cbiAgc2V0QWN0aXZlRWRpdG9yKGVkaXRvcikge1xuICAgIGNvbnN0IGN1cnJlbnRBY3RpdmUgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk7XG4gICAgaWYgKGN1cnJlbnRBY3RpdmUgPT09IGVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0QWN0aXZlRWRpdG9yKGVkaXRvcik7XG4gIH1cbiAgZW5hYmxlQ2xpY2soKSB7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI2JvdW5kUG9pbnRlcmRvd24pO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy4jYm91bmRQb2ludGVydXApO1xuICB9XG4gIGRpc2FibGVDbGljaygpIHtcbiAgICB0aGlzLmRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jYm91bmRQb2ludGVyZG93bik7XG4gICAgdGhpcy5kaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLiNib3VuZFBvaW50ZXJ1cCk7XG4gIH1cbiAgYXR0YWNoKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnMuc2V0KGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uRWxlbWVudElkXG4gICAgfSA9IGVkaXRvcjtcbiAgICBpZiAoYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiB0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbkVsZW1lbnRJZCkpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgZGV0YWNoKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnMuZGVsZXRlKGVkaXRvci5pZCk7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/LnJlbW92ZVBvaW50ZXJJblRleHRMYXllcihlZGl0b3IuY29udGVudERpdik7XG4gICAgaWYgKCF0aGlzLiNpc0Rpc2FibGluZyAmJiBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICByZW1vdmUoZWRpdG9yKSB7XG4gICAgdGhpcy5kZXRhY2goZWRpdG9yKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlRWRpdG9yKGVkaXRvcik7XG4gICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLiN1aU1hbmFnZXIuZm9jdXNNYWluQ29udGFpbmVyKCk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLiNpc0NsZWFuaW5nVXApIHtcbiAgICAgIHRoaXMuYWRkSW5rRWRpdG9ySWZOZWVkZWQoZmFsc2UpO1xuICAgIH1cbiAgfVxuICBjaGFuZ2VQYXJlbnQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5kZWxldGVBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgICAgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmF0dGFjaChlZGl0b3IpO1xuICAgIGVkaXRvci5wYXJlbnQ/LmRldGFjaChlZGl0b3IpO1xuICAgIGVkaXRvci5zZXRQYXJlbnQodGhpcyk7XG4gICAgaWYgKGVkaXRvci5kaXYgJiYgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChlZGl0b3IuZGl2KTtcbiAgICB9XG4gIH1cbiAgYWRkKGVkaXRvcikge1xuICAgIHRoaXMuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZEVkaXRvcihlZGl0b3IpO1xuICAgIHRoaXMuYXR0YWNoKGVkaXRvcik7XG4gICAgaWYgKCFlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICBjb25zdCBkaXYgPSBlZGl0b3IucmVuZGVyKCk7XG4gICAgICB0aGlzLmRpdi5hcHBlbmQoZGl2KTtcbiAgICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSB0cnVlO1xuICAgIH1cbiAgICBlZGl0b3IuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICBlZGl0b3Iub25jZUFkZGVkKCk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKTtcbiAgfVxuICBtb3ZlRWRpdG9ySW5ET00oZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICB9ID0gZG9jdW1lbnQ7XG4gICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCFlZGl0b3IuZGl2LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgZWRpdG9yLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCAoKSA9PiB7XG4gICAgICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICBlZGl0b3IuX3N0cnVjdFRyZWVQYXJlbnRJZCA9IHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5tb3ZlRWxlbWVudEluRE9NKHRoaXMuZGl2LCBlZGl0b3IuZGl2LCBlZGl0b3IuY29udGVudERpdiwgdHJ1ZSk7XG4gIH1cbiAgYWRkT3JSZWJ1aWxkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IubmVlZHNUb0JlUmVidWlsdCgpKSB7XG4gICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBhZGRVbmRvYWJsZUVkaXRvcihlZGl0b3IpIHtcbiAgICBjb25zdCBjbWQgPSAoKSA9PiBlZGl0b3IuX3VpTWFuYWdlci5yZWJ1aWxkKGVkaXRvcik7XG4gICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGdldE5leHRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jdWlNYW5hZ2VyLmdldElkKCk7XG4gIH1cbiAgI2NyZWF0ZU5ld0VkaXRvcihwYXJhbXMpIHtcbiAgICBzd2l0Y2ggKHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgX2ZyZWV0ZXh0LkZyZWVUZXh0RWRpdG9yKHBhcmFtcyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLklOSzpcbiAgICAgICAgcmV0dXJuIG5ldyBfaW5rLklua0VkaXRvcihwYXJhbXMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUDpcbiAgICAgICAgcmV0dXJuIG5ldyBfc3RhbXAuU3RhbXBFZGl0b3IocGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcGFzdGVFZGl0b3IobW9kZSwgcGFyYW1zKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZVRvb2xiYXIobW9kZSk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZU1vZGUobW9kZSk7XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFlcbiAgICB9ID0gdGhpcy4jZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jY3JlYXRlTmV3RWRpdG9yKHtcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGlkLFxuICAgICAgeDogb2Zmc2V0WCxcbiAgICAgIHk6IG9mZnNldFksXG4gICAgICB1aU1hbmFnZXI6IHRoaXMuI3VpTWFuYWdlcixcbiAgICAgIGlzQ2VudGVyZWQ6IHRydWUsXG4gICAgICAuLi5wYXJhbXNcbiAgICB9KTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBkZXNlcmlhbGl6ZShkYXRhKSB7XG4gICAgc3dpdGNoIChkYXRhLmFubm90YXRpb25UeXBlID8/IGRhdGEuYW5ub3RhdGlvbkVkaXRvclR5cGUpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQ6XG4gICAgICAgIHJldHVybiBfZnJlZXRleHQuRnJlZVRleHRFZGl0b3IuZGVzZXJpYWxpemUoZGF0YSwgdGhpcywgdGhpcy4jdWlNYW5hZ2VyKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LOlxuICAgICAgICByZXR1cm4gX2luay5JbmtFZGl0b3IuZGVzZXJpYWxpemUoZGF0YSwgdGhpcywgdGhpcy4jdWlNYW5hZ2VyKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVA6XG4gICAgICAgIHJldHVybiBfc3RhbXAuU3RhbXBFZGl0b3IuZGVzZXJpYWxpemUoZGF0YSwgdGhpcywgdGhpcy4jdWlNYW5hZ2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgI2NyZWF0ZUFuZEFkZE5ld0VkaXRvcihldmVudCwgaXNDZW50ZXJlZCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXROZXh0SWQoKTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVOZXdFZGl0b3Ioe1xuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgaWQsXG4gICAgICB4OiBldmVudC5vZmZzZXRYLFxuICAgICAgeTogZXZlbnQub2Zmc2V0WSxcbiAgICAgIHVpTWFuYWdlcjogdGhpcy4jdWlNYW5hZ2VyLFxuICAgICAgaXNDZW50ZXJlZFxuICAgIH0pO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgI2dldENlbnRlclBvaW50KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgdGxYID0gTWF0aC5tYXgoMCwgeCk7XG4gICAgY29uc3QgdGxZID0gTWF0aC5tYXgoMCwgeSk7XG4gICAgY29uc3QgYnJYID0gTWF0aC5taW4od2luZG93LmlubmVyV2lkdGgsIHggKyB3aWR0aCk7XG4gICAgY29uc3QgYnJZID0gTWF0aC5taW4od2luZG93LmlubmVySGVpZ2h0LCB5ICsgaGVpZ2h0KTtcbiAgICBjb25zdCBjZW50ZXJYID0gKHRsWCArIGJyWCkgLyAyIC0geDtcbiAgICBjb25zdCBjZW50ZXJZID0gKHRsWSArIGJyWSkgLyAyIC0geTtcbiAgICBjb25zdCBbb2Zmc2V0WCwgb2Zmc2V0WV0gPSB0aGlzLnZpZXdwb3J0LnJvdGF0aW9uICUgMTgwID09PSAwID8gW2NlbnRlclgsIGNlbnRlclldIDogW2NlbnRlclksIGNlbnRlclhdO1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WVxuICAgIH07XG4gIH1cbiAgYWRkTmV3RWRpdG9yKCkge1xuICAgIHRoaXMuI2NyZWF0ZUFuZEFkZE5ld0VkaXRvcih0aGlzLiNnZXRDZW50ZXJQb2ludCgpLCB0cnVlKTtcbiAgfVxuICBzZXRTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0U2VsZWN0ZWQoZWRpdG9yKTtcbiAgfVxuICB0b2dnbGVTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKTtcbiAgfVxuICBpc1NlbGVjdGVkKGVkaXRvcikge1xuICAgIHJldHVybiB0aGlzLiN1aU1hbmFnZXIuaXNTZWxlY3RlZChlZGl0b3IpO1xuICB9XG4gIHVuc2VsZWN0KGVkaXRvcikge1xuICAgIHRoaXMuI3VpTWFuYWdlci51bnNlbGVjdChlZGl0b3IpO1xuICB9XG4gIHBvaW50ZXJ1cChldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2hhZFBvaW50ZXJEb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLiNhbGxvd0NsaWNrKSB7XG4gICAgICB0aGlzLiNhbGxvd0NsaWNrID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkgPT09IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY3JlYXRlQW5kQWRkTmV3RWRpdG9yKGV2ZW50LCBmYWxzZSk7XG4gIH1cbiAgcG9pbnRlcmRvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jaGFkUG9pbnRlckRvd24pIHtcbiAgICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYWRQb2ludGVyRG93biA9IHRydWU7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpO1xuICAgIHRoaXMuI2FsbG93Q2xpY2sgPSAhZWRpdG9yIHx8IGVkaXRvci5pc0VtcHR5KCk7XG4gIH1cbiAgZmluZE5ld1BhcmVudChlZGl0b3IsIHgsIHkpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI3VpTWFuYWdlci5maW5kUGFyZW50KHgsIHkpO1xuICAgIGlmIChsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsYXllci5jaGFuZ2VQYXJlbnQoZWRpdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk/LnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuc2V0QWN0aXZlRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ucmVtb3ZlUG9pbnRlckluVGV4dExheWVyKGVkaXRvci5jb250ZW50RGl2KTtcbiAgICAgIGVkaXRvci5zZXRQYXJlbnQobnVsbCk7XG4gICAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gICAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgdGhpcy4jZWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVMYXllcih0aGlzKTtcbiAgfVxuICAjY2xlYW51cCgpIHtcbiAgICB0aGlzLiNpc0NsZWFuaW5nVXAgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jaXNDbGVhbmluZ1VwID0gZmFsc2U7XG4gIH1cbiAgcmVuZGVyKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICgwLCBfZGlzcGxheV91dGlscy5zZXRMYXllckRpbWVuc2lvbnMpKHRoaXMuZGl2LCB2aWV3cG9ydCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jdWlNYW5hZ2VyLmdldEVkaXRvcnModGhpcy5wYWdlSW5kZXgpKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZU1vZGUoKTtcbiAgfVxuICB1cGRhdGUoe1xuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgKDAsIF9kaXNwbGF5X3V0aWxzLnNldExheWVyRGltZW5zaW9ucykodGhpcy5kaXYsIHtcbiAgICAgIHJvdGF0aW9uOiB2aWV3cG9ydC5yb3RhdGlvblxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlTW9kZSgpO1xuICB9XG4gIGdldCBwYWdlRGltZW5zaW9ucygpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHRoaXMudmlld3BvcnQucmF3RGltcztcbiAgICByZXR1cm4gW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF07XG4gIH1cbn1cbmV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvckxheWVyID0gQW5ub3RhdGlvbkVkaXRvckxheWVyO1xuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkZyZWVUZXh0RWRpdG9yID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfdG9vbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xudmFyIF9lZGl0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xudmFyIF9hbm5vdGF0aW9uX2xheWVyID0gX193X3BkZmpzX3JlcXVpcmVfXygyOSk7XG5jbGFzcyBGcmVlVGV4dEVkaXRvciBleHRlbmRzIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvciB7XG4gICNib3VuZEVkaXRvckRpdkJsdXIgPSB0aGlzLmVkaXRvckRpdkJsdXIuYmluZCh0aGlzKTtcbiAgI2JvdW5kRWRpdG9yRGl2Rm9jdXMgPSB0aGlzLmVkaXRvckRpdkZvY3VzLmJpbmQodGhpcyk7XG4gICNib3VuZEVkaXRvckRpdklucHV0ID0gdGhpcy5lZGl0b3JEaXZJbnB1dC5iaW5kKHRoaXMpO1xuICAjYm91bmRFZGl0b3JEaXZLZXlkb3duID0gdGhpcy5lZGl0b3JEaXZLZXlkb3duLmJpbmQodGhpcyk7XG4gICNjb2xvcjtcbiAgI2NvbnRlbnQgPSBcIlwiO1xuICAjZWRpdG9yRGl2SWQgPSBgJHt0aGlzLmlkfS1lZGl0b3JgO1xuICAjZm9udFNpemU7XG4gICNpbml0aWFsRGF0YSA9IG51bGw7XG4gIHN0YXRpYyBfZnJlZVRleHREZWZhdWx0Q29udGVudCA9IFwiXCI7XG4gIHN0YXRpYyBfaW50ZXJuYWxQYWRkaW5nID0gMDtcbiAgc3RhdGljIF9kZWZhdWx0Q29sb3IgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRGb250U2l6ZSA9IDEwO1xuICBzdGF0aWMgZ2V0IF9rZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgY29uc3QgcHJvdG8gPSBGcmVlVGV4dEVkaXRvci5wcm90b3R5cGU7XG4gICAgY29uc3QgYXJyb3dDaGVja2VyID0gc2VsZiA9PiBzZWxmLmlzRW1wdHkoKTtcbiAgICBjb25zdCBzbWFsbCA9IF90b29scy5Bbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9TTUFMTDtcbiAgICBjb25zdCBiaWcgPSBfdG9vbHMuQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfQklHO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcIl9rZXlib2FyZE1hbmFnZXJcIiwgbmV3IF90b29scy5LZXlib2FyZE1hbmFnZXIoW1tbXCJjdHJsK3NcIiwgXCJtYWMrbWV0YStzXCIsIFwiY3RybCtwXCIsIFwibWFjK21ldGErcFwiXSwgcHJvdG8uY29tbWl0T3JSZW1vdmUsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICB9XSwgW1tcImN0cmwrRW50ZXJcIiwgXCJtYWMrbWV0YStFbnRlclwiLCBcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIHByb3RvLmNvbW1pdE9yUmVtb3ZlXSwgW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWy1zbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dMZWZ0XCIsIFwibWFjK3NoaWZ0K0Fycm93TGVmdFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbLWJpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93UmlnaHRcIiwgXCJtYWMrc2hpZnQrQXJyb3dSaWdodFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCAtc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93VXBcIiwgXCJtYWMrc2hpZnQrQXJyb3dVcFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgLWJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIHNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0Rvd25cIiwgXCJtYWMrc2hpZnQrQXJyb3dEb3duXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCBiaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV1dKSk7XG4gIH1cbiAgc3RhdGljIF90eXBlID0gXCJmcmVldGV4dFwiO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcImZyZWVUZXh0RWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLiNjb2xvciA9IHBhcmFtcy5jb2xvciB8fCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yIHx8IF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcjtcbiAgICB0aGlzLiNmb250U2l6ZSA9IHBhcmFtcy5mb250U2l6ZSB8fCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4pIHtcbiAgICBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB7XG4gICAgICBzdHJpbmdzOiBbXCJmcmVlX3RleHQyX2RlZmF1bHRfY29udGVudFwiLCBcImVkaXRvcl9mcmVlX3RleHQyX2FyaWFfbGFiZWxcIl1cbiAgICB9KTtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICB0aGlzLl9pbnRlcm5hbFBhZGRpbmcgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLWZyZWV0ZXh0LXBhZGRpbmdcIikpO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkU6XG4gICAgICAgIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemUgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SOlxuICAgICAgICBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRTpcbiAgICAgICAgdGhpcy4jdXBkYXRlRm9udFNpemUodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1I6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFLCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplXSwgW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yIHx8IF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcl1dO1xuICB9XG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSwgdGhpcy4jZm9udFNpemVdLCBbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1IsIHRoaXMuI2NvbG9yXV07XG4gIH1cbiAgI3VwZGF0ZUZvbnRTaXplKGZvbnRTaXplKSB7XG4gICAgY29uc3Qgc2V0Rm9udHNpemUgPSBzaXplID0+IHtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LnN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHtzaXplfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgdGhpcy50cmFuc2xhdGUoMCwgLShzaXplIC0gdGhpcy4jZm9udFNpemUpICogdGhpcy5wYXJlbnRTY2FsZSk7XG4gICAgICB0aGlzLiNmb250U2l6ZSA9IHNpemU7XG4gICAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gICAgfTtcbiAgICBjb25zdCBzYXZlZEZvbnRzaXplID0gdGhpcy4jZm9udFNpemU7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgc2V0Rm9udHNpemUoZm9udFNpemUpO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgc2V0Rm9udHNpemUoc2F2ZWRGb250c2l6ZSk7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgI3VwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgY29uc3Qgc2F2ZWRDb2xvciA9IHRoaXMuI2NvbG9yO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2NvbG9yID0gdGhpcy5lZGl0b3JEaXYuc3R5bGUuY29sb3IgPSBjb2xvcjtcbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2NvbG9yID0gdGhpcy5lZGl0b3JEaXYuc3R5bGUuY29sb3IgPSBzYXZlZENvbG9yO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1IsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICBfdHJhbnNsYXRlRW1wdHkoeCwgeSkge1xuICAgIHRoaXMuX3VpTWFuYWdlci50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMoeCwgeSwgdHJ1ZSk7XG4gIH1cbiAgZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5wYXJlbnRTY2FsZTtcbiAgICByZXR1cm4gWy1GcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICogc2NhbGUsIC0oRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyArIHRoaXMuI2ZvbnRTaXplKSAqIHNjYWxlXTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICh0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZShmYWxzZSk7XG4gICAgdGhpcy5wYXJlbnQudXBkYXRlVG9vbGJhcihfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVCk7XG4gICAgc3VwZXIuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LnJlbW92ZShcImVuYWJsZWRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZGl2LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEVkaXRvckRpdktleWRvd24pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLiNib3VuZEVkaXRvckRpdkZvY3VzKTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLiNib3VuZEVkaXRvckRpdkJsdXIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLiNib3VuZEVkaXRvckRpdklucHV0KTtcbiAgfVxuICBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICBzdXBlci5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LmFkZChcImVuYWJsZWRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIHRoaXMuI2VkaXRvckRpdklkKTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZLZXlkb3duKTtcbiAgICB0aGlzLmVkaXRvckRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZGb2N1cyk7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZCbHVyKTtcbiAgICB0aGlzLmVkaXRvckRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZJbnB1dCk7XG4gICAgdGhpcy5kaXYuZm9jdXMoe1xuICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5wYXJlbnQuZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVlVGV4dEVkaXRpbmdcIik7XG4gIH1cbiAgZm9jdXNpbihldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmZvY3VzaW4oZXZlbnQpO1xuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuZWRpdG9yRGl2KSB7XG4gICAgICB0aGlzLmVkaXRvckRpdi5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBvbmNlQWRkZWQoKSB7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIHRoaXMuI2NoZWF0SW5pdGlhbFJlY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxPcHRpb25zPy5pc0NlbnRlcmVkKSB7XG4gICAgICB0aGlzLmNlbnRlcigpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gIXRoaXMuZWRpdG9yRGl2IHx8IHRoaXMuZWRpdG9yRGl2LmlubmVyVGV4dC50cmltKCkgPT09IFwiXCI7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRFZGl0aW5nU3RhdGUodHJ1ZSk7XG4gICAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LmFkZChcImZyZWVUZXh0RWRpdGluZ1wiKTtcbiAgICB9XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgI2V4dHJhY3RUZXh0KCkge1xuICAgIGNvbnN0IGRpdnMgPSB0aGlzLmVkaXRvckRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpdlwiKTtcbiAgICBpZiAoZGl2cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmVkaXRvckRpdi5pbm5lclRleHQ7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGZvciAoY29uc3QgZGl2IG9mIGRpdnMpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGRpdi5pbm5lclRleHQucmVwbGFjZSgvXFxyXFxuP3xcXG4vLCBcIlwiKSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbihcIlxcblwiKTtcbiAgfVxuICAjc2V0RWRpdG9yRGltZW5zaW9ucygpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgbGV0IHJlY3Q7XG4gICAgaWYgKHRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZWN0ID0gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3VycmVudExheWVyLFxuICAgICAgICBkaXZcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3Qgc2F2ZWREaXNwbGF5ID0gZGl2LnN0eWxlLmRpc3BsYXk7XG4gICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IFwiaGlkZGVuXCI7XG4gICAgICBjdXJyZW50TGF5ZXIuZGl2LmFwcGVuZCh0aGlzLmRpdik7XG4gICAgICByZWN0ID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgZGl2LnJlbW92ZSgpO1xuICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBzYXZlZERpc3BsYXk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJvdGF0aW9uICUgMTgwID09PSB0aGlzLnBhcmVudFJvdGF0aW9uICUgMTgwKSB7XG4gICAgICB0aGlzLndpZHRoID0gcmVjdC53aWR0aCAvIHBhcmVudFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSByZWN0LmhlaWdodCAvIHBhcmVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHJlY3QuaGVpZ2h0IC8gcGFyZW50V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHJlY3Qud2lkdGggLyBwYXJlbnRIZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBjb21taXQoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmNvbW1pdCgpO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgY29uc3Qgc2F2ZWRUZXh0ID0gdGhpcy4jY29udGVudDtcbiAgICBjb25zdCBuZXdUZXh0ID0gdGhpcy4jY29udGVudCA9IHRoaXMuI2V4dHJhY3RUZXh0KCkudHJpbUVuZCgpO1xuICAgIGlmIChzYXZlZFRleHQgPT09IG5ld1RleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2V0VGV4dCA9IHRleHQgPT4ge1xuICAgICAgdGhpcy4jY29udGVudCA9IHRleHQ7XG4gICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlYnVpbGQodGhpcyk7XG4gICAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICBzZXRUZXh0KG5ld1RleHQpO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgc2V0VGV4dChzYXZlZFRleHQpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgfVxuICBzaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0luRWRpdE1vZGUoKTtcbiAgfVxuICBlbnRlckluRWRpdE1vZGUoKSB7XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gIH1cbiAgZGJsY2xpY2soZXZlbnQpIHtcbiAgICB0aGlzLmVudGVySW5FZGl0TW9kZSgpO1xuICB9XG4gIGtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLmRpdiAmJiBldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgdGhpcy5lbnRlckluRWRpdE1vZGUoKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIGVkaXRvckRpdktleWRvd24oZXZlbnQpIHtcbiAgICBGcmVlVGV4dEVkaXRvci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICB9XG4gIGVkaXRvckRpdkZvY3VzKGV2ZW50KSB7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSB0cnVlO1xuICB9XG4gIGVkaXRvckRpdkJsdXIoZXZlbnQpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICB9XG4gIGVkaXRvckRpdklucHV0KGV2ZW50KSB7XG4gICAgdGhpcy5wYXJlbnQuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJmcmVlVGV4dEVkaXRpbmdcIiwgdGhpcy5pc0VtcHR5KCkpO1xuICB9XG4gIGRpc2FibGVFZGl0aW5nKCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJjb21tZW50XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbXVsdGlsaW5lXCIpO1xuICB9XG4gIGVuYWJsZUVkaXRpbmcoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRleHRib3hcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1tdWx0aWxpbmVcIiwgdHJ1ZSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLmVkaXRvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY2xhc3NOYW1lID0gXCJpbnRlcm5hbFwiO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImlkXCIsIHRoaXMuI2VkaXRvckRpdklkKTtcbiAgICB0aGlzLmVuYWJsZUVkaXRpbmcoKTtcbiAgICBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2wxMG5Qcm9taXNlLmdldChcImVkaXRvcl9mcmVlX3RleHQyX2FyaWFfbGFiZWxcIikudGhlbihtc2cgPT4gdGhpcy5lZGl0b3JEaXY/LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbXNnKSk7XG4gICAgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZS5nZXQoXCJmcmVlX3RleHQyX2RlZmF1bHRfY29udGVudFwiKS50aGVuKG1zZyA9PiB0aGlzLmVkaXRvckRpdj8uc2V0QXR0cmlidXRlKFwiZGVmYXVsdC1jb250ZW50XCIsIG1zZykpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5lZGl0b3JEaXY7XG4gICAgc3R5bGUuZm9udFNpemUgPSBgY2FsYygke3RoaXMuI2ZvbnRTaXplfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgIHN0eWxlLmNvbG9yID0gdGhpcy4jY29sb3I7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMuZWRpdG9yRGl2KTtcbiAgICB0aGlzLm92ZXJsYXlEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QuYWRkKFwib3ZlcmxheVwiLCBcImVuYWJsZWRcIik7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMub3ZlcmxheURpdik7XG4gICAgKDAsIF90b29scy5iaW5kRXZlbnRzKSh0aGlzLCB0aGlzLmRpdiwgW1wiZGJsY2xpY2tcIiwgXCJrZXlkb3duXCJdKTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgfSA9IHRoaXMuI2luaXRpYWxEYXRhO1xuICAgICAgICBsZXQgW3R4LCB0eV0gPSB0aGlzLmdldEluaXRpYWxUcmFuc2xhdGlvbigpO1xuICAgICAgICBbdHgsIHR5XSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uVG9TY3JlZW4odHgsIHR5KTtcbiAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgICAgICBsZXQgcG9zWCwgcG9zWTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYICsgKHBvc2l0aW9uWzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZICsgdGhpcy5oZWlnaHQgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFt0eSwgLXR4XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTgwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYIC0gdGhpcy53aWR0aCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFstdHgsIC10eV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI3MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYIC0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0KSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSArIChwb3NpdGlvblsxXSAtIHBhZ2VZIC0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aCkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbLXR5LCB0eF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEF0KHBvc1ggKiBwYXJlbnRXaWR0aCwgcG9zWSAqIHBhcmVudEhlaWdodCwgdHgsIHR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0QXQoYmFzZVggKiBwYXJlbnRXaWR0aCwgYmFzZVkgKiBwYXJlbnRIZWlnaHQsIHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgI3NldENvbnRlbnQoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVwbGFjZUNoaWxkcmVuKCk7XG4gICAgaWYgKCF0aGlzLiNjb250ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLiNjb250ZW50LnNwbGl0KFwiXFxuXCIpKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2LmFwcGVuZChsaW5lID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGluZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuYXBwZW5kKGRpdik7XG4gICAgfVxuICB9XG4gIGdldCBjb250ZW50RGl2KCkge1xuICAgIHJldHVybiB0aGlzLmVkaXRvckRpdjtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgX2Fubm90YXRpb25fbGF5ZXIuRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZGVmYXVsdEFwcGVhcmFuY2VEYXRhOiB7XG4gICAgICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRDb2xvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVjdCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpZFxuICAgICAgICB9LFxuICAgICAgICB0ZXh0Q29udGVudCxcbiAgICAgICAgdGV4dFBvc2l0aW9uLFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGlmICghdGV4dENvbnRlbnQgfHwgdGV4dENvbnRlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQsXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGZvbnRDb2xvciksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICB2YWx1ZTogdGV4dENvbnRlbnQuam9pbihcIlxcblwiKSxcbiAgICAgICAgcG9zaXRpb246IHRleHRQb3NpdGlvbixcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdCxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci4jZm9udFNpemUgPSBkYXRhLmZvbnRTaXplO1xuICAgIGVkaXRvci4jY29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvciguLi5kYXRhLmNvbG9yKTtcbiAgICBlZGl0b3IuI2NvbnRlbnQgPSBkYXRhLnZhbHVlO1xuICAgIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gZGF0YS5pZCB8fCBudWxsO1xuICAgIGVkaXRvci4jaW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICAgIGlkOiB0aGlzLmFubm90YXRpb25FbGVtZW50SWQsXG4gICAgICAgIGRlbGV0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmcgPSBGcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICogdGhpcy5wYXJlbnRTY2FsZTtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5nZXRSZWN0KHBhZGRpbmcsIHBhZGRpbmcpO1xuICAgIGNvbnN0IGNvbG9yID0gX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9jb2xvck1hbmFnZXIuY29udmVydCh0aGlzLmlzQXR0YWNoZWRUb0RPTSA/IGdldENvbXB1dGVkU3R5bGUodGhpcy5lZGl0b3JEaXYpLmNvbG9yIDogdGhpcy4jY29sb3IpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQsXG4gICAgICBjb2xvcixcbiAgICAgIGZvbnRTaXplOiB0aGlzLiNmb250U2l6ZSxcbiAgICAgIHZhbHVlOiB0aGlzLiNjb250ZW50LFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3QsXG4gICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkXG4gICAgfTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAhdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBmb250U2l6ZSxcbiAgICAgIGNvbG9yLFxuICAgICAgcmVjdCxcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0gPSB0aGlzLiNpbml0aWFsRGF0YTtcbiAgICByZXR1cm4gc2VyaWFsaXplZC52YWx1ZSAhPT0gdmFsdWUgfHwgc2VyaWFsaXplZC5mb250U2l6ZSAhPT0gZm9udFNpemUgfHwgc2VyaWFsaXplZC5yZWN0LnNvbWUoKHgsIGkpID0+IE1hdGguYWJzKHggLSByZWN0W2ldKSA+PSAxKSB8fCBzZXJpYWxpemVkLmNvbG9yLnNvbWUoKGMsIGkpID0+IGMgIT09IGNvbG9yW2ldKSB8fCBzZXJpYWxpemVkLnBhZ2VJbmRleCAhPT0gcGFnZUluZGV4O1xuICB9XG4gICNjaGVhdEluaXRpYWxSZWN0KGRlbGF5ZWQgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgICBpZiAoIWRlbGF5ZWQgJiYgKHRoaXMud2lkdGggPT09IDAgfHwgdGhpcy5oZWlnaHQgPT09IDApKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuI2NoZWF0SW5pdGlhbFJlY3QodHJ1ZSksIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nID0gRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyAqIHRoaXMucGFyZW50U2NhbGU7XG4gICAgdGhpcy4jaW5pdGlhbERhdGEucmVjdCA9IHRoaXMuZ2V0UmVjdChwYWRkaW5nLCBwYWRkaW5nKTtcbiAgfVxufVxuZXhwb3J0cy5GcmVlVGV4dEVkaXRvciA9IEZyZWVUZXh0RWRpdG9yO1xuXG4vKioqLyB9KSxcbi8qIDI5ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlN0YW1wQW5ub3RhdGlvbkVsZW1lbnQgPSBleHBvcnRzLklua0Fubm90YXRpb25FbGVtZW50ID0gZXhwb3J0cy5GcmVlVGV4dEFubm90YXRpb25FbGVtZW50ID0gZXhwb3J0cy5Bbm5vdGF0aW9uTGF5ZXIgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbnZhciBfYW5ub3RhdGlvbl9zdG9yYWdlID0gX193X3BkZmpzX3JlcXVpcmVfXygzKTtcbnZhciBfc2NyaXB0aW5nX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygzMCk7XG52YXIgX2Rpc3BsYXlMMTBuX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygzMSk7XG52YXIgX3hmYV9sYXllciA9IF9fd19wZGZqc19yZXF1aXJlX18oMzIpO1xuY29uc3QgREVGQVVMVF9UQUJfSU5ERVggPSAxMDAwO1xuY29uc3QgREVGQVVMVF9GT05UX1NJWkUgPSA5O1xuY29uc3QgR2V0RWxlbWVudHNCeU5hbWVTZXQgPSBuZXcgV2Vha1NldCgpO1xuZnVuY3Rpb24gZ2V0UmVjdERpbXMocmVjdCkge1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0WzJdIC0gcmVjdFswXSxcbiAgICBoZWlnaHQ6IHJlY3RbM10gLSByZWN0WzFdXG4gIH07XG59XG5jbGFzcyBBbm5vdGF0aW9uRWxlbWVudEZhY3Rvcnkge1xuICBzdGF0aWMgY3JlYXRlKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzdWJ0eXBlID0gcGFyYW1ldGVycy5kYXRhLmFubm90YXRpb25UeXBlO1xuICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5MSU5LOlxuICAgICAgICByZXR1cm4gbmV3IExpbmtBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuVEVYVDpcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLldJREdFVDpcbiAgICAgICAgY29uc3QgZmllbGRUeXBlID0gcGFyYW1ldGVycy5kYXRhLmZpZWxkVHlwZTtcbiAgICAgICAgc3dpdGNoIChmaWVsZFR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiVHhcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJCdG5cIjpcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmRhdGEucmFkaW9CdXR0b24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXJzLmRhdGEuY2hlY2tCb3gpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgY2FzZSBcIkNoXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJTaWdcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuUE9QVVA6XG4gICAgICAgIHJldHVybiBuZXcgUG9wdXBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuRlJFRVRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlNRVUFSRTpcbiAgICAgICAgcmV0dXJuIG5ldyBTcXVhcmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuQ0lSQ0xFOlxuICAgICAgICByZXR1cm4gbmV3IENpcmNsZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5QT0xZTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5DQVJFVDpcbiAgICAgICAgcmV0dXJuIG5ldyBDYXJldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5JTks6XG4gICAgICAgIHJldHVybiBuZXcgSW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlBPTFlHT046XG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbkFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5ISUdITElHSFQ6XG4gICAgICAgIHJldHVybiBuZXcgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlVOREVSTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuU1FVSUdHTFk6XG4gICAgICAgIHJldHVybiBuZXcgU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuU1RSSUtFT1VUOlxuICAgICAgICByZXR1cm4gbmV3IFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5TVEFNUDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFtcEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5GSUxFQVRUQUNITUVOVDpcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI2hhc0JvcmRlciA9IGZhbHNlO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCB7XG4gICAgaXNSZW5kZXJhYmxlID0gZmFsc2UsXG4gICAgaWdub3JlQm9yZGVyID0gZmFsc2UsXG4gICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHMgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICB0aGlzLmlzUmVuZGVyYWJsZSA9IGlzUmVuZGVyYWJsZTtcbiAgICB0aGlzLmRhdGEgPSBwYXJhbWV0ZXJzLmRhdGE7XG4gICAgdGhpcy5sYXllciA9IHBhcmFtZXRlcnMubGF5ZXI7XG4gICAgdGhpcy5saW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXIgPSBwYXJhbWV0ZXJzLmRvd25sb2FkTWFuYWdlcjtcbiAgICB0aGlzLmltYWdlUmVzb3VyY2VzUGF0aCA9IHBhcmFtZXRlcnMuaW1hZ2VSZXNvdXJjZXNQYXRoO1xuICAgIHRoaXMucmVuZGVyRm9ybXMgPSBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zO1xuICAgIHRoaXMuc3ZnRmFjdG9yeSA9IHBhcmFtZXRlcnMuc3ZnRmFjdG9yeTtcbiAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICB0aGlzLmVuYWJsZVNjcmlwdGluZyA9IHBhcmFtZXRlcnMuZW5hYmxlU2NyaXB0aW5nO1xuICAgIHRoaXMuaGFzSlNBY3Rpb25zID0gcGFyYW1ldGVycy5oYXNKU0FjdGlvbnM7XG4gICAgdGhpcy5fZmllbGRPYmplY3RzID0gcGFyYW1ldGVycy5maWVsZE9iamVjdHM7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJhbWV0ZXJzLnBhcmVudDtcbiAgICBpZiAoaXNSZW5kZXJhYmxlKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUNvbnRhaW5lcihpZ25vcmVCb3JkZXIpO1xuICAgIH1cbiAgICBpZiAoY3JlYXRlUXVhZHJpbGF0ZXJhbHMpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVF1YWRyaWxhdGVyYWxzKCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfaGFzUG9wdXBEYXRhKHtcbiAgICB0aXRsZU9iaixcbiAgICBjb250ZW50c09iaixcbiAgICByaWNoVGV4dFxuICB9KSB7XG4gICAgcmV0dXJuICEhKHRpdGxlT2JqPy5zdHIgfHwgY29udGVudHNPYmo/LnN0ciB8fCByaWNoVGV4dD8uc3RyKTtcbiAgfVxuICBnZXQgaGFzUG9wdXBEYXRhKCkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWxlbWVudC5faGFzUG9wdXBEYXRhKHRoaXMuZGF0YSk7XG4gIH1cbiAgX2NyZWF0ZUNvbnRhaW5lcihpZ25vcmVCb3JkZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgcGFyZW50OiB7XG4gICAgICAgIHBhZ2UsXG4gICAgICAgIHZpZXdwb3J0XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIik7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtYW5ub3RhdGlvbi1pZFwiLCBkYXRhLmlkKTtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpKSB7XG4gICAgICBjb250YWluZXIudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICB9XG4gICAgY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHRoaXMucGFyZW50LnpJbmRleCsrO1xuICAgIGlmICh0aGlzLmRhdGEucG9wdXBSZWYpIHtcbiAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhhc3BvcHVwXCIsIFwiZGlhbG9nXCIpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5ub1JvdGF0ZSkge1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJub3JvdGF0ZVwiKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICBpZiAoIWRhdGEucmVjdCB8fCB0aGlzIGluc3RhbmNlb2YgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3RhdGlvblxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpZiAoIWRhdGEuaGFzT3duQ2FudmFzICYmIHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24sIGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IHJlY3QgPSBfdXRpbC5VdGlsLm5vcm1hbGl6ZVJlY3QoW2RhdGEucmVjdFswXSwgcGFnZS52aWV3WzNdIC0gZGF0YS5yZWN0WzFdICsgcGFnZS52aWV3WzFdLCBkYXRhLnJlY3RbMl0sIHBhZ2Uudmlld1szXSAtIGRhdGEucmVjdFszXSArIHBhZ2Uudmlld1sxXV0pO1xuICAgIGlmICghaWdub3JlQm9yZGVyICYmIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggPiAwKSB7XG4gICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyV2lkdGggPSBgJHtkYXRhLmJvcmRlclN0eWxlLndpZHRofXB4YDtcbiAgICAgIGNvbnN0IGhvcml6b250YWxSYWRpdXMgPSBkYXRhLmJvcmRlclN0eWxlLmhvcml6b250YWxDb3JuZXJSYWRpdXM7XG4gICAgICBjb25zdCB2ZXJ0aWNhbFJhZGl1cyA9IGRhdGEuYm9yZGVyU3R5bGUudmVydGljYWxDb3JuZXJSYWRpdXM7XG4gICAgICBpZiAoaG9yaXpvbnRhbFJhZGl1cyA+IDAgfHwgdmVydGljYWxSYWRpdXMgPiAwKSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGBjYWxjKCR7aG9yaXpvbnRhbFJhZGl1c31weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpIC8gY2FsYygke3ZlcnRpY2FsUmFkaXVzfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyUmFkaXVzID0gcmFkaXVzO1xuICAgICAgfSBlbHNlIGlmICh0aGlzIGluc3RhbmNlb2YgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgICBjb25zdCByYWRpdXMgPSBgY2FsYygke3dpZHRofXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSkgLyBjYWxjKCR7aGVpZ2h0fXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyUmFkaXVzID0gcmFkaXVzO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChkYXRhLmJvcmRlclN0eWxlLnN0eWxlKSB7XG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5TT0xJRDpcbiAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5EQVNIRUQ6XG4gICAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlclN0eWxlID0gXCJkYXNoZWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLkJFVkVMRUQ6XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiVW5pbXBsZW1lbnRlZCBib3JkZXIgc3R5bGU6IGJldmVsZWRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5JTlNFVDpcbiAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJVbmltcGxlbWVudGVkIGJvcmRlciBzdHlsZTogaW5zZXRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5VTkRFUkxJTkU6XG4gICAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlckJvdHRvbVN0eWxlID0gXCJzb2xpZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgYm9yZGVyQ29sb3IgPSBkYXRhLmJvcmRlckNvbG9yIHx8IG51bGw7XG4gICAgICBpZiAoYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgdGhpcy4jaGFzQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlckNvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoYm9yZGVyQ29sb3JbMF0gfCAwLCBib3JkZXJDb2xvclsxXSB8IDAsIGJvcmRlckNvbG9yWzJdIHwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBjb250YWluZXIuc3R5bGUubGVmdCA9IGAkezEwMCAqIChyZWN0WzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRofSVgO1xuICAgIGNvbnRhaW5lci5zdHlsZS50b3AgPSBgJHsxMDAgKiAocmVjdFsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgY29uc3Qge1xuICAgICAgcm90YXRpb25cbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZGF0YS5oYXNPd25DYW52YXMgfHwgcm90YXRpb24gPT09IDApIHtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IGAkezEwMCAqIHdpZHRoIC8gcGFnZVdpZHRofSVgO1xuICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodCAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24sIGNvbnRhaW5lcik7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgc2V0Um90YXRpb24oYW5nbGUsIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucmVjdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0LnJhd0RpbXM7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXModGhpcy5kYXRhLnJlY3QpO1xuICAgIGxldCBlbGVtZW50V2lkdGgsIGVsZW1lbnRIZWlnaHQ7XG4gICAgaWYgKGFuZ2xlICUgMTgwID09PSAwKSB7XG4gICAgICBlbGVtZW50V2lkdGggPSAxMDAgKiB3aWR0aCAvIHBhZ2VXaWR0aDtcbiAgICAgIGVsZW1lbnRIZWlnaHQgPSAxMDAgKiBoZWlnaHQgLyBwYWdlSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50V2lkdGggPSAxMDAgKiBoZWlnaHQgLyBwYWdlV2lkdGg7XG4gICAgICBlbGVtZW50SGVpZ2h0ID0gMTAwICogd2lkdGggLyBwYWdlSGVpZ2h0O1xuICAgIH1cbiAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBgJHtlbGVtZW50V2lkdGh9JWA7XG4gICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAke2VsZW1lbnRIZWlnaHR9JWA7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCAoMzYwIC0gYW5nbGUpICUgMzYwKTtcbiAgfVxuICBnZXQgX2NvbW1vbkFjdGlvbnMoKSB7XG4gICAgY29uc3Qgc2V0Q29sb3IgPSAoanNOYW1lLCBzdHlsZU5hbWUsIGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBjb2xvciA9IGV2ZW50LmRldGFpbFtqc05hbWVdO1xuICAgICAgY29uc3QgY29sb3JUeXBlID0gY29sb3JbMF07XG4gICAgICBjb25zdCBjb2xvckFycmF5ID0gY29sb3Iuc2xpY2UoMSk7XG4gICAgICBldmVudC50YXJnZXQuc3R5bGVbc3R5bGVOYW1lXSA9IF9zY3JpcHRpbmdfdXRpbHMuQ29sb3JDb252ZXJ0ZXJzW2Ake2NvbG9yVHlwZX1fSFRNTGBdKGNvbG9yQXJyYXkpO1xuICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgW3N0eWxlTmFtZV06IF9zY3JpcHRpbmdfdXRpbHMuQ29sb3JDb252ZXJ0ZXJzW2Ake2NvbG9yVHlwZX1fcmdiYF0oY29sb3JBcnJheSlcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiX2NvbW1vbkFjdGlvbnNcIiwge1xuICAgICAgZGlzcGxheTogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGlzcGxheVxuICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBjb25zdCBoaWRkZW4gPSBkaXNwbGF5ICUgMiA9PT0gMTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IGhpZGRlbiA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIjtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ZpZXc6IGhpZGRlbixcbiAgICAgICAgICBub1ByaW50OiBkaXNwbGF5ID09PSAxIHx8IGRpc3BsYXkgPT09IDJcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcHJpbnQ6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ByaW50OiAhZXZlbnQuZGV0YWlsLnByaW50XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGhpZGRlbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaGlkZGVuXG4gICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBoaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9QcmludDogaGlkZGVuLFxuICAgICAgICAgIG5vVmlldzogaGlkZGVuXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZvY3VzOiBldmVudCA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZXZlbnQudGFyZ2V0LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBmYWxzZVxuICAgICAgICB9KSwgMCk7XG4gICAgICB9LFxuICAgICAgdXNlck5hbWU6IGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQudGFyZ2V0LnRpdGxlID0gZXZlbnQuZGV0YWlsLnVzZXJOYW1lO1xuICAgICAgfSxcbiAgICAgIHJlYWRvbmx5OiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9IGV2ZW50LmRldGFpbC5yZWFkb25seTtcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9zZXRSZXF1aXJlZChldmVudC50YXJnZXQsIGV2ZW50LmRldGFpbC5yZXF1aXJlZCk7XG4gICAgICB9LFxuICAgICAgYmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImJnQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGZpbGxDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZpbGxDb2xvclwiLCBcImJhY2tncm91bmRDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgZmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZnQ29sb3JcIiwgXCJjb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgdGV4dENvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwidGV4dENvbG9yXCIsIFwiY29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGJvcmRlckNvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwiYm9yZGVyQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgc3Ryb2tlQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJzdHJva2VDb2xvclwiLCBcImJvcmRlckNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICByb3RhdGlvbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhbmdsZSA9IGV2ZW50LmRldGFpbC5yb3RhdGlvbjtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihhbmdsZSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgcm90YXRpb246IGFuZ2xlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCkge1xuICAgIGNvbnN0IGNvbW1vbkFjdGlvbnMgPSB0aGlzLl9jb21tb25BY3Rpb25zO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhqc0V2ZW50LmRldGFpbCkpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGFjdGlvbnNbbmFtZV0gfHwgY29tbW9uQWN0aW9uc1tuYW1lXTtcbiAgICAgIGFjdGlvbj8uKGpzRXZlbnQpO1xuICAgIH1cbiAgfVxuICBfc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVTY3JpcHRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UuZ2V0UmF3VmFsdWUodGhpcy5kYXRhLmlkKTtcbiAgICBpZiAoIXN0b3JlZERhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29tbW9uQWN0aW9ucyA9IHRoaXMuX2NvbW1vbkFjdGlvbnM7XG4gICAgZm9yIChjb25zdCBbYWN0aW9uTmFtZSwgZGV0YWlsXSBvZiBPYmplY3QuZW50cmllcyhzdG9yZWREYXRhKSkge1xuICAgICAgY29uc3QgYWN0aW9uID0gY29tbW9uQWN0aW9uc1thY3Rpb25OYW1lXTtcbiAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXZlbnRQcm94eSA9IHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIFthY3Rpb25OYW1lXTogZGV0YWlsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0YXJnZXQ6IGVsZW1lbnRcbiAgICAgICAgfTtcbiAgICAgICAgYWN0aW9uKGV2ZW50UHJveHkpO1xuICAgICAgICBkZWxldGUgc3RvcmVkRGF0YVthY3Rpb25OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2NyZWF0ZVF1YWRyaWxhdGVyYWxzKCkge1xuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcXVhZFBvaW50c1xuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgaWYgKCFxdWFkUG9pbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtyZWN0QmxYLCByZWN0QmxZLCByZWN0VHJYLCByZWN0VHJZXSA9IHRoaXMuZGF0YS5yZWN0O1xuICAgIGlmIChxdWFkUG9pbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgWywge1xuICAgICAgICB4OiB0clgsXG4gICAgICAgIHk6IHRyWVxuICAgICAgfSwge1xuICAgICAgICB4OiBibFgsXG4gICAgICAgIHk6IGJsWVxuICAgICAgfV0gPSBxdWFkUG9pbnRzWzBdO1xuICAgICAgaWYgKHJlY3RUclggPT09IHRyWCAmJiByZWN0VHJZID09PSB0clkgJiYgcmVjdEJsWCA9PT0gYmxYICYmIHJlY3RCbFkgPT09IGJsWSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuY29udGFpbmVyO1xuICAgIGxldCBzdmdCdWZmZXI7XG4gICAgaWYgKHRoaXMuI2hhc0JvcmRlcikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBib3JkZXJDb2xvcixcbiAgICAgICAgYm9yZGVyV2lkdGhcbiAgICAgIH0gPSBzdHlsZTtcbiAgICAgIHN0eWxlLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIHN2Z0J1ZmZlciA9IFtcInVybCgnZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsXCIsIGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcImAsIGAgcHJlc2VydmVBc3BlY3RSYXRpbz1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDEgMVwiPmAsIGA8ZyBmaWxsPVwidHJhbnNwYXJlbnRcIiBzdHJva2U9XCIke2JvcmRlckNvbG9yfVwiIHN0cm9rZS13aWR0aD1cIiR7Ym9yZGVyV2lkdGh9XCI+YF07XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGFzQm9yZGVyXCIpO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IHJlY3RUclggLSByZWN0QmxYO1xuICAgIGNvbnN0IGhlaWdodCA9IHJlY3RUclkgLSByZWN0QmxZO1xuICAgIGNvbnN0IHtcbiAgICAgIHN2Z0ZhY3RvcnlcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzdmcgPSBzdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIik7XG4gICAgc3ZnLmNsYXNzTGlzdC5hZGQoXCJxdWFkcmlsYXRlcmFsc0NvbnRhaW5lclwiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgMCk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCAwKTtcbiAgICBjb25zdCBkZWZzID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKTtcbiAgICBzdmcuYXBwZW5kKGRlZnMpO1xuICAgIGNvbnN0IGNsaXBQYXRoID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIik7XG4gICAgY29uc3QgaWQgPSBgY2xpcHBhdGhfJHt0aGlzLmRhdGEuaWR9YDtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiY2xpcFBhdGhVbml0c1wiLCBcIm9iamVjdEJvdW5kaW5nQm94XCIpO1xuICAgIGRlZnMuYXBwZW5kKGNsaXBQYXRoKTtcbiAgICBmb3IgKGNvbnN0IFssIHtcbiAgICAgIHg6IHRyWCxcbiAgICAgIHk6IHRyWVxuICAgIH0sIHtcbiAgICAgIHg6IGJsWCxcbiAgICAgIHk6IGJsWVxuICAgIH1dIG9mIHF1YWRQb2ludHMpIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBzdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIpO1xuICAgICAgY29uc3QgeCA9IChibFggLSByZWN0QmxYKSAvIHdpZHRoO1xuICAgICAgY29uc3QgeSA9IChyZWN0VHJZIC0gdHJZKSAvIGhlaWdodDtcbiAgICAgIGNvbnN0IHJlY3RXaWR0aCA9ICh0clggLSBibFgpIC8gd2lkdGg7XG4gICAgICBjb25zdCByZWN0SGVpZ2h0ID0gKHRyWSAtIGJsWSkgLyBoZWlnaHQ7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcInhcIiwgeCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcInlcIiwgeSk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHJlY3RXaWR0aCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCByZWN0SGVpZ2h0KTtcbiAgICAgIGNsaXBQYXRoLmFwcGVuZChyZWN0KTtcbiAgICAgIHN2Z0J1ZmZlcj8ucHVzaChgPHJlY3QgdmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiIHg9XCIke3h9XCIgeT1cIiR7eX1cIiB3aWR0aD1cIiR7cmVjdFdpZHRofVwiIGhlaWdodD1cIiR7cmVjdEhlaWdodH1cIi8+YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNoYXNCb3JkZXIpIHtcbiAgICAgIHN2Z0J1ZmZlci5wdXNoKGA8L2c+PC9zdmc+JylgKTtcbiAgICAgIHN0eWxlLmJhY2tncm91bmRJbWFnZSA9IHN2Z0J1ZmZlci5qb2luKFwiXCIpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5jbGlwUGF0aCA9IGB1cmwoIyR7aWR9KWA7XG4gIH1cbiAgX2NyZWF0ZVBvcHVwKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1oYXNwb3B1cFwiLCBcImRpYWxvZ1wiKTtcbiAgICBjb25zdCBwb3B1cCA9IG5ldyBQb3B1cEFubm90YXRpb25FbGVtZW50KHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY29sb3I6IGRhdGEuY29sb3IsXG4gICAgICAgIHRpdGxlT2JqOiBkYXRhLnRpdGxlT2JqLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlOiBkYXRhLm1vZGlmaWNhdGlvbkRhdGUsXG4gICAgICAgIGNvbnRlbnRzT2JqOiBkYXRhLmNvbnRlbnRzT2JqLFxuICAgICAgICByaWNoVGV4dDogZGF0YS5yaWNoVGV4dCxcbiAgICAgICAgcGFyZW50UmVjdDogZGF0YS5yZWN0LFxuICAgICAgICBib3JkZXJTdHlsZTogMCxcbiAgICAgICAgaWQ6IGBwb3B1cF8ke2RhdGEuaWR9YCxcbiAgICAgICAgcm90YXRpb246IGRhdGEucm90YXRpb25cbiAgICAgIH0sXG4gICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgZWxlbWVudHM6IFt0aGlzXVxuICAgIH0pO1xuICAgIHRoaXMucGFyZW50LmRpdi5hcHBlbmQocG9wdXAucmVuZGVyKCkpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBBbm5vdGF0aW9uRWxlbWVudC5yZW5kZXJgIGNhbGxlZFwiKTtcbiAgfVxuICBfZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgc2tpcElkID0gbnVsbCkge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgIGlmICh0aGlzLl9maWVsZE9iamVjdHMpIHtcbiAgICAgIGNvbnN0IGZpZWxkT2JqID0gdGhpcy5fZmllbGRPYmplY3RzW25hbWVdO1xuICAgICAgaWYgKGZpZWxkT2JqKSB7XG4gICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgIHBhZ2UsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgZXhwb3J0VmFsdWVzXG4gICAgICAgIH0gb2YgZmllbGRPYmopIHtcbiAgICAgICAgICBpZiAocGFnZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaWQgPT09IHNraXBJZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGV4cG9ydFZhbHVlID0gdHlwZW9mIGV4cG9ydFZhbHVlcyA9PT0gXCJzdHJpbmdcIiA/IGV4cG9ydFZhbHVlcyA6IG51bGw7XG4gICAgICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWVsZW1lbnQtaWQ9XCIke2lkfVwiXWApO1xuICAgICAgICAgIGlmIChkb21FbGVtZW50ICYmICFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgX2dldEVsZW1lbnRzQnlOYW1lIC0gZWxlbWVudCBub3QgYWxsb3dlZDogJHtpZH1gKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGV4cG9ydFZhbHVlLFxuICAgICAgICAgICAgZG9tRWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmllbGRzO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRvbUVsZW1lbnQgb2YgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUobmFtZSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXhwb3J0VmFsdWVcbiAgICAgIH0gPSBkb21FbGVtZW50O1xuICAgICAgY29uc3QgaWQgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiKTtcbiAgICAgIGlmIChpZCA9PT0gc2tpcElkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICBleHBvcnRWYWx1ZSxcbiAgICAgICAgZG9tRWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHM7XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnBvcHVwPy5tYXliZVNob3coKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5wb3B1cD8uZm9yY2VIaWRlKCk7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICBjb25zdCB0cmlnZ2VycyA9IHRoaXMuZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRyaWdnZXJzKSkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRyaWdnZXJzKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXJzLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICAgIH1cbiAgfVxuICBfZWRpdE9uRG91YmxlQ2xpY2soKSB7XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkVkaXRvclR5cGU6IG1vZGUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkOiBlZGl0SWRcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ybW9kZVwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgZWRpdElkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgTGlua0Fubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCBvcHRpb25zID0gbnVsbCkge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogISFvcHRpb25zPy5pZ25vcmVCb3JkZXIsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuaXNUb29sdGlwT25seSA9IHBhcmFtZXRlcnMuZGF0YS5pc1Rvb2x0aXBPbmx5O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgbGlua1NlcnZpY2VcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgbGluay5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgZGF0YS5pZCk7XG4gICAgbGV0IGlzQm91bmQgPSBmYWxzZTtcbiAgICBpZiAoZGF0YS51cmwpIHtcbiAgICAgIGxpbmtTZXJ2aWNlLmFkZExpbmtBdHRyaWJ1dGVzKGxpbmssIGRhdGEudXJsLCBkYXRhLm5ld1dpbmRvdyk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuYWN0aW9uKSB7XG4gICAgICB0aGlzLl9iaW5kTmFtZWRBY3Rpb24obGluaywgZGF0YS5hY3Rpb24pO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmF0dGFjaG1lbnQpIHtcbiAgICAgIHRoaXMuX2JpbmRBdHRhY2htZW50KGxpbmssIGRhdGEuYXR0YWNobWVudCk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuc2V0T0NHU3RhdGUpIHtcbiAgICAgIHRoaXMuI2JpbmRTZXRPQ0dTdGF0ZShsaW5rLCBkYXRhLnNldE9DR1N0YXRlKTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5kZXN0KSB7XG4gICAgICB0aGlzLl9iaW5kTGluayhsaW5rLCBkYXRhLmRlc3QpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkYXRhLmFjdGlvbnMgJiYgKGRhdGEuYWN0aW9ucy5BY3Rpb24gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgVXBcIl0gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgRG93blwiXSkgJiYgdGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYmluZEpTQWN0aW9uKGxpbmssIGRhdGEpO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnJlc2V0Rm9ybSkge1xuICAgICAgICB0aGlzLl9iaW5kUmVzZXRGb3JtQWN0aW9uKGxpbmssIGRhdGEucmVzZXRGb3JtKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNUb29sdGlwT25seSAmJiAhaXNCb3VuZCkge1xuICAgICAgICB0aGlzLl9iaW5kTGluayhsaW5rLCBcIlwiKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJsaW5rQW5ub3RhdGlvblwiKTtcbiAgICBpZiAoaXNCb3VuZCkge1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGxpbmspO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgI3NldEludGVybmFsTGluaygpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLWludGVybmFsLWxpbmtcIiwgXCJcIik7XG4gIH1cbiAgX2JpbmRMaW5rKGxpbmssIGRlc3RpbmF0aW9uKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXREZXN0aW5hdGlvbkhhc2goZGVzdGluYXRpb24pO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIGlmIChkZXN0aW5hdGlvbikge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmdvVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBpZiAoZGVzdGluYXRpb24gfHwgZGVzdGluYXRpb24gPT09IFwiXCIpIHtcbiAgICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICAgIH1cbiAgfVxuICBfYmluZE5hbWVkQWN0aW9uKGxpbmssIGFjdGlvbikge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMubGlua1NlcnZpY2UuZXhlY3V0ZU5hbWVkQWN0aW9uKGFjdGlvbik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICBfYmluZEF0dGFjaG1lbnQobGluaywgYXR0YWNobWVudCkge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyPy5vcGVuT3JEb3dubG9hZERhdGEodGhpcy5jb250YWluZXIsIGF0dGFjaG1lbnQuY29udGVudCwgYXR0YWNobWVudC5maWxlbmFtZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICAjYmluZFNldE9DR1N0YXRlKGxpbmssIGFjdGlvbikge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMubGlua1NlcnZpY2UuZXhlY3V0ZVNldE9DR1N0YXRlKGFjdGlvbik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICBfYmluZEpTQWN0aW9uKGxpbmssIGRhdGEpIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKFtbXCJBY3Rpb25cIiwgXCJvbmNsaWNrXCJdLCBbXCJNb3VzZSBVcFwiLCBcIm9ubW91c2V1cFwiXSwgW1wiTW91c2UgRG93blwiLCBcIm9ubW91c2Vkb3duXCJdXSk7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGRhdGEuYWN0aW9ucykpIHtcbiAgICAgIGNvbnN0IGpzTmFtZSA9IG1hcC5nZXQobmFtZSk7XG4gICAgICBpZiAoIWpzTmFtZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxpbmtbanNOYW1lXSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogZGF0YS5pZCxcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWxpbmsub25jbGljaykge1xuICAgICAgbGluay5vbmNsaWNrID0gKCkgPT4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gIF9iaW5kUmVzZXRGb3JtQWN0aW9uKGxpbmssIHJlc2V0Rm9ybSkge1xuICAgIGNvbnN0IG90aGVyQ2xpY2tBY3Rpb24gPSBsaW5rLm9uY2xpY2s7XG4gICAgaWYgKCFvdGhlckNsaWNrQWN0aW9uKSB7XG4gICAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICB9XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gICAgaWYgKCF0aGlzLl9maWVsZE9iamVjdHMpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShgX2JpbmRSZXNldEZvcm1BY3Rpb24gLSBcInJlc2V0Rm9ybVwiIGFjdGlvbiBub3Qgc3VwcG9ydGVkLCBgICsgXCJlbnN1cmUgdGhhdCB0aGUgYGZpZWxkT2JqZWN0c2AgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLlwiKTtcbiAgICAgIGlmICghb3RoZXJDbGlja0FjdGlvbikge1xuICAgICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgb3RoZXJDbGlja0FjdGlvbj8uKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpZWxkczogcmVzZXRGb3JtRmllbGRzLFxuICAgICAgICByZWZzOiByZXNldEZvcm1SZWZzLFxuICAgICAgICBpbmNsdWRlXG4gICAgICB9ID0gcmVzZXRGb3JtO1xuICAgICAgY29uc3QgYWxsRmllbGRzID0gW107XG4gICAgICBpZiAocmVzZXRGb3JtRmllbGRzLmxlbmd0aCAhPT0gMCB8fCByZXNldEZvcm1SZWZzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCBmaWVsZElkcyA9IG5ldyBTZXQocmVzZXRGb3JtUmVmcyk7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIHJlc2V0Rm9ybUZpZWxkcykge1xuICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkT2JqZWN0c1tmaWVsZE5hbWVdIHx8IFtdO1xuICAgICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9IG9mIGZpZWxkcykge1xuICAgICAgICAgICAgZmllbGRJZHMuYWRkKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmaWVsZHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9maWVsZE9iamVjdHMpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZElkcy5oYXMoZmllbGQuaWQpID09PSBpbmNsdWRlKSB7XG4gICAgICAgICAgICAgIGFsbEZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRzIG9mIE9iamVjdC52YWx1ZXModGhpcy5fZmllbGRPYmplY3RzKSkge1xuICAgICAgICAgIGFsbEZpZWxkcy5wdXNoKC4uLmZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgICAgY29uc3QgYWxsSWRzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGFsbEZpZWxkcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IGZpZWxkO1xuICAgICAgICBhbGxJZHMucHVzaChpZCk7XG4gICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlIHx8IFwiXCI7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICAgICAgY2FzZSBcInJhZGlvYnV0dG9uXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlID09PSBmaWVsZC5leHBvcnRWYWx1ZXM7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImNvbWJvYm94XCI6XG4gICAgICAgICAgY2FzZSBcImxpc3Rib3hcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWVsZW1lbnQtaWQ9XCIke2lkfVwiXWApO1xuICAgICAgICBpZiAoIWRvbUVsZW1lbnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmICghR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBfYmluZFJlc2V0Rm9ybUFjdGlvbiAtIGVsZW1lbnQgbm90IGFsbG93ZWQ6ICR7aWR9YCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZG9tRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInJlc2V0Zm9ybVwiKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcpIHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogXCJhcHBcIixcbiAgICAgICAgICAgIGlkczogYWxsSWRzLFxuICAgICAgICAgICAgbmFtZTogXCJSZXNldEZvcm1cIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxufVxuY2xhc3MgVGV4dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ0ZXh0QW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgaW1hZ2Uuc3JjID0gdGhpcy5pbWFnZVJlc291cmNlc1BhdGggKyBcImFubm90YXRpb24tXCIgKyB0aGlzLmRhdGEubmFtZS50b0xvd2VyQ2FzZSgpICsgXCIuc3ZnXCI7XG4gICAgaW1hZ2UuYWx0ID0gXCJbe3t0eXBlfX0gQW5ub3RhdGlvbl1cIjtcbiAgICBpbWFnZS5kYXRhc2V0LmwxMG5JZCA9IFwidGV4dF9hbm5vdGF0aW9uX3R5cGVcIjtcbiAgICBpbWFnZS5kYXRhc2V0LmwxMG5BcmdzID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdHlwZTogdGhpcy5kYXRhLm5hbWVcbiAgICB9KTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGltYWdlKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGF0YS5hbHRlcm5hdGl2ZVRleHQpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnRpdGxlID0gdGhpcy5kYXRhLmFsdGVybmF0aXZlVGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIHNob3dFbGVtZW50QW5kSGlkZUNhbnZhcyhlbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuZGF0YS5oYXNPd25DYW52YXMpIHtcbiAgICAgIGlmIChlbGVtZW50LnByZXZpb3VzU2libGluZz8ubm9kZU5hbWUgPT09IFwiQ0FOVkFTXCIpIHtcbiAgICAgICAgZWxlbWVudC5wcmV2aW91c1NpYmxpbmcuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIF9nZXRLZXlNb2RpZmllcihldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzV2luLFxuICAgICAgaXNNYWNcbiAgICB9ID0gX3V0aWwuRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgcmV0dXJuIGlzV2luICYmIGV2ZW50LmN0cmxLZXkgfHwgaXNNYWMgJiYgZXZlbnQubWV0YUtleTtcbiAgfVxuICBfc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgYmFzZU5hbWUsIGV2ZW50TmFtZSwgdmFsdWVHZXR0ZXIpIHtcbiAgICBpZiAoYmFzZU5hbWUuaW5jbHVkZXMoXCJtb3VzZVwiKSkge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGJhc2VOYW1lLCBldmVudCA9PiB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IHRoaXMuZGF0YS5pZCxcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZUdldHRlcihldmVudCksXG4gICAgICAgICAgICBzaGlmdDogZXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICBtb2RpZmllcjogdGhpcy5fZ2V0S2V5TW9kaWZpZXIoZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYmFzZU5hbWUsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGJhc2VOYW1lID09PSBcImJsdXJcIikge1xuICAgICAgICAgIGlmICghZWxlbWVudERhdGEuZm9jdXNlZCB8fCAhZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoYmFzZU5hbWUgPT09IFwiZm9jdXNcIikge1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWVHZXR0ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogdGhpcy5kYXRhLmlkLFxuICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlR2V0dGVyKGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBuYW1lcywgZ2V0dGVyKSB7XG4gICAgZm9yIChjb25zdCBbYmFzZU5hbWUsIGV2ZW50TmFtZV0gb2YgbmFtZXMpIHtcbiAgICAgIGlmIChldmVudE5hbWUgPT09IFwiQWN0aW9uXCIgfHwgdGhpcy5kYXRhLmFjdGlvbnM/LltldmVudE5hbWVdKSB7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiRm9jdXNcIiB8fCBldmVudE5hbWUgPT09IFwiQmx1clwiKSB7XG4gICAgICAgICAgZWxlbWVudERhdGEgfHw9IHtcbiAgICAgICAgICAgIGZvY3VzZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBiYXNlTmFtZSwgZXZlbnROYW1lLCBnZXR0ZXIpO1xuICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcIkZvY3VzXCIgJiYgIXRoaXMuZGF0YS5hY3Rpb25zPy5CbHVyKSB7XG4gICAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgXCJibHVyXCIsIFwiQmx1clwiLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09IFwiQmx1clwiICYmICF0aGlzLmRhdGEuYWN0aW9ucz8uRm9jdXMpIHtcbiAgICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBcImZvY3VzXCIsIFwiRm9jdXNcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KSB7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmRhdGEuYmFja2dyb3VuZENvbG9yIHx8IG51bGw7XG4gICAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvciA9PT0gbnVsbCA/IFwidHJhbnNwYXJlbnRcIiA6IF91dGlsLlV0aWwubWFrZUhleENvbG9yKGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0pO1xuICB9XG4gIF9zZXRUZXh0U3R5bGUoZWxlbWVudCkge1xuICAgIGNvbnN0IFRFWFRfQUxJR05NRU5UID0gW1wibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCJdO1xuICAgIGNvbnN0IHtcbiAgICAgIGZvbnRDb2xvclxuICAgIH0gPSB0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhO1xuICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YS5mb250U2l6ZSB8fCBERUZBVUxUX0ZPTlRfU0laRTtcbiAgICBjb25zdCBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgbGV0IGNvbXB1dGVkRm9udFNpemU7XG4gICAgY29uc3QgQk9SREVSX1NJWkUgPSAyO1xuICAgIGNvbnN0IHJvdW5kVG9PbmVEZWNpbWFsID0geCA9PiBNYXRoLnJvdW5kKDEwICogeCkgLyAxMDtcbiAgICBpZiAodGhpcy5kYXRhLm11bHRpTGluZSkge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnModGhpcy5kYXRhLnJlY3RbM10gLSB0aGlzLmRhdGEucmVjdFsxXSAtIEJPUkRFUl9TSVpFKTtcbiAgICAgIGNvbnN0IG51bWJlck9mTGluZXMgPSBNYXRoLnJvdW5kKGhlaWdodCAvIChfdXRpbC5MSU5FX0ZBQ1RPUiAqIGZvbnRTaXplKSkgfHwgMTtcbiAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBoZWlnaHQgLyBudW1iZXJPZkxpbmVzO1xuICAgICAgY29tcHV0ZWRGb250U2l6ZSA9IE1hdGgubWluKGZvbnRTaXplLCByb3VuZFRvT25lRGVjaW1hbChsaW5lSGVpZ2h0IC8gX3V0aWwuTElORV9GQUNUT1IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnModGhpcy5kYXRhLnJlY3RbM10gLSB0aGlzLmRhdGEucmVjdFsxXSAtIEJPUkRFUl9TSVpFKTtcbiAgICAgIGNvbXB1dGVkRm9udFNpemUgPSBNYXRoLm1pbihmb250U2l6ZSwgcm91bmRUb09uZURlY2ltYWwoaGVpZ2h0IC8gX3V0aWwuTElORV9GQUNUT1IpKTtcbiAgICB9XG4gICAgc3R5bGUuZm9udFNpemUgPSBgY2FsYygke2NvbXB1dGVkRm9udFNpemV9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWA7XG4gICAgc3R5bGUuY29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihmb250Q29sb3JbMF0sIGZvbnRDb2xvclsxXSwgZm9udENvbG9yWzJdKTtcbiAgICBpZiAodGhpcy5kYXRhLnRleHRBbGlnbm1lbnQgIT09IG51bGwpIHtcbiAgICAgIHN0eWxlLnRleHRBbGlnbiA9IFRFWFRfQUxJR05NRU5UW3RoaXMuZGF0YS50ZXh0QWxpZ25tZW50XTtcbiAgICB9XG4gIH1cbiAgX3NldFJlcXVpcmVkKGVsZW1lbnQsIGlzUmVxdWlyZWQpIHtcbiAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJyZXF1aXJlZFwiLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJyZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXJlcXVpcmVkXCIsIGlzUmVxdWlyZWQpO1xuICB9XG59XG5jbGFzcyBUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBpc1JlbmRlcmFibGUgPSBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zIHx8ICFwYXJhbWV0ZXJzLmRhdGEuaGFzQXBwZWFyYW5jZSAmJiAhIXBhcmFtZXRlcnMuZGF0YS5maWVsZFZhbHVlO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZVxuICAgIH0pO1xuICB9XG4gIHNldFByb3BlcnR5T25TaWJsaW5ncyhiYXNlLCBrZXksIHZhbHVlLCBrZXlJblN0b3JhZ2UpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoYmFzZS5uYW1lLCBiYXNlLmlkKSkge1xuICAgICAgaWYgKGVsZW1lbnQuZG9tRWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmRvbUVsZW1lbnRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShlbGVtZW50LmlkLCB7XG4gICAgICAgIFtrZXlJblN0b3JhZ2VdOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZGF0YS5pZDtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGV4dFdpZGdldEFubm90YXRpb25cIik7XG4gICAgbGV0IGVsZW1lbnQgPSBudWxsO1xuICAgIGlmICh0aGlzLnJlbmRlckZvcm1zKSB7XG4gICAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogdGhpcy5kYXRhLmZpZWxkVmFsdWVcbiAgICAgIH0pO1xuICAgICAgbGV0IHRleHRDb250ZW50ID0gc3RvcmVkRGF0YS52YWx1ZSB8fCBcIlwiO1xuICAgICAgY29uc3QgbWF4TGVuID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgICBjaGFyTGltaXQ6IHRoaXMuZGF0YS5tYXhMZW5cbiAgICAgIH0pLmNoYXJMaW1pdDtcbiAgICAgIGlmIChtYXhMZW4gJiYgdGV4dENvbnRlbnQubGVuZ3RoID4gbWF4TGVuKSB7XG4gICAgICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMCwgbWF4TGVuKTtcbiAgICAgIH1cbiAgICAgIGxldCBmaWVsZEZvcm1hdHRlZFZhbHVlcyA9IHN0b3JlZERhdGEuZm9ybWF0dGVkVmFsdWUgfHwgdGhpcy5kYXRhLnRleHRDb250ZW50Py5qb2luKFwiXFxuXCIpIHx8IG51bGw7XG4gICAgICBpZiAoZmllbGRGb3JtYXR0ZWRWYWx1ZXMgJiYgdGhpcy5kYXRhLmNvbWIpIHtcbiAgICAgICAgZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPSBmaWVsZEZvcm1hdHRlZFZhbHVlcy5yZXBsYWNlQWxsKC9cXHMrL2csIFwiXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudERhdGEgPSB7XG4gICAgICAgIHVzZXJWYWx1ZTogdGV4dENvbnRlbnQsXG4gICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmaWVsZEZvcm1hdHRlZFZhbHVlcyxcbiAgICAgICAgbGFzdENvbW1pdHRlZFZhbHVlOiBudWxsLFxuICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgIGZvY3VzZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IGZpZWxkRm9ybWF0dGVkVmFsdWVzID8/IHRleHRDb250ZW50O1xuICAgICAgICBpZiAodGhpcy5kYXRhLmRvTm90U2Nyb2xsKSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSBcImhpZGRlblwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBlbGVtZW50LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBmaWVsZEZvcm1hdHRlZFZhbHVlcyA/PyB0ZXh0Q29udGVudCk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZG9Ob3RTY3JvbGwpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLm92ZXJmbG93WCA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRhdGEuaGFzT3duQ2FudmFzKSB7XG4gICAgICAgIGVsZW1lbnQuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICAgIGVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG4gICAgICBlbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuICAgICAgZWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgICAgdGhpcy5fc2V0UmVxdWlyZWQoZWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICAgIGlmIChtYXhMZW4pIHtcbiAgICAgICAgZWxlbWVudC5tYXhMZW5ndGggPSBtYXhMZW47XG4gICAgICB9XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFByb3BlcnR5T25TaWJsaW5ncyhlbGVtZW50LCBcInZhbHVlXCIsIGV2ZW50LnRhcmdldC52YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWUgPz8gXCJcIjtcbiAgICAgICAgZWxlbWVudC52YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBsZXQgYmx1ckxpc3RlbmVyID0gZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgfSA9IGVsZW1lbnREYXRhO1xuICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgIT09IG51bGwgJiYgZm9ybWF0dGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnRhcmdldC5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEudXNlclZhbHVlKSB7XG4gICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IHRhcmdldC52YWx1ZTtcbiAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAxO1xuICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgICAgdGhpcy5zaG93RWxlbWVudEFuZEhpZGVDYW52YXMoanNFdmVudC50YXJnZXQpO1xuICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgICBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSBldmVudC5kZXRhaWwudmFsdWUgPz8gXCJcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBlbGVtZW50RGF0YS51c2VyVmFsdWUudG9TdHJpbmcoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICBlbGVtZW50RGF0YS5mb3JtYXR0ZWRWYWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgIT09IG51bGwgJiYgZm9ybWF0dGVkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBldmVudC50YXJnZXQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsUmFuZ2UoZXZlbnQpIHtcbiAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnNldFNlbGVjdGlvblJhbmdlKC4uLmV2ZW50LmRldGFpbC5zZWxSYW5nZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhckxpbWl0OiBldmVudCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBjaGFyTGltaXRcbiAgICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgICAgIGlmIChjaGFyTGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwibWF4TGVuZ3RoXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwibWF4TGVuZ3RoXCIsIGNoYXJMaW1pdCk7XG4gICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPD0gY2hhckxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgY2hhckxpbWl0KTtcbiAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgICAgICAgICAgICBzZWxTdGFydDogdGFyZ2V0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgc2VsRW5kOiB0YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGVsZW1lbnREYXRhLmNvbW1pdEtleSA9IDE7XG4gICAgICAgICAgbGV0IGNvbW1pdEtleSA9IC0xO1xuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgICAgIGNvbW1pdEtleSA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIiAmJiAhdGhpcy5kYXRhLm11bHRpTGluZSkge1xuICAgICAgICAgICAgY29tbWl0S2V5ID0gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJUYWJcIikge1xuICAgICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbW1pdEtleSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICBjb21taXRLZXksXG4gICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbEVuZDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX2JsdXJMaXN0ZW5lciA9IGJsdXJMaXN0ZW5lcjtcbiAgICAgICAgYmx1ckxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50RGF0YS5mb2N1c2VkIHx8ICFldmVudC5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbW1pdEtleTogZWxlbWVudERhdGEuY29tbWl0S2V5LFxuICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfYmx1ckxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuYWN0aW9ucz8uS2V5c3Ryb2tlKSB7XG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICB9ID0gdGFyZ2V0O1xuICAgICAgICAgICAgbGV0IHNlbFN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbEVuZCA9IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQuaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVXb3JkQmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCkubWF0Y2goL1xcdypbXlxcd10qJC8pO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0IC09IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVdvcmRGb3J3YXJkXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uU3RhcnQpLm1hdGNoKC9eW15cXHddKlxcdyovKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxFbmQgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0IC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEZvcndhcmRcIjpcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgc2VsRW5kICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2U6IGRhdGEgfHwgXCJcIixcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZWxTdGFydCxcbiAgICAgICAgICAgICAgICBzZWxFbmRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgZWxlbWVudERhdGEsIFtbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChibHVyTGlzdGVuZXIpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBibHVyTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5jb21iKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkV2lkdGggPSB0aGlzLmRhdGEucmVjdFsyXSAtIHRoaXMuZGF0YS5yZWN0WzBdO1xuICAgICAgICBjb25zdCBjb21iV2lkdGggPSBmaWVsZFdpZHRoIC8gbWF4TGVuO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjb21iXCIpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxldHRlclNwYWNpbmcgPSBgY2FsYygke2NvbWJXaWR0aH1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikgLSAxY2gpYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5kYXRhLmZpZWxkVmFsdWU7XG4gICAgICBlbGVtZW50LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcIm1pZGRsZVwiO1xuICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJ0YWJsZS1jZWxsXCI7XG4gICAgfVxuICAgIHRoaXMuX3NldFRleHRTdHlsZShlbGVtZW50KTtcbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6ICEhcGFyYW1ldGVycy5kYXRhLmhhc093bkNhbnZhc1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmV4cG9ydFZhbHVlID09PSBkYXRhLmZpZWxkVmFsdWVcbiAgICB9KS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSBcIk9mZlwiO1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwiY2hlY2tCb3hcIik7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIGVsZW1lbnQuZGlzYWJsZWQgPSBkYXRhLnJlYWRPbmx5O1xuICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgZWxlbWVudC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgIGVsZW1lbnQubmFtZSA9IGRhdGEuZmllbGROYW1lO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImV4cG9ydFZhbHVlXCIsIGRhdGEuZXhwb3J0VmFsdWUpO1xuICAgIGVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBjaGVja2VkXG4gICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShuYW1lLCBpZCkpIHtcbiAgICAgICAgY29uc3QgY3VyQ2hlY2tlZCA9IGNoZWNrZWQgJiYgY2hlY2tib3guZXhwb3J0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgICAgIGlmIChjaGVja2JveC5kb21FbGVtZW50KSB7XG4gICAgICAgICAgY2hlY2tib3guZG9tRWxlbWVudC5jaGVja2VkID0gY3VyQ2hlY2tlZDtcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGNoZWNrYm94LmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGN1ckNoZWNrZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiBjaGVja2VkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSB8fCBcIk9mZlwiO1xuICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBldmVudC5kZXRhaWwudmFsdWUgIT09IFwiT2ZmXCI7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuY2hlY2tlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIG51bGwsIFtbXCJjaGFuZ2VcIiwgXCJWYWxpZGF0ZVwiXSwgW1wiY2hhbmdlXCIsIFwiQWN0aW9uXCJdLCBbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcInJhZGlvQnV0dG9uXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmZpZWxkVmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWVcbiAgICB9KS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICBlbGVtZW50LmRpc2FibGVkID0gZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIGVsZW1lbnQudHlwZSA9IFwicmFkaW9cIjtcbiAgICBlbGVtZW50Lm5hbWUgPSBkYXRhLmZpZWxkTmFtZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICB9XG4gICAgZWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNoZWNrZWRcbiAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICBmb3IgKGNvbnN0IHJhZGlvIG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUsIGlkKSkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogY2hlY2tlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGRhdGEuZGVmYXVsdEZpZWxkVmFsdWU7XG4gICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0VmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBjb25zdCBwZGZCdXR0b25WYWx1ZSA9IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IHBkZkJ1dHRvblZhbHVlID09PSBldmVudC5kZXRhaWwudmFsdWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJhZGlvIG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKGV2ZW50LnRhcmdldC5uYW1lKSkge1xuICAgICAgICAgICAgICBjb25zdCBjdXJDaGVja2VkID0gY2hlY2tlZCAmJiByYWRpby5pZCA9PT0gaWQ7XG4gICAgICAgICAgICAgIGlmIChyYWRpby5kb21FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmFkaW8uZG9tRWxlbWVudC5jaGVja2VkID0gY3VyQ2hlY2tlZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGN1ckNoZWNrZWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIG51bGwsIFtbXCJjaGFuZ2VcIiwgXCJWYWxpZGF0ZVwiXSwgW1wiY2hhbmdlXCIsIFwiQWN0aW9uXCJdLCBbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgTGlua0Fubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlnbm9yZUJvcmRlcjogcGFyYW1ldGVycy5kYXRhLmhhc0FwcGVhcmFuY2VcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gc3VwZXIucmVuZGVyKCk7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwicHVzaEJ1dHRvblwiKTtcbiAgICBpZiAodGhpcy5kYXRhLmFsdGVybmF0aXZlVGV4dCkge1xuICAgICAgY29udGFpbmVyLnRpdGxlID0gdGhpcy5kYXRhLmFsdGVybmF0aXZlVGV4dDtcbiAgICB9XG4gICAgY29uc3QgbGlua0VsZW1lbnQgPSBjb250YWluZXIubGFzdENoaWxkO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucyAmJiBsaW5rRWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMobGlua0VsZW1lbnQpO1xuICAgICAgbGlua0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goe30sIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjaG9pY2VXaWRnZXRBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGlkID0gdGhpcy5kYXRhLmlkO1xuICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogdGhpcy5kYXRhLmZpZWxkVmFsdWVcbiAgICB9KTtcbiAgICBjb25zdCBzZWxlY3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoc2VsZWN0RWxlbWVudCk7XG4gICAgc2VsZWN0RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIHNlbGVjdEVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG4gICAgdGhpcy5fc2V0UmVxdWlyZWQoc2VsZWN0RWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICBzZWxlY3RFbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuICAgIHNlbGVjdEVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICBsZXQgYWRkQW5FbXB0eUVudHJ5ID0gdGhpcy5kYXRhLmNvbWJvICYmIHRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aCA+IDA7XG4gICAgaWYgKCF0aGlzLmRhdGEuY29tYm8pIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuc2l6ZSA9IHRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLmRhdGEubXVsdGlTZWxlY3QpIHtcbiAgICAgICAgc2VsZWN0RWxlbWVudC5tdWx0aXBsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBzZWxlY3RFbGVtZW50Lm9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gb3B0aW9uLnZhbHVlID09PSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBvcHRpb24gb2YgdGhpcy5kYXRhLm9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IG9wdGlvbi5kaXNwbGF5VmFsdWU7XG4gICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gb3B0aW9uLmV4cG9ydFZhbHVlO1xuICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUuaW5jbHVkZXMob3B0aW9uLmV4cG9ydFZhbHVlKSkge1xuICAgICAgICBvcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIHRydWUpO1xuICAgICAgICBhZGRBbkVtcHR5RW50cnkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgIH1cbiAgICBsZXQgcmVtb3ZlRW1wdHlFbnRyeSA9IG51bGw7XG4gICAgaWYgKGFkZEFuRW1wdHlFbnRyeSkge1xuICAgICAgY29uc3Qgbm9uZU9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQudmFsdWUgPSBcIiBcIjtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCB0cnVlKTtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIHRydWUpO1xuICAgICAgc2VsZWN0RWxlbWVudC5wcmVwZW5kKG5vbmVPcHRpb25FbGVtZW50KTtcbiAgICAgIHJlbW92ZUVtcHR5RW50cnkgPSAoKSA9PiB7XG4gICAgICAgIG5vbmVPcHRpb25FbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCByZW1vdmVFbXB0eUVudHJ5KTtcbiAgICAgICAgcmVtb3ZlRW1wdHlFbnRyeSA9IG51bGw7XG4gICAgICB9O1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgcmVtb3ZlRW1wdHlFbnRyeSk7XG4gICAgfVxuICAgIGNvbnN0IGdldFZhbHVlID0gaXNFeHBvcnQgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGlzRXhwb3J0ID8gXCJ2YWx1ZVwiIDogXCJ0ZXh0Q29udGVudFwiO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvcHRpb25zLFxuICAgICAgICBtdWx0aXBsZVxuICAgICAgfSA9IHNlbGVjdEVsZW1lbnQ7XG4gICAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnNlbGVjdGVkSW5kZXggPT09IC0xID8gbnVsbCA6IG9wdGlvbnNbb3B0aW9ucy5zZWxlY3RlZEluZGV4XVtuYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwob3B0aW9ucywgb3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZCkubWFwKG9wdGlvbiA9PiBvcHRpb25bbmFtZV0pO1xuICAgIH07XG4gICAgbGV0IHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgIGNvbnN0IGdldEl0ZW1zID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGV2ZW50LnRhcmdldC5vcHRpb25zO1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChvcHRpb25zLCBvcHRpb24gPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpc3BsYXlWYWx1ZTogb3B0aW9uLnRleHRDb250ZW50LFxuICAgICAgICAgIGV4cG9ydFZhbHVlOiBvcHRpb24udmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgcmVtb3ZlRW1wdHlFbnRyeT8uKCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV2ZW50LmRldGFpbC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBTZXQoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygc2VsZWN0RWxlbWVudC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlcy5oYXMob3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbXVsdGlwbGVTZWxlY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gc2VsZWN0RWxlbWVudC5vcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBldmVudC5kZXRhaWwucmVtb3ZlO1xuICAgICAgICAgICAgb3B0aW9uc1tpbmRleF0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgaSA9IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXguY2FsbChvcHRpb25zLCBvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xlYXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluc2VydChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbC5pbnNlcnQ7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RDaGlsZCA9IHNlbGVjdEVsZW1lbnQuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gZGlzcGxheVZhbHVlO1xuICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgaWYgKHNlbGVjdENoaWxkKSB7XG4gICAgICAgICAgICAgIHNlbGVjdENoaWxkLmJlZm9yZShvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpdGVtcyhldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpdGVtc1xuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICAgICAgICAgIH0gPSBpdGVtO1xuICAgICAgICAgICAgICBjb25zdCBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IGRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZChvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RFbGVtZW50Lm9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50Lm9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbmRpY2VzKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gbmV3IFNldChldmVudC5kZXRhaWwuaW5kaWNlcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBldmVudC50YXJnZXQub3B0aW9ucykge1xuICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBpbmRpY2VzLmhhcyhvcHRpb24uaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlZGl0YWJsZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmRpc2FibGVkID0gIWV2ZW50LmRldGFpbC5lZGl0YWJsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBleHBvcnRWYWx1ZSA9IGdldFZhbHVlKHRydWUpO1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGV4cG9ydFZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgIHZhbHVlOiBzZWxlY3RlZFZhbHVlcyxcbiAgICAgICAgICAgIGNoYW5nZUV4OiBleHBvcnRWYWx1ZSxcbiAgICAgICAgICAgIHdpbGxDb21taXQ6IGZhbHNlLFxuICAgICAgICAgICAgY29tbWl0S2V5OiAxLFxuICAgICAgICAgICAga2V5RG93bjogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhzZWxlY3RFbGVtZW50LCBudWxsLCBbW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXSwgW1wiaW5wdXRcIiwgXCJBY3Rpb25cIl0sIFtcImlucHV0XCIsIFwiVmFsaWRhdGVcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5kYXRhLmNvbWJvKSB7XG4gICAgICB0aGlzLl9zZXRUZXh0U3R5bGUoc2VsZWN0RWxlbWVudCk7XG4gICAgfSBlbHNlIHt9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKHNlbGVjdEVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKHNlbGVjdEVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzZWxlY3RFbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgZWxlbWVudHNcbiAgICB9ID0gcGFyYW1ldGVycztcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IEFubm90YXRpb25FbGVtZW50Ll9oYXNQb3B1cERhdGEoZGF0YSlcbiAgICB9KTtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJwb3B1cEFubm90YXRpb25cIik7XG4gICAgY29uc3QgcG9wdXAgPSBuZXcgUG9wdXBFbGVtZW50KHtcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIsXG4gICAgICBjb2xvcjogdGhpcy5kYXRhLmNvbG9yLFxuICAgICAgdGl0bGVPYmo6IHRoaXMuZGF0YS50aXRsZU9iaixcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGU6IHRoaXMuZGF0YS5tb2RpZmljYXRpb25EYXRlLFxuICAgICAgY29udGVudHNPYmo6IHRoaXMuZGF0YS5jb250ZW50c09iaixcbiAgICAgIHJpY2hUZXh0OiB0aGlzLmRhdGEucmljaFRleHQsXG4gICAgICByZWN0OiB0aGlzLmRhdGEucmVjdCxcbiAgICAgIHBhcmVudFJlY3Q6IHRoaXMuZGF0YS5wYXJlbnRSZWN0IHx8IG51bGwsXG4gICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgZWxlbWVudHM6IHRoaXMuZWxlbWVudHMsXG4gICAgICBvcGVuOiB0aGlzLmRhdGEub3BlblxuICAgIH0pO1xuICAgIGNvbnN0IGVsZW1lbnRJZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgZWxlbWVudC5wb3B1cCA9IHBvcHVwO1xuICAgICAgZWxlbWVudElkcy5wdXNoKGVsZW1lbnQuZGF0YS5pZCk7XG4gICAgICBlbGVtZW50LmFkZEhpZ2hsaWdodEFyZWEoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1jb250cm9sc1wiLCBlbGVtZW50SWRzLm1hcChpZCA9PiBgJHtfdXRpbC5Bbm5vdGF0aW9uUHJlZml4fSR7aWR9YCkuam9pbihcIixcIikpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUG9wdXBFbGVtZW50IHtcbiAgI2RhdGVUaW1lUHJvbWlzZSA9IG51bGw7XG4gICNib3VuZEtleURvd24gPSB0aGlzLiNrZXlEb3duLmJpbmQodGhpcyk7XG4gICNib3VuZEhpZGUgPSB0aGlzLiNoaWRlLmJpbmQodGhpcyk7XG4gICNib3VuZFNob3cgPSB0aGlzLiNzaG93LmJpbmQodGhpcyk7XG4gICNib3VuZFRvZ2dsZSA9IHRoaXMuI3RvZ2dsZS5iaW5kKHRoaXMpO1xuICAjY29sb3IgPSBudWxsO1xuICAjY29udGFpbmVyID0gbnVsbDtcbiAgI2NvbnRlbnRzT2JqID0gbnVsbDtcbiAgI2VsZW1lbnRzID0gbnVsbDtcbiAgI3BhcmVudCA9IG51bGw7XG4gICNwYXJlbnRSZWN0ID0gbnVsbDtcbiAgI3Bpbm5lZCA9IGZhbHNlO1xuICAjcG9wdXAgPSBudWxsO1xuICAjcmVjdCA9IG51bGw7XG4gICNyaWNoVGV4dCA9IG51bGw7XG4gICN0aXRsZU9iaiA9IG51bGw7XG4gICN3YXNWaXNpYmxlID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb250YWluZXIsXG4gICAgY29sb3IsXG4gICAgZWxlbWVudHMsXG4gICAgdGl0bGVPYmosXG4gICAgbW9kaWZpY2F0aW9uRGF0ZSxcbiAgICBjb250ZW50c09iaixcbiAgICByaWNoVGV4dCxcbiAgICBwYXJlbnQsXG4gICAgcmVjdCxcbiAgICBwYXJlbnRSZWN0LFxuICAgIG9wZW5cbiAgfSkge1xuICAgIHRoaXMuI2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLiN0aXRsZU9iaiA9IHRpdGxlT2JqO1xuICAgIHRoaXMuI2NvbnRlbnRzT2JqID0gY29udGVudHNPYmo7XG4gICAgdGhpcy4jcmljaFRleHQgPSByaWNoVGV4dDtcbiAgICB0aGlzLiNwYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy4jY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLiNyZWN0ID0gcmVjdDtcbiAgICB0aGlzLiNwYXJlbnRSZWN0ID0gcGFyZW50UmVjdDtcbiAgICB0aGlzLiNlbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgIGNvbnN0IGRhdGVPYmplY3QgPSBfZGlzcGxheV91dGlscy5QREZEYXRlU3RyaW5nLnRvRGF0ZU9iamVjdChtb2RpZmljYXRpb25EYXRlKTtcbiAgICBpZiAoZGF0ZU9iamVjdCkge1xuICAgICAgdGhpcy4jZGF0ZVRpbWVQcm9taXNlID0gcGFyZW50LmwxMG4uZ2V0KFwiYW5ub3RhdGlvbl9kYXRlX3N0cmluZ1wiLCB7XG4gICAgICAgIGRhdGU6IGRhdGVPYmplY3QudG9Mb2NhbGVEYXRlU3RyaW5nKCksXG4gICAgICAgIHRpbWU6IGRhdGVPYmplY3QudG9Mb2NhbGVUaW1lU3RyaW5nKClcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnRyaWdnZXIgPSBlbGVtZW50cy5mbGF0TWFwKGUgPT4gZS5nZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkpO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLnRyaWdnZXIpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI2JvdW5kVG9nZ2xlKTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgdGhpcy4jYm91bmRTaG93KTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy4jYm91bmRIaWRlKTtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInBvcHVwVHJpZ2dlckFyZWFcIik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgZWxlbWVudC5jb250YWluZXI/LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93bik7XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgIGlmIChvcGVuKSB7XG4gICAgICB0aGlzLiN0b2dnbGUoKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLiNwb3B1cCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHZpZXdcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICByYXdEaW1zOiB7XG4gICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgcGFnZVgsXG4gICAgICAgICAgcGFnZVlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzLiNwYXJlbnQ7XG4gICAgY29uc3QgcG9wdXAgPSB0aGlzLiNwb3B1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcG9wdXAuY2xhc3NOYW1lID0gXCJwb3B1cFwiO1xuICAgIGlmICh0aGlzLiNjb2xvcikge1xuICAgICAgY29uc3QgYmFzZUNvbG9yID0gcG9wdXAuc3R5bGUub3V0bGluZUNvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoLi4udGhpcy4jY29sb3IpO1xuICAgICAgaWYgKENTUy5zdXBwb3J0cyhcImJhY2tncm91bmQtY29sb3JcIiwgXCJjb2xvci1taXgoaW4gc3JnYiwgcmVkIDMwJSwgd2hpdGUpXCIpKSB7XG4gICAgICAgIHBvcHVwLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGBjb2xvci1taXgoaW4gc3JnYiwgJHtiYXNlQ29sb3J9IDMwJSwgd2hpdGUpYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IEJBQ0tHUk9VTkRfRU5MSUdIVCA9IDAuNztcbiAgICAgICAgcG9wdXAuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoLi4udGhpcy4jY29sb3IubWFwKGMgPT4gTWF0aC5mbG9vcihCQUNLR1JPVU5EX0VOTElHSFQgKiAoMjU1IC0gYykgKyBjKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBoZWFkZXIuY2xhc3NOYW1lID0gXCJoZWFkZXJcIjtcbiAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoMVwiKTtcbiAgICBoZWFkZXIuYXBwZW5kKHRpdGxlKTtcbiAgICAoe1xuICAgICAgZGlyOiB0aXRsZS5kaXIsXG4gICAgICBzdHI6IHRpdGxlLnRleHRDb250ZW50XG4gICAgfSA9IHRoaXMuI3RpdGxlT2JqKTtcbiAgICBwb3B1cC5hcHBlbmQoaGVhZGVyKTtcbiAgICBpZiAodGhpcy4jZGF0ZVRpbWVQcm9taXNlKSB7XG4gICAgICBjb25zdCBtb2RpZmljYXRpb25EYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBtb2RpZmljYXRpb25EYXRlLmNsYXNzTGlzdC5hZGQoXCJwb3B1cERhdGVcIik7XG4gICAgICB0aGlzLiNkYXRlVGltZVByb21pc2UudGhlbihsb2NhbGl6ZWQgPT4ge1xuICAgICAgICBtb2RpZmljYXRpb25EYXRlLnRleHRDb250ZW50ID0gbG9jYWxpemVkO1xuICAgICAgfSk7XG4gICAgICBoZWFkZXIuYXBwZW5kKG1vZGlmaWNhdGlvbkRhdGUpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50c09iaiA9IHRoaXMuI2NvbnRlbnRzT2JqO1xuICAgIGNvbnN0IHJpY2hUZXh0ID0gdGhpcy4jcmljaFRleHQ7XG4gICAgaWYgKHJpY2hUZXh0Py5zdHIgJiYgKCFjb250ZW50c09iaj8uc3RyIHx8IGNvbnRlbnRzT2JqLnN0ciA9PT0gcmljaFRleHQuc3RyKSkge1xuICAgICAgX3hmYV9sYXllci5YZmFMYXllci5yZW5kZXIoe1xuICAgICAgICB4ZmFIdG1sOiByaWNoVGV4dC5odG1sLFxuICAgICAgICBpbnRlbnQ6IFwicmljaFRleHRcIixcbiAgICAgICAgZGl2OiBwb3B1cFxuICAgICAgfSk7XG4gICAgICBwb3B1cC5sYXN0Q2hpbGQuY2xhc3NMaXN0LmFkZChcInJpY2hUZXh0XCIsIFwicG9wdXBDb250ZW50XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250ZW50cyA9IHRoaXMuX2Zvcm1hdENvbnRlbnRzKGNvbnRlbnRzT2JqKTtcbiAgICAgIHBvcHVwLmFwcGVuZChjb250ZW50cyk7XG4gICAgfVxuICAgIGxldCB1c2VQYXJlbnRSZWN0ID0gISF0aGlzLiNwYXJlbnRSZWN0O1xuICAgIGxldCByZWN0ID0gdXNlUGFyZW50UmVjdCA/IHRoaXMuI3BhcmVudFJlY3QgOiB0aGlzLiNyZWN0O1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLiNlbGVtZW50cykge1xuICAgICAgaWYgKCFyZWN0IHx8IF91dGlsLlV0aWwuaW50ZXJzZWN0KGVsZW1lbnQuZGF0YS5yZWN0LCByZWN0KSAhPT0gbnVsbCkge1xuICAgICAgICByZWN0ID0gZWxlbWVudC5kYXRhLnJlY3Q7XG4gICAgICAgIHVzZVBhcmVudFJlY3QgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZFJlY3QgPSBfdXRpbC5VdGlsLm5vcm1hbGl6ZVJlY3QoW3JlY3RbMF0sIHZpZXdbM10gLSByZWN0WzFdICsgdmlld1sxXSwgcmVjdFsyXSwgdmlld1szXSAtIHJlY3RbM10gKyB2aWV3WzFdXSk7XG4gICAgY29uc3QgSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OID0gNTtcbiAgICBjb25zdCBwYXJlbnRXaWR0aCA9IHVzZVBhcmVudFJlY3QgPyByZWN0WzJdIC0gcmVjdFswXSArIEhPUklaT05UQUxfU1BBQ0VfQUZURVJfQU5OT1RBVElPTiA6IDA7XG4gICAgY29uc3QgcG9wdXBMZWZ0ID0gbm9ybWFsaXplZFJlY3RbMF0gKyBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCBwb3B1cFRvcCA9IG5vcm1hbGl6ZWRSZWN0WzFdO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuI2NvbnRhaW5lcjtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7MTAwICogKHBvcHVwTGVmdCAtIHBhZ2VYKSAvIHBhZ2VXaWR0aH0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsxMDAgKiAocG9wdXBUb3AgLSBwYWdlWSkgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIHRoaXMuI2NvbnRhaW5lci5hcHBlbmQocG9wdXApO1xuICB9XG4gIF9mb3JtYXRDb250ZW50cyh7XG4gICAgc3RyLFxuICAgIGRpclxuICB9KSB7XG4gICAgY29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xuICAgIHAuY2xhc3NMaXN0LmFkZChcInBvcHVwQ29udGVudFwiKTtcbiAgICBwLmRpciA9IGRpcjtcbiAgICBjb25zdCBsaW5lcyA9IHN0ci5zcGxpdCgvKD86XFxyXFxuP3xcXG4pLyk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGluZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgcC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGluZSkpO1xuICAgICAgaWYgKGkgPCBpaSAtIDEpIHtcbiAgICAgICAgcC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgI2tleURvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgfHwgZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiICYmIHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jdG9nZ2xlKCk7XG4gICAgfVxuICB9XG4gICN0b2dnbGUoKSB7XG4gICAgdGhpcy4jcGlubmVkID0gIXRoaXMuI3Bpbm5lZDtcbiAgICBpZiAodGhpcy4jcGlubmVkKSB7XG4gICAgICB0aGlzLiNzaG93KCk7XG4gICAgICB0aGlzLiNjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI2JvdW5kVG9nZ2xlKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNoaWRlKCk7XG4gICAgICB0aGlzLiNjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI2JvdW5kVG9nZ2xlKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24pO1xuICAgIH1cbiAgfVxuICAjc2hvdygpIHtcbiAgICBpZiAoIXRoaXMuI3BvcHVwKSB7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gZmFsc2U7XG4gICAgICB0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4ID0gcGFyc2VJbnQodGhpcy4jY29udGFpbmVyLnN0eWxlLnpJbmRleCkgKyAxMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jcGlubmVkKSB7XG4gICAgICB0aGlzLiNjb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZvY3VzZWRcIik7XG4gICAgfVxuICB9XG4gICNoaWRlKCkge1xuICAgIHRoaXMuI2NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwiZm9jdXNlZFwiKTtcbiAgICBpZiAodGhpcy4jcGlubmVkIHx8ICF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICB0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4ID0gcGFyc2VJbnQodGhpcy4jY29udGFpbmVyLnN0eWxlLnpJbmRleCkgLSAxMDAwO1xuICB9XG4gIGZvcmNlSGlkZSgpIHtcbiAgICB0aGlzLiN3YXNWaXNpYmxlID0gdGhpcy5pc1Zpc2libGU7XG4gICAgaWYgKCF0aGlzLiN3YXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICB9XG4gIG1heWJlU2hvdygpIHtcbiAgICBpZiAoIXRoaXMuI3dhc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jd2FzVmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuICBnZXQgaXNWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNjb250YWluZXIuaGlkZGVuID09PSBmYWxzZTtcbiAgfVxufVxuY2xhc3MgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSBwYXJhbWV0ZXJzLmRhdGEudGV4dENvbnRlbnQ7XG4gICAgdGhpcy50ZXh0UG9zaXRpb24gPSBwYXJhbWV0ZXJzLmRhdGEudGV4dFBvc2l0aW9uO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVkaXRvclR5cGUgPSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZyZWVUZXh0QW5ub3RhdGlvblwiKTtcbiAgICBpZiAodGhpcy50ZXh0Q29udGVudCkge1xuICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoXCJhbm5vdGF0aW9uVGV4dENvbnRlbnRcIik7XG4gICAgICBjb250ZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJjb21tZW50XCIpO1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMudGV4dENvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgbGluZVNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgbGluZVNwYW4udGV4dENvbnRlbnQgPSBsaW5lO1xuICAgICAgICBjb250ZW50LmFwcGVuZChsaW5lU3Bhbik7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoY29udGVudCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0T25Eb3VibGVDbGljaygpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuZXhwb3J0cy5GcmVlVGV4dEFubm90YXRpb25FbGVtZW50ID0gRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudDtcbmNsYXNzIExpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI2xpbmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJsaW5lQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBsaW5lID0gdGhpcy4jbGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmxpbmVcIik7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ4MVwiLCBkYXRhLnJlY3RbMl0gLSBkYXRhLmxpbmVDb29yZGluYXRlc1swXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ5MVwiLCBkYXRhLnJlY3RbM10gLSBkYXRhLmxpbmVDb29yZGluYXRlc1sxXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ4MlwiLCBkYXRhLnJlY3RbMl0gLSBkYXRhLmxpbmVDb29yZGluYXRlc1syXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ5MlwiLCBkYXRhLnJlY3RbM10gLSBkYXRhLmxpbmVDb29yZGluYXRlc1szXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCB8fCAxKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQobGluZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jbGluZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBTcXVhcmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3NxdWFyZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInNxdWFyZUFubm90YXRpb25cIik7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgIGNvbnN0IHNxdWFyZSA9IHRoaXMuI3NxdWFyZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInhcIiwgYm9yZGVyV2lkdGggLyAyKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwieVwiLCBib3JkZXJXaWR0aCAvIDIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aCAtIGJvcmRlcldpZHRoKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodCAtIGJvcmRlcldpZHRoKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlcldpZHRoIHx8IDEpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQoc3F1YXJlKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNzcXVhcmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNjaXJjbGUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjaXJjbGVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gZGF0YS5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICBjb25zdCBjaXJjbGUgPSB0aGlzLiNjaXJjbGUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzplbGxpcHNlXCIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeFwiLCB3aWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeVwiLCBoZWlnaHQgLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwicnhcIiwgd2lkdGggLyAyIC0gYm9yZGVyV2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwicnlcIiwgaGVpZ2h0IC8gMiAtIGJvcmRlcldpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKGNpcmNsZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY2lyY2xlO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNwb2x5bGluZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwicG9seWxpbmVBbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlsaW5lXCI7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQodGhpcy5jb250YWluZXJDbGFzc05hbWUpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNvb3JkaW5hdGUgb2YgZGF0YS52ZXJ0aWNlcykge1xuICAgICAgY29uc3QgeCA9IGNvb3JkaW5hdGUueCAtIGRhdGEucmVjdFswXTtcbiAgICAgIGNvbnN0IHkgPSBkYXRhLnJlY3RbM10gLSBjb29yZGluYXRlLnk7XG4gICAgICBwb2ludHMucHVzaCh4ICsgXCIsXCIgKyB5KTtcbiAgICB9XG4gICAgcG9pbnRzID0gcG9pbnRzLmpvaW4oXCIgXCIpO1xuICAgIGNvbnN0IHBvbHlsaW5lID0gdGhpcy4jcG9seWxpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudCh0aGlzLnN2Z0VsZW1lbnROYW1lKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcG9pbnRzKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCB8fCAxKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChwb2x5bGluZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9seWxpbmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgUG9seWdvbkFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwicG9seWdvbkFubm90YXRpb25cIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWdvblwiO1xuICB9XG59XG5jbGFzcyBDYXJldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjYXJldEFubm90YXRpb25cIik7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgSW5rQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNwb2x5bGluZXMgPSBbXTtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJpbmtBbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlsaW5lXCI7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLklOSztcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgZm9yIChjb25zdCBpbmtMaXN0IG9mIGRhdGEuaW5rTGlzdHMpIHtcbiAgICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgY29vcmRpbmF0ZSBvZiBpbmtMaXN0KSB7XG4gICAgICAgIGNvbnN0IHggPSBjb29yZGluYXRlLnggLSBkYXRhLnJlY3RbMF07XG4gICAgICAgIGNvbnN0IHkgPSBkYXRhLnJlY3RbM10gLSBjb29yZGluYXRlLnk7XG4gICAgICAgIHBvaW50cy5wdXNoKGAke3h9LCR7eX1gKTtcbiAgICAgIH1cbiAgICAgIHBvaW50cyA9IHBvaW50cy5qb2luKFwiIFwiKTtcbiAgICAgIGNvbnN0IHBvbHlsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQodGhpcy5zdmdFbGVtZW50TmFtZSk7XG4gICAgICB0aGlzLiNwb2x5bGluZXMucHVzaChwb2x5bGluZSk7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcG9pbnRzKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBkYXRhLmJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICAgIH1cbiAgICAgIHN2Zy5hcHBlbmQocG9seWxpbmUpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9seWxpbmVzO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmV4cG9ydHMuSW5rQW5ub3RhdGlvbkVsZW1lbnQgPSBJbmtBbm5vdGF0aW9uRWxlbWVudDtcbmNsYXNzIEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBbm5vdGF0aW9uXCIpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInVuZGVybGluZUFubm90YXRpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTcXVpZ2dseUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzcXVpZ2dseUFubm90YXRpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3RyaWtlb3V0QW5ub3RhdGlvblwiKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInN0YW1wQW5ub3RhdGlvblwiKTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5leHBvcnRzLlN0YW1wQW5ub3RhdGlvbkVsZW1lbnQgPSBTdGFtcEFubm90YXRpb25FbGVtZW50O1xuY2xhc3MgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3RyaWdnZXIgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgZmlsZW5hbWUsXG4gICAgICBjb250ZW50XG4gICAgfSA9IHRoaXMuZGF0YS5maWxlO1xuICAgIHRoaXMuZmlsZW5hbWUgPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0RmlsZW5hbWVGcm9tVXJsKShmaWxlbmFtZSwgdHJ1ZSk7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImZpbGVhdHRhY2htZW50YW5ub3RhdGlvblwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBmaWxlbmFtZSxcbiAgICAgIGNvbnRlbnRcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZpbGVBdHRhY2htZW50QW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXIsXG4gICAgICBkYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHRyaWdnZXI7XG4gICAgaWYgKGRhdGEuaGFzQXBwZWFyYW5jZSB8fCBkYXRhLmZpbGxBbHBoYSA9PT0gMCkge1xuICAgICAgdHJpZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgdHJpZ2dlci5zcmMgPSBgJHt0aGlzLmltYWdlUmVzb3VyY2VzUGF0aH1hbm5vdGF0aW9uLSR7L3BhcGVyY2xpcC9pLnRlc3QoZGF0YS5uYW1lKSA/IFwicGFwZXJjbGlwXCIgOiBcInB1c2hwaW5cIn0uc3ZnYDtcbiAgICAgIGlmIChkYXRhLmZpbGxBbHBoYSAmJiBkYXRhLmZpbGxBbHBoYSA8IDEpIHtcbiAgICAgICAgdHJpZ2dlci5zdHlsZSA9IGBmaWx0ZXI6IG9wYWNpdHkoJHtNYXRoLnJvdW5kKGRhdGEuZmlsbEFscGhhICogMTAwKX0lKTtgO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCB0aGlzLiNkb3dubG9hZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLiN0cmlnZ2VyID0gdHJpZ2dlcjtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSBfdXRpbC5GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZ0ID0+IHtcbiAgICAgIGlmIChldnQua2V5ID09PSBcIkVudGVyXCIgJiYgKGlzTWFjID8gZXZ0Lm1ldGFLZXkgOiBldnQuY3RybEtleSkpIHtcbiAgICAgICAgdGhpcy4jZG93bmxvYWQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXIuY2xhc3NMaXN0LmFkZChcInBvcHVwVHJpZ2dlckFyZWFcIik7XG4gICAgfVxuICAgIGNvbnRhaW5lci5hcHBlbmQodHJpZ2dlcik7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiN0cmlnZ2VyO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbiAgI2Rvd25sb2FkKCkge1xuICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyPy5vcGVuT3JEb3dubG9hZERhdGEodGhpcy5jb250YWluZXIsIHRoaXMuY29udGVudCwgdGhpcy5maWxlbmFtZSk7XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25MYXllciB7XG4gICNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IG51bGw7XG4gICNhbm5vdGF0aW9uQ2FudmFzTWFwID0gbnVsbDtcbiAgI2VkaXRhYmxlQW5ub3RhdGlvbnMgPSBuZXcgTWFwKCk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkaXYsXG4gICAgYWNjZXNzaWJpbGl0eU1hbmFnZXIsXG4gICAgYW5ub3RhdGlvbkNhbnZhc01hcCxcbiAgICBsMTBuLFxuICAgIHBhZ2UsXG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gYWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4gICAgdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy5sMTBuID0gbDEwbjtcbiAgICB0aGlzLnBhZ2UgPSBwYWdlO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICB0aGlzLnpJbmRleCA9IDA7XG4gICAgdGhpcy5sMTBuIHx8PSBfZGlzcGxheUwxMG5fdXRpbHMuTnVsbEwxMG47XG4gIH1cbiAgI2FwcGVuZEVsZW1lbnQoZWxlbWVudCwgaWQpIHtcbiAgICBjb25zdCBjb250ZW50RWxlbWVudCA9IGVsZW1lbnQuZmlyc3RDaGlsZCB8fCBlbGVtZW50O1xuICAgIGNvbnRlbnRFbGVtZW50LmlkID0gYCR7X3V0aWwuQW5ub3RhdGlvblByZWZpeH0ke2lkfWA7XG4gICAgdGhpcy5kaXYuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5tb3ZlRWxlbWVudEluRE9NKHRoaXMuZGl2LCBlbGVtZW50LCBjb250ZW50RWxlbWVudCwgZmFsc2UpO1xuICB9XG4gIGFzeW5jIHJlbmRlcihwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uc1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuc2V0TGF5ZXJEaW1lbnNpb25zKShsYXllciwgdGhpcy52aWV3cG9ydCk7XG4gICAgY29uc3QgcG9wdXBUb0VsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGVsZW1lbnRQYXJhbXMgPSB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgbGF5ZXIsXG4gICAgICBsaW5rU2VydmljZTogcGFyYW1zLmxpbmtTZXJ2aWNlLFxuICAgICAgZG93bmxvYWRNYW5hZ2VyOiBwYXJhbXMuZG93bmxvYWRNYW5hZ2VyLFxuICAgICAgaW1hZ2VSZXNvdXJjZXNQYXRoOiBwYXJhbXMuaW1hZ2VSZXNvdXJjZXNQYXRoIHx8IFwiXCIsXG4gICAgICByZW5kZXJGb3JtczogcGFyYW1zLnJlbmRlckZvcm1zICE9PSBmYWxzZSxcbiAgICAgIHN2Z0ZhY3Rvcnk6IG5ldyBfZGlzcGxheV91dGlscy5ET01TVkdGYWN0b3J5KCksXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogcGFyYW1zLmFubm90YXRpb25TdG9yYWdlIHx8IG5ldyBfYW5ub3RhdGlvbl9zdG9yYWdlLkFubm90YXRpb25TdG9yYWdlKCksXG4gICAgICBlbmFibGVTY3JpcHRpbmc6IHBhcmFtcy5lbmFibGVTY3JpcHRpbmcgPT09IHRydWUsXG4gICAgICBoYXNKU0FjdGlvbnM6IHBhcmFtcy5oYXNKU0FjdGlvbnMsXG4gICAgICBmaWVsZE9iamVjdHM6IHBhcmFtcy5maWVsZE9iamVjdHMsXG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBlbGVtZW50czogbnVsbFxuICAgIH07XG4gICAgZm9yIChjb25zdCBkYXRhIG9mIGFubm90YXRpb25zKSB7XG4gICAgICBpZiAoZGF0YS5ub0hUTUwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1BvcHVwQW5ub3RhdGlvbiA9IGRhdGEuYW5ub3RhdGlvblR5cGUgPT09IF91dGlsLkFubm90YXRpb25UeXBlLlBPUFVQO1xuICAgICAgaWYgKCFpc1BvcHVwQW5ub3RhdGlvbikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0XG4gICAgICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgICAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHBvcHVwVG9FbGVtZW50cy5nZXQoZGF0YS5pZCk7XG4gICAgICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50UGFyYW1zLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICB9XG4gICAgICBlbGVtZW50UGFyYW1zLmRhdGEgPSBkYXRhO1xuICAgICAgY29uc3QgZWxlbWVudCA9IEFubm90YXRpb25FbGVtZW50RmFjdG9yeS5jcmVhdGUoZWxlbWVudFBhcmFtcyk7XG4gICAgICBpZiAoIWVsZW1lbnQuaXNSZW5kZXJhYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1BvcHVwQW5ub3RhdGlvbiAmJiBkYXRhLnBvcHVwUmVmKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gcG9wdXBUb0VsZW1lbnRzLmdldChkYXRhLnBvcHVwUmVmKTtcbiAgICAgICAgaWYgKCFlbGVtZW50cykge1xuICAgICAgICAgIHBvcHVwVG9FbGVtZW50cy5zZXQoZGF0YS5wb3B1cFJlZiwgW2VsZW1lbnRdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5hbm5vdGF0aW9uRWRpdG9yVHlwZSA+IDApIHtcbiAgICAgICAgdGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy5zZXQoZWxlbWVudC5kYXRhLmlkLCBlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbmRlcmVkID0gZWxlbWVudC5yZW5kZXIoKTtcbiAgICAgIGlmIChkYXRhLmhpZGRlbikge1xuICAgICAgICByZW5kZXJlZC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2FwcGVuZEVsZW1lbnQocmVuZGVyZWQsIGRhdGEuaWQpO1xuICAgIH1cbiAgICB0aGlzLiNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCk7XG4gICAgYXdhaXQgdGhpcy5sMTBuLnRyYW5zbGF0ZShsYXllcik7XG4gIH1cbiAgdXBkYXRlKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgKDAsIF9kaXNwbGF5X3V0aWxzLnNldExheWVyRGltZW5zaW9ucykobGF5ZXIsIHtcbiAgICAgIHJvdGF0aW9uOiB2aWV3cG9ydC5yb3RhdGlvblxuICAgIH0pO1xuICAgIHRoaXMuI3NldEFubm90YXRpb25DYW52YXNNYXAoKTtcbiAgICBsYXllci5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuICAjc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpIHtcbiAgICBpZiAoIXRoaXMuI2Fubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICBmb3IgKGNvbnN0IFtpZCwgY2FudmFzXSBvZiB0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gbGF5ZXIucXVlcnlTZWxlY3RvcihgW2RhdGEtYW5ub3RhdGlvbi1pZD1cIiR7aWR9XCJdYCk7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpcnN0Q2hpbGRcbiAgICAgIH0gPSBlbGVtZW50O1xuICAgICAgaWYgKCFmaXJzdENoaWxkKSB7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kKGNhbnZhcyk7XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0Q2hpbGQubm9kZU5hbWUgPT09IFwiQ0FOVkFTXCIpIHtcbiAgICAgICAgZmlyc3RDaGlsZC5yZXBsYWNlV2l0aChjYW52YXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3RDaGlsZC5iZWZvcmUoY2FudmFzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcC5jbGVhcigpO1xuICB9XG4gIGdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy52YWx1ZXMoKSk7XG4gIH1cbiAgZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMuZ2V0KGlkKTtcbiAgfVxufVxuZXhwb3J0cy5Bbm5vdGF0aW9uTGF5ZXIgPSBBbm5vdGF0aW9uTGF5ZXI7XG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuQ29sb3JDb252ZXJ0ZXJzID0gdm9pZCAwO1xuZnVuY3Rpb24gbWFrZUNvbG9yQ29tcChuKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWF4KDAsIE1hdGgubWluKDEsIG4pKSAqIDI1NSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbn1cbmZ1bmN0aW9uIHNjYWxlQW5kQ2xhbXAoeCkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCAyNTUgKiB4KSk7XG59XG5jbGFzcyBDb2xvckNvbnZlcnRlcnMge1xuICBzdGF0aWMgQ01ZS19HKFtjLCB5LCBtLCBrXSkge1xuICAgIHJldHVybiBbXCJHXCIsIDEgLSBNYXRoLm1pbigxLCAwLjMgKiBjICsgMC41OSAqIG0gKyAwLjExICogeSArIGspXTtcbiAgfVxuICBzdGF0aWMgR19DTVlLKFtnXSkge1xuICAgIHJldHVybiBbXCJDTVlLXCIsIDAsIDAsIDAsIDEgLSBnXTtcbiAgfVxuICBzdGF0aWMgR19SR0IoW2ddKSB7XG4gICAgcmV0dXJuIFtcIlJHQlwiLCBnLCBnLCBnXTtcbiAgfVxuICBzdGF0aWMgR19yZ2IoW2ddKSB7XG4gICAgZyA9IHNjYWxlQW5kQ2xhbXAoZyk7XG4gICAgcmV0dXJuIFtnLCBnLCBnXTtcbiAgfVxuICBzdGF0aWMgR19IVE1MKFtnXSkge1xuICAgIGNvbnN0IEcgPSBtYWtlQ29sb3JDb21wKGcpO1xuICAgIHJldHVybiBgIyR7R30ke0d9JHtHfWA7XG4gIH1cbiAgc3RhdGljIFJHQl9HKFtyLCBnLCBiXSkge1xuICAgIHJldHVybiBbXCJHXCIsIDAuMyAqIHIgKyAwLjU5ICogZyArIDAuMTEgKiBiXTtcbiAgfVxuICBzdGF0aWMgUkdCX3JnYihjb2xvcikge1xuICAgIHJldHVybiBjb2xvci5tYXAoc2NhbGVBbmRDbGFtcCk7XG4gIH1cbiAgc3RhdGljIFJHQl9IVE1MKGNvbG9yKSB7XG4gICAgcmV0dXJuIGAjJHtjb2xvci5tYXAobWFrZUNvbG9yQ29tcCkuam9pbihcIlwiKX1gO1xuICB9XG4gIHN0YXRpYyBUX0hUTUwoKSB7XG4gICAgcmV0dXJuIFwiIzAwMDAwMDAwXCI7XG4gIH1cbiAgc3RhdGljIFRfcmdiKCkge1xuICAgIHJldHVybiBbbnVsbF07XG4gIH1cbiAgc3RhdGljIENNWUtfUkdCKFtjLCB5LCBtLCBrXSkge1xuICAgIHJldHVybiBbXCJSR0JcIiwgMSAtIE1hdGgubWluKDEsIGMgKyBrKSwgMSAtIE1hdGgubWluKDEsIG0gKyBrKSwgMSAtIE1hdGgubWluKDEsIHkgKyBrKV07XG4gIH1cbiAgc3RhdGljIENNWUtfcmdiKFtjLCB5LCBtLCBrXSkge1xuICAgIHJldHVybiBbc2NhbGVBbmRDbGFtcCgxIC0gTWF0aC5taW4oMSwgYyArIGspKSwgc2NhbGVBbmRDbGFtcCgxIC0gTWF0aC5taW4oMSwgbSArIGspKSwgc2NhbGVBbmRDbGFtcCgxIC0gTWF0aC5taW4oMSwgeSArIGspKV07XG4gIH1cbiAgc3RhdGljIENNWUtfSFRNTChjb21wb25lbnRzKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5DTVlLX1JHQihjb21wb25lbnRzKS5zbGljZSgxKTtcbiAgICByZXR1cm4gdGhpcy5SR0JfSFRNTChyZ2IpO1xuICB9XG4gIHN0YXRpYyBSR0JfQ01ZSyhbciwgZywgYl0pIHtcbiAgICBjb25zdCBjID0gMSAtIHI7XG4gICAgY29uc3QgbSA9IDEgLSBnO1xuICAgIGNvbnN0IHkgPSAxIC0gYjtcbiAgICBjb25zdCBrID0gTWF0aC5taW4oYywgbSwgeSk7XG4gICAgcmV0dXJuIFtcIkNNWUtcIiwgYywgbSwgeSwga107XG4gIH1cbn1cbmV4cG9ydHMuQ29sb3JDb252ZXJ0ZXJzID0gQ29sb3JDb252ZXJ0ZXJzO1xuXG4vKioqLyB9KSxcbi8qIDMxICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLk51bGxMMTBuID0gdm9pZCAwO1xuZXhwb3J0cy5nZXRMMTBuRmFsbGJhY2sgPSBnZXRMMTBuRmFsbGJhY2s7XG5jb25zdCBERUZBVUxUX0wxME5fU1RSSU5HUyA9IHtcbiAgb2ZfcGFnZXM6IFwib2Yge3twYWdlc0NvdW50fX1cIixcbiAgcGFnZV9vZl9wYWdlczogXCIoe3twYWdlTnVtYmVyfX0gb2Yge3twYWdlc0NvdW50fX0pXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfa2I6IFwie3tzaXplX2tifX0gS0IgKHt7c2l6ZV9ifX0gYnl0ZXMpXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfbWI6IFwie3tzaXplX21ifX0gTUIgKHt7c2l6ZV9ifX0gYnl0ZXMpXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfZGF0ZV9zdHJpbmc6IFwie3tkYXRlfX0sIHt7dGltZX19XCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX3VuaXRfaW5jaGVzOiBcImluXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX3VuaXRfbWlsbGltZXRlcnM6IFwibW1cIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfb3JpZW50YXRpb25fcG9ydHJhaXQ6IFwicG9ydHJhaXRcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfb3JpZW50YXRpb25fbGFuZHNjYXBlOiBcImxhbmRzY2FwZVwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9uYW1lX2EzOiBcIkEzXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX25hbWVfYTQ6IFwiQTRcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfbmFtZV9sZXR0ZXI6IFwiTGV0dGVyXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX25hbWVfbGVnYWw6IFwiTGVnYWxcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfZGltZW5zaW9uX3N0cmluZzogXCJ7e3dpZHRofX0gw5cge3toZWlnaHR9fSB7e3VuaXR9fSAoe3tvcmllbnRhdGlvbn19KVwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9kaW1lbnNpb25fbmFtZV9zdHJpbmc6IFwie3t3aWR0aH19IMOXIHt7aGVpZ2h0fX0ge3t1bml0fX0gKHt7bmFtZX19LCB7e29yaWVudGF0aW9ufX0pXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfbGluZWFyaXplZF95ZXM6IFwiWWVzXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfbGluZWFyaXplZF9ubzogXCJOb1wiLFxuICBhZGRpdGlvbmFsX2xheWVyczogXCJBZGRpdGlvbmFsIExheWVyc1wiLFxuICBwYWdlX2xhbmRtYXJrOiBcIlBhZ2Uge3twYWdlfX1cIixcbiAgdGh1bWJfcGFnZV90aXRsZTogXCJQYWdlIHt7cGFnZX19XCIsXG4gIHRodW1iX3BhZ2VfY2FudmFzOiBcIlRodW1ibmFpbCBvZiBQYWdlIHt7cGFnZX19XCIsXG4gIGZpbmRfcmVhY2hlZF90b3A6IFwiUmVhY2hlZCB0b3Agb2YgZG9jdW1lbnQsIGNvbnRpbnVlZCBmcm9tIGJvdHRvbVwiLFxuICBmaW5kX3JlYWNoZWRfYm90dG9tOiBcIlJlYWNoZWQgZW5kIG9mIGRvY3VtZW50LCBjb250aW51ZWQgZnJvbSB0b3BcIixcbiAgXCJmaW5kX21hdGNoX2NvdW50W29uZV1cIjogXCJ7e2N1cnJlbnR9fSBvZiB7e3RvdGFsfX0gbWF0Y2hcIixcbiAgXCJmaW5kX21hdGNoX2NvdW50W290aGVyXVwiOiBcInt7Y3VycmVudH19IG9mIHt7dG90YWx9fSBtYXRjaGVzXCIsXG4gIFwiZmluZF9tYXRjaF9jb3VudF9saW1pdFtvbmVdXCI6IFwiTW9yZSB0aGFuIHt7bGltaXR9fSBtYXRjaFwiLFxuICBcImZpbmRfbWF0Y2hfY291bnRfbGltaXRbb3RoZXJdXCI6IFwiTW9yZSB0aGFuIHt7bGltaXR9fSBtYXRjaGVzXCIsXG4gIGZpbmRfbm90X2ZvdW5kOiBcIlBocmFzZSBub3QgZm91bmRcIixcbiAgcGFnZV9zY2FsZV93aWR0aDogXCJQYWdlIFdpZHRoXCIsXG4gIHBhZ2Vfc2NhbGVfZml0OiBcIlBhZ2UgRml0XCIsXG4gIHBhZ2Vfc2NhbGVfYXV0bzogXCJBdXRvbWF0aWMgWm9vbVwiLFxuICBwYWdlX3NjYWxlX2FjdHVhbDogXCJBY3R1YWwgU2l6ZVwiLFxuICBwYWdlX3NjYWxlX3BlcmNlbnQ6IFwie3tzY2FsZX19JVwiLFxuICBsb2FkaW5nX2Vycm9yOiBcIkFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGxvYWRpbmcgdGhlIFBERi5cIixcbiAgaW52YWxpZF9maWxlX2Vycm9yOiBcIkludmFsaWQgb3IgY29ycnVwdGVkIFBERiBmaWxlLlwiLFxuICBtaXNzaW5nX2ZpbGVfZXJyb3I6IFwiTWlzc2luZyBQREYgZmlsZS5cIixcbiAgdW5leHBlY3RlZF9yZXNwb25zZV9lcnJvcjogXCJVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZS5cIixcbiAgcmVuZGVyaW5nX2Vycm9yOiBcIkFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHJlbmRlcmluZyB0aGUgcGFnZS5cIixcbiAgYW5ub3RhdGlvbl9kYXRlX3N0cmluZzogXCJ7e2RhdGV9fSwge3t0aW1lfX1cIixcbiAgcHJpbnRpbmdfbm90X3N1cHBvcnRlZDogXCJXYXJuaW5nOiBQcmludGluZyBpcyBub3QgZnVsbHkgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci5cIixcbiAgcHJpbnRpbmdfbm90X3JlYWR5OiBcIldhcm5pbmc6IFRoZSBQREYgaXMgbm90IGZ1bGx5IGxvYWRlZCBmb3IgcHJpbnRpbmcuXCIsXG4gIHdlYl9mb250c19kaXNhYmxlZDogXCJXZWIgZm9udHMgYXJlIGRpc2FibGVkOiB1bmFibGUgdG8gdXNlIGVtYmVkZGVkIFBERiBmb250cy5cIixcbiAgZnJlZV90ZXh0Ml9kZWZhdWx0X2NvbnRlbnQ6IFwiU3RhcnQgdHlwaW5n4oCmXCIsXG4gIGVkaXRvcl9mcmVlX3RleHQyX2FyaWFfbGFiZWw6IFwiVGV4dCBFZGl0b3JcIixcbiAgZWRpdG9yX2luazJfYXJpYV9sYWJlbDogXCJEcmF3IEVkaXRvclwiLFxuICBlZGl0b3JfaW5rX2NhbnZhc19hcmlhX2xhYmVsOiBcIlVzZXItY3JlYXRlZCBpbWFnZVwiLFxuICBlZGl0b3JfYWx0X3RleHRfYnV0dG9uX2xhYmVsOiBcIkFsdCB0ZXh0XCIsXG4gIGVkaXRvcl9hbHRfdGV4dF9lZGl0X2J1dHRvbl9sYWJlbDogXCJFZGl0IGFsdCB0ZXh0XCIsXG4gIGVkaXRvcl9hbHRfdGV4dF9kZWNvcmF0aXZlX3Rvb2x0aXA6IFwiTWFya2VkIGFzIGRlY29yYXRpdmVcIlxufTtcbntcbiAgREVGQVVMVF9MMTBOX1NUUklOR1MucHJpbnRfcHJvZ3Jlc3NfcGVyY2VudCA9IFwie3twcm9ncmVzc319JVwiO1xufVxuZnVuY3Rpb24gZ2V0TDEwbkZhbGxiYWNrKGtleSwgYXJncykge1xuICBzd2l0Y2ggKGtleSkge1xuICAgIGNhc2UgXCJmaW5kX21hdGNoX2NvdW50XCI6XG4gICAgICBrZXkgPSBgZmluZF9tYXRjaF9jb3VudFske2FyZ3MudG90YWwgPT09IDEgPyBcIm9uZVwiIDogXCJvdGhlclwifV1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZpbmRfbWF0Y2hfY291bnRfbGltaXRcIjpcbiAgICAgIGtleSA9IGBmaW5kX21hdGNoX2NvdW50X2xpbWl0WyR7YXJncy5saW1pdCA9PT0gMSA/IFwib25lXCIgOiBcIm90aGVyXCJ9XWA7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gREVGQVVMVF9MMTBOX1NUUklOR1Nba2V5XSB8fCBcIlwiO1xufVxuZnVuY3Rpb24gZm9ybWF0TDEwblZhbHVlKHRleHQsIGFyZ3MpIHtcbiAgaWYgKCFhcmdzKSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgcmV0dXJuIHRleHQucmVwbGFjZUFsbCgvXFx7XFx7XFxzKihcXHcrKVxccypcXH1cXH0vZywgKGFsbCwgbmFtZSkgPT4ge1xuICAgIHJldHVybiBuYW1lIGluIGFyZ3MgPyBhcmdzW25hbWVdIDogXCJ7e1wiICsgbmFtZSArIFwifX1cIjtcbiAgfSk7XG59XG5jb25zdCBOdWxsTDEwbiA9IHtcbiAgYXN5bmMgZ2V0TGFuZ3VhZ2UoKSB7XG4gICAgcmV0dXJuIFwiZW4tdXNcIjtcbiAgfSxcbiAgYXN5bmMgZ2V0RGlyZWN0aW9uKCkge1xuICAgIHJldHVybiBcImx0clwiO1xuICB9LFxuICBhc3luYyBnZXQoa2V5LCBhcmdzID0gbnVsbCwgZmFsbGJhY2sgPSBnZXRMMTBuRmFsbGJhY2soa2V5LCBhcmdzKSkge1xuICAgIHJldHVybiBmb3JtYXRMMTBuVmFsdWUoZmFsbGJhY2ssIGFyZ3MpO1xuICB9LFxuICBhc3luYyB0cmFuc2xhdGUoZWxlbWVudCkge31cbn07XG5leHBvcnRzLk51bGxMMTBuID0gTnVsbEwxMG47XG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuWGZhTGF5ZXIgPSB2b2lkIDA7XG52YXIgX3hmYV90ZXh0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNSk7XG5jbGFzcyBYZmFMYXllciB7XG4gIHN0YXRpYyBzZXR1cFN0b3JhZ2UoaHRtbCwgaWQsIGVsZW1lbnQsIHN0b3JhZ2UsIGludGVudCkge1xuICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0pO1xuICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICBodG1sLnRleHRDb250ZW50ID0gc3RvcmVkRGF0YS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgaWYgKGVsZW1lbnQuYXR0cmlidXRlcy50eXBlID09PSBcInJhZGlvXCIgfHwgZWxlbWVudC5hdHRyaWJ1dGVzLnR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICAgICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlID09PSBlbGVtZW50LmF0dHJpYnV0ZXMueGZhT24pIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0b3JlZERhdGEudmFsdWUgPT09IGVsZW1lbnQuYXR0cmlidXRlcy54ZmFPZmYpIHtcbiAgICAgICAgICAgIGh0bWwucmVtb3ZlQXR0cmlidXRlKFwiY2hlY2tlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGludGVudCA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC5jaGVja2VkID8gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInhmYU9uXCIpIDogZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInhmYU9mZlwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgc3RvcmVkRGF0YS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBzdG9yZWREYXRhLnZhbHVlKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBlbGVtZW50LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uLmF0dHJpYnV0ZXMudmFsdWUgPT09IHN0b3JlZERhdGEudmFsdWUpIHtcbiAgICAgICAgICAgICAgb3B0aW9uLmF0dHJpYnV0ZXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb24uYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShcInNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb24uYXR0cmlidXRlcy5zZWxlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBldmVudC50YXJnZXQub3B0aW9ucztcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyBcIlwiIDogb3B0aW9uc1tvcHRpb25zLnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhdGljIHNldEF0dHJpYnV0ZXMoe1xuICAgIGh0bWwsXG4gICAgZWxlbWVudCxcbiAgICBzdG9yYWdlID0gbnVsbCxcbiAgICBpbnRlbnQsXG4gICAgbGlua1NlcnZpY2VcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9ID0gZWxlbWVudDtcbiAgICBjb25zdCBpc0hUTUxBbmNob3JFbGVtZW50ID0gaHRtbCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50O1xuICAgIGlmIChhdHRyaWJ1dGVzLnR5cGUgPT09IFwicmFkaW9cIikge1xuICAgICAgYXR0cmlidXRlcy5uYW1lID0gYCR7YXR0cmlidXRlcy5uYW1lfS0ke2ludGVudH1gO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKSkge1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkYXRhSWRcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGh0bWwuc3R5bGUsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRleHRDb250ZW50XCI6XG4gICAgICAgICAgaHRtbC50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghaXNIVE1MQW5jaG9yRWxlbWVudCB8fCBrZXkgIT09IFwiaHJlZlwiICYmIGtleSAhPT0gXCJuZXdXaW5kb3dcIikge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNIVE1MQW5jaG9yRWxlbWVudCkge1xuICAgICAgbGlua1NlcnZpY2UuYWRkTGlua0F0dHJpYnV0ZXMoaHRtbCwgYXR0cmlidXRlcy5ocmVmLCBhdHRyaWJ1dGVzLm5ld1dpbmRvdyk7XG4gICAgfVxuICAgIGlmIChzdG9yYWdlICYmIGF0dHJpYnV0ZXMuZGF0YUlkKSB7XG4gICAgICB0aGlzLnNldHVwU3RvcmFnZShodG1sLCBhdHRyaWJ1dGVzLmRhdGFJZCwgZWxlbWVudCwgc3RvcmFnZSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyByZW5kZXIocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSBwYXJhbWV0ZXJzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGxpbmtTZXJ2aWNlID0gcGFyYW1ldGVycy5saW5rU2VydmljZTtcbiAgICBjb25zdCByb290ID0gcGFyYW1ldGVycy54ZmFIdG1sO1xuICAgIGNvbnN0IGludGVudCA9IHBhcmFtZXRlcnMuaW50ZW50IHx8IFwiZGlzcGxheVwiO1xuICAgIGNvbnN0IHJvb3RIdG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChyb290Lm5hbWUpO1xuICAgIGlmIChyb290LmF0dHJpYnV0ZXMpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgIGh0bWw6IHJvb3RIdG1sLFxuICAgICAgICBlbGVtZW50OiByb290LFxuICAgICAgICBpbnRlbnQsXG4gICAgICAgIGxpbmtTZXJ2aWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBbW3Jvb3QsIC0xLCByb290SHRtbF1dO1xuICAgIGNvbnN0IHJvb3REaXYgPSBwYXJhbWV0ZXJzLmRpdjtcbiAgICByb290RGl2LmFwcGVuZChyb290SHRtbCk7XG4gICAgaWYgKHBhcmFtZXRlcnMudmlld3BvcnQpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGBtYXRyaXgoJHtwYXJhbWV0ZXJzLnZpZXdwb3J0LnRyYW5zZm9ybS5qb2luKFwiLFwiKX0pYDtcbiAgICAgIHJvb3REaXYuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH1cbiAgICBpZiAoaW50ZW50ICE9PSBcInJpY2hUZXh0XCIpIHtcbiAgICAgIHJvb3REaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJ4ZmFMYXllciB4ZmFGb250XCIpO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0RGl2cyA9IFtdO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBbcGFyZW50LCBpLCBodG1sXSA9IHN0YWNrLmF0KC0xKTtcbiAgICAgIGlmIChpICsgMSA9PT0gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlblsrK3N0YWNrLmF0KC0xKVsxXV07XG4gICAgICBpZiAoY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWVcbiAgICAgIH0gPSBjaGlsZDtcbiAgICAgIGlmIChuYW1lID09PSBcIiN0ZXh0XCIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkLnZhbHVlKTtcbiAgICAgICAgdGV4dERpdnMucHVzaChub2RlKTtcbiAgICAgICAgaHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRIdG1sID0gY2hpbGQ/LmF0dHJpYnV0ZXM/LnhtbG5zID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGNoaWxkLmF0dHJpYnV0ZXMueG1sbnMsIG5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbiAgICAgIGh0bWwuYXBwZW5kKGNoaWxkSHRtbCk7XG4gICAgICBpZiAoY2hpbGQuYXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgIGh0bWw6IGNoaWxkSHRtbCxcbiAgICAgICAgICBlbGVtZW50OiBjaGlsZCxcbiAgICAgICAgICBzdG9yYWdlLFxuICAgICAgICAgIGludGVudCxcbiAgICAgICAgICBsaW5rU2VydmljZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5jaGlsZHJlbiAmJiBjaGlsZC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0YWNrLnB1c2goW2NoaWxkLCAtMSwgY2hpbGRIdG1sXSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLnZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZC52YWx1ZSk7XG4gICAgICAgIGlmIChfeGZhX3RleHQuWGZhVGV4dC5zaG91bGRCdWlsZFRleHQobmFtZSkpIHtcbiAgICAgICAgICB0ZXh0RGl2cy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkSHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWwgb2Ygcm9vdERpdi5xdWVyeVNlbGVjdG9yQWxsKFwiLnhmYU5vbkludGVyYWN0aXZlIGlucHV0LCAueGZhTm9uSW50ZXJhY3RpdmUgdGV4dGFyZWFcIikpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcInJlYWRPbmx5XCIsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdGV4dERpdnNcbiAgICB9O1xuICB9XG4gIHN0YXRpYyB1cGRhdGUocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGBtYXRyaXgoJHtwYXJhbWV0ZXJzLnZpZXdwb3J0LnRyYW5zZm9ybS5qb2luKFwiLFwiKX0pYDtcbiAgICBwYXJhbWV0ZXJzLmRpdi5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgcGFyYW1ldGVycy5kaXYuaGlkZGVuID0gZmFsc2U7XG4gIH1cbn1cbmV4cG9ydHMuWGZhTGF5ZXIgPSBYZmFMYXllcjtcblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5JbmtFZGl0b3IgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9lZGl0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xudmFyIF9hbm5vdGF0aW9uX2xheWVyID0gX193X3BkZmpzX3JlcXVpcmVfXygyOSk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xudmFyIF90b29scyA9IF9fd19wZGZqc19yZXF1aXJlX18oNSk7XG5jbGFzcyBJbmtFZGl0b3IgZXh0ZW5kcyBfZWRpdG9yLkFubm90YXRpb25FZGl0b3Ige1xuICAjYmFzZUhlaWdodCA9IDA7XG4gICNiYXNlV2lkdGggPSAwO1xuICAjYm91bmRDYW52YXNQb2ludGVybW92ZSA9IHRoaXMuY2FudmFzUG9pbnRlcm1vdmUuYmluZCh0aGlzKTtcbiAgI2JvdW5kQ2FudmFzUG9pbnRlcmxlYXZlID0gdGhpcy5jYW52YXNQb2ludGVybGVhdmUuYmluZCh0aGlzKTtcbiAgI2JvdW5kQ2FudmFzUG9pbnRlcnVwID0gdGhpcy5jYW52YXNQb2ludGVydXAuYmluZCh0aGlzKTtcbiAgI2JvdW5kQ2FudmFzUG9pbnRlcmRvd24gPSB0aGlzLmNhbnZhc1BvaW50ZXJkb3duLmJpbmQodGhpcyk7XG4gICNjdXJyZW50UGF0aDJEID0gbmV3IFBhdGgyRCgpO1xuICAjZGlzYWJsZUVkaXRpbmcgPSBmYWxzZTtcbiAgI2hhc1NvbWV0aGluZ1RvRHJhdyA9IGZhbHNlO1xuICAjaXNDYW52YXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAjb2JzZXJ2ZXIgPSBudWxsO1xuICAjcmVhbFdpZHRoID0gMDtcbiAgI3JlYWxIZWlnaHQgPSAwO1xuICAjcmVxdWVzdEZyYW1lQ2FsbGJhY2sgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRDb2xvciA9IG51bGw7XG4gIHN0YXRpYyBfZGVmYXVsdE9wYWNpdHkgPSAxO1xuICBzdGF0aWMgX2RlZmF1bHRUaGlja25lc3MgPSAxO1xuICBzdGF0aWMgX3R5cGUgPSBcImlua1wiO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcImlua0VkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy5jb2xvciA9IHBhcmFtcy5jb2xvciB8fCBudWxsO1xuICAgIHRoaXMudGhpY2tuZXNzID0gcGFyYW1zLnRoaWNrbmVzcyB8fCBudWxsO1xuICAgIHRoaXMub3BhY2l0eSA9IHBhcmFtcy5vcGFjaXR5IHx8IG51bGw7XG4gICAgdGhpcy5wYXRocyA9IFtdO1xuICAgIHRoaXMuYmV6aWVyUGF0aDJEID0gW107XG4gICAgdGhpcy5hbGxSYXdQYXRocyA9IFtdO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBbXTtcbiAgICB0aGlzLnNjYWxlRmFjdG9yID0gMTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWCA9IHRoaXMudHJhbnNsYXRpb25ZID0gMDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbikge1xuICAgIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHtcbiAgICAgIHN0cmluZ3M6IFtcImVkaXRvcl9pbmtfY2FudmFzX2FyaWFfbGFiZWxcIiwgXCJlZGl0b3JfaW5rMl9hcmlhX2xhYmVsXCJdXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHVwZGF0ZURlZmF1bHRQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUzpcbiAgICAgICAgSW5rRWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1I6XG4gICAgICAgIElua0VkaXRvci5fZGVmYXVsdENvbG9yID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfT1BBQ0lUWTpcbiAgICAgICAgSW5rRWRpdG9yLl9kZWZhdWx0T3BhY2l0eSA9IHZhbHVlIC8gMTAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1M6XG4gICAgICAgIHRoaXMuI3VwZGF0ZVRoaWNrbmVzcyh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1I6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19PUEFDSVRZOlxuICAgICAgICB0aGlzLiN1cGRhdGVPcGFjaXR5KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfVEhJQ0tORVNTLCBJbmtFZGl0b3IuX2RlZmF1bHRUaGlja25lc3NdLCBbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SLCBJbmtFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3JdLCBbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFksIE1hdGgucm91bmQoSW5rRWRpdG9yLl9kZWZhdWx0T3BhY2l0eSAqIDEwMCldXTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1MsIHRoaXMudGhpY2tuZXNzIHx8IElua0VkaXRvci5fZGVmYXVsdFRoaWNrbmVzc10sIFtfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1IsIHRoaXMuY29sb3IgfHwgSW5rRWRpdG9yLl9kZWZhdWx0Q29sb3IgfHwgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yXSwgW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19PUEFDSVRZLCBNYXRoLnJvdW5kKDEwMCAqICh0aGlzLm9wYWNpdHkgPz8gSW5rRWRpdG9yLl9kZWZhdWx0T3BhY2l0eSkpXV07XG4gIH1cbiAgI3VwZGF0ZVRoaWNrbmVzcyh0aGlja25lc3MpIHtcbiAgICBjb25zdCBzYXZlZFRoaWNrbmVzcyA9IHRoaXMudGhpY2tuZXNzO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHRoaXMudGhpY2tuZXNzID0gdGhpY2tuZXNzO1xuICAgICAgICB0aGlzLiNmaXRUb0NvbnRlbnQoKTtcbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIHRoaXMudGhpY2tuZXNzID0gc2F2ZWRUaGlja25lc3M7XG4gICAgICAgIHRoaXMuI2ZpdFRvQ29udGVudCgpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUyxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICN1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICB0aGlzLmNvbG9yID0gc2F2ZWRDb2xvcjtcbiAgICAgICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1IsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICAjdXBkYXRlT3BhY2l0eShvcGFjaXR5KSB7XG4gICAgb3BhY2l0eSAvPSAxMDA7XG4gICAgY29uc3Qgc2F2ZWRPcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgIHRoaXMuI3JlZHJhdygpO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gc2F2ZWRPcGFjaXR5O1xuICAgICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19PUEFDSVRZLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgICB0aGlzLiNjcmVhdGVPYnNlcnZlcigpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgICB0aGlzLiNzZXRDYW52YXNEaW1zKCk7XG4gICAgfVxuICAgIHRoaXMuI2ZpdFRvQ29udGVudCgpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy5jYW52YXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICB9XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMuY2FudmFzLnJlbW92ZSgpO1xuICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICB0aGlzLiNvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy4jb2JzZXJ2ZXIgPSBudWxsO1xuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50ICYmIHBhcmVudCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlbW92ZVNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudCAmJiBwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5hZGRTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgIH1cbiAgICBzdXBlci5zZXRQYXJlbnQocGFyZW50KTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aCAqIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuc2V0RGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAodGhpcy4jZGlzYWJsZUVkaXRpbmcgfHwgdGhpcy5jYW52YXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJkb3duKTtcbiAgfVxuICBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5FZGl0TW9kZSgpIHx8IHRoaXMuY2FudmFzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gIXRoaXMuaXNFbXB0eSgpO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJlZGl0aW5nXCIpO1xuICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJkb3duKTtcbiAgfVxuICBvbmNlQWRkZWQoKSB7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSAhdGhpcy5pc0VtcHR5KCk7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRocy5sZW5ndGggPT09IDAgfHwgdGhpcy5wYXRocy5sZW5ndGggPT09IDEgJiYgdGhpcy5wYXRoc1swXS5sZW5ndGggPT09IDA7XG4gIH1cbiAgI2dldEluaXRpYWxCQm94KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudFJvdGF0aW9uLFxuICAgICAgcGFyZW50RGltZW5zaW9uczogW3dpZHRoLCBoZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgc3dpdGNoIChwYXJlbnRSb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFswLCBoZWlnaHQsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbd2lkdGgsIGhlaWdodCwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt3aWR0aCwgMCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWzAsIDAsIHdpZHRoLCBoZWlnaHRdO1xuICAgIH1cbiAgfVxuICAjc2V0U3Ryb2tlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eCxcbiAgICAgIGNvbG9yLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHRoaWNrbmVzcyxcbiAgICAgIHBhcmVudFNjYWxlLFxuICAgICAgc2NhbGVGYWN0b3JcbiAgICB9ID0gdGhpcztcbiAgICBjdHgubGluZVdpZHRoID0gdGhpY2tuZXNzICogcGFyZW50U2NhbGUgLyBzY2FsZUZhY3RvcjtcbiAgICBjdHgubGluZUNhcCA9IFwicm91bmRcIjtcbiAgICBjdHgubGluZUpvaW4gPSBcInJvdW5kXCI7XG4gICAgY3R4Lm1pdGVyTGltaXQgPSAxMDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBgJHtjb2xvcn0keygwLCBfdG9vbHMub3BhY2l0eVRvSGV4KShvcGFjaXR5KX1gO1xuICB9XG4gICNzdGFydERyYXdpbmcoeCwgeSkge1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBfZGlzcGxheV91dGlscy5ub0NvbnRleHRNZW51KTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcmxlYXZlKTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVybW92ZSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJ1cCk7XG4gICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcmRvd24pO1xuICAgIHRoaXMuaXNFZGl0aW5nID0gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuI2lzQ2FudmFzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuI2lzQ2FudmFzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgICAgdGhpcy50aGlja25lc3MgfHw9IElua0VkaXRvci5fZGVmYXVsdFRoaWNrbmVzcztcbiAgICAgIHRoaXMuY29sb3IgfHw9IElua0VkaXRvci5fZGVmYXVsdENvbG9yIHx8IF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcjtcbiAgICAgIHRoaXMub3BhY2l0eSA/Pz0gSW5rRWRpdG9yLl9kZWZhdWx0T3BhY2l0eTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50UGF0aC5wdXNoKFt4LCB5XSk7XG4gICAgdGhpcy4jaGFzU29tZXRoaW5nVG9EcmF3ID0gZmFsc2U7XG4gICAgdGhpcy4jc2V0U3Ryb2tlKCk7XG4gICAgdGhpcy4jcmVxdWVzdEZyYW1lQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLiNkcmF3UG9pbnRzKCk7XG4gICAgICBpZiAodGhpcy4jcmVxdWVzdEZyYW1lQ2FsbGJhY2spIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLiNyZXF1ZXN0RnJhbWVDYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuI3JlcXVlc3RGcmFtZUNhbGxiYWNrKTtcbiAgfVxuICAjZHJhdyh4LCB5KSB7XG4gICAgY29uc3QgW2xhc3RYLCBsYXN0WV0gPSB0aGlzLmN1cnJlbnRQYXRoLmF0KC0xKTtcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5sZW5ndGggPiAxICYmIHggPT09IGxhc3RYICYmIHkgPT09IGxhc3RZKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gdGhpcy5jdXJyZW50UGF0aDtcbiAgICBsZXQgcGF0aDJEID0gdGhpcy4jY3VycmVudFBhdGgyRDtcbiAgICBjdXJyZW50UGF0aC5wdXNoKFt4LCB5XSk7XG4gICAgdGhpcy4jaGFzU29tZXRoaW5nVG9EcmF3ID0gdHJ1ZTtcbiAgICBpZiAoY3VycmVudFBhdGgubGVuZ3RoIDw9IDIpIHtcbiAgICAgIHBhdGgyRC5tb3ZlVG8oLi4uY3VycmVudFBhdGhbMF0pO1xuICAgICAgcGF0aDJELmxpbmVUbyh4LCB5KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQYXRoLmxlbmd0aCA9PT0gMykge1xuICAgICAgdGhpcy4jY3VycmVudFBhdGgyRCA9IHBhdGgyRCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIHBhdGgyRC5tb3ZlVG8oLi4uY3VycmVudFBhdGhbMF0pO1xuICAgIH1cbiAgICB0aGlzLiNtYWtlQmV6aWVyQ3VydmUocGF0aDJELCAuLi5jdXJyZW50UGF0aC5hdCgtMyksIC4uLmN1cnJlbnRQYXRoLmF0KC0yKSwgeCwgeSk7XG4gIH1cbiAgI2VuZFBhdGgoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3RQb2ludCA9IHRoaXMuY3VycmVudFBhdGguYXQoLTEpO1xuICAgIHRoaXMuI2N1cnJlbnRQYXRoMkQubGluZVRvKC4uLmxhc3RQb2ludCk7XG4gIH1cbiAgI3N0b3BEcmF3aW5nKHgsIHkpIHtcbiAgICB0aGlzLiNyZXF1ZXN0RnJhbWVDYWxsYmFjayA9IG51bGw7XG4gICAgeCA9IE1hdGgubWluKE1hdGgubWF4KHgsIDApLCB0aGlzLmNhbnZhcy53aWR0aCk7XG4gICAgeSA9IE1hdGgubWluKE1hdGgubWF4KHksIDApLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMuI2RyYXcoeCwgeSk7XG4gICAgdGhpcy4jZW5kUGF0aCgpO1xuICAgIGxldCBiZXppZXI7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgubGVuZ3RoICE9PSAxKSB7XG4gICAgICBiZXppZXIgPSB0aGlzLiNnZW5lcmF0ZUJlemllclBvaW50cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB4eSA9IFt4LCB5XTtcbiAgICAgIGJlemllciA9IFtbeHksIHh5LnNsaWNlKCksIHh5LnNsaWNlKCksIHh5XV07XG4gICAgfVxuICAgIGNvbnN0IHBhdGgyRCA9IHRoaXMuI2N1cnJlbnRQYXRoMkQ7XG4gICAgY29uc3QgY3VycmVudFBhdGggPSB0aGlzLmN1cnJlbnRQYXRoO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBbXTtcbiAgICB0aGlzLiNjdXJyZW50UGF0aDJEID0gbmV3IFBhdGgyRCgpO1xuICAgIGNvbnN0IGNtZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuYWxsUmF3UGF0aHMucHVzaChjdXJyZW50UGF0aCk7XG4gICAgICB0aGlzLnBhdGhzLnB1c2goYmV6aWVyKTtcbiAgICAgIHRoaXMuYmV6aWVyUGF0aDJELnB1c2gocGF0aDJEKTtcbiAgICAgIHRoaXMucmVidWlsZCgpO1xuICAgIH07XG4gICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgIHRoaXMuYWxsUmF3UGF0aHMucG9wKCk7XG4gICAgICB0aGlzLnBhdGhzLnBvcCgpO1xuICAgICAgdGhpcy5iZXppZXJQYXRoMkQucG9wKCk7XG4gICAgICBpZiAodGhpcy5wYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgICAgICAgICB0aGlzLiNjcmVhdGVPYnNlcnZlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2ZpdFRvQ29udGVudCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgfVxuICAjZHJhd1BvaW50cygpIHtcbiAgICBpZiAoIXRoaXMuI2hhc1NvbWV0aGluZ1RvRHJhdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYXNTb21ldGhpbmdUb0RyYXcgPSBmYWxzZTtcbiAgICBjb25zdCB0aGlja25lc3MgPSBNYXRoLmNlaWwodGhpcy50aGlja25lc3MgKiB0aGlzLnBhcmVudFNjYWxlKTtcbiAgICBjb25zdCBsYXN0UG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5zbGljZSgtMyk7XG4gICAgY29uc3QgeCA9IGxhc3RQb2ludHMubWFwKHh5ID0+IHh5WzBdKTtcbiAgICBjb25zdCB5ID0gbGFzdFBvaW50cy5tYXAoeHkgPT4geHlbMV0pO1xuICAgIGNvbnN0IHhNaW4gPSBNYXRoLm1pbiguLi54KSAtIHRoaWNrbmVzcztcbiAgICBjb25zdCB4TWF4ID0gTWF0aC5tYXgoLi4ueCkgKyB0aGlja25lc3M7XG4gICAgY29uc3QgeU1pbiA9IE1hdGgubWluKC4uLnkpIC0gdGhpY2tuZXNzO1xuICAgIGNvbnN0IHlNYXggPSBNYXRoLm1heCguLi55KSArIHRoaWNrbmVzcztcbiAgICBjb25zdCB7XG4gICAgICBjdHhcbiAgICB9ID0gdGhpcztcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHRoaXMuYmV6aWVyUGF0aDJEKSB7XG4gICAgICBjdHguc3Ryb2tlKHBhdGgpO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKHRoaXMuI2N1cnJlbnRQYXRoMkQpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgI21ha2VCZXppZXJDdXJ2ZShwYXRoMkQsIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBjb25zdCBwcmV2WCA9ICh4MCArIHgxKSAvIDI7XG4gICAgY29uc3QgcHJldlkgPSAoeTAgKyB5MSkgLyAyO1xuICAgIGNvbnN0IHgzID0gKHgxICsgeDIpIC8gMjtcbiAgICBjb25zdCB5MyA9ICh5MSArIHkyKSAvIDI7XG4gICAgcGF0aDJELmJlemllckN1cnZlVG8ocHJldlggKyAyICogKHgxIC0gcHJldlgpIC8gMywgcHJldlkgKyAyICogKHkxIC0gcHJldlkpIC8gMywgeDMgKyAyICogKHgxIC0geDMpIC8gMywgeTMgKyAyICogKHkxIC0geTMpIC8gMywgeDMsIHkzKTtcbiAgfVxuICAjZ2VuZXJhdGVCZXppZXJQb2ludHMoKSB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMuY3VycmVudFBhdGg7XG4gICAgaWYgKHBhdGgubGVuZ3RoIDw9IDIpIHtcbiAgICAgIHJldHVybiBbW3BhdGhbMF0sIHBhdGhbMF0sIHBhdGguYXQoLTEpLCBwYXRoLmF0KC0xKV1dO1xuICAgIH1cbiAgICBjb25zdCBiZXppZXJQb2ludHMgPSBbXTtcbiAgICBsZXQgaTtcbiAgICBsZXQgW3gwLCB5MF0gPSBwYXRoWzBdO1xuICAgIGZvciAoaSA9IDE7IGkgPCBwYXRoLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgY29uc3QgW3gxLCB5MV0gPSBwYXRoW2ldO1xuICAgICAgY29uc3QgW3gyLCB5Ml0gPSBwYXRoW2kgKyAxXTtcbiAgICAgIGNvbnN0IHgzID0gKHgxICsgeDIpIC8gMjtcbiAgICAgIGNvbnN0IHkzID0gKHkxICsgeTIpIC8gMjtcbiAgICAgIGNvbnN0IGNvbnRyb2wxID0gW3gwICsgMiAqICh4MSAtIHgwKSAvIDMsIHkwICsgMiAqICh5MSAtIHkwKSAvIDNdO1xuICAgICAgY29uc3QgY29udHJvbDIgPSBbeDMgKyAyICogKHgxIC0geDMpIC8gMywgeTMgKyAyICogKHkxIC0geTMpIC8gM107XG4gICAgICBiZXppZXJQb2ludHMucHVzaChbW3gwLCB5MF0sIGNvbnRyb2wxLCBjb250cm9sMiwgW3gzLCB5M11dKTtcbiAgICAgIFt4MCwgeTBdID0gW3gzLCB5M107XG4gICAgfVxuICAgIGNvbnN0IFt4MSwgeTFdID0gcGF0aFtpXTtcbiAgICBjb25zdCBbeDIsIHkyXSA9IHBhdGhbaSArIDFdO1xuICAgIGNvbnN0IGNvbnRyb2wxID0gW3gwICsgMiAqICh4MSAtIHgwKSAvIDMsIHkwICsgMiAqICh5MSAtIHkwKSAvIDNdO1xuICAgIGNvbnN0IGNvbnRyb2wyID0gW3gyICsgMiAqICh4MSAtIHgyKSAvIDMsIHkyICsgMiAqICh5MSAtIHkyKSAvIDNdO1xuICAgIGJlemllclBvaW50cy5wdXNoKFtbeDAsIHkwXSwgY29udHJvbDEsIGNvbnRyb2wyLCBbeDIsIHkyXV0pO1xuICAgIHJldHVybiBiZXppZXJQb2ludHM7XG4gIH1cbiAgI3JlZHJhdygpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuI3VwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZXRTdHJva2UoKTtcbiAgICBjb25zdCB7XG4gICAgICBjYW52YXMsXG4gICAgICBjdHhcbiAgICB9ID0gdGhpcztcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLiN1cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgdGhpcy5iZXppZXJQYXRoMkQpIHtcbiAgICAgIGN0eC5zdHJva2UocGF0aCk7XG4gICAgfVxuICB9XG4gIGNvbW1pdCgpIHtcbiAgICBpZiAodGhpcy4jZGlzYWJsZUVkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuY29tbWl0KCk7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuc2V0SW5Gb3JlZ3JvdW5kKCk7XG4gICAgdGhpcy4jZGlzYWJsZUVkaXRpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC5hZGQoXCJkaXNhYmxlZFwiKTtcbiAgICB0aGlzLiNmaXRUb0NvbnRlbnQodHJ1ZSk7XG4gICAgdGhpcy5tYWtlUmVzaXphYmxlKCk7XG4gICAgdGhpcy5wYXJlbnQuYWRkSW5rRWRpdG9ySWZOZWVkZWQodHJ1ZSk7XG4gICAgdGhpcy5tb3ZlSW5ET00oKTtcbiAgICB0aGlzLmRpdi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZm9jdXNpbihldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmZvY3VzaW4oZXZlbnQpO1xuICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgfVxuICBjYW52YXNQb2ludGVyZG93bihldmVudCkge1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgIXRoaXMuaXNJbkVkaXRNb2RlKCkgfHwgdGhpcy4jZGlzYWJsZUVkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRJbkZvcmVncm91bmQoKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChldmVudC50eXBlICE9PSBcIm1vdXNlXCIpIHtcbiAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgfVxuICAgIHRoaXMuI3N0YXJ0RHJhd2luZyhldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgfVxuICBjYW52YXNQb2ludGVybW92ZShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy4jZHJhdyhldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgfVxuICBjYW52YXNQb2ludGVydXAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuI2VuZERyYXdpbmcoZXZlbnQpO1xuICB9XG4gIGNhbnZhc1BvaW50ZXJsZWF2ZShldmVudCkge1xuICAgIHRoaXMuI2VuZERyYXdpbmcoZXZlbnQpO1xuICB9XG4gICNlbmREcmF3aW5nKGV2ZW50KSB7XG4gICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJsZWF2ZSk7XG4gICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcm1vdmUpO1xuICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVydXApO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJkb3duKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBfZGlzcGxheV91dGlscy5ub0NvbnRleHRNZW51KTtcbiAgICB9LCAxMCk7XG4gICAgdGhpcy4jc3RvcERyYXdpbmcoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKCk7XG4gICAgdGhpcy5zZXRJbkJhY2tncm91bmQoKTtcbiAgfVxuICAjY3JlYXRlQ2FudmFzKCkge1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuY2FudmFzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5jYW52YXMuY2xhc3NOYW1lID0gXCJpbmtFZGl0b3JDYW52YXNcIjtcbiAgICBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2wxMG5Qcm9taXNlLmdldChcImVkaXRvcl9pbmtfY2FudmFzX2FyaWFfbGFiZWxcIikudGhlbihtc2cgPT4gdGhpcy5jYW52YXM/LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbXNnKSk7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMuY2FudmFzKTtcbiAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgfVxuICAjY3JlYXRlT2JzZXJ2ZXIoKSB7XG4gICAgdGhpcy4jb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBjb25zdCByZWN0ID0gZW50cmllc1swXS5jb250ZW50UmVjdDtcbiAgICAgIGlmIChyZWN0LndpZHRoICYmIHJlY3QuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuc2V0RGltZW5zaW9ucyhyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy4jb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmRpdik7XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiAhdGhpcy5pc0VtcHR5KCkgJiYgdGhpcy4jZGlzYWJsZUVkaXRpbmc7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2wxMG5Qcm9taXNlLmdldChcImVkaXRvcl9pbmsyX2FyaWFfbGFiZWxcIikudGhlbihtc2cgPT4gdGhpcy5kaXY/LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbXNnKSk7XG4gICAgY29uc3QgW3gsIHksIHcsIGhdID0gdGhpcy4jZ2V0SW5pdGlhbEJCb3goKTtcbiAgICB0aGlzLnNldEF0KHgsIHksIDAsIDApO1xuICAgIHRoaXMuc2V0RGltcyh3LCBoKTtcbiAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgdGhpcy5zZXRBc3BlY3RSYXRpbyh0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICAgIHRoaXMuc2V0QXQoYmFzZVggKiBwYXJlbnRXaWR0aCwgYmFzZVkgKiBwYXJlbnRIZWlnaHQsIHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgICAgdGhpcy4jaXNDYW52YXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLiNzZXRDYW52YXNEaW1zKCk7XG4gICAgICB0aGlzLnNldERpbXModGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICAgIHRoaXMuZGl2LmNsYXNzTGlzdC5hZGQoXCJkaXNhYmxlZFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LmFkZChcImVkaXRpbmdcIik7XG4gICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgfVxuICAgIHRoaXMuI2NyZWF0ZU9ic2VydmVyKCk7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gICNzZXRDYW52YXNEaW1zKCkge1xuICAgIGlmICghdGhpcy4jaXNDYW52YXNJbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSBNYXRoLmNlaWwodGhpcy53aWR0aCAqIHBhcmVudFdpZHRoKTtcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwodGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIHRoaXMuI3VwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIHNldERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJvdW5kZWRXaWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuICAgIGNvbnN0IHJvdW5kZWRIZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgaWYgKHRoaXMuI3JlYWxXaWR0aCA9PT0gcm91bmRlZFdpZHRoICYmIHRoaXMuI3JlYWxIZWlnaHQgPT09IHJvdW5kZWRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jcmVhbFdpZHRoID0gcm91bmRlZFdpZHRoO1xuICAgIHRoaXMuI3JlYWxIZWlnaHQgPSByb3VuZGVkSGVpZ2h0O1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLndpZHRoID0gd2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAvIHBhcmVudEhlaWdodDtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgaWYgKHRoaXMuI2Rpc2FibGVFZGl0aW5nKSB7XG4gICAgICB0aGlzLiNzZXRTY2FsZUZhY3Rvcih3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgIHRoaXMuI3JlZHJhdygpO1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgICB0aGlzLmZpeERpbXMoKTtcbiAgfVxuICAjc2V0U2NhbGVGYWN0b3Iod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLiNnZXRQYWRkaW5nKCk7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3JXID0gKHdpZHRoIC0gcGFkZGluZykgLyB0aGlzLiNiYXNlV2lkdGg7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3JIID0gKGhlaWdodCAtIHBhZGRpbmcpIC8gdGhpcy4jYmFzZUhlaWdodDtcbiAgICB0aGlzLnNjYWxlRmFjdG9yID0gTWF0aC5taW4oc2NhbGVGYWN0b3JXLCBzY2FsZUZhY3RvckgpO1xuICB9XG4gICN1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuI2dldFBhZGRpbmcoKSAvIDI7XG4gICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKHRoaXMuc2NhbGVGYWN0b3IsIDAsIDAsIHRoaXMuc2NhbGVGYWN0b3IsIHRoaXMudHJhbnNsYXRpb25YICogdGhpcy5zY2FsZUZhY3RvciArIHBhZGRpbmcsIHRoaXMudHJhbnNsYXRpb25ZICogdGhpcy5zY2FsZUZhY3RvciArIHBhZGRpbmcpO1xuICB9XG4gIHN0YXRpYyAjYnVpbGRQYXRoMkQoYmV6aWVyKSB7XG4gICAgY29uc3QgcGF0aDJEID0gbmV3IFBhdGgyRCgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGJlemllci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBbZmlyc3QsIGNvbnRyb2wxLCBjb250cm9sMiwgc2Vjb25kXSA9IGJlemllcltpXTtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHBhdGgyRC5tb3ZlVG8oLi4uZmlyc3QpO1xuICAgICAgfVxuICAgICAgcGF0aDJELmJlemllckN1cnZlVG8oY29udHJvbDFbMF0sIGNvbnRyb2wxWzFdLCBjb250cm9sMlswXSwgY29udHJvbDJbMV0sIHNlY29uZFswXSwgc2Vjb25kWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGgyRDtcbiAgfVxuICBzdGF0aWMgI3RvUERGQ29vcmRpbmF0ZXMocG9pbnRzLCByZWN0LCByb3RhdGlvbikge1xuICAgIGNvbnN0IFtibFgsIGJsWSwgdHJYLCB0clldID0gcmVjdDtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgcG9pbnRzW2ldICs9IGJsWDtcbiAgICAgICAgICBwb2ludHNbaSArIDFdID0gdHJZIC0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBwb2ludHNbaV0gPSBwb2ludHNbaSArIDFdICsgYmxYO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB4ICsgYmxZO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgcG9pbnRzW2ldID0gdHJYIC0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gKz0gYmxZO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBwb2ludHNbaV0gPSB0clggLSBwb2ludHNbaSArIDFdO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB0clkgLSB4O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuICBzdGF0aWMgI2Zyb21QREZDb29yZGluYXRlcyhwb2ludHMsIHJlY3QsIHJvdGF0aW9uKSB7XG4gICAgY29uc3QgW2JsWCwgYmxZLCB0clgsIHRyWV0gPSByZWN0O1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBwb2ludHNbaV0gLT0gYmxYO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB0clkgLSBwb2ludHNbaSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpXSA9IHBvaW50c1tpICsgMV0gLSBibFk7XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHggLSBibFg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBwb2ludHNbaV0gPSB0clggLSBwb2ludHNbaV07XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSAtPSBibFk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpXSA9IHRyWSAtIHBvaW50c1tpICsgMV07XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHRyWCAtIHg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG4gICNzZXJpYWxpemVQYXRocyhzLCB0eCwgdHksIHJlY3QpIHtcbiAgICBjb25zdCBwYXRocyA9IFtdO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLnRoaWNrbmVzcyAvIDI7XG4gICAgY29uc3Qgc2hpZnRYID0gcyAqIHR4ICsgcGFkZGluZztcbiAgICBjb25zdCBzaGlmdFkgPSBzICogdHkgKyBwYWRkaW5nO1xuICAgIGZvciAoY29uc3QgYmV6aWVyIG9mIHRoaXMucGF0aHMpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICBmb3IgKGxldCBqID0gMCwgamogPSBiZXppZXIubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICBjb25zdCBbZmlyc3QsIGNvbnRyb2wxLCBjb250cm9sMiwgc2Vjb25kXSA9IGJlemllcltqXTtcbiAgICAgICAgY29uc3QgcDEwID0gcyAqIGZpcnN0WzBdICsgc2hpZnRYO1xuICAgICAgICBjb25zdCBwMTEgPSBzICogZmlyc3RbMV0gKyBzaGlmdFk7XG4gICAgICAgIGNvbnN0IHAyMCA9IHMgKiBjb250cm9sMVswXSArIHNoaWZ0WDtcbiAgICAgICAgY29uc3QgcDIxID0gcyAqIGNvbnRyb2wxWzFdICsgc2hpZnRZO1xuICAgICAgICBjb25zdCBwMzAgPSBzICogY29udHJvbDJbMF0gKyBzaGlmdFg7XG4gICAgICAgIGNvbnN0IHAzMSA9IHMgKiBjb250cm9sMlsxXSArIHNoaWZ0WTtcbiAgICAgICAgY29uc3QgcDQwID0gcyAqIHNlY29uZFswXSArIHNoaWZ0WDtcbiAgICAgICAgY29uc3QgcDQxID0gcyAqIHNlY29uZFsxXSArIHNoaWZ0WTtcbiAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICBidWZmZXIucHVzaChwMTAsIHAxMSk7XG4gICAgICAgICAgcG9pbnRzLnB1c2gocDEwLCBwMTEpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5wdXNoKHAyMCwgcDIxLCBwMzAsIHAzMSwgcDQwLCBwNDEpO1xuICAgICAgICBwb2ludHMucHVzaChwMjAsIHAyMSk7XG4gICAgICAgIGlmIChqID09PSBqaiAtIDEpIHtcbiAgICAgICAgICBwb2ludHMucHVzaChwNDAsIHA0MSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhdGhzLnB1c2goe1xuICAgICAgICBiZXppZXI6IElua0VkaXRvci4jdG9QREZDb29yZGluYXRlcyhidWZmZXIsIHJlY3QsIHRoaXMucm90YXRpb24pLFxuICAgICAgICBwb2ludHM6IElua0VkaXRvci4jdG9QREZDb29yZGluYXRlcyhwb2ludHMsIHJlY3QsIHRoaXMucm90YXRpb24pXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGhzO1xuICB9XG4gICNnZXRCYm94KCkge1xuICAgIGxldCB4TWluID0gSW5maW5pdHk7XG4gICAgbGV0IHhNYXggPSAtSW5maW5pdHk7XG4gICAgbGV0IHlNaW4gPSBJbmZpbml0eTtcbiAgICBsZXQgeU1heCA9IC1JbmZpbml0eTtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgdGhpcy5wYXRocykge1xuICAgICAgZm9yIChjb25zdCBbZmlyc3QsIGNvbnRyb2wxLCBjb250cm9sMiwgc2Vjb25kXSBvZiBwYXRoKSB7XG4gICAgICAgIGNvbnN0IGJib3ggPSBfdXRpbC5VdGlsLmJlemllckJvdW5kaW5nQm94KC4uLmZpcnN0LCAuLi5jb250cm9sMSwgLi4uY29udHJvbDIsIC4uLnNlY29uZCk7XG4gICAgICAgIHhNaW4gPSBNYXRoLm1pbih4TWluLCBiYm94WzBdKTtcbiAgICAgICAgeU1pbiA9IE1hdGgubWluKHlNaW4sIGJib3hbMV0pO1xuICAgICAgICB4TWF4ID0gTWF0aC5tYXgoeE1heCwgYmJveFsyXSk7XG4gICAgICAgIHlNYXggPSBNYXRoLm1heCh5TWF4LCBiYm94WzNdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFt4TWluLCB5TWluLCB4TWF4LCB5TWF4XTtcbiAgfVxuICAjZ2V0UGFkZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy4jZGlzYWJsZUVkaXRpbmcgPyBNYXRoLmNlaWwodGhpcy50aGlja25lc3MgKiB0aGlzLnBhcmVudFNjYWxlKSA6IDA7XG4gIH1cbiAgI2ZpdFRvQ29udGVudChmaXJzdFRpbWUgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2Rpc2FibGVFZGl0aW5nKSB7XG4gICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2dldEJib3goKTtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy4jZ2V0UGFkZGluZygpO1xuICAgIHRoaXMuI2Jhc2VXaWR0aCA9IE1hdGgubWF4KF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSwgYmJveFsyXSAtIGJib3hbMF0pO1xuICAgIHRoaXMuI2Jhc2VIZWlnaHQgPSBNYXRoLm1heChfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUsIGJib3hbM10gLSBiYm94WzFdKTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChwYWRkaW5nICsgdGhpcy4jYmFzZVdpZHRoICogdGhpcy5zY2FsZUZhY3Rvcik7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5jZWlsKHBhZGRpbmcgKyB0aGlzLiNiYXNlSGVpZ2h0ICogdGhpcy5zY2FsZUZhY3Rvcik7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCAvIHBhcmVudFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuc2V0QXNwZWN0UmF0aW8od2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgcHJldlRyYW5zbGF0aW9uWCA9IHRoaXMudHJhbnNsYXRpb25YO1xuICAgIGNvbnN0IHByZXZUcmFuc2xhdGlvblkgPSB0aGlzLnRyYW5zbGF0aW9uWTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWCA9IC1iYm94WzBdO1xuICAgIHRoaXMudHJhbnNsYXRpb25ZID0gLWJib3hbMV07XG4gICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgIHRoaXMuI3JlZHJhdygpO1xuICAgIHRoaXMuI3JlYWxXaWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuI3JlYWxIZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5zZXREaW1zKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHVuc2NhbGVkUGFkZGluZyA9IGZpcnN0VGltZSA/IHBhZGRpbmcgLyB0aGlzLnNjYWxlRmFjdG9yIC8gMiA6IDA7XG4gICAgdGhpcy50cmFuc2xhdGUocHJldlRyYW5zbGF0aW9uWCAtIHRoaXMudHJhbnNsYXRpb25YIC0gdW5zY2FsZWRQYWRkaW5nLCBwcmV2VHJhbnNsYXRpb25ZIC0gdGhpcy50cmFuc2xhdGlvblkgLSB1bnNjYWxlZFBhZGRpbmcpO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgX2Fubm90YXRpb25fbGF5ZXIuSW5rQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLnRoaWNrbmVzcyA9IGRhdGEudGhpY2tuZXNzO1xuICAgIGVkaXRvci5jb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKC4uLmRhdGEuY29sb3IpO1xuICAgIGVkaXRvci5vcGFjaXR5ID0gZGF0YS5vcGFjaXR5O1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IHdpZHRoID0gZWRpdG9yLndpZHRoICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGVkaXRvci5oZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gZWRpdG9yLnBhcmVudFNjYWxlO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBkYXRhLnRoaWNrbmVzcyAvIDI7XG4gICAgZWRpdG9yLiNkaXNhYmxlRWRpdGluZyA9IHRydWU7XG4gICAgZWRpdG9yLiNyZWFsV2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKTtcbiAgICBlZGl0b3IuI3JlYWxIZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgY29uc3Qge1xuICAgICAgcGF0aHMsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb25cbiAgICB9ID0gZGF0YTtcbiAgICBmb3IgKGxldCB7XG4gICAgICBiZXppZXJcbiAgICB9IG9mIHBhdGhzKSB7XG4gICAgICBiZXppZXIgPSBJbmtFZGl0b3IuI2Zyb21QREZDb29yZGluYXRlcyhiZXppZXIsIHJlY3QsIHJvdGF0aW9uKTtcbiAgICAgIGNvbnN0IHBhdGggPSBbXTtcbiAgICAgIGVkaXRvci5wYXRocy5wdXNoKHBhdGgpO1xuICAgICAgbGV0IHAwID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyWzBdIC0gcGFkZGluZyk7XG4gICAgICBsZXQgcDEgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbMV0gLSBwYWRkaW5nKTtcbiAgICAgIGZvciAobGV0IGkgPSAyLCBpaSA9IGJlemllci5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICAgIGNvbnN0IHAxMCA9IHNjYWxlRmFjdG9yICogKGJlemllcltpXSAtIHBhZGRpbmcpO1xuICAgICAgICBjb25zdCBwMTEgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbaSArIDFdIC0gcGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHAyMCA9IHNjYWxlRmFjdG9yICogKGJlemllcltpICsgMl0gLSBwYWRkaW5nKTtcbiAgICAgICAgY29uc3QgcDIxID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyW2kgKyAzXSAtIHBhZGRpbmcpO1xuICAgICAgICBjb25zdCBwMzAgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbaSArIDRdIC0gcGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHAzMSA9IHNjYWxlRmFjdG9yICogKGJlemllcltpICsgNV0gLSBwYWRkaW5nKTtcbiAgICAgICAgcGF0aC5wdXNoKFtbcDAsIHAxXSwgW3AxMCwgcDExXSwgW3AyMCwgcDIxXSwgW3AzMCwgcDMxXV0pO1xuICAgICAgICBwMCA9IHAzMDtcbiAgICAgICAgcDEgPSBwMzE7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXRoMkQgPSB0aGlzLiNidWlsZFBhdGgyRChwYXRoKTtcbiAgICAgIGVkaXRvci5iZXppZXJQYXRoMkQucHVzaChwYXRoMkQpO1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gZWRpdG9yLiNnZXRCYm94KCk7XG4gICAgZWRpdG9yLiNiYXNlV2lkdGggPSBNYXRoLm1heChfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUsIGJib3hbMl0gLSBiYm94WzBdKTtcbiAgICBlZGl0b3IuI2Jhc2VIZWlnaHQgPSBNYXRoLm1heChfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUsIGJib3hbM10gLSBiYm94WzFdKTtcbiAgICBlZGl0b3IuI3NldFNjYWxlRmFjdG9yKHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlY3QgPSB0aGlzLmdldFJlY3QoMCwgMCk7XG4gICAgY29uc3QgY29sb3IgPSBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuY3R4LnN0cm9rZVN0eWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5ub3RhdGlvblR5cGU6IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLklOSyxcbiAgICAgIGNvbG9yLFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLnRoaWNrbmVzcyxcbiAgICAgIG9wYWNpdHk6IHRoaXMub3BhY2l0eSxcbiAgICAgIHBhdGhzOiB0aGlzLiNzZXJpYWxpemVQYXRocyh0aGlzLnNjYWxlRmFjdG9yIC8gdGhpcy5wYXJlbnRTY2FsZSwgdGhpcy50cmFuc2xhdGlvblgsIHRoaXMudHJhbnNsYXRpb25ZLCByZWN0KSxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gIH1cbn1cbmV4cG9ydHMuSW5rRWRpdG9yID0gSW5rRWRpdG9yO1xuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlN0YW1wRWRpdG9yID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZWRpdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG52YXIgX2Fubm90YXRpb25fbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI5KTtcbmNsYXNzIFN0YW1wRWRpdG9yIGV4dGVuZHMgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2JpdG1hcCA9IG51bGw7XG4gICNiaXRtYXBJZCA9IG51bGw7XG4gICNiaXRtYXBQcm9taXNlID0gbnVsbDtcbiAgI2JpdG1hcFVybCA9IG51bGw7XG4gICNiaXRtYXBGaWxlID0gbnVsbDtcbiAgI2NhbnZhcyA9IG51bGw7XG4gICNvYnNlcnZlciA9IG51bGw7XG4gICNyZXNpemVUaW1lb3V0SWQgPSBudWxsO1xuICAjaXNTdmcgPSBmYWxzZTtcbiAgI2hhc0JlZW5BZGRlZEluVW5kb1N0YWNrID0gZmFsc2U7XG4gIHN0YXRpYyBfdHlwZSA9IFwic3RhbXBcIjtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJzdGFtcEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy4jYml0bWFwVXJsID0gcGFyYW1zLmJpdG1hcFVybDtcbiAgICB0aGlzLiNiaXRtYXBGaWxlID0gcGFyYW1zLmJpdG1hcEZpbGU7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbikge1xuICAgIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4pO1xuICB9XG4gIHN0YXRpYyBnZXQgc3VwcG9ydGVkVHlwZXMoKSB7XG4gICAgY29uc3QgdHlwZXMgPSBbXCJhcG5nXCIsIFwiYXZpZlwiLCBcImJtcFwiLCBcImdpZlwiLCBcImpwZWdcIiwgXCJwbmdcIiwgXCJzdmcreG1sXCIsIFwid2VicFwiLCBcIngtaWNvblwiXTtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJzdXBwb3J0ZWRUeXBlc1wiLCB0eXBlcy5tYXAodHlwZSA9PiBgaW1hZ2UvJHt0eXBlfWApKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHN1cHBvcnRlZFR5cGVzU3RyKCkge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcInN1cHBvcnRlZFR5cGVzU3RyXCIsIHRoaXMuc3VwcG9ydGVkVHlwZXMuam9pbihcIixcIikpO1xuICB9XG4gIHN0YXRpYyBpc0hhbmRsaW5nTWltZUZvclBhc3RpbmcobWltZSkge1xuICAgIHJldHVybiB0aGlzLnN1cHBvcnRlZFR5cGVzLmluY2x1ZGVzKG1pbWUpO1xuICB9XG4gIHN0YXRpYyBwYXN0ZShpdGVtLCBwYXJlbnQpIHtcbiAgICBwYXJlbnQucGFzdGVFZGl0b3IoX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVAsIHtcbiAgICAgIGJpdG1hcEZpbGU6IGl0ZW0uZ2V0QXNGaWxlKClcbiAgICB9KTtcbiAgfVxuICAjZ2V0Qml0bWFwRmV0Y2hlZChkYXRhLCBmcm9tSWQgPSBmYWxzZSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYml0bWFwID0gZGF0YS5iaXRtYXA7XG4gICAgaWYgKCFmcm9tSWQpIHtcbiAgICAgIHRoaXMuI2JpdG1hcElkID0gZGF0YS5pZDtcbiAgICAgIHRoaXMuI2lzU3ZnID0gZGF0YS5pc1N2ZztcbiAgICB9XG4gICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gIH1cbiAgI2dldEJpdG1hcERvbmUoKSB7XG4gICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcoZmFsc2UpO1xuICAgIGlmICh0aGlzLiNjYW52YXMpIHtcbiAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG4gICNnZXRCaXRtYXAoKSB7XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbUlkKHRoaXMuI2JpdG1hcElkKS50aGVuKGRhdGEgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhLCB0cnVlKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYml0bWFwVXJsKSB7XG4gICAgICBjb25zdCB1cmwgPSB0aGlzLiNiaXRtYXBVcmw7XG4gICAgICB0aGlzLiNiaXRtYXBVcmwgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tVXJsKHVybCkudGhlbihkYXRhID0+IHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSkpLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcEZpbGUpIHtcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLiNiaXRtYXBGaWxlO1xuICAgICAgdGhpcy4jYml0bWFwRmlsZSA9IG51bGw7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgIHRoaXMuI2JpdG1hcFByb21pc2UgPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21GaWxlKGZpbGUpLnRoZW4oZGF0YSA9PiB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpKS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlucHV0LnR5cGUgPSBcImZpbGVcIjtcbiAgICBpbnB1dC5hY2NlcHQgPSBTdGFtcEVkaXRvci5zdXBwb3J0ZWRUeXBlc1N0cjtcbiAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKCFpbnB1dC5maWxlcyB8fCBpbnB1dC5maWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21GaWxlKGlucHV0LmZpbGVzWzBdKTtcbiAgICAgICAgICB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNhbmNlbFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICBpbnB1dC5jbGljaygpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgIHRoaXMuI2JpdG1hcCA9IG51bGw7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmRlbGV0ZUlkKHRoaXMuI2JpdG1hcElkKTtcbiAgICAgIHRoaXMuI2NhbnZhcz8ucmVtb3ZlKCk7XG4gICAgICB0aGlzLiNjYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy4jb2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuI29ic2VydmVyID0gbnVsbDtcbiAgICB9XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICB0aGlzLiNnZXRCaXRtYXAoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBvbmNlQWRkZWQoKSB7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gISh0aGlzLiNiaXRtYXBQcm9taXNlIHx8IHRoaXMuI2JpdG1hcCB8fCB0aGlzLiNiaXRtYXBVcmwgfHwgdGhpcy4jYml0bWFwRmlsZSk7XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgbGV0IGJhc2VYLCBiYXNlWTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgYmFzZVggPSB0aGlzLng7XG4gICAgICBiYXNlWSA9IHRoaXMueTtcbiAgICB9XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy5kaXYuaGlkZGVuID0gdHJ1ZTtcbiAgICBpZiAodGhpcy4jYml0bWFwKSB7XG4gICAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICB0aGlzLnNldEF0KGJhc2VYICogcGFyZW50V2lkdGgsIGJhc2VZICogcGFyZW50SGVpZ2h0LCB0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gICNjcmVhdGVDYW52YXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGl2XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI2JpdG1hcDtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgTUFYX1JBVElPID0gMC43NTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgd2lkdGggPSB0aGlzLndpZHRoICogcGFnZVdpZHRoO1xuICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAod2lkdGggPiBNQVhfUkFUSU8gKiBwYWdlV2lkdGggfHwgaGVpZ2h0ID4gTUFYX1JBVElPICogcGFnZUhlaWdodCkge1xuICAgICAgY29uc3QgZmFjdG9yID0gTWF0aC5taW4oTUFYX1JBVElPICogcGFnZVdpZHRoIC8gd2lkdGgsIE1BWF9SQVRJTyAqIHBhZ2VIZWlnaHQgLyBoZWlnaHQpO1xuICAgICAgd2lkdGggKj0gZmFjdG9yO1xuICAgICAgaGVpZ2h0ICo9IGZhY3RvcjtcbiAgICB9XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuc2V0RGltcyh3aWR0aCAqIHBhcmVudFdpZHRoIC8gcGFnZVdpZHRoLCBoZWlnaHQgKiBwYXJlbnRIZWlnaHQgLyBwYWdlSGVpZ2h0KTtcbiAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyhmYWxzZSk7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy4jY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBkaXYuYXBwZW5kKGNhbnZhcyk7XG4gICAgZGl2LmhpZGRlbiA9IGZhbHNlO1xuICAgIHRoaXMuI2RyYXdCaXRtYXAod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy4jY3JlYXRlT2JzZXJ2ZXIoKTtcbiAgICBpZiAoIXRoaXMuI2hhc0JlZW5BZGRlZEluVW5kb1N0YWNrKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGRVbmRvYWJsZUVkaXRvcih0aGlzKTtcbiAgICAgIHRoaXMuI2hhc0JlZW5BZGRlZEluVW5kb1N0YWNrID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fdWlNYW5hZ2VyLl9ldmVudEJ1cy5kaXNwYXRjaChcInJlcG9ydHRlbGVtZXRyeVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBkZXRhaWxzOiB7XG4gICAgICAgIHR5cGU6IFwiZWRpdGluZ1wiLFxuICAgICAgICBzdWJ0eXBlOiB0aGlzLmVkaXRvclR5cGUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBhY3Rpb246IFwiaW5zZXJ0ZWRfaW1hZ2VcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hZGRBbHRUZXh0QnV0dG9uKCk7XG4gIH1cbiAgI3NldERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLndpZHRoID0gd2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAvIHBhcmVudEhlaWdodDtcbiAgICB0aGlzLnNldERpbXMod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxPcHRpb25zPy5pc0NlbnRlcmVkKSB7XG4gICAgICB0aGlzLmNlbnRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxPcHRpb25zID0gbnVsbDtcbiAgICBpZiAodGhpcy4jcmVzaXplVGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jcmVzaXplVGltZW91dElkKTtcbiAgICB9XG4gICAgY29uc3QgVElNRV9UT19XQUlUID0gMjAwO1xuICAgIHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy4jcmVzaXplVGltZW91dElkID0gbnVsbDtcbiAgICAgIHRoaXMuI2RyYXdCaXRtYXAod2lkdGgsIGhlaWdodCk7XG4gICAgfSwgVElNRV9UT19XQUlUKTtcbiAgfVxuICAjc2NhbGVCaXRtYXAod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoOiBiaXRtYXBXaWR0aCxcbiAgICAgIGhlaWdodDogYml0bWFwSGVpZ2h0XG4gICAgfSA9IHRoaXMuI2JpdG1hcDtcbiAgICBsZXQgbmV3V2lkdGggPSBiaXRtYXBXaWR0aDtcbiAgICBsZXQgbmV3SGVpZ2h0ID0gYml0bWFwSGVpZ2h0O1xuICAgIGxldCBiaXRtYXAgPSB0aGlzLiNiaXRtYXA7XG4gICAgd2hpbGUgKG5ld1dpZHRoID4gMiAqIHdpZHRoIHx8IG5ld0hlaWdodCA+IDIgKiBoZWlnaHQpIHtcbiAgICAgIGNvbnN0IHByZXZXaWR0aCA9IG5ld1dpZHRoO1xuICAgICAgY29uc3QgcHJldkhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgIGlmIChuZXdXaWR0aCA+IDIgKiB3aWR0aCkge1xuICAgICAgICBuZXdXaWR0aCA9IG5ld1dpZHRoID49IDE2Mzg0ID8gTWF0aC5mbG9vcihuZXdXaWR0aCAvIDIpIC0gMSA6IE1hdGguY2VpbChuZXdXaWR0aCAvIDIpO1xuICAgICAgfVxuICAgICAgaWYgKG5ld0hlaWdodCA+IDIgKiBoZWlnaHQpIHtcbiAgICAgICAgbmV3SGVpZ2h0ID0gbmV3SGVpZ2h0ID49IDE2Mzg0ID8gTWF0aC5mbG9vcihuZXdIZWlnaHQgLyAyKSAtIDEgOiBNYXRoLmNlaWwobmV3SGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBwcmV2V2lkdGgsIHByZXZIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgYml0bWFwID0gb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO1xuICAgIH1cbiAgICByZXR1cm4gYml0bWFwO1xuICB9XG4gICNkcmF3Qml0bWFwKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB3aWR0aCA9IE1hdGguY2VpbCh3aWR0aCk7XG4gICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCk7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy4jY2FudmFzO1xuICAgIGlmICghY2FudmFzIHx8IGNhbnZhcy53aWR0aCA9PT0gd2lkdGggJiYgY2FudmFzLmhlaWdodCA9PT0gaGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgY29uc3QgYml0bWFwID0gdGhpcy4jaXNTdmcgPyB0aGlzLiNiaXRtYXAgOiB0aGlzLiNzY2FsZUJpdG1hcCh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGN0eC5maWx0ZXIgPSB0aGlzLl91aU1hbmFnZXIuaGNtRmlsdGVyO1xuICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gICNzZXJpYWxpemVCaXRtYXAodG9VcmwpIHtcbiAgICBpZiAodG9VcmwpIHtcbiAgICAgIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldFN2Z1VybCh0aGlzLiNiaXRtYXBJZCk7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgKHtcbiAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgICB9ID0gdGhpcy4jYml0bWFwKTtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuI2JpdG1hcCwgMCwgMCk7XG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaXNTdmcpIHtcbiAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5yb3VuZCh0aGlzLndpZHRoICogcGFnZVdpZHRoICogX2Rpc3BsYXlfdXRpbHMuUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTKTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0ICogX2Rpc3BsYXlfdXRpbHMuUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTKTtcbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLiNiaXRtYXAsIDAsIDAsIHRoaXMuI2JpdG1hcC53aWR0aCwgdGhpcy4jYml0bWFwLmhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICByZXR1cm4gb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKHRoaXMuI2JpdG1hcCk7XG4gIH1cbiAgI2NyZWF0ZU9ic2VydmVyKCkge1xuICAgIHRoaXMuI29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgY29uc3QgcmVjdCA9IGVudHJpZXNbMF0uY29udGVudFJlY3Q7XG4gICAgICBpZiAocmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCkge1xuICAgICAgICB0aGlzLiNzZXREaW1lbnNpb25zKHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLiNvYnNlcnZlci5vYnNlcnZlKHRoaXMuZGl2KTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIF9hbm5vdGF0aW9uX2xheWVyLlN0YW1wQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgY29uc3Qge1xuICAgICAgcmVjdCxcbiAgICAgIGJpdG1hcFVybCxcbiAgICAgIGJpdG1hcElkLFxuICAgICAgaXNTdmcsXG4gICAgICBhY2Nlc3NpYmlsaXR5RGF0YVxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChiaXRtYXBJZCAmJiB1aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmlzVmFsaWRJZChiaXRtYXBJZCkpIHtcbiAgICAgIGVkaXRvci4jYml0bWFwSWQgPSBiaXRtYXBJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLiNiaXRtYXBVcmwgPSBiaXRtYXBVcmw7XG4gICAgfVxuICAgIGVkaXRvci4jaXNTdmcgPSBpc1N2ZztcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgZWRpdG9yLndpZHRoID0gKHJlY3RbMl0gLSByZWN0WzBdKSAvIHBhcmVudFdpZHRoO1xuICAgIGVkaXRvci5oZWlnaHQgPSAocmVjdFszXSAtIHJlY3RbMV0pIC8gcGFyZW50SGVpZ2h0O1xuICAgIGlmIChhY2Nlc3NpYmlsaXR5RGF0YSkge1xuICAgICAgZWRpdG9yLmFsdFRleHREYXRhID0gYWNjZXNzaWJpbGl0eURhdGE7XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlLCBjb250ZXh0ID0gbnVsbCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVAsXG4gICAgICBiaXRtYXBJZDogdGhpcy4jYml0bWFwSWQsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcmVjdDogdGhpcy5nZXRSZWN0KDAsIDApLFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICBpc1N2ZzogdGhpcy4jaXNTdmcsXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gICAgaWYgKGlzRm9yQ29weWluZykge1xuICAgICAgc2VyaWFsaXplZC5iaXRtYXBVcmwgPSB0aGlzLiNzZXJpYWxpemVCaXRtYXAodHJ1ZSk7XG4gICAgICBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhID0gdGhpcy5hbHRUZXh0RGF0YTtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkZWNvcmF0aXZlLFxuICAgICAgYWx0VGV4dFxuICAgIH0gPSB0aGlzLmFsdFRleHREYXRhO1xuICAgIGlmICghZGVjb3JhdGl2ZSAmJiBhbHRUZXh0KSB7XG4gICAgICBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhID0ge1xuICAgICAgICB0eXBlOiBcIkZpZ3VyZVwiLFxuICAgICAgICBhbHQ6IGFsdFRleHRcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgY29udGV4dC5zdGFtcHMgfHw9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBhcmVhID0gdGhpcy4jaXNTdmcgPyAoc2VyaWFsaXplZC5yZWN0WzJdIC0gc2VyaWFsaXplZC5yZWN0WzBdKSAqIChzZXJpYWxpemVkLnJlY3RbM10gLSBzZXJpYWxpemVkLnJlY3RbMV0pIDogbnVsbDtcbiAgICBpZiAoIWNvbnRleHQuc3RhbXBzLmhhcyh0aGlzLiNiaXRtYXBJZCkpIHtcbiAgICAgIGNvbnRleHQuc3RhbXBzLnNldCh0aGlzLiNiaXRtYXBJZCwge1xuICAgICAgICBhcmVhLFxuICAgICAgICBzZXJpYWxpemVkXG4gICAgICB9KTtcbiAgICAgIHNlcmlhbGl6ZWQuYml0bWFwID0gdGhpcy4jc2VyaWFsaXplQml0bWFwKGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI2lzU3ZnKSB7XG4gICAgICBjb25zdCBwcmV2RGF0YSA9IGNvbnRleHQuc3RhbXBzLmdldCh0aGlzLiNiaXRtYXBJZCk7XG4gICAgICBpZiAoYXJlYSA+IHByZXZEYXRhLmFyZWEpIHtcbiAgICAgICAgcHJldkRhdGEuYXJlYSA9IGFyZWE7XG4gICAgICAgIHByZXZEYXRhLnNlcmlhbGl6ZWQuYml0bWFwLmNsb3NlKCk7XG4gICAgICAgIHByZXZEYXRhLnNlcmlhbGl6ZWQuYml0bWFwID0gdGhpcy4jc2VyaWFsaXplQml0bWFwKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbn1cbmV4cG9ydHMuU3RhbXBFZGl0b3IgPSBTdGFtcEVkaXRvcjtcblxuLyoqKi8gfSlcbi8qKioqKiovIFx0XSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd19wZGZqc19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuLy8gVGhpcyBlbnRyeSBuZWVkIHRvIGJlIHdyYXBwZWQgaW4gYW4gSUlGRSBiZWNhdXNlIGl0IG5lZWQgdG8gYmUgaXNvbGF0ZWQgYWdhaW5zdCBvdGhlciBtb2R1bGVzIGluIHRoZSBjaHVuay5cbigoKSA9PiB7XG52YXIgZXhwb3J0cyA9IF9fd2VicGFja19leHBvcnRzX187XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJvcnRFeGNlcHRpb25cIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLkFib3J0RXhjZXB0aW9uO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbm5vdGF0aW9uRWRpdG9yTGF5ZXJcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hbm5vdGF0aW9uX2VkaXRvcl9sYXllci5Bbm5vdGF0aW9uRWRpdG9yTGF5ZXI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQW5ub3RhdGlvbkVkaXRvclR5cGVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdG9vbHMuQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQW5ub3RhdGlvbkxheWVyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYW5ub3RhdGlvbl9sYXllci5Bbm5vdGF0aW9uTGF5ZXI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFubm90YXRpb25Nb2RlXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5Bbm5vdGF0aW9uTW9kZTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ01hcENvbXByZXNzaW9uVHlwZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuQ01hcENvbXByZXNzaW9uVHlwZTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRE9NU1ZHRmFjdG9yeVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuRE9NU1ZHRmFjdG9yeTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmVhdHVyZVRlc3RcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLkZlYXR1cmVUZXN0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHbG9iYWxXb3JrZXJPcHRpb25zXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfd29ya2VyX29wdGlvbnMuR2xvYmFsV29ya2VyT3B0aW9ucztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW1hZ2VLaW5kXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5JbWFnZUtpbmQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludmFsaWRQREZFeGNlcHRpb25cIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLkludmFsaWRQREZFeGNlcHRpb247XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1pc3NpbmdQREZFeGNlcHRpb25cIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb247XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk9QU1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuT1BTO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQREZEYXRhUmFuZ2VUcmFuc3BvcnRcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hcGkuUERGRGF0YVJhbmdlVHJhbnNwb3J0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQREZEYXRlU3RyaW5nXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5QREZEYXRlU3RyaW5nO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQREZXb3JrZXJcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hcGkuUERGV29ya2VyO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXNzd29yZFJlc3BvbnNlc1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuUGFzc3dvcmRSZXNwb25zZXM7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBlcm1pc3Npb25GbGFnXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5QZXJtaXNzaW9uRmxhZztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGl4ZWxzUGVySW5jaFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuUGl4ZWxzUGVySW5jaDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvbWlzZUNhcGFiaWxpdHlcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLlByb21pc2VDYXBhYmlsaXR5O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb25cIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU1ZHR3JhcGhpY3NcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hcGkuU1ZHR3JhcGhpY3M7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvblwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVdGlsXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5VdGlsO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWZXJib3NpdHlMZXZlbFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuVmVyYm9zaXR5TGV2ZWw7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlhmYUxheWVyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfeGZhX2xheWVyLlhmYUxheWVyO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJidWlsZFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FwaS5idWlsZDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlVmFsaWRBYnNvbHV0ZVVybFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuY3JlYXRlVmFsaWRBYnNvbHV0ZVVybDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0RG9jdW1lbnRcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hcGkuZ2V0RG9jdW1lbnQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEZpbGVuYW1lRnJvbVVybFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuZ2V0RmlsZW5hbWVGcm9tVXJsO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRQZGZGaWxlbmFtZUZyb21VcmxcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLmdldFBkZkZpbGVuYW1lRnJvbVVybDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0WGZhUGFnZVZpZXdwb3J0XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5nZXRYZmFQYWdlVmlld3BvcnQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzRGF0YVNjaGVtZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuaXNEYXRhU2NoZW1lO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1BkZkZpbGVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLmlzUGRmRmlsZTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9hZFNjcmlwdFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMubG9hZFNjcmlwdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibm9Db250ZXh0TWVudVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMubm9Db250ZXh0TWVudTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibm9ybWFsaXplVW5pY29kZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwubm9ybWFsaXplVW5pY29kZTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVuZGVyVGV4dExheWVyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGV4dF9sYXllci5yZW5kZXJUZXh0TGF5ZXI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNldExheWVyRGltZW5zaW9uc1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuc2V0TGF5ZXJEaW1lbnNpb25zO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzaGFkb3dcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLnNoYWRvdztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXBkYXRlVGV4dExheWVyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGV4dF9sYXllci51cGRhdGVUZXh0TGF5ZXI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcnNpb25cIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hcGkudmVyc2lvbjtcbiAgfVxufSkpO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfYXBpID0gX193X3BkZmpzX3JlcXVpcmVfXygyKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG52YXIgX3RleHRfbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI2KTtcbnZhciBfYW5ub3RhdGlvbl9lZGl0b3JfbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI3KTtcbnZhciBfdG9vbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xudmFyIF9hbm5vdGF0aW9uX2xheWVyID0gX193X3BkZmpzX3JlcXVpcmVfXygyOSk7XG52YXIgX3dvcmtlcl9vcHRpb25zID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG52YXIgX3hmYV9sYXllciA9IF9fd19wZGZqc19yZXF1aXJlX18oMzIpO1xuY29uc3QgcGRmanNWZXJzaW9uID0gJzMuMTEuMTc0JztcbmNvbnN0IHBkZmpzQnVpbGQgPSAnY2U4NzE2NzQzJztcbn0pKCk7XG5cbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBkZi5qcy5tYXAiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJwZGZqc0xpYiIsImRlZmluZSIsImFtZCIsImdsb2JhbFRoaXMiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwiX191bnVzZWRfd2VicGFja19tb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiVmVyYm9zaXR5TGV2ZWwiLCJVdGlsIiwiVW5rbm93bkVycm9yRXhjZXB0aW9uIiwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uIiwiVGV4dFJlbmRlcmluZ01vZGUiLCJSZW5kZXJpbmdJbnRlbnRGbGFnIiwiUHJvbWlzZUNhcGFiaWxpdHkiLCJQZXJtaXNzaW9uRmxhZyIsIlBhc3N3b3JkUmVzcG9uc2VzIiwiUGFzc3dvcmRFeGNlcHRpb24iLCJQYWdlQWN0aW9uRXZlbnRUeXBlIiwiT1BTIiwiTWlzc2luZ1BERkV4Y2VwdGlvbiIsIk1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFIiwiTElORV9GQUNUT1IiLCJMSU5FX0RFU0NFTlRfRkFDVE9SIiwiSW52YWxpZFBERkV4Y2VwdGlvbiIsIkltYWdlS2luZCIsIklERU5USVRZX01BVFJJWCIsIkZvcm1hdEVycm9yIiwiRmVhdHVyZVRlc3QiLCJGT05UX0lERU5USVRZX01BVFJJWCIsIkRvY3VtZW50QWN0aW9uRXZlbnRUeXBlIiwiQ01hcENvbXByZXNzaW9uVHlwZSIsIkJhc2VFeGNlcHRpb24iLCJCQVNFTElORV9GQUNUT1IiLCJBbm5vdGF0aW9uVHlwZSIsIkFubm90YXRpb25SZXBseVR5cGUiLCJBbm5vdGF0aW9uUHJlZml4IiwiQW5ub3RhdGlvbk1vZGUiLCJBbm5vdGF0aW9uRmxhZyIsIkFubm90YXRpb25GaWVsZEZsYWciLCJBbm5vdGF0aW9uRWRpdG9yVHlwZSIsIkFubm90YXRpb25FZGl0b3JQcmVmaXgiLCJBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSIsIkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUiLCJBbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlIiwiQWJvcnRFeGNlcHRpb24iLCJhc3NlcnQiLCJieXRlc1RvU3RyaW5nIiwiY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCIsImdldE1vZGlmaWNhdGlvbkRhdGUiLCJnZXRVdWlkIiwiZ2V0VmVyYm9zaXR5TGV2ZWwiLCJpbmZvIiwiaXNBcnJheUJ1ZmZlciIsImlzQXJyYXlFcXVhbCIsImlzTm9kZUpTIiwibm9ybWFsaXplVW5pY29kZSIsIm9iamVjdEZyb21NYXAiLCJvYmplY3RTaXplIiwic2V0VmVyYm9zaXR5TGV2ZWwiLCJzaGFkb3ciLCJzdHJpbmczMiIsInN0cmluZ1RvQnl0ZXMiLCJzdHJpbmdUb1BERlN0cmluZyIsInN0cmluZ1RvVVRGOFN0cmluZyIsInVucmVhY2hhYmxlIiwidXRmOFN0cmluZ1RvU3RyaW5nIiwid2FybiIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsIm53IiwiZWxlY3Ryb24iLCJ0eXBlIiwiQU5ZIiwiRElTUExBWSIsIlBSSU5UIiwiU0FWRSIsIkFOTk9UQVRJT05TX0ZPUk1TIiwiQU5OT1RBVElPTlNfU1RPUkFHRSIsIkFOTk9UQVRJT05TX0RJU0FCTEUiLCJPUExJU1QiLCJESVNBQkxFIiwiRU5BQkxFIiwiRU5BQkxFX0ZPUk1TIiwiRU5BQkxFX1NUT1JBR0UiLCJOT05FIiwiRlJFRVRFWFQiLCJTVEFNUCIsIklOSyIsIlJFU0laRSIsIkNSRUFURSIsIkZSRUVURVhUX1NJWkUiLCJGUkVFVEVYVF9DT0xPUiIsIkZSRUVURVhUX09QQUNJVFkiLCJJTktfQ09MT1IiLCJJTktfVEhJQ0tORVNTIiwiSU5LX09QQUNJVFkiLCJNT0RJRllfQ09OVEVOVFMiLCJDT1BZIiwiTU9ESUZZX0FOTk9UQVRJT05TIiwiRklMTF9JTlRFUkFDVElWRV9GT1JNUyIsIkNPUFlfRk9SX0FDQ0VTU0lCSUxJVFkiLCJBU1NFTUJMRSIsIlBSSU5UX0hJR0hfUVVBTElUWSIsIkZJTEwiLCJTVFJPS0UiLCJGSUxMX1NUUk9LRSIsIklOVklTSUJMRSIsIkZJTExfQUREX1RPX1BBVEgiLCJTVFJPS0VfQUREX1RPX1BBVEgiLCJGSUxMX1NUUk9LRV9BRERfVE9fUEFUSCIsIkFERF9UT19QQVRIIiwiRklMTF9TVFJPS0VfTUFTSyIsIkFERF9UT19QQVRIX0ZMQUciLCJHUkFZU0NBTEVfMUJQUCIsIlJHQl8yNEJQUCIsIlJHQkFfMzJCUFAiLCJURVhUIiwiTElOSyIsIkxJTkUiLCJTUVVBUkUiLCJDSVJDTEUiLCJQT0xZR09OIiwiUE9MWUxJTkUiLCJISUdITElHSFQiLCJVTkRFUkxJTkUiLCJTUVVJR0dMWSIsIlNUUklLRU9VVCIsIkNBUkVUIiwiUE9QVVAiLCJGSUxFQVRUQUNITUVOVCIsIlNPVU5EIiwiTU9WSUUiLCJXSURHRVQiLCJTQ1JFRU4iLCJQUklOVEVSTUFSSyIsIlRSQVBORVQiLCJXQVRFUk1BUksiLCJUSFJFRUQiLCJSRURBQ1QiLCJHUk9VUCIsIlJFUExZIiwiSElEREVOIiwiTk9aT09NIiwiTk9ST1RBVEUiLCJOT1ZJRVciLCJSRUFET05MWSIsIkxPQ0tFRCIsIlRPR0dMRU5PVklFVyIsIkxPQ0tFRENPTlRFTlRTIiwiUkVRVUlSRUQiLCJOT0VYUE9SVCIsIk1VTFRJTElORSIsIlBBU1NXT1JEIiwiTk9UT0dHTEVUT09GRiIsIlJBRElPIiwiUFVTSEJVVFRPTiIsIkNPTUJPIiwiRURJVCIsIlNPUlQiLCJGSUxFU0VMRUNUIiwiTVVMVElTRUxFQ1QiLCJET05PVFNQRUxMQ0hFQ0siLCJET05PVFNDUk9MTCIsIkNPTUIiLCJSSUNIVEVYVCIsIlJBRElPU0lOVU5JU09OIiwiQ09NTUlUT05TRUxDSEFOR0UiLCJTT0xJRCIsIkRBU0hFRCIsIkJFVkVMRUQiLCJJTlNFVCIsIkUiLCJYIiwiRCIsIlUiLCJGbyIsIkJsIiwiUE8iLCJQQyIsIlBWIiwiUEkiLCJLIiwiRiIsIlYiLCJDIiwiV0MiLCJXUyIsIkRTIiwiV1AiLCJEUCIsIk8iLCJFUlJPUlMiLCJXQVJOSU5HUyIsIklORk9TIiwiQklOQVJZIiwiZGVwZW5kZW5jeSIsInNldExpbmVXaWR0aCIsInNldExpbmVDYXAiLCJzZXRMaW5lSm9pbiIsInNldE1pdGVyTGltaXQiLCJzZXREYXNoIiwic2V0UmVuZGVyaW5nSW50ZW50Iiwic2V0RmxhdG5lc3MiLCJzZXRHU3RhdGUiLCJzYXZlIiwicmVzdG9yZSIsInRyYW5zZm9ybSIsIm1vdmVUbyIsImxpbmVUbyIsImN1cnZlVG8iLCJjdXJ2ZVRvMiIsImN1cnZlVG8zIiwiY2xvc2VQYXRoIiwicmVjdGFuZ2xlIiwic3Ryb2tlIiwiY2xvc2VTdHJva2UiLCJmaWxsIiwiZW9GaWxsIiwiZmlsbFN0cm9rZSIsImVvRmlsbFN0cm9rZSIsImNsb3NlRmlsbFN0cm9rZSIsImNsb3NlRU9GaWxsU3Ryb2tlIiwiZW5kUGF0aCIsImNsaXAiLCJlb0NsaXAiLCJiZWdpblRleHQiLCJlbmRUZXh0Iiwic2V0Q2hhclNwYWNpbmciLCJzZXRXb3JkU3BhY2luZyIsInNldEhTY2FsZSIsInNldExlYWRpbmciLCJzZXRGb250Iiwic2V0VGV4dFJlbmRlcmluZ01vZGUiLCJzZXRUZXh0UmlzZSIsIm1vdmVUZXh0Iiwic2V0TGVhZGluZ01vdmVUZXh0Iiwic2V0VGV4dE1hdHJpeCIsIm5leHRMaW5lIiwic2hvd1RleHQiLCJzaG93U3BhY2VkVGV4dCIsIm5leHRMaW5lU2hvd1RleHQiLCJuZXh0TGluZVNldFNwYWNpbmdTaG93VGV4dCIsInNldENoYXJXaWR0aCIsInNldENoYXJXaWR0aEFuZEJvdW5kcyIsInNldFN0cm9rZUNvbG9yU3BhY2UiLCJzZXRGaWxsQ29sb3JTcGFjZSIsInNldFN0cm9rZUNvbG9yIiwic2V0U3Ryb2tlQ29sb3JOIiwic2V0RmlsbENvbG9yIiwic2V0RmlsbENvbG9yTiIsInNldFN0cm9rZUdyYXkiLCJzZXRGaWxsR3JheSIsInNldFN0cm9rZVJHQkNvbG9yIiwic2V0RmlsbFJHQkNvbG9yIiwic2V0U3Ryb2tlQ01ZS0NvbG9yIiwic2V0RmlsbENNWUtDb2xvciIsInNoYWRpbmdGaWxsIiwiYmVnaW5JbmxpbmVJbWFnZSIsImJlZ2luSW1hZ2VEYXRhIiwiZW5kSW5saW5lSW1hZ2UiLCJwYWludFhPYmplY3QiLCJtYXJrUG9pbnQiLCJtYXJrUG9pbnRQcm9wcyIsImJlZ2luTWFya2VkQ29udGVudCIsImJlZ2luTWFya2VkQ29udGVudFByb3BzIiwiZW5kTWFya2VkQ29udGVudCIsImJlZ2luQ29tcGF0IiwiZW5kQ29tcGF0IiwicGFpbnRGb3JtWE9iamVjdEJlZ2luIiwicGFpbnRGb3JtWE9iamVjdEVuZCIsImJlZ2luR3JvdXAiLCJlbmRHcm91cCIsImJlZ2luQW5ub3RhdGlvbiIsImVuZEFubm90YXRpb24iLCJwYWludEltYWdlTWFza1hPYmplY3QiLCJwYWludEltYWdlTWFza1hPYmplY3RHcm91cCIsInBhaW50SW1hZ2VYT2JqZWN0IiwicGFpbnRJbmxpbmVJbWFnZVhPYmplY3QiLCJwYWludElubGluZUltYWdlWE9iamVjdEdyb3VwIiwicGFpbnRJbWFnZVhPYmplY3RSZXBlYXQiLCJwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQiLCJwYWludFNvbGlkQ29sb3JJbWFnZU1hc2siLCJjb25zdHJ1Y3RQYXRoIiwiTkVFRF9QQVNTV09SRCIsIklOQ09SUkVDVF9QQVNTV09SRCIsInZlcmJvc2l0eSIsImxldmVsIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwibXNnIiwiY29uc29sZSIsImxvZyIsIkVycm9yIiwiY29uZCIsIl9pc1ZhbGlkUHJvdG9jb2wiLCJ1cmwiLCJwcm90b2NvbCIsImJhc2VVcmwiLCJvcHRpb25zIiwiYWRkRGVmYXVsdFByb3RvY29sIiwic3RhcnRzV2l0aCIsImRvdHMiLCJtYXRjaCIsImxlbmd0aCIsInRyeUNvbnZlcnRFbmNvZGluZyIsImFic29sdXRlVXJsIiwiVVJMIiwib2JqIiwicHJvcCIsIm5vblNlcmlhbGl6YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIkJhc2VFeGNlcHRpb25DbG9zdXJlIiwibWVzc2FnZSIsIm5hbWUiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsImNvZGUiLCJkZXRhaWxzIiwic3RhdHVzIiwiYnl0ZXMiLCJ1bmRlZmluZWQiLCJNQVhfQVJHVU1FTlRfQ09VTlQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsInN0ckJ1ZiIsImkiLCJjaHVua0VuZCIsIk1hdGgiLCJtaW4iLCJjaHVuayIsInN1YmFycmF5IiwicHVzaCIsImpvaW4iLCJzdHIiLCJVaW50OEFycmF5IiwiY2hhckNvZGVBdCIsImtleXMiLCJtYXAiLCJjcmVhdGUiLCJrZXkiLCJpc0xpdHRsZUVuZGlhbiIsImJ1ZmZlcjgiLCJ2aWV3MzIiLCJVaW50MzJBcnJheSIsImJ1ZmZlciIsImlzRXZhbFN1cHBvcnRlZCIsIkZ1bmN0aW9uIiwiaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQiLCJPZmZzY3JlZW5DYW52YXMiLCJwbGF0Zm9ybSIsIm5hdmlnYXRvciIsImlzV2luIiwiaXNNYWMiLCJpbmNsdWRlcyIsImlzQ1NTUm91bmRTdXBwb3J0ZWQiLCJDU1MiLCJzdXBwb3J0cyIsImhleE51bWJlcnMiLCJBcnJheSIsIm4iLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwibWFrZUhleENvbG9yIiwiciIsImciLCJiIiwic2NhbGVNaW5NYXgiLCJtaW5NYXgiLCJ0ZW1wIiwibTEiLCJtMiIsImFwcGx5VHJhbnNmb3JtIiwicCIsIm0iLCJ4dCIsInl0IiwiYXBwbHlJbnZlcnNlVHJhbnNmb3JtIiwiZCIsImdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94IiwicDEiLCJwMiIsInNsaWNlIiwicDMiLCJwNCIsIm1heCIsImludmVyc2VUcmFuc2Zvcm0iLCJzaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSIsInRyYW5zcG9zZSIsImEiLCJjIiwiZmlyc3QiLCJzZWNvbmQiLCJzcXJ0Iiwic3giLCJzeSIsIm5vcm1hbGl6ZVJlY3QiLCJyZWN0IiwiaW50ZXJzZWN0IiwicmVjdDEiLCJyZWN0MiIsInhMb3ciLCJ4SGlnaCIsInlMb3ciLCJ5SGlnaCIsImJlemllckJvdW5kaW5nQm94IiwieDAiLCJ5MCIsIngxIiwieTEiLCJ4MiIsInkyIiwieDMiLCJ5MyIsInR2YWx1ZXMiLCJib3VuZHMiLCJ0IiwidDEiLCJ0MiIsImIyYWMiLCJzcXJ0YjJhYyIsImFicyIsImoiLCJtdCIsImpsZW4iLCJQREZTdHJpbmdUcmFuc2xhdGVUYWJsZSIsImVuY29kaW5nIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiZmF0YWwiLCJkZWNvZGUiLCJleCIsImlpIiwiY2hhckF0IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZXNjYXBlIiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJ2IiwiYnl0ZUxlbmd0aCIsImFycjEiLCJhcnIyIiwiZGF0ZSIsIkRhdGUiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJzZXR0bGVkIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZGF0YSIsInJlYXNvbiIsIk5vcm1hbGl6ZVJlZ2V4IiwiTm9ybWFsaXphdGlvbk1hcCIsIk1hcCIsInJlcGxhY2VBbGwiLCJfIiwibm9ybWFsaXplIiwiZ2V0IiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsImJ1ZiIsImdldFJhbmRvbVZhbHVlcyIsImZsb29yIiwicmFuZG9tIiwiX193X3BkZmpzX3JlcXVpcmVfXyIsIlJlbmRlclRhc2siLCJQREZXb3JrZXJVdGlsIiwiUERGV29ya2VyIiwiUERGUGFnZVByb3h5IiwiUERGRG9jdW1lbnRQcm94eSIsIlBERkRvY3VtZW50TG9hZGluZ1Rhc2siLCJQREZEYXRhUmFuZ2VUcmFuc3BvcnQiLCJMb29wYmFja1BvcnQiLCJEZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJEZWZhdWx0RmlsdGVyRmFjdG9yeSIsIkRlZmF1bHRDYW52YXNGYWN0b3J5IiwiRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5IiwiX2Rpc3BsYXlTdmciLCJTVkdHcmFwaGljcyIsImJ1aWxkIiwiZ2V0RG9jdW1lbnQiLCJ2ZXJzaW9uIiwiX3V0aWwiLCJfYW5ub3RhdGlvbl9zdG9yYWdlIiwiX2Rpc3BsYXlfdXRpbHMiLCJfZm9udF9sb2FkZXIiLCJfZGlzcGxheU5vZGVfdXRpbHMiLCJfY2FudmFzIiwiX3dvcmtlcl9vcHRpb25zIiwiX21lc3NhZ2VfaGFuZGxlciIsIl9tZXRhZGF0YSIsIl9vcHRpb25hbF9jb250ZW50X2NvbmZpZyIsIl90cmFuc3BvcnRfc3RyZWFtIiwiX2Rpc3BsYXlGZXRjaF9zdHJlYW0iLCJfZGlzcGxheU5ldHdvcmsiLCJfZGlzcGxheU5vZGVfc3RyZWFtIiwiX3hmYV90ZXh0IiwiREVGQVVMVF9SQU5HRV9DSFVOS19TSVpFIiwiUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUIiwiREVMQVlFRF9DTEVBTlVQX1RJTUVPVVQiLCJOb2RlQ2FudmFzRmFjdG9yeSIsIkRPTUNhbnZhc0ZhY3RvcnkiLCJOb2RlQ01hcFJlYWRlckZhY3RvcnkiLCJET01DTWFwUmVhZGVyRmFjdG9yeSIsIk5vZGVGaWx0ZXJGYWN0b3J5IiwiRE9NRmlsdGVyRmFjdG9yeSIsIk5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsIkRPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5Iiwic3JjIiwicmFuZ2UiLCJ0YXNrIiwiZG9jSWQiLCJnZXRVcmxQcm9wIiwiZ2V0RGF0YVByb3AiLCJodHRwSGVhZGVycyIsIndpdGhDcmVkZW50aWFscyIsInBhc3N3b3JkIiwicmFuZ2VUcmFuc3BvcnQiLCJyYW5nZUNodW5rU2l6ZSIsIndvcmtlciIsImRvY0Jhc2VVcmwiLCJpc0RhdGFTY2hlbWUiLCJjTWFwVXJsIiwiY01hcFBhY2tlZCIsIkNNYXBSZWFkZXJGYWN0b3J5Iiwic3RhbmRhcmRGb250RGF0YVVybCIsIlN0YW5kYXJkRm9udERhdGFGYWN0b3J5IiwiaWdub3JlRXJyb3JzIiwic3RvcEF0RXJyb3JzIiwibWF4SW1hZ2VTaXplIiwiY2FudmFzTWF4QXJlYUluQnl0ZXMiLCJkaXNhYmxlRm9udEZhY2UiLCJmb250RXh0cmFQcm9wZXJ0aWVzIiwiZW5hYmxlWGZhIiwib3duZXJEb2N1bWVudCIsImRvY3VtZW50IiwiZGlzYWJsZVJhbmdlIiwiZGlzYWJsZVN0cmVhbSIsImRpc2FibGVBdXRvRmV0Y2giLCJwZGZCdWciLCJOYU4iLCJ1c2VTeXN0ZW1Gb250cyIsInVzZVdvcmtlckZldGNoIiwiaXNWYWxpZEZldGNoVXJsIiwiYmFzZVVSSSIsImNhbnZhc0ZhY3RvcnkiLCJmaWx0ZXJGYWN0b3J5Iiwic3R5bGVFbGVtZW50IiwidHJhbnNwb3J0RmFjdG9yeSIsImNNYXBSZWFkZXJGYWN0b3J5IiwiaXNDb21wcmVzc2VkIiwic3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJ3b3JrZXJQYXJhbXMiLCJwb3J0IiwiR2xvYmFsV29ya2VyT3B0aW9ucyIsIndvcmtlclBvcnQiLCJmcm9tUG9ydCIsIl93b3JrZXIiLCJmZXRjaERvY1BhcmFtcyIsImFwaVZlcnNpb24iLCJldmFsdWF0b3JPcHRpb25zIiwidHJhbnNwb3J0UGFyYW1zIiwidGhlbiIsImRlc3Ryb3llZCIsIndvcmtlcklkUHJvbWlzZSIsIl9mZXRjaERvY3VtZW50IiwibmV0d29ya1N0cmVhbVByb21pc2UiLCJuZXR3b3JrU3RyZWFtIiwiUERGRGF0YVRyYW5zcG9ydFN0cmVhbSIsImluaXRpYWxEYXRhIiwicHJvZ3Jlc3NpdmVEb25lIiwiY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUiLCJjcmVhdGVQREZOZXR3b3JrU3RyZWFtIiwicGFyYW1zIiwiUERGTm9kZVN0cmVhbSIsIlBERkZldGNoU3RyZWFtIiwiUERGTmV0d29ya1N0cmVhbSIsImFsbCIsIndvcmtlcklkIiwibWVzc2FnZUhhbmRsZXIiLCJNZXNzYWdlSGFuZGxlciIsInRyYW5zcG9ydCIsIldvcmtlclRyYW5zcG9ydCIsIl90cmFuc3BvcnQiLCJzZW5kIiwiY2F0Y2giLCJfY2FwYWJpbGl0eSIsInNvdXJjZSIsInNlbmRXaXRoUHJvbWlzZSIsInZhbCIsImhyZWYiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIkJ1ZmZlciIsImlzTmFOIiwib25QYXNzd29yZCIsIm9uUHJvZ3Jlc3MiLCJkZXN0cm95IiwiX3BlbmRpbmdEZXN0cm95IiwiX3JhbmdlTGlzdGVuZXJzIiwiX3Byb2dyZXNzTGlzdGVuZXJzIiwiX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycyIsIl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMiLCJfcmVhZHlDYXBhYmlsaXR5IiwiYWRkUmFuZ2VMaXN0ZW5lciIsImxpc3RlbmVyIiwiYWRkUHJvZ3Jlc3NMaXN0ZW5lciIsImFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyIiwiYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXIiLCJvbkRhdGFSYW5nZSIsImJlZ2luIiwib25EYXRhUHJvZ3Jlc3MiLCJsb2FkZWQiLCJ0b3RhbCIsIm9uRGF0YVByb2dyZXNzaXZlUmVhZCIsIm9uRGF0YVByb2dyZXNzaXZlRG9uZSIsInRyYW5zcG9ydFJlYWR5IiwicmVxdWVzdERhdGFSYW5nZSIsImVuZCIsImFib3J0IiwicGRmSW5mbyIsIl9wZGZJbmZvIiwiZGVwcmVjYXRlZCIsImdldEpTQWN0aW9ucyIsImpzIiwianNBcnIiLCJhbm5vdGF0aW9uU3RvcmFnZSIsIm51bVBhZ2VzIiwiZmluZ2VycHJpbnRzIiwiaXNQdXJlWGZhIiwiX2h0bWxGb3JYZmEiLCJhbGxYZmFIdG1sIiwiZ2V0UGFnZSIsInBhZ2VOdW1iZXIiLCJnZXRQYWdlSW5kZXgiLCJyZWYiLCJnZXREZXN0aW5hdGlvbnMiLCJnZXREZXN0aW5hdGlvbiIsImlkIiwiZ2V0UGFnZUxhYmVscyIsImdldFBhZ2VMYXlvdXQiLCJnZXRQYWdlTW9kZSIsImdldFZpZXdlclByZWZlcmVuY2VzIiwiZ2V0T3BlbkFjdGlvbiIsImdldEF0dGFjaG1lbnRzIiwiZ2V0RG9jSlNBY3Rpb25zIiwiZ2V0T3V0bGluZSIsImdldE9wdGlvbmFsQ29udGVudENvbmZpZyIsImdldFBlcm1pc3Npb25zIiwiZ2V0TWV0YWRhdGEiLCJnZXRNYXJrSW5mbyIsImdldERhdGEiLCJzYXZlRG9jdW1lbnQiLCJnZXREb3dubG9hZEluZm8iLCJkb3dubG9hZEluZm9DYXBhYmlsaXR5IiwiY2xlYW51cCIsImtlZXBMb2FkZWRGb250cyIsInN0YXJ0Q2xlYW51cCIsImxvYWRpbmdUYXNrIiwibG9hZGluZ1BhcmFtcyIsImdldEZpZWxkT2JqZWN0cyIsImhhc0pTQWN0aW9ucyIsImdldENhbGN1bGF0aW9uT3JkZXJJZHMiLCJkZWxheWVkQ2xlYW51cFRpbWVvdXQiLCJwZW5kaW5nQ2xlYW51cCIsInBhZ2VJbmRleCIsInBhZ2VJbmZvIiwiX3BhZ2VJbmRleCIsIl9wYWdlSW5mbyIsIl9zdGF0cyIsIlN0YXRUaW1lciIsIl9wZGZCdWciLCJjb21tb25PYmpzIiwib2JqcyIsIlBERk9iamVjdHMiLCJfbWF5YmVDbGVhbnVwQWZ0ZXJSZW5kZXIiLCJfaW50ZW50U3RhdGVzIiwicm90YXRlIiwidXNlclVuaXQiLCJ2aWV3IiwiZ2V0Vmlld3BvcnQiLCJzY2FsZSIsInJvdGF0aW9uIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJkb250RmxpcCIsIlBhZ2VWaWV3cG9ydCIsInZpZXdCb3giLCJnZXRBbm5vdGF0aW9ucyIsImludGVudCIsImludGVudEFyZ3MiLCJnZXRSZW5kZXJpbmdJbnRlbnQiLCJyZW5kZXJpbmdJbnRlbnQiLCJnZXRQYWdlSlNBY3Rpb25zIiwiZ2V0WGZhIiwiY2hpbGRyZW4iLCJyZW5kZXIiLCJjYW52YXNDb250ZXh0Iiwidmlld3BvcnQiLCJhbm5vdGF0aW9uTW9kZSIsImJhY2tncm91bmQiLCJvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlIiwiYW5ub3RhdGlvbkNhbnZhc01hcCIsInBhZ2VDb2xvcnMiLCJwcmludEFubm90YXRpb25TdG9yYWdlIiwidGltZSIsImFib3J0RGVsYXllZENsZWFudXAiLCJpbnRlbnRTdGF0ZSIsImNhY2hlS2V5Iiwic2V0Iiwic3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCIsImNsZWFyVGltZW91dCIsImludGVudFByaW50IiwiZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSIsIm9wZXJhdG9yTGlzdCIsImZuQXJyYXkiLCJhcmdzQXJyYXkiLCJsYXN0Q2h1bmsiLCJzZXBhcmF0ZUFubm90cyIsIl9wdW1wT3BlcmF0b3JMaXN0IiwiY29tcGxldGUiLCJlcnJvciIsInJlbmRlclRhc2tzIiwiZGVsZXRlIiwiaW50ZXJuYWxSZW5kZXJUYXNrIiwidHJ5Q2xlYW51cCIsImNhcGFiaWxpdHkiLCJfYWJvcnRPcGVyYXRvckxpc3QiLCJ0aW1lRW5kIiwiSW50ZXJuYWxSZW5kZXJUYXNrIiwiY2FsbGJhY2siLCJ1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJTZXQiLCJhZGQiLCJyZW5kZXJUYXNrIiwidHJhbnNwYXJlbmN5Iiwib3B0aW9uYWxDb250ZW50Q29uZmlnIiwiaW5pdGlhbGl6ZUdyYXBoaWNzIiwib3BlcmF0b3JMaXN0Q2hhbmdlZCIsImdldE9wZXJhdG9yTGlzdCIsIm9wTGlzdFJlYWRDYXBhYmlsaXR5Iiwib3BMaXN0VGFzayIsInN0cmVhbVRleHRDb250ZW50IiwiaW5jbHVkZU1hcmtlZENvbnRlbnQiLCJkaXNhYmxlTm9ybWFsaXphdGlvbiIsIlRFWFRfQ09OVEVOVF9DSFVOS19TSVpFIiwic2VuZFdpdGhTdHJlYW0iLCJoaWdoV2F0ZXJNYXJrIiwic2l6ZSIsInRleHRDb250ZW50IiwiaXRlbXMiLCJnZXRUZXh0Q29udGVudCIsInhmYSIsIlhmYVRleHQiLCJyZWFkYWJsZVN0cmVhbSIsInB1bXAiLCJyZWFkZXIiLCJyZWFkIiwiZG9uZSIsImFzc2lnbiIsInN0eWxlcyIsImdldFJlYWRlciIsImdldFN0cnVjdFRyZWUiLCJfZGVzdHJveSIsIndhaXRPbiIsInZhbHVlcyIsImZvcmNlIiwiY29tcGxldGVkIiwiY2FuY2VsIiwiY2xlYXIiLCJyZXNldFN0YXRzIiwic3VjY2VzcyIsImRlbGF5ZWQiLCJzZXRUaW1lb3V0IiwiX3N0YXJ0UmVuZGVyUGFnZSIsIl9yZW5kZXJQYWdlQ2h1bmsiLCJvcGVyYXRvckxpc3RDaHVuayIsImFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlIiwidHJhbnNmZXJzIiwic3RyZWFtUmVhZGVyIiwiUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uIiwiZGVsYXkiLCJleHRyYURlbGF5IiwiY3VyQ2FjaGVLZXkiLCJjdXJJbnRlbnRTdGF0ZSIsInN0YXRzIiwibGlzdGVuZXJzIiwiZGVmZXJyZWQiLCJwb3N0TWVzc2FnZSIsInRyYW5zZmVyIiwiZXZlbnQiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJjYWxsIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0ZXJtaW5hdGUiLCJpc1dvcmtlckRpc2FibGVkIiwiZmFsbGJhY2tXb3JrZXJTcmMiLCJmYWtlV29ya2VySWQiLCJyZXF1aXJlIiwicGRmanNGaWxlUGF0aCIsImN1cnJlbnRTY3JpcHQiLCJyZXBsYWNlIiwiaXNTYW1lT3JpZ2luIiwib3RoZXJVcmwiLCJiYXNlIiwib3JpZ2luIiwib3RoZXIiLCJjcmVhdGVDRE5XcmFwcGVyIiwid3JhcHBlciIsImNyZWF0ZU9iamVjdFVSTCIsIkJsb2IiLCJ3b3JrZXJQb3J0cyIsIl9wb3J0IiwiX3dlYldvcmtlciIsIl9tZXNzYWdlSGFuZGxlciIsImhhcyIsIldlYWtNYXAiLCJfaW5pdGlhbGl6ZUZyb21Qb3J0IiwiX2luaXRpYWxpemUiLCJvbiIsIl9tYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIiLCJ3b3JrZXJTcmMiLCJXb3JrZXIiLCJ0ZXJtaW5hdGVFYXJseSIsIm9uV29ya2VyRXJyb3IiLCJfc2V0dXBGYWtlV29ya2VyIiwic2VuZFRlc3QiLCJ0ZXN0T2JqIiwiX3NldHVwRmFrZVdvcmtlckdsb2JhbCIsIldvcmtlck1lc3NhZ2VIYW5kbGVyIiwid29ya2VySGFuZGxlciIsInNldHVwIiwiY2FjaGVkUG9ydCIsInBkZmpzV29ya2VyIiwibG9hZGVyIiwibWFpbldvcmtlck1lc3NhZ2VIYW5kbGVyIiwiZXZhbCIsImxvYWRTY3JpcHQiLCJtZXRob2RQcm9taXNlcyIsInBhZ2VDYWNoZSIsInBhZ2VQcm9taXNlcyIsInBhc3N3b3JkQ2FwYWJpbGl0eSIsImZvbnRMb2FkZXIiLCJGb250TG9hZGVyIiwiX3BhcmFtcyIsImRlc3Ryb3lDYXBhYmlsaXR5IiwiX25ldHdvcmtTdHJlYW0iLCJfZnVsbFJlYWRlciIsIl9sYXN0UHJvZ3Jlc3MiLCJzZXR1cE1lc3NhZ2VIYW5kbGVyIiwiY2FjaGVTaW1wbGVNZXRob2QiLCJjYWNoZWRQcm9taXNlIiwiQW5ub3RhdGlvblN0b3JhZ2UiLCJpc09wTGlzdCIsIlNlcmlhbGl6YWJsZUVtcHR5IiwiUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSIsInNlcmlhbGl6YWJsZSIsImhhc2giLCJwYWdlIiwiaGFzT3duUHJvcGVydHkiLCJyZXNldE1vZGlmaWVkIiwidGVybWluYXRlZCIsImNhbmNlbEFsbFJlcXVlc3RzIiwic2luayIsImdldEZ1bGxSZWFkZXIiLCJldnQiLCJvblB1bGwiLCJjbG9zZSIsIkFycmF5QnVmZmVyIiwiZW5xdWV1ZSIsIm9uQ2FuY2VsIiwicmVhZHkiLCJyZWFkeVJlYXNvbiIsImhlYWRlcnNDYXBhYmlsaXR5IiwiZnVsbFJlYWRlciIsImhlYWRlcnNSZWFkeSIsImlzU3RyZWFtaW5nU3VwcG9ydGVkIiwiaXNSYW5nZVN1cHBvcnRlZCIsImNvbnRlbnRMZW5ndGgiLCJyYW5nZVJlYWRlciIsImdldFJhbmdlUmVhZGVyIiwiX251bVBhZ2VzIiwiaHRtbEZvclhmYSIsImV4Y2VwdGlvbiIsInVwZGF0ZVBhc3N3b3JkIiwiZXhwb3J0ZWREYXRhIiwiZXhwb3J0ZWRFcnJvciIsImluc3BlY3RGb250IiwiRm9udEluc3BlY3RvciIsImVuYWJsZWQiLCJmb250IiwiZm9udEFkZGVkIiwiRm9udEZhY2VPYmplY3QiLCJiaW5kIiwiZmluYWxseSIsImltYWdlRGF0YSIsInBhZ2VQcm94eSIsImJpdG1hcCIsIndpZHRoIiwiaGVpZ2h0IiwiZmV0Y2giLCJmaWxlbmFtZSIsIm51bSIsImdlbiIsInJlc3VsdHMiLCJPcHRpb25hbENvbnRlbnRDb25maWciLCJtZXRhZGF0YSIsIk1ldGFkYXRhIiwiY2xlYW51cFN1Y2Nlc3NmdWwiLCJlbnN1cmVPYmoiLCJvYmpJZCIsIm9uQ29udGludWUiLCJmb3JtIiwiY2FudmFzIiwiY2FudmFzSW5Vc2UiLCJXZWFrU2V0Iiwib3BlcmF0b3JMaXN0SWR4IiwicnVubmluZyIsImdyYXBoaWNzUmVhZHlDYWxsYmFjayIsImdyYXBoaWNzUmVhZHkiLCJfdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsbGVkIiwiX2NhbmNlbEJvdW5kIiwiX2NvbnRpbnVlQm91bmQiLCJfY29udGludWUiLCJfc2NoZWR1bGVOZXh0Qm91bmQiLCJfc2NoZWR1bGVOZXh0IiwiX25leHRCb3VuZCIsIl9uZXh0IiwiU3RlcHBlck1hbmFnZXIiLCJzdGVwcGVyIiwiaW5pdCIsIm5leHRCcmVha1BvaW50IiwiZ2V0TmV4dEJyZWFrUG9pbnQiLCJnZngiLCJDYW52YXNHcmFwaGljcyIsImJlZ2luRHJhd2luZyIsImVuZERyYXdpbmciLCJ1cGRhdGVPcGVyYXRvckxpc3QiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJleGVjdXRlT3BlcmF0b3JMaXN0IiwiX2VkaXRvciIsIl9tdXJtdXJoYXNoIiwiZnJlZXplIiwibW9kaWZpZWQiLCJzdG9yYWdlIiwib25TZXRNb2RpZmllZCIsIm9uUmVzZXRNb2RpZmllZCIsIm9uQW5ub3RhdGlvbkVkaXRvciIsImdldFZhbHVlIiwiZGVmYXVsdFZhbHVlIiwiZ2V0UmF3VmFsdWUiLCJyZW1vdmUiLCJBbm5vdGF0aW9uRWRpdG9yIiwic2V0VmFsdWUiLCJlbnRyeSIsImVudHJpZXMiLCJzZXRNb2RpZmllZCIsIl90eXBlIiwiZ2V0QWxsIiwic2V0QWxsIiwicHJpbnQiLCJNdXJtdXJIYXNoM182NCIsImNvbnRleHQiLCJoYXNCaXRtYXAiLCJzZXJpYWxpemVkIiwic2VyaWFsaXplIiwidXBkYXRlIiwiSlNPTiIsInN0cmluZ2lmeSIsImhleGRpZ2VzdCIsInBhcmVudCIsImNsb25lIiwiX3Rvb2xzIiwiYWx0VGV4dCIsImFsdFRleHREZWNvcmF0aXZlIiwiYWx0VGV4dEJ1dHRvbiIsImFsdFRleHRUb29sdGlwIiwiYWx0VGV4dFRvb2x0aXBUaW1lb3V0Iiwia2VlcEFzcGVjdFJhdGlvIiwicmVzaXplcnNEaXYiLCJib3VuZEZvY3VzaW4iLCJib3VuZEZvY3Vzb3V0IiwiaGFzQmVlbkNsaWNrZWQiLCJpc0VkaXRpbmciLCJpc0luRWRpdE1vZGUiLCJpc0RyYWdnYWJsZSIsInpJbmRleCIsIl9ib3JkZXJMaW5lV2lkdGgiLCJfY29sb3JNYW5hZ2VyIiwiQ29sb3JNYW5hZ2VyIiwiX3pJbmRleCIsIlNNQUxMX0VESVRPUl9TSVpFIiwicGFyYW1ldGVycyIsImZvY3VzaW4iLCJmb2N1c291dCIsIl9pbml0aWFsT3B0aW9ucyIsIl91aU1hbmFnZXIiLCJfZm9jdXNFdmVudHNBbGxvd2VkIiwiX2wxMG5Qcm9taXNlIiwiZGl2IiwidWlNYW5hZ2VyIiwiYW5ub3RhdGlvbkVsZW1lbnRJZCIsIl93aWxsS2VlcEFzcGVjdFJhdGlvIiwiaXNDZW50ZXJlZCIsIl9zdHJ1Y3RUcmVlUGFyZW50SWQiLCJyYXdEaW1zIiwicGFnZVdpZHRoIiwicGFnZUhlaWdodCIsInBhZ2VYIiwicGFnZVkiLCJwYWdlUm90YXRpb24iLCJ2aWV3UGFyYW1ldGVycyIsInBhZ2VEaW1lbnNpb25zIiwicGFnZVRyYW5zbGF0aW9uIiwicGFyZW50RGltZW5zaW9ucyIsIngiLCJ5IiwiaXNBdHRhY2hlZFRvRE9NIiwiZGVsZXRlZCIsImVkaXRvclR5cGUiLCJnZXRQcm90b3R5cGVPZiIsIl9kZWZhdWx0TGluZUNvbG9yIiwiZ2V0SGV4Q29kZSIsImRlbGV0ZUFubm90YXRpb25FbGVtZW50IiwiZWRpdG9yIiwiZmFrZUVkaXRvciIsIkZha2VFZGl0b3IiLCJnZXROZXh0SWQiLCJhZGRUb0Fubm90YXRpb25TdG9yYWdlIiwiaW5pdGlhbGl6ZSIsImwxMG4iLCJzdHJpbmdzIiwic3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiZG9jdW1lbnRFbGVtZW50IiwicGFyc2VGbG9hdCIsImdldFByb3BlcnR5VmFsdWUiLCJ1cGRhdGVEZWZhdWx0UGFyYW1zIiwiX3ZhbHVlIiwiZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSIsImlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyIsIm1pbWUiLCJwYXN0ZSIsIml0ZW0iLCJwcm9wZXJ0aWVzVG9VcGRhdGUiLCJfaXNEcmFnZ2FibGUiLCJjbGFzc0xpc3QiLCJ0b2dnbGUiLCJjZW50ZXIiLCJwYXJlbnRSb3RhdGlvbiIsImZpeEFuZFNldFBvc2l0aW9uIiwiYWRkQ29tbWFuZHMiLCJjdXJyZW50TGF5ZXIiLCJzZXRJbkJhY2tncm91bmQiLCJzZXRJbkZvcmVncm91bmQiLCJzZXRQYXJlbnQiLCJzZXRTZWxlY3RlZCIsInRhcmdldCIsInJlbGF0ZWRUYXJnZXQiLCJjbG9zZXN0IiwicHJldmVudERlZmF1bHQiLCJpc011bHRpcGxlU2VsZWN0aW9uIiwiY29tbWl0T3JSZW1vdmUiLCJpc0VtcHR5IiwiY29tbWl0Iiwic2V0QXQiLCJ0eCIsInR5Iiwic2NyZWVuVG9QYWdlVHJhbnNsYXRpb24iLCJ0cmFuc2xhdGUiLCJ0cmFuc2xhdGVJblBhZ2UiLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwiZHJhZyIsInBhcmVudFdpZHRoIiwicGFyZW50SGVpZ2h0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZmluZE5ld1BhcmVudCIsImJ4IiwiYnkiLCJnZXRCYXNlVHJhbnNsYXRpb24iLCJsZWZ0IiwidG9GaXhlZCIsInRvcCIsIm1vdmVJbkRPTSIsInJvdGF0ZVBvaW50IiwiYW5nbGUiLCJwYWdlVHJhbnNsYXRpb25Ub1NjcmVlbiIsImdldFJvdGF0aW9uTWF0cml4IiwicGFyZW50U2NhbGUiLCJyZWFsU2NhbGUiLCJzY2FsZWRXaWR0aCIsInNjYWxlZEhlaWdodCIsInJvdW5kIiwic2V0RGltcyIsImZpeERpbXMiLCJ3aWR0aFBlcmNlbnQiLCJlbmRzV2l0aCIsImhlaWdodFBlcmNlbnQiLCJnZXRJbml0aWFsVHJhbnNsYXRpb24iLCJjcmVhdGVSZXNpemVycyIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc2VzIiwiYXBwZW5kIiwicmVzaXplclBvaW50ZXJkb3duIiwibm9Db250ZXh0TWVudSIsInByZXBlbmQiLCJidXR0b24iLCJjdHJsS2V5IiwiYm91bmRSZXNpemVyUG9pbnRlcm1vdmUiLCJyZXNpemVyUG9pbnRlcm1vdmUiLCJzYXZlZERyYWdnYWJsZSIsInBvaW50ZXJNb3ZlT3B0aW9ucyIsInBhc3NpdmUiLCJjYXB0dXJlIiwic2F2ZWRYIiwic2F2ZWRZIiwic2F2ZWRXaWR0aCIsInNhdmVkSGVpZ2h0Iiwic2F2ZWRQYXJlbnRDdXJzb3IiLCJjdXJzb3IiLCJzYXZlZEN1cnNvciIsInBvaW50ZXJVcENhbGxiYWNrIiwibmV3WCIsIm5ld1kiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsImNtZCIsInVuZG8iLCJtdXN0RXhlYyIsIm1pbldpZHRoIiwiTUlOX1NJWkUiLCJtaW5IZWlnaHQiLCJyb3RhdGlvbk1hdHJpeCIsInRyYW5zZiIsImludlJvdGF0aW9uTWF0cml4IiwiaW52VHJhbnNmIiwiZ2V0UG9pbnQiLCJnZXRPcHBvc2l0ZSIsImlzRGlhZ29uYWwiLCJpc0hvcml6b250YWwiLCJ3IiwiaCIsInBvaW50Iiwib3Bwb3NpdGVQb2ludCIsInRyYW5zZk9wcG9zaXRlUG9pbnQiLCJvcHBvc2l0ZVgiLCJvcHBvc2l0ZVkiLCJyYXRpb1giLCJyYXRpb1kiLCJkZWx0YVgiLCJkZWx0YVkiLCJtb3ZlbWVudFgiLCJtb3ZlbWVudFkiLCJvbGREaWFnIiwiaHlwb3QiLCJhZGRBbHRUZXh0QnV0dG9uIiwiY2xhc3NOYW1lIiwic2V0QXR0cmlidXRlIiwidGFiSW5kZXgiLCJzdG9wUHJvcGFnYXRpb24iLCJlZGl0QWx0VGV4dCIsInNldEFsdFRleHRCdXR0b25TdGF0ZSIsIlBFUkNFTlQiLCJ0b29sdGlwIiwiREVMQVlfVE9fU0hPV19UT09MVElQIiwiX2V2ZW50QnVzIiwiZGlzcGF0Y2giLCJzdWJ0eXBlIiwiYWN0aW9uIiwiaW5uZXJUZXh0IiwicGFyZW50Tm9kZSIsImdldENsaWVudERpbWVuc2lvbnMiLCJhbHRUZXh0RGF0YSIsImRlY29yYXRpdmUiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsImJpbmRFdmVudHMiLCJwb2ludGVyZG93biIsInNldFVwRHJhZ1Nlc3Npb24iLCJpc1NlbGVjdGVkIiwicG9pbnRlck1vdmVDYWxsYmFjayIsImUiLCJkcmFnU2VsZWN0ZWRFZGl0b3JzIiwiZW5kRHJhZ1Nlc3Npb24iLCJzaGlmdEtleSIsIm1ldGFLZXkiLCJ0b2dnbGVTZWxlY3RlZCIsIm1vdmVFZGl0b3JJbkRPTSIsIl9zZXRQYXJlbnRBbmRQb3NpdGlvbiIsImNoYW5nZVBhcmVudCIsImdldFJlY3QiLCJzaGlmdFgiLCJzaGlmdFkiLCJnZXRSZWN0SW5DdXJyZW50Q29vcmRzIiwib25jZUFkZGVkIiwiZW5hYmxlRWRpdE1vZGUiLCJkaXNhYmxlRWRpdE1vZGUiLCJzaG91bGRHZXRLZXlib2FyZEV2ZW50cyIsIm5lZWRzVG9CZVJlYnVpbHQiLCJyZWJ1aWxkIiwiaXNGb3JDb3B5aW5nIiwiZGVzZXJpYWxpemUiLCJyZW1vdmVFZGl0b3IiLCJpc1Jlc2l6YWJsZSIsIm1ha2VSZXNpemFibGUiLCJzZWxlY3QiLCJ1bnNlbGVjdCIsImNvbnRhaW5zIiwiYWN0aXZlRWxlbWVudCIsImZvY3VzIiwidXBkYXRlUGFyYW1zIiwiZGlzYWJsZUVkaXRpbmciLCJoaWRkZW4iLCJlbmFibGVFZGl0aW5nIiwiZW50ZXJJbkVkaXRNb2RlIiwiY29udGVudERpdiIsInNldEFjdGl2ZUVkaXRvciIsInNldEFzcGVjdFJhdGlvIiwiYXNwZWN0UmF0aW8iLCJLZXlib2FyZE1hbmFnZXIiLCJDb21tYW5kTWFuYWdlciIsIkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIiLCJvcGFjaXR5VG9IZXgiLCJlbGVtZW50IiwibmFtZXMiLCJvcGFjaXR5IiwiSWRNYW5hZ2VyIiwiZ2V0SWQiLCJJbWFnZU1hbmFnZXIiLCJiYXNlSWQiLCJjYWNoZSIsIl9pc1NWR0ZpdHRpbmdDYW52YXMiLCJzdmciLCJjdHgiLCJnZXRDb250ZXh0IiwiaW1hZ2UiLCJJbWFnZSIsImRyYXdJbWFnZSIsImdldEltYWdlRGF0YSIsInJhd0RhdGEiLCJyZWZDb3VudGVyIiwiaXNTdmciLCJyZXNwb25zZSIsIm9rIiwic3RhdHVzVGV4dCIsImJsb2IiLCJmaWxlIiwibXVzdFJlbW92ZUFzcGVjdFJhdGlvUHJvbWlzZSIsImZpbGVSZWFkZXIiLCJGaWxlUmVhZGVyIiwiaW1hZ2VFbGVtZW50IiwiaW1hZ2VQcm9taXNlIiwib25sb2FkIiwic3ZnVXJsIiwicmVzdWx0Iiwib25lcnJvciIsInJlYWRBc0RhdGFVUkwiLCJjcmVhdGVJbWFnZUJpdG1hcCIsImdldEZyb21GaWxlIiwibGFzdE1vZGlmaWVkIiwiZ2V0RnJvbVVybCIsImdldEZyb21JZCIsImdldFN2Z1VybCIsImRlbGV0ZUlkIiwiaXNWYWxpZElkIiwiY29tbWFuZHMiLCJsb2NrZWQiLCJtYXhTaXplIiwicG9zaXRpb24iLCJvdmVyd3JpdGVJZlNhbWVUeXBlIiwia2VlcFVuZG8iLCJuZXh0Iiwic3BsaWNlIiwicmVkbyIsImhhc1NvbWV0aGluZ1RvVW5kbyIsImhhc1NvbWV0aGluZ1RvUmVkbyIsImNhbGxiYWNrcyIsImFsbEtleXMiLCJpc01hY0tleSIsInNwbGl0IiwiYXQiLCJhbHRLZXkiLCJleGVjIiwic2VsZiIsImJ1YmJsZXMiLCJhcmdzIiwiY2hlY2tlciIsIl9jb2xvcnNNYXBwaW5nIiwiX2NvbG9ycyIsImNvbG9ycyIsImdldENvbG9yVmFsdWVzIiwiY29udmVydCIsImNvbG9yIiwicmdiIiwiZ2V0UkdCIiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJSR0IiLCJldmVyeSIsImFjdGl2ZUVkaXRvciIsImFsbEVkaXRvcnMiLCJhbGxMYXllcnMiLCJhbHRUZXh0TWFuYWdlciIsImNvbW1hbmRNYW5hZ2VyIiwiY3VycmVudFBhZ2VJbmRleCIsImRlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMiLCJkcmFnZ2luZ0VkaXRvcnMiLCJlZGl0b3JUeXBlcyIsImVkaXRvcnNUb1Jlc2NhbGUiLCJpZE1hbmFnZXIiLCJpc0VuYWJsZWQiLCJpc1dhaXRpbmciLCJsYXN0QWN0aXZlRWxlbWVudCIsIm1vZGUiLCJzZWxlY3RlZEVkaXRvcnMiLCJib3VuZEJsdXIiLCJib3VuZEZvY3VzIiwiYm91bmRDb3B5IiwiYm91bmRDdXQiLCJib3VuZFBhc3RlIiwiYm91bmRLZXlkb3duIiwiYm91bmRPbkVkaXRpbmdBY3Rpb24iLCJib3VuZE9uUGFnZUNoYW5naW5nIiwiYm91bmRPblNjYWxlQ2hhbmdpbmciLCJib3VuZE9uUm90YXRpb25DaGFuZ2luZyIsInByZXZpb3VzU3RhdGVzIiwidHJhbnNsYXRpb24iLCJ0cmFuc2xhdGlvblRpbWVvdXRJZCIsImNvbnRhaW5lciIsInZpZXdlciIsIlRSQU5TTEFURV9TTUFMTCIsIlRSQU5TTEFURV9CSUciLCJfa2V5Ym9hcmRNYW5hZ2VyIiwicHJvdG8iLCJhcnJvd0NoZWNrZXIiLCJoYXNTb21ldGhpbmdUb0NvbnRyb2wiLCJzbWFsbCIsImJpZyIsInNlbGVjdEFsbCIsInVuc2VsZWN0QWxsIiwidHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzIiwiZXZlbnRCdXMiLCJwZGZEb2N1bWVudCIsImJsdXIiLCJjb3B5IiwiY3V0Iiwia2V5ZG93biIsIm9uRWRpdGluZ0FjdGlvbiIsIm9uUGFnZUNoYW5naW5nIiwib25TY2FsZUNoYW5naW5nIiwib25Sb3RhdGlvbkNoYW5naW5nIiwiaGFzU2VsZWN0ZWRFZGl0b3IiLCJfb24iLCJQaXhlbHNQZXJJbmNoIiwiUERGX1RPX0NTU19VTklUUyIsInJlbW92ZUtleWJvYXJkTWFuYWdlciIsInJlbW92ZUZvY3VzTWFuYWdlciIsIl9vZmYiLCJsYXllciIsImhjbUZpbHRlciIsImFkZEhDTUZpbHRlciIsImZvcmVncm91bmQiLCJkaXJlY3Rpb24iLCJmb2N1c01haW5Db250YWluZXIiLCJmaW5kUGFyZW50IiwibGF5ZXJYIiwibGF5ZXJZIiwiZGlzYWJsZVVzZXJTZWxlY3QiLCJhZGRTaG91bGRSZXNjYWxlIiwicmVtb3ZlU2hvdWxkUmVzY2FsZSIsInBhZ2VzUm90YXRpb24iLCJhZGRGb2N1c01hbmFnZXIiLCJoYXNTZWxlY3Rpb24iLCJsYXN0RWRpdG9yIiwib25jZSIsImFkZEtleWJvYXJkTWFuYWdlciIsImFkZENvcHlQYXN0ZUxpc3RlbmVycyIsInJlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycyIsImFkZEVkaXRMaXN0ZW5lcnMiLCJyZW1vdmVFZGl0TGlzdGVuZXJzIiwiZWRpdG9ycyIsImNsaXBib2FyZERhdGEiLCJzZXREYXRhIiwicGFyc2UiLCJpc0FycmF5IiwibmV3RWRpdG9ycyIsImRlc2VyaWFsaXplZEVkaXRvciIsImFkZEVkaXRvclRvTGF5ZXIiLCJzZWxlY3RFZGl0b3JzIiwiZ2V0QWN0aXZlIiwiZGlzcGF0Y2hVcGRhdGVTdGF0ZXMiLCJoYXNDaGFuZ2VkIiwic29tZSIsImRpc3BhdGNoVXBkYXRlVUkiLCJzZXRFZGl0aW5nU3RhdGUiLCJyZWdpc3RlckVkaXRvclR5cGVzIiwidHlwZXMiLCJnZXRMYXllciIsImFkZExheWVyIiwiZW5hYmxlIiwiZGlzYWJsZSIsInJlbW92ZUxheWVyIiwidXBkYXRlTW9kZSIsImVkaXRJZCIsImRpc2FibGVBbGwiLCJlbmFibGVBbGwiLCJ1cGRhdGVUb29sYmFyIiwiYWRkTmV3RWRpdG9yIiwiZW5hYmxlV2FpdGluZyIsIm11c3RXYWl0IiwiZGlzYWJsZUNsaWNrIiwiZW5hYmxlQ2xpY2siLCJnZXRFZGl0b3JzIiwiZ2V0RWRpdG9yIiwiYWRkRWRpdG9yIiwiYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50IiwiaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQiLCJyZW1vdmVEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQiLCJhZGRPclJlYnVpbGQiLCJlZCIsIm5vQ29tbWl0IiwidG90YWxYIiwidG90YWxZIiwiVElNRV9UT19XQUlUIiwic2F2ZWRQYWdlSW5kZXgiLCJuZXdQYWdlSW5kZXgiLCJtdXN0QmVBZGRlZEluVW5kb1N0YWNrIiwibW92ZSIsImlzQWN0aXZlIiwiZ2V0TW9kZSIsImltYWdlTWFuYWdlciIsIlBERkRhdGVTdHJpbmciLCJET01TVkdGYWN0b3J5IiwiZ2V0Q3VycmVudFRyYW5zZm9ybSIsImdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlIiwiZ2V0RmlsZW5hbWVGcm9tVXJsIiwiZ2V0UGRmRmlsZW5hbWVGcm9tVXJsIiwiZ2V0WGZhUGFnZVZpZXdwb3J0IiwiaXNQZGZGaWxlIiwic2V0TGF5ZXJEaW1lbnNpb25zIiwiX2Jhc2VfZmFjdG9yeSIsIlNWR19OUyIsIlBERiIsIkJhc2VGaWx0ZXJGYWN0b3J5IiwiX2NhY2hlIiwiX2RlZnMiLCJoY21LZXkiLCJoY21VcmwiLCJoY21IaWdobGlnaHRGaWx0ZXIiLCJoY21IaWdobGlnaHRLZXkiLCJoY21IaWdobGlnaHRVcmwiLCJkZWZzIiwidmlzaWJpbGl0eSIsImNvbnRhaW4iLCJjcmVhdGVFbGVtZW50TlMiLCJib2R5IiwiYWRkRmlsdGVyIiwibWFwcyIsInRhYmxlUiIsInRhYmxlRyIsInRhYmxlQiIsIm1hcFIiLCJtYXBHIiwibWFwQiIsImJ1ZmZlclIiLCJidWZmZXJHIiwiYnVmZmVyQiIsImZpbHRlciIsImNyZWF0ZUZpbHRlciIsImFkZFRyYW5zZmVyTWFwQ29udmVyc2lvbiIsImZnQ29sb3IiLCJiZ0NvbG9yIiwiZmdSR0IiLCJiZ1JHQiIsInRhYmxlIiwiYWRkR3JheUNvbnZlcnNpb24iLCJnZXRTdGVwcyIsInN0YXJ0IiwiYXJyIiwiYWRkSGlnaGxpZ2h0SENNRmlsdGVyIiwibmV3RmdDb2xvciIsIm5ld0JnQ29sb3IiLCJmZ0dyYXkiLCJiZ0dyYXkiLCJuZXdGZ1JHQiIsIm5ld0JnUkdCIiwiZmciLCJiZyIsInN0ZXAiLCJuZXdTdGFydCIsIm5ld1N0ZXAiLCJwcmV2IiwiayIsImtlZXBIQ00iLCJmZUNvbG9yTWF0cml4IiwiYXBwZW5kRmVGdW5jIiwiZmVDb21wb25lbnRUcmFuc2ZlciIsImZ1bmMiLCJmZUZ1bmMiLCJyVGFibGUiLCJnVGFibGUiLCJiVGFibGUiLCJCYXNlQ2FudmFzRmFjdG9yeSIsIl9kb2N1bWVudCIsIl9jcmVhdGVDYW52YXMiLCJmZXRjaERhdGEiLCJhc1R5cGVkQXJyYXkiLCJhcnJheUJ1ZmZlciIsInRleHQiLCJyZXF1ZXN0IiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwicmVzcG9uc2VUeXBlIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsIkRPTkUiLCJyZXNwb25zZVRleHQiLCJCYXNlQ01hcFJlYWRlckZhY3RvcnkiLCJfZmV0Y2hEYXRhIiwiY29tcHJlc3Npb25UeXBlIiwiY01hcERhdGEiLCJCYXNlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJCYXNlU1ZHRmFjdG9yeSIsIl9jcmVhdGVTVkciLCJjZW50ZXJYIiwiY2VudGVyWSIsInJvdGF0ZUEiLCJyb3RhdGVCIiwicm90YXRlQyIsInJvdGF0ZUQiLCJvZmZzZXRDYW52YXNYIiwib2Zmc2V0Q2FudmFzWSIsImNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQiLCJjb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZSIsInRvcExlZnQiLCJib3R0b21SaWdodCIsImNvbnZlcnRUb1BkZlBvaW50IiwidHJpbSIsInN1YnN0cmluZyIsInRvTG93ZXJDYXNlIiwidGVzdCIsIm9ubHlTdHJpcFBhdGgiLCJsYXN0SW5kZXhPZiIsImRlZmF1bHRGaWxlbmFtZSIsInJlVVJJIiwicmVGaWxlbmFtZSIsInNwbGl0VVJJIiwic3VnZ2VzdGVkRmlsZW5hbWUiLCJzdGFydGVkIiwibm93IiwidGltZXMiLCJvdXRCdWYiLCJsb25nZXN0IiwicGFkRW5kIiwicmVtb3ZlU2NyaXB0RWxlbWVudCIsInNjcmlwdCIsImhlYWQiLCJwZGZEYXRlU3RyaW5nUmVnZXgiLCJ0b0RhdGVPYmplY3QiLCJpbnB1dCIsIlJlZ0V4cCIsInllYXIiLCJwYXJzZUludCIsIm1vbnRoIiwiZGF5IiwiaG91ciIsIm1pbnV0ZSIsInVuaXZlcnNhbFRpbWVSZWxhdGlvbiIsIm9mZnNldEhvdXIiLCJvZmZzZXRNaW51dGUiLCJVVEMiLCJ4ZmFQYWdlIiwiYXR0cmlidXRlcyIsImNvbG9yUkdCIiwic3BhbiIsImNvbXB1dGVkQ29sb3IiLCJmIiwiZ2V0VHJhbnNmb3JtIiwiaW52ZXJ0U2VsZiIsIm11c3RGbGlwIiwibXVzdFJvdGF0ZSIsInVzZVJvdW5kIiwid2lkdGhTdHIiLCJoZWlnaHRTdHIiLCJyZXNldCIsImNhbnZhc0FuZENvbnRleHQiLCJza2lwRGltZW5zaW9ucyIsIlNFRUQiLCJNQVNLX0hJR0giLCJNQVNLX0xPVyIsInNlZWQiLCJoMSIsImgyIiwiYmxvY2tDb3VudHMiLCJ0YWlsTGVuZ3RoIiwiZGF0YVVpbnQzMiIsImsxIiwiazIiLCJDMSIsIkMyIiwiQzFfTE9XIiwiQzJfTE9XIiwic3lzdGVtRm9udHMiLCJuYXRpdmVGb250RmFjZXMiLCJsb2FkaW5nUmVxdWVzdHMiLCJsb2FkVGVzdEZvbnRJZCIsImFkZE5hdGl2ZUZvbnRGYWNlIiwibmF0aXZlRm9udEZhY2UiLCJmb250cyIsInJlbW92ZU5hdGl2ZUZvbnRGYWNlIiwiaW5zZXJ0UnVsZSIsInJ1bGUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInN0eWxlU2hlZXQiLCJzaGVldCIsImNzc1J1bGVzIiwibG9hZFN5c3RlbUZvbnQiLCJsb2FkZWROYW1lIiwiaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCIsImZvbnRGYWNlIiwiRm9udEZhY2UiLCJsb2FkIiwiYmFzZUZvbnROYW1lIiwiYXR0YWNoZWQiLCJtaXNzaW5nRmlsZSIsInN5c3RlbUZvbnRJbmZvIiwiY3JlYXRlTmF0aXZlRm9udEZhY2UiLCJmYW1pbHkiLCJjcmVhdGVGb250RmFjZVJ1bGUiLCJpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCIsIl9xdWV1ZUxvYWRpbmdDYWxsYmFjayIsIl9wcmVwYXJlRm9udExvYWRFdmVudCIsImhhc0ZvbnRzIiwic3VwcG9ydGVkIiwidXNlckFnZW50IiwiY29tcGxldGVSZXF1ZXN0Iiwib3RoZXJSZXF1ZXN0Iiwic2hpZnQiLCJfbG9hZFRlc3RGb250IiwidGVzdEZvbnQiLCJhdG9iIiwiaW50MzIiLCJvZmZzZXQiLCJzcGxpY2VTdHJpbmciLCJzIiwiaW5zZXJ0IiwiY2h1bmsxIiwiY2h1bmsyIiwiY2FsbGVkIiwiaXNGb250UmVhZHkiLCJmaWxsVGV4dCIsIkNPTU1FTlRfT0ZGU0VUIiwiQ0ZGX0NIRUNLU1VNX09GRlNFVCIsIlhYWFhfVkFMVUUiLCJjaGVja3N1bSIsImJ0b2EiLCJmb250RmFtaWx5IiwidHJhbnNsYXRlZERhdGEiLCJjb21waWxlZEdseXBocyIsIl9pbnNwZWN0Rm9udCIsImNzc0ZvbnRJbmZvIiwiY3NzIiwid2VpZ2h0IiwiZm9udFdlaWdodCIsIml0YWxpY0FuZ2xlIiwibWltZXR5cGUiLCJnZXRQYXRoR2VuZXJhdG9yIiwiY2hhcmFjdGVyIiwiY21kcyIsImpzQnVmIiwiY3VycmVudCIsImZzIiwicmVhZEZpbGUiLCJDYW52YXMiLCJjcmVhdGVDYW52YXMiLCJfcGF0dGVybl9oZWxwZXIiLCJfaW1hZ2VfdXRpbHMiLCJNSU5fRk9OVF9TSVpFIiwiTUFYX0ZPTlRfU0laRSIsIk1BWF9HUk9VUF9TSVpFIiwiRVhFQ1VUSU9OX1RJTUUiLCJFWEVDVVRJT05fU1RFUFMiLCJNQVhfU0laRV9UT19DT01QSUxFIiwiRlVMTF9DSFVOS19IRUlHSFQiLCJtaXJyb3JDb250ZXh0T3BlcmF0aW9ucyIsImRlc3RDdHgiLCJfcmVtb3ZlTWlycm9yaW5nIiwiX19vcmlnaW5hbFNhdmUiLCJfX29yaWdpbmFsUmVzdG9yZSIsIl9fb3JpZ2luYWxSb3RhdGUiLCJfX29yaWdpbmFsU2NhbGUiLCJfX29yaWdpbmFsVHJhbnNsYXRlIiwiX19vcmlnaW5hbFRyYW5zZm9ybSIsIl9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0iLCJzZXRUcmFuc2Zvcm0iLCJfX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm0iLCJyZXNldFRyYW5zZm9ybSIsIl9fb3JpZ2luYWxDbGlwIiwiX19vcmlnaW5hbE1vdmVUbyIsIl9fb3JpZ2luYWxMaW5lVG8iLCJfX29yaWdpbmFsQmV6aWVyQ3VydmVUbyIsImJlemllckN1cnZlVG8iLCJfX29yaWdpbmFsUmVjdCIsIl9fb3JpZ2luYWxDbG9zZVBhdGgiLCJfX29yaWdpbmFsQmVnaW5QYXRoIiwiYmVnaW5QYXRoIiwiY3R4U2F2ZSIsImN0eFJlc3RvcmUiLCJjdHhUcmFuc2xhdGUiLCJjdHhTY2FsZSIsImN0eFRyYW5zZm9ybSIsImN0eFNldFRyYW5zZm9ybSIsImN0eFJlc2V0VHJhbnNmb3JtIiwiY3R4Um90YXRlIiwiY3AxeCIsImNwMXkiLCJjcDJ4IiwiY3AyeSIsIkNhY2hlZENhbnZhc2VzIiwiZ2V0Q2FudmFzIiwiY2FudmFzRW50cnkiLCJkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMiLCJzcmNJbWciLCJzcmNYIiwic3JjWSIsInNyY1ciLCJzcmNIIiwiZGVzdFgiLCJkZXN0WSIsImRlc3RXIiwiZGVzdEgiLCJ0bFgiLCJyVGxYIiwidGxZIiwiclRsWSIsImJyWCIsInJXaWR0aCIsImJyWSIsInJIZWlnaHQiLCJzaWduIiwic2NhbGVYIiwic2NhbGVZIiwiY29tcGlsZVR5cGUzR2x5cGgiLCJpbWdEYXRhIiwiUE9JTlRfVE9fUFJPQ0VTU19MSU1JVCIsIlBPSU5UX1RZUEVTIiwid2lkdGgxIiwicG9pbnRzIiwiajAiLCJsaW5lU2l6ZSIsInBvcyIsImVsZW0iLCJtYXNrIiwiY291bnQiLCJzdW0iLCJzdGVwcyIsIkludDMyQXJyYXkiLCJwYXRoIiwiUGF0aDJEIiwicDAiLCJwcCIsImRyYXdPdXRsaW5lIiwiQ2FudmFzRXh0cmFTdGF0ZSIsImFscGhhSXNTaGFwZSIsImZvbnRTaXplIiwiZm9udFNpemVTY2FsZSIsInRleHRNYXRyaXgiLCJ0ZXh0TWF0cml4U2NhbGUiLCJmb250TWF0cml4IiwibGVhZGluZyIsImxpbmVYIiwibGluZVkiLCJjaGFyU3BhY2luZyIsIndvcmRTcGFjaW5nIiwidGV4dEhTY2FsZSIsInRleHRSZW5kZXJpbmdNb2RlIiwidGV4dFJpc2UiLCJmaWxsQ29sb3IiLCJzdHJva2VDb2xvciIsInBhdHRlcm5GaWxsIiwiZmlsbEFscGhhIiwic3Ryb2tlQWxwaGEiLCJsaW5lV2lkdGgiLCJhY3RpdmVTTWFzayIsInRyYW5zZmVyTWFwcyIsInN0YXJ0TmV3UGF0aEFuZENsaXBCb3giLCJjbGlwQm94Iiwic2V0Q3VycmVudFBvaW50IiwidXBkYXRlUGF0aE1pbk1heCIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJ1cGRhdGVSZWN0TWluTWF4IiwidXBkYXRlU2NhbGluZ1BhdGhNaW5NYXgiLCJ1cGRhdGVDdXJ2ZVBhdGhNaW5NYXgiLCJib3giLCJnZXRQYXRoQm91bmRpbmdCb3giLCJwYXRoVHlwZSIsIlBhdGhUeXBlIiwieFN0cm9rZVBhZCIsInlTdHJva2VQYWQiLCJ1cGRhdGVDbGlwRnJvbVBhdGgiLCJpc0VtcHR5Q2xpcCIsIkluZmluaXR5IiwiZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCIsInB1dEJpbmFyeUltYWdlRGF0YSIsIkltYWdlRGF0YSIsInB1dEltYWdlRGF0YSIsInBhcnRpYWxDaHVua0hlaWdodCIsImZ1bGxDaHVua3MiLCJ0b3RhbENodW5rcyIsImNodW5rSW1nRGF0YSIsImNyZWF0ZUltYWdlRGF0YSIsInNyY1BvcyIsImRlc3RQb3MiLCJkZXN0IiwidGhpc0NodW5rSGVpZ2h0IiwiZWxlbXNJblRoaXNDaHVuayIsImtpbmQiLCJzcmNMZW5ndGgiLCJkZXN0MzIiLCJkZXN0MzJEYXRhTGVuZ3RoIiwiZnVsbFNyY0RpZmYiLCJ3aGl0ZSIsImJsYWNrIiwic3JjRGlmZiIsImtFbmQiLCJrRW5kVW5yb2xsZWQiLCJzcmNCeXRlIiwicHV0QmluYXJ5SW1hZ2VNYXNrIiwiY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEiLCJub25CbGFja0NvbG9yIiwiY29weUN0eFN0YXRlIiwic291cmNlQ3R4IiwicHJvcGVydGllcyIsInByb3BlcnR5Iiwic2V0TGluZURhc2giLCJnZXRMaW5lRGFzaCIsImxpbmVEYXNoT2Zmc2V0IiwicmVzZXRDdHhUb0RlZmF1bHQiLCJzdHJva2VTdHlsZSIsImZpbGxTdHlsZSIsImZpbGxSdWxlIiwiZ2xvYmFsQWxwaGEiLCJsaW5lQ2FwIiwibGluZUpvaW4iLCJtaXRlckxpbWl0IiwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIiwiY29tcG9zZVNNYXNrQmFja2Ryb3AiLCJyMCIsImcwIiwiYjAiLCJhbHBoYSIsImFscGhhXyIsImNvbXBvc2VTTWFza0FscGhhIiwibWFza0RhdGEiLCJsYXllckRhdGEiLCJ0cmFuc2Zlck1hcCIsImNvbXBvc2VTTWFza0x1bWlub3NpdHkiLCJnZW5lcmljQ29tcG9zZVNNYXNrIiwibWFza0N0eCIsImxheWVyQ3R4IiwiYmFja2Ryb3AiLCJsYXllck9mZnNldFgiLCJsYXllck9mZnNldFkiLCJtYXNrT2Zmc2V0WCIsIm1hc2tPZmZzZXRZIiwiaGFzQmFja2Ryb3AiLCJjb21wb3NlRm4iLCJQSVhFTFNfVE9fUFJPQ0VTUyIsImNodW5rU2l6ZSIsImNlaWwiLCJyb3ciLCJjaHVua0hlaWdodCIsImNvbXBvc2VTTWFzayIsInNtYXNrIiwibGF5ZXJCb3giLCJsYXllcldpZHRoIiwibGF5ZXJIZWlnaHQiLCJnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQiLCJpbnRlcnBvbGF0ZSIsImZyb3VuZCIsImFjdHVhbFNjYWxlIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIkxJTkVfQ0FQX1NUWUxFUyIsIkxJTkVfSk9JTl9TVFlMRVMiLCJOT1JNQUxfQ0xJUCIsIkVPX0NMSVAiLCJjYW52YXNDdHgiLCJtYXJrZWRDb250ZW50U3RhY2siLCJzdGF0ZVN0YWNrIiwicGVuZGluZ0NsaXAiLCJwZW5kaW5nRU9GaWxsIiwicmVzIiwieG9ianMiLCJncm91cFN0YWNrIiwicHJvY2Vzc2luZ1R5cGUzIiwiYmFzZVRyYW5zZm9ybSIsImJhc2VUcmFuc2Zvcm1TdGFjayIsImdyb3VwTGV2ZWwiLCJzbWFza1N0YWNrIiwic21hc2tDb3VudGVyIiwidGVtcFNNYXNrIiwic3VzcGVuZGVkQ3R4IiwiY29udGVudFZpc2libGUiLCJjYWNoZWRDYW52YXNlcyIsImNhY2hlZFBhdHRlcm5zIiwidmlld3BvcnRTY2FsZSIsIm91dHB1dFNjYWxlWCIsIm91dHB1dFNjYWxlWSIsIl9jYWNoZWRTY2FsZUZvclN0cm9raW5nIiwiX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGgiLCJfY2FjaGVkQml0bWFwc01hcCIsImdldE9iamVjdCIsImZhbGxiYWNrIiwic2F2ZWRGaWxsU3R5bGUiLCJmaWxsUmVjdCIsInRyYW5zcGFyZW50Q2FudmFzIiwiY29tcG9zaXRlQ3R4IiwiZXhlY3V0aW9uU3RhcnRJZHgiLCJjb250aW51ZUNhbGxiYWNrIiwiYXJnc0FycmF5TGVuIiwiY2h1bmtPcGVyYXRpb25zIiwiZW5kVGltZSIsImZuSWQiLCJicmVha0l0IiwiZGVwT2JqSWQiLCJvYmpzUG9vbCIsInJlc3RvcmVJbml0aWFsU3RhdGUiLCJpblNNYXNrTW9kZSIsIkhUTUxDYW52YXNFbGVtZW50IiwiZHJhd0ZpbHRlciIsImhjbUZpbHRlcklkIiwic2F2ZWRGaWx0ZXIiLCJfc2NhbGVJbWFnZSIsImltZyIsIndpZHRoU2NhbGUiLCJoZWlnaHRTY2FsZSIsInBhaW50V2lkdGgiLCJwYWludEhlaWdodCIsInRtcENhbnZhc0lkIiwidG1wQ2FudmFzIiwidG1wQ3R4IiwiY2xlYXJSZWN0IiwiX2NyZWF0ZU1hc2tDYW52YXMiLCJpc1BhdHRlcm5GaWxsIiwiY3VycmVudFRyYW5zZm9ybSIsInNjYWxlZCIsIm1hc2tDYW52YXMiLCJtYWluS2V5IiwiY2FjaGVkSW1hZ2UiLCJtYXNrVG9DYW52YXMiLCJjb3JkMSIsImNvcmQyIiwiZHJhd25XaWR0aCIsImRyYXduSGVpZ2h0IiwiZmlsbENhbnZhcyIsImZpbGxDdHgiLCJpbWFnZVNtb290aGluZ0VuYWJsZWQiLCJpbnZlcnNlIiwiZ2V0UGF0dGVybiIsImxpbWl0IiwiZGFzaEFycmF5IiwiZGFzaFBoYXNlIiwiZmxhdG5lc3MiLCJzdGF0ZXMiLCJjaGVja1NNYXNrU3RhdGUiLCJiZWdpblNNYXNrTW9kZSIsImVuZFNNYXNrTW9kZSIsImNhY2hlSWQiLCJzY3JhdGNoQ2FudmFzIiwiY29tcG9zZSIsImRpcnR5Qm94Iiwib2xkIiwicG9wIiwib3BzIiwic3RhcnRYIiwic3RhcnRZIiwiaXNTY2FsaW5nTWF0cml4IiwibWluTWF4Rm9yQmV6aWVyIiwieHciLCJ5aCIsImNvbnN1bWVQYXRoIiwicmVzY2FsZUFuZFN0cm9rZSIsIm5lZWRSZXN0b3JlIiwicGF0aHMiLCJwZW5kaW5nVGV4dFBhdGhzIiwiYWRkVG9QYXRoIiwic3BhY2luZyIsImZvbnRSZWZOYW1lIiwiZm9udE9iaiIsImZvbnREaXJlY3Rpb24iLCJpc1R5cGUzRm9udCIsInR5cGVmYWNlIiwiZmFsbGJhY2tOYW1lIiwiYm9sZCIsIml0YWxpYyIsImJyb3dzZXJGb250U2l6ZSIsInJpc2UiLCJwYWludENoYXIiLCJwYXR0ZXJuVHJhbnNmb3JtIiwiZmlsbFN0cm9rZU1vZGUiLCJpc0FkZFRvUGF0aFNldCIsInN0cm9rZVRleHQiLCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCIsImdseXBocyIsInNob3dUeXBlM1RleHQiLCJnbHlwaHNMZW5ndGgiLCJ2ZXJ0aWNhbCIsInNwYWNpbmdEaXIiLCJkZWZhdWx0Vk1ldHJpY3MiLCJ3aWR0aEFkdmFuY2VTY2FsZSIsInNpbXBsZUZpbGxUZXh0IiwicGF0dGVybiIsImdldFNpbmdsZVBpeGVsV2lkdGgiLCJpc0ludmFsaWRQREZqc0ZvbnQiLCJjaGFycyIsImdseXBoIiwidW5pY29kZSIsInJlc3RvcmVOZWVkZWQiLCJpc1NwYWNlIiwiZm9udENoYXIiLCJhY2NlbnQiLCJzY2FsZWRYIiwic2NhbGVkWSIsInZtZXRyaWMiLCJ2eCIsInZ5IiwicmVtZWFzdXJlIiwibWVhc3VyZWRXaWR0aCIsIm1lYXN1cmVUZXh0IiwiY2hhcmFjdGVyU2NhbGVYIiwiaXNJbkZvbnQiLCJzY2FsZWRBY2NlbnRYIiwic2NhbGVkQWNjZW50WSIsImNoYXJXaWR0aCIsImlzVGV4dEludmlzaWJsZSIsInNwYWNpbmdMZW5ndGgiLCJjaGFyUHJvY09wZXJhdG9yTGlzdCIsIm9wZXJhdG9yTGlzdElkIiwidHJhbnNmb3JtZWQiLCJ4V2lkdGgiLCJ5V2lkdGgiLCJsbHgiLCJsbHkiLCJ1cngiLCJ1cnkiLCJnZXRDb2xvck5fUGF0dGVybiIsIklSIiwiY2FudmFzR3JhcGhpY3NGYWN0b3J5IiwiY3JlYXRlQ2FudmFzR3JhcGhpY3MiLCJUaWxpbmdQYXR0ZXJuIiwiX2dldFBhdHRlcm4iLCJhcmd1bWVudHMiLCJtYXRyaXgiLCJnZXRTaGFkaW5nUGF0dGVybiIsIlNIQURJTkciLCJpbnYiLCJiYm94IiwiZ3JvdXAiLCJjdXJyZW50Q3R4IiwiaXNvbGF0ZWQiLCJrbm9ja291dCIsImNhbnZhc0JvdW5kcyIsImdyb3VwQ3R4Iiwic3RhcnRUcmFuc2Zvcm1JbnZlcnNlIiwiY3VycmVudE10eCIsImhhc093bkNhbnZhcyIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiYW5ub3RhdGlvbkNhbnZhcyIsInNhdmVkQ3R4IiwiY29tcGlsZWQiLCJza2V3WCIsInNrZXdZIiwicG9zaXRpb25zIiwidHJhbnMiLCJpbWFnZXMiLCJhcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzIiwiYXBwbHlUcmFuc2Zlck1hcHNUb0JpdG1hcCIsImltZ1RvUGFpbnQiLCJIVE1MRWxlbWVudCIsInRhZyIsInZpc2libGUiLCJpc1Zpc2libGUiLCJpc0NvbnRlbnRWaXNpYmxlIiwiYWJzRGV0Iiwibm9ybVgiLCJub3JtWSIsImdldFNjYWxlRm9yU3Ryb2tpbmciLCJzY2FsZWRMaW5lV2lkdGgiLCJzY2FsZWRYTGluZVdpZHRoIiwic2NhbGVkWUxpbmVXaWR0aCIsImJhc2VBcmVhIiwic2F2ZVJlc3RvcmUiLCJkYXNoZXMiLCJvcCIsImFwcGx5Qm91bmRpbmdCb3giLCJyZWdpb24iLCJCYXNlU2hhZGluZ1BhdHRlcm4iLCJSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuIiwiX2Jib3giLCJfY29sb3JTdG9wcyIsIl9wMCIsIl9wMSIsIl9yMCIsIl9yMSIsIl9jcmVhdGVHcmFkaWVudCIsImdyYWQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImNyZWF0ZVJhZGlhbEdyYWRpZW50IiwiY29sb3JTdG9wIiwiYWRkQ29sb3JTdG9wIiwib3duZXIiLCJvd25lckJCb3giLCJjcmVhdGVQYXR0ZXJuIiwiZG9tTWF0cml4IiwiRE9NTWF0cml4IiwiZHJhd1RyaWFuZ2xlIiwiYzEiLCJjMiIsImMzIiwiY29vcmRzIiwicm93U2l6ZSIsInRtcCIsImMxciIsImMxZyIsImMxYiIsImMyciIsImMyZyIsImMyYiIsImMzciIsImMzZyIsImMzYiIsInhhIiwiY2FyIiwiY2FnIiwiY2FiIiwieGIiLCJjYnIiLCJjYmciLCJjYmIiLCJ4MV8iLCJ4Ml8iLCJkcmF3RmlndXJlIiwiZmlndXJlIiwicHMiLCJjcyIsInZlcnRpY2VzUGVyUm93Iiwicm93cyIsImNvbHMiLCJxIiwiTWVzaFNoYWRpbmdQYXR0ZXJuIiwiX2Nvb3JkcyIsIl9maWd1cmVzIiwiX2JvdW5kcyIsIl9iYWNrZ3JvdW5kIiwiX2NyZWF0ZU1lc2hDYW52YXMiLCJjb21iaW5lZFNjYWxlIiwiYmFja2dyb3VuZENvbG9yIiwiRVhQRUNURURfU0NBTEUiLCJNQVhfUEFUVEVSTl9TSVpFIiwiQk9SREVSX1NJWkUiLCJib3VuZHNXaWR0aCIsImJvdW5kc0hlaWdodCIsInBhZGRlZFdpZHRoIiwicGFkZGVkSGVpZ2h0IiwibWF0cml4U2NhbGUiLCJ0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzIiwiRHVtbXlTaGFkaW5nUGF0dGVybiIsIlBhaW50VHlwZSIsIkNPTE9SRUQiLCJVTkNPTE9SRUQiLCJ4c3RlcCIsInlzdGVwIiwicGFpbnRUeXBlIiwidGlsaW5nVHlwZSIsImNyZWF0ZVBhdHRlcm5DYW52YXMiLCJjdXJNYXRyaXhTY2FsZSIsImRpbXgiLCJnZXRTaXplQW5kU2NhbGUiLCJkaW15IiwiZ3JhcGhpY3MiLCJzZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQiLCJhZGp1c3RlZFgwIiwiYWRqdXN0ZWRZMCIsImFkanVzdGVkWDEiLCJhZGp1c3RlZFkxIiwiY2xpcEJib3giLCJyZWFsT3V0cHV0U2l6ZSIsImJib3hXaWR0aCIsImJib3hIZWlnaHQiLCJjc3NDb2xvciIsImNvbnZlcnRUb1JHQkEiLCJncmF5VG9SR0JBIiwiY29udmVydFJHQlRvUkdCQSIsImludmVyc2VEZWNvZGUiLCJ6ZXJvTWFwcGluZyIsIm9uZU1hcHBpbmciLCJ3aWR0aEluU291cmNlIiwid2lkdGhSZW1haW5kZXIiLCJsZW4zMiIsInNyYzMyIiwiczEiLCJzMiIsInMzIiwiamoiLCJDYWxsYmFja0tpbmQiLCJVTktOT1dOIiwiREFUQSIsIkVSUk9SIiwiU3RyZWFtS2luZCIsIkNBTkNFTCIsIkNBTkNFTF9DT01QTEVURSIsIkNMT1NFIiwiRU5RVUVVRSIsIlBVTEwiLCJQVUxMX0NPTVBMRVRFIiwiU1RBUlRfQ09NUExFVEUiLCJ3cmFwUmVhc29uIiwic291cmNlTmFtZSIsInRhcmdldE5hbWUiLCJjb21PYmoiLCJjYWxsYmFja0lkIiwic3RyZWFtSWQiLCJzdHJlYW1TaW5rcyIsInN0cmVhbUNvbnRyb2xsZXJzIiwiY2FsbGJhY2tDYXBhYmlsaXRpZXMiLCJhY3Rpb25IYW5kbGVyIiwiX29uQ29tT2JqT25NZXNzYWdlIiwic3RyZWFtIiwicHJvY2Vzc1N0cmVhbU1lc3NhZ2UiLCJjYlNvdXJjZU5hbWUiLCJjYlRhcmdldE5hbWUiLCJjcmVhdGVTdHJlYW1TaW5rIiwiYWN0aW9uTmFtZSIsImhhbmRsZXIiLCJhaCIsInF1ZXVlaW5nU3RyYXRlZ3kiLCJSZWFkYWJsZVN0cmVhbSIsImNvbnRyb2xsZXIiLCJzdGFydENhcGFiaWxpdHkiLCJzdGFydENhbGwiLCJwdWxsQ2FsbCIsImNhbmNlbENhbGwiLCJpc0Nsb3NlZCIsImRlc2lyZWRTaXplIiwicHVsbCIsInB1bGxDYXBhYmlsaXR5IiwiY2FuY2VsQ2FwYWJpbGl0eSIsInN0cmVhbVNpbmsiLCJpc0NhbmNlbGxlZCIsImxhc3REZXNpcmVkU2l6ZSIsInNpbmtDYXBhYmlsaXR5Iiwic3RyZWFtQ29udHJvbGxlciIsImRlbGV0ZVN0cmVhbUNvbnRyb2xsZXIiLCJhbGxTZXR0bGVkIiwibWV0YWRhdGFNYXAiLCJwYXJzZWREYXRhIiwiZ2V0UmF3IiwiSU5URVJOQUwiLCJTeW1ib2wiLCJPcHRpb25hbENvbnRlbnRHcm91cCIsIl9zZXRWaXNpYmxlIiwiaW50ZXJuYWwiLCJjYWNoZWRHZXRIYXNoIiwiZ3JvdXBzIiwiaW5pdGlhbEhhc2giLCJvcmRlciIsImNyZWF0b3IiLCJiYXNlU3RhdGUiLCJvZmYiLCJnZXRIYXNoIiwiZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbiIsImFycmF5Iiwib3BlcmF0b3IiLCJzdGF0ZSIsImV4cHJlc3Npb24iLCJwb2xpY3kiLCJpZHMiLCJzZXRWaXNpYmlsaXR5IiwiaGFzSW5pdGlhbFZpc2liaWxpdHkiLCJnZXRPcmRlciIsImdldEdyb3VwcyIsImdldEdyb3VwIiwicGRmRGF0YVJhbmdlVHJhbnNwb3J0IiwiX3F1ZXVlZENodW5rcyIsIl9wcm9ncmVzc2l2ZURvbmUiLCJfY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUiLCJfcGRmRGF0YVJhbmdlVHJhbnNwb3J0IiwiX2lzU3RyZWFtaW5nU3VwcG9ydGVkIiwiX2lzUmFuZ2VTdXBwb3J0ZWQiLCJfY29udGVudExlbmd0aCIsIl9mdWxsUmVxdWVzdFJlYWRlciIsIl9yYW5nZVJlYWRlcnMiLCJfb25SZWNlaXZlRGF0YSIsIl9vblByb2dyZXNzIiwiX29uUHJvZ3Jlc3NpdmVEb25lIiwiX2VucXVldWUiLCJmb3VuZCIsIl9iZWdpbiIsIl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgiLCJfbG9hZGVkIiwiX3JlbW92ZVJhbmdlUmVhZGVyIiwiaW5kZXhPZiIsInF1ZXVlZENodW5rcyIsIlBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIiLCJQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIiLCJfc3RyZWFtIiwiX2RvbmUiLCJfZmlsZW5hbWUiLCJfcmVxdWVzdHMiLCJfaGVhZGVyc1JlYWR5IiwicmVxdWVzdENhcGFiaWxpdHkiLCJfZW5kIiwiX3F1ZXVlZENodW5rIiwicmVxdWVzdHNDYXBhYmlsaXR5IiwiX25ldHdvcmtfdXRpbHMiLCJjcmVhdGVGZXRjaE9wdGlvbnMiLCJoZWFkZXJzIiwiYWJvcnRDb250cm9sbGVyIiwibWV0aG9kIiwic2lnbmFsIiwiY3JlZGVudGlhbHMiLCJyZWRpcmVjdCIsImNyZWF0ZUhlYWRlcnMiLCJIZWFkZXJzIiwiZ2V0QXJyYXlCdWZmZXIiLCJpc0h0dHAiLCJfcmFuZ2VSZXF1ZXN0UmVhZGVycyIsIlBERkZldGNoU3RyZWFtUmVhZGVyIiwiUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciIsIl9yZWFkZXIiLCJfd2l0aENyZWRlbnRpYWxzIiwiX2hlYWRlcnNDYXBhYmlsaXR5IiwiX2Rpc2FibGVSYW5nZSIsIl9yYW5nZUNodW5rU2l6ZSIsIl9hYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJfaGVhZGVycyIsInZhbGlkYXRlUmVzcG9uc2VTdGF0dXMiLCJjcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJhbGxvd1JhbmdlUmVxdWVzdHMiLCJzdWdnZXN0ZWRMZW5ndGgiLCJ2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyIsImV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIiLCJfcmVhZENhcGFiaWxpdHkiLCJfY29udGVudF9kaXNwb3NpdGlvbiIsInJldHVyblZhbHVlcyIsImNvbnRlbnRFbmNvZGluZyIsImNvbnRlbnREaXNwb3NpdGlvbiIsImdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlciIsIm5lZWRzRW5jb2RpbmdGaXh1cCIsInRvUGFyYW1SZWdFeHAiLCJyZmMyNjE2dW5xdW90ZSIsInJmYzU5ODdkZWNvZGUiLCJyZmMyMDQ3ZGVjb2RlIiwiZml4dXBFbmNvZGluZyIsInJmYzIyMzFnZXRwYXJhbSIsImF0dHJpYnV0ZVBhdHRlcm4iLCJmbGFncyIsInRleHRkZWNvZGUiLCJjb250ZW50RGlzcG9zaXRpb25TdHIiLCJpdGVyIiwicXVvdCIsInBhcnQiLCJwYXJ0cyIsInF1b3RpbmRleCIsImV4dHZhbHVlIiwiZW5jb2RpbmdlbmQiLCJsYW5ndmFsdWUiLCJjaGFyc2V0IiwiaGV4IiwiT0tfUkVTUE9OU0UiLCJQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UiLCJ4aHIiLCJOZXR3b3JrTWFuYWdlciIsImN1cnJYaHJJZCIsInBlbmRpbmdSZXF1ZXN0cyIsInJlcXVlc3RSYW5nZSIsInJlcXVlc3RGdWxsIiwieGhySWQiLCJwZW5kaW5nUmVxdWVzdCIsInNldFJlcXVlc3RIZWFkZXIiLCJleHBlY3RlZFN0YXR1cyIsIm9uRXJyb3IiLCJvblN0YXRlQ2hhbmdlIiwib25wcm9ncmVzcyIsIm9uSGVhZGVyc1JlY2VpdmVkIiwib25Eb25lIiwieGhyU3RhdHVzIiwib2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCIsInJhbmdlSGVhZGVyIiwiZ2V0UmVxdWVzdFhociIsImlzUGVuZGluZ1JlcXVlc3QiLCJhYm9ydFJlcXVlc3QiLCJfc291cmNlIiwiX21hbmFnZXIiLCJfb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQiLCJQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIiLCJQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyIiwib25DbG9zZWQiLCJtYW5hZ2VyIiwiX29uSGVhZGVyc1JlY2VpdmVkIiwiX29uRG9uZSIsIl9vbkVycm9yIiwiX3VybCIsIl9mdWxsUmVxdWVzdElkIiwiX2hlYWRlcnNSZWNlaXZlZENhcGFiaWxpdHkiLCJfY2FjaGVkQ2h1bmtzIiwiX3N0b3JlZEVycm9yIiwiZnVsbFJlcXVlc3RYaHJJZCIsImZ1bGxSZXF1ZXN0WGhyIiwibGVuZ3RoQ29tcHV0YWJsZSIsIl9yZXF1ZXN0SWQiLCJfY2xvc2UiLCJmaWxlVXJpUmVnZXgiLCJwYXJzZVVybCIsInNvdXJjZVVybCIsInBhcnNlZFVybCIsImhvc3QiLCJpc0ZzVXJsIiwiUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlciIsIlBERk5vZGVTdHJlYW1GdWxsUmVhZGVyIiwiUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIiLCJQREZOb2RlU3RyZWFtUmFuZ2VSZWFkZXIiLCJCYXNlRnVsbFJlYWRlciIsIl9yZWFkYWJsZVN0cmVhbSIsIl9lcnJvciIsIl9zZXRSZWFkYWJsZVN0cmVhbSIsIkJhc2VSYW5nZVJlYWRlciIsImNyZWF0ZVJlcXVlc3RPcHRpb25zIiwiYXV0aCIsImhvc3RuYW1lIiwiaGFuZGxlUmVzcG9uc2UiLCJzdGF0dXNDb2RlIiwiX3JlcXVlc3QiLCJodHRwIiwiaHR0cHMiLCJfaHR0cEhlYWRlcnMiLCJSYW5nZSIsImxzdGF0Iiwic3RhdCIsImNyZWF0ZVJlYWRTdHJlYW0iLCJTVkdfREVGQVVMVFMiLCJmb250U3R5bGUiLCJYTUxfTlMiLCJYTElOS19OUyIsImNvbnRlbnRUeXBlIiwiZm9yY2VEYXRhU2NoZW1hIiwiZGlnaXRzIiwiYjEiLCJiMiIsImIzIiwiZDEiLCJkMiIsImQzIiwiZDQiLCJjb252ZXJ0SW1nRGF0YVRvUG5nIiwiUE5HX0hFQURFUiIsIkNIVU5LX1dSQVBQRVJfU0laRSIsImNyY1RhYmxlIiwiY3JjMzIiLCJjcmMiLCJ3cml0ZVBuZ0NodW5rIiwibGVuIiwiYWRsZXIzMiIsImRlZmxhdGVTeW5jIiwibGl0ZXJhbHMiLCJkZWZsYXRlU3luY1VuY29tcHJlc3NlZCIsIm5vZGUiLCJmcm9tIiwib3V0cHV0IiwibWF4QmxvY2tMZW5ndGgiLCJkZWZsYXRlQmxvY2tzIiwiaWRhdCIsInBpIiwiYWRsZXIiLCJlbmNvZGUiLCJpc01hc2siLCJiaXREZXB0aCIsImNvbG9yVHlwZSIsIm9mZnNldExpdGVyYWxzIiwib2Zmc2V0Qnl0ZXMiLCJpaGRyIiwicG5nTGVuZ3RoIiwiU1ZHRXh0cmFTdGF0ZSIsImRlcGVuZGVuY2llcyIsImFjdGl2ZUNsaXBVcmwiLCJjbGlwR3JvdXAiLCJtYXNrSWQiLCJvcExpc3RUb1RyZWUiLCJvcExpc3QiLCJvcFRyZWUiLCJvcExpc3RFbGVtZW50IiwiZm4iLCJwZiIsInBtIiwiYWNvcyIsImNsaXBDb3VudCIsIm1hc2tDb3VudCIsInNoYWRpbmdDb3VudCIsInN2Z0ZhY3RvcnkiLCJ0cmFuc2Zvcm1NYXRyaXgiLCJ0cmFuc2Zvcm1TdGFjayIsImV4dHJhU3RhY2siLCJlbWJlZEZvbnRzIiwiZW1iZWRkZWRGb250cyIsImNzc1N0eWxlIiwiX29wZXJhdG9ySWRNYXBwaW5nIiwidGdycCIsImV4ZWN1dGVPcFRyZWUiLCJsb2FkRGVwZW5kZW5jaWVzIiwiZ2V0U1ZHIiwic3ZnRWxlbWVudCIsImNvbnZlcnRPcExpc3QiLCJvcGVyYXRvcklkTWFwcGluZyIsIm9wVHJlZUVsZW1lbnQiLCJsaW5lTWF0cml4IiwieGNvb3JkcyIsInljb29yZHMiLCJ0c3BhbiIsInNldEF0dHJpYnV0ZU5TIiwidHh0RWxlbWVudCIsInR4dGdycCIsImxpbmVXaWR0aFNjYWxlIiwiX3NldFN0cm9rZUF0dHJpYnV0ZXMiLCJfZW5zdXJlVHJhbnNmb3JtR3JvdXAiLCJhZGRGb250U3R5bGUiLCJoYXNDaGlsZE5vZGVzIiwic2V0U3Ryb2tlQWxwaGEiLCJzZXRGaWxsQWxwaGEiLCJfbWFrZUNvbG9yTl9QYXR0ZXJuIiwiX21ha2VTaGFkaW5nUGF0dGVybiIsIl9tYWtlVGlsaW5nUGF0dGVybiIsInRpbGluZ0lkIiwidHgwIiwidHkwIiwidHgxIiwidHkxIiwieHNjYWxlIiwieXNjYWxlIiwidHhzdGVwIiwidHlzdGVwIiwidGlsaW5nIiwiY2hpbGROb2RlcyIsInNoYWRpbmdJZCIsImNvbG9yU3RvcHMiLCJncmFkaWVudCIsInBvaW50MCIsInBvaW50MSIsImZvY2FsUG9pbnQiLCJjaXJjbGVQb2ludCIsImZvY2FsUmFkaXVzIiwiY2lyY2xlUmFkaXVzIiwic3RvcCIsImdldEF0dHJpYnV0ZU5TIiwiY2xpcElkIiwiY2xpcFBhdGgiLCJjbGlwRWxlbWVudCIsImNsb25lTm9kZSIsImltZ1NyYyIsImNsaXByZWN0IiwiaW1nRWwiLCJkZWZpbml0aW9ucyIsInJvb3RHcm91cCIsIl9lbnN1cmVDbGlwR3JvdXAiLCJ3YWxrIiwic2hvdWxkQnVpbGRUZXh0IiwiY2hpbGQiLCJUZXh0TGF5ZXJSZW5kZXJUYXNrIiwicmVuZGVyVGV4dExheWVyIiwidXBkYXRlVGV4dExheWVyIiwiTUFYX1RFWFRfRElWU19UT19SRU5ERVIiLCJERUZBVUxUX0ZPTlRfU0laRSIsIkRFRkFVTFRfRk9OVF9BU0NFTlQiLCJhc2NlbnRDYWNoZSIsImdldEN0eCIsImdldEFzY2VudCIsImNhY2hlZEFzY2VudCIsIm1ldHJpY3MiLCJhc2NlbnQiLCJmb250Qm91bmRpbmdCb3hBc2NlbnQiLCJkZXNjZW50IiwiZm9udEJvdW5kaW5nQm94RGVzY2VudCIsInJhdGlvIiwicGl4ZWxzIiwiYXBwZW5kVGV4dCIsImdlb20iLCJ0ZXh0RGl2IiwidGV4dERpdlByb3BlcnRpZXMiLCJoYXNUZXh0IiwiaGFzRU9MIiwiX3RleHREaXZzIiwiX3RyYW5zZm9ybSIsImF0YW4yIiwiZm9udE5hbWUiLCJmb250SGVpZ2h0IiwiZm9udEFzY2VudCIsIl9pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCIsInNpbiIsImNvcyIsInNjYWxlRmFjdG9yU3RyIiwiZGl2U3R5bGUiLCJfY29udGFpbmVyIiwiX3Jvb3RDb250YWluZXIiLCJfcGFnZVdpZHRoIiwiX3BhZ2VIZWlnaHQiLCJkaXIiLCJfZm9udEluc3BlY3RvckVuYWJsZWQiLCJkYXRhc2V0Iiwic2hvdWxkU2NhbGVUZXh0IiwiYWJzU2NhbGVYIiwiYWJzU2NhbGVZIiwiX3RleHREaXZQcm9wZXJ0aWVzIiwiX2lzUmVhZGFibGVTdHJlYW0iLCJfbGF5b3V0VGV4dCIsImxheW91dCIsInByZXZGb250U2l6ZSIsInByZXZGb250RmFtaWx5IiwiX2NhbmNlbGVkIiwidGV4dERpdnMiLCJ0ZXh0RGl2c0xlbmd0aCIsInRleHRDb250ZW50U291cmNlIiwidGV4dENvbnRlbnRJdGVtc1N0ciIsIl90ZXh0Q29udGVudFNvdXJjZSIsIl90ZXh0Q29udGVudEl0ZW1zU3RyIiwiX2xheW91dFRleHRQYXJhbXMiLCJfcHJvY2Vzc0l0ZW1zIiwic3R5bGVDYWNoZSIsImJyIiwiX3JlbmRlciIsInRleHRDb250ZW50U3RyZWFtIiwic2NhbGVGYWN0b3IiLCJtdXN0UmVzY2FsZSIsIkFubm90YXRpb25FZGl0b3JMYXllciIsIl9mcmVldGV4dCIsIl9pbmsiLCJfc3RhbXAiLCJhY2Nlc3NpYmlsaXR5TWFuYWdlciIsImFsbG93Q2xpY2siLCJhbm5vdGF0aW9uTGF5ZXIiLCJib3VuZFBvaW50ZXJ1cCIsImJvdW5kUG9pbnRlcmRvd24iLCJoYWRQb2ludGVyRG93biIsImlzQ2xlYW5pbmdVcCIsImlzRGlzYWJsaW5nIiwiX2luaXRpYWxpemVkIiwicG9pbnRlcnVwIiwiRnJlZVRleHRFZGl0b3IiLCJJbmtFZGl0b3IiLCJTdGFtcEVkaXRvciIsImFkZElua0VkaXRvcklmTmVlZGVkIiwiaXNDb21taXR0aW5nIiwiY3JlYXRlQW5kQWRkTmV3RWRpdG9yIiwicG9pbnRlckV2ZW50cyIsImFubm90YXRpb25FbGVtZW50SWRzIiwiZWRpdGFibGVzIiwiZ2V0RWRpdGFibGVBbm5vdGF0aW9ucyIsImVkaXRhYmxlIiwiaGlkZSIsImhpZGRlbkFubm90YXRpb25JZHMiLCJnZXRFZGl0YWJsZUFubm90YXRpb24iLCJzaG93IiwiY3VycmVudEFjdGl2ZSIsImF0dGFjaCIsImRldGFjaCIsInJlbW92ZVBvaW50ZXJJblRleHRMYXllciIsIm1vdmVFbGVtZW50SW5ET00iLCJhZGRVbmRvYWJsZUVkaXRvciIsImNyZWF0ZU5ld0VkaXRvciIsInBhc3RlRWRpdG9yIiwiZ2V0Q2VudGVyUG9pbnQiLCJhbm5vdGF0aW9uVHlwZSIsImFubm90YXRpb25FZGl0b3JUeXBlIiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiX2Fubm90YXRpb25fbGF5ZXIiLCJib3VuZEVkaXRvckRpdkJsdXIiLCJib3VuZEVkaXRvckRpdkZvY3VzIiwiYm91bmRFZGl0b3JEaXZJbnB1dCIsImJvdW5kRWRpdG9yRGl2S2V5ZG93biIsImNvbnRlbnQiLCJlZGl0b3JEaXZJZCIsIl9mcmVlVGV4dERlZmF1bHRDb250ZW50IiwiX2ludGVybmFsUGFkZGluZyIsIl9kZWZhdWx0Q29sb3IiLCJfZGVmYXVsdEZvbnRTaXplIiwiX3RyYW5zbGF0ZUVtcHR5IiwiZWRpdG9yRGl2Qmx1ciIsImVkaXRvckRpdkZvY3VzIiwiZWRpdG9yRGl2SW5wdXQiLCJlZGl0b3JEaXZLZXlkb3duIiwidXBkYXRlRm9udFNpemUiLCJ1cGRhdGVDb2xvciIsInNldEZvbnRzaXplIiwiZWRpdG9yRGl2Iiwic2V0RWRpdG9yRGltZW5zaW9ucyIsInNhdmVkRm9udHNpemUiLCJzYXZlZENvbG9yIiwib3ZlcmxheURpdiIsImNvbnRlbnRFZGl0YWJsZSIsInJlbW92ZUF0dHJpYnV0ZSIsInByZXZlbnRTY3JvbGwiLCJjaGVhdEluaXRpYWxSZWN0IiwiZXh0cmFjdFRleHQiLCJkaXZzIiwic2F2ZWREaXNwbGF5IiwiZGlzcGxheSIsInNhdmVkVGV4dCIsIm5ld1RleHQiLCJ0cmltRW5kIiwic2V0VGV4dCIsInNldENvbnRlbnQiLCJkYmxjbGljayIsImJhc2VYIiwiYmFzZVkiLCJwb3NYIiwicG9zWSIsInJlcGxhY2VDaGlsZHJlbiIsImxpbmUiLCJjcmVhdGVUZXh0Tm9kZSIsIkZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQiLCJkZWZhdWx0QXBwZWFyYW5jZURhdGEiLCJmb250Q29sb3IiLCJ0ZXh0UG9zaXRpb24iLCJwYWRkaW5nIiwic3RydWN0VHJlZVBhcmVudElkIiwiaGFzRWxlbWVudENoYW5nZWQiLCJTdGFtcEFubm90YXRpb25FbGVtZW50IiwiSW5rQW5ub3RhdGlvbkVsZW1lbnQiLCJBbm5vdGF0aW9uTGF5ZXIiLCJfc2NyaXB0aW5nX3V0aWxzIiwiX2Rpc3BsYXlMMTBuX3V0aWxzIiwiX3hmYV9sYXllciIsIkRFRkFVTFRfVEFCX0lOREVYIiwiR2V0RWxlbWVudHNCeU5hbWVTZXQiLCJnZXRSZWN0RGltcyIsIkFubm90YXRpb25FbGVtZW50RmFjdG9yeSIsIkxpbmtBbm5vdGF0aW9uRWxlbWVudCIsIlRleHRBbm5vdGF0aW9uRWxlbWVudCIsImZpZWxkVHlwZSIsIlRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsInJhZGlvQnV0dG9uIiwiUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsImNoZWNrQm94IiwiQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIlB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIkNob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50IiwiU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIlBvcHVwQW5ub3RhdGlvbkVsZW1lbnQiLCJMaW5lQW5ub3RhdGlvbkVsZW1lbnQiLCJTcXVhcmVBbm5vdGF0aW9uRWxlbWVudCIsIkNpcmNsZUFubm90YXRpb25FbGVtZW50IiwiUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudCIsIkNhcmV0QW5ub3RhdGlvbkVsZW1lbnQiLCJQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQiLCJIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCIsIlVuZGVybGluZUFubm90YXRpb25FbGVtZW50IiwiU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudCIsIlN0cmlrZU91dEFubm90YXRpb25FbGVtZW50IiwiRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudCIsIkFubm90YXRpb25FbGVtZW50IiwiaGFzQm9yZGVyIiwiaXNSZW5kZXJhYmxlIiwiaWdub3JlQm9yZGVyIiwiY3JlYXRlUXVhZHJpbGF0ZXJhbHMiLCJsaW5rU2VydmljZSIsImRvd25sb2FkTWFuYWdlciIsImltYWdlUmVzb3VyY2VzUGF0aCIsInJlbmRlckZvcm1zIiwiZW5hYmxlU2NyaXB0aW5nIiwiX2ZpZWxkT2JqZWN0cyIsImZpZWxkT2JqZWN0cyIsIl9jcmVhdGVDb250YWluZXIiLCJfY3JlYXRlUXVhZHJpbGF0ZXJhbHMiLCJfaGFzUG9wdXBEYXRhIiwidGl0bGVPYmoiLCJjb250ZW50c09iaiIsInJpY2hUZXh0IiwiaGFzUG9wdXBEYXRhIiwicG9wdXBSZWYiLCJub1JvdGF0ZSIsInNldFJvdGF0aW9uIiwiYm9yZGVyU3R5bGUiLCJib3JkZXJXaWR0aCIsImhvcml6b250YWxSYWRpdXMiLCJob3Jpem9udGFsQ29ybmVyUmFkaXVzIiwidmVydGljYWxSYWRpdXMiLCJ2ZXJ0aWNhbENvcm5lclJhZGl1cyIsInJhZGl1cyIsImJvcmRlclJhZGl1cyIsImJvcmRlckJvdHRvbVN0eWxlIiwiYm9yZGVyQ29sb3IiLCJlbGVtZW50V2lkdGgiLCJlbGVtZW50SGVpZ2h0IiwiX2NvbW1vbkFjdGlvbnMiLCJzZXRDb2xvciIsImpzTmFtZSIsInN0eWxlTmFtZSIsImRldGFpbCIsImNvbG9yQXJyYXkiLCJDb2xvckNvbnZlcnRlcnMiLCJub1ZpZXciLCJub1ByaW50IiwidXNlck5hbWUiLCJ0aXRsZSIsInJlYWRvbmx5IiwiZGlzYWJsZWQiLCJyZXF1aXJlZCIsIl9zZXRSZXF1aXJlZCIsInRleHRDb2xvciIsIl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3giLCJhY3Rpb25zIiwianNFdmVudCIsImNvbW1vbkFjdGlvbnMiLCJfc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMiLCJzdG9yZWREYXRhIiwiZXZlbnRQcm94eSIsInF1YWRQb2ludHMiLCJyZWN0QmxYIiwicmVjdEJsWSIsInJlY3RUclgiLCJyZWN0VHJZIiwidHJYIiwidHJZIiwiYmxYIiwiYmxZIiwic3ZnQnVmZmVyIiwicmVjdFdpZHRoIiwicmVjdEhlaWdodCIsImJhY2tncm91bmRJbWFnZSIsIl9jcmVhdGVQb3B1cCIsInBvcHVwIiwibW9kaWZpY2F0aW9uRGF0ZSIsInBhcmVudFJlY3QiLCJlbGVtZW50cyIsIl9nZXRFbGVtZW50c0J5TmFtZSIsInNraXBJZCIsImZpZWxkcyIsImZpZWxkT2JqIiwiZXhwb3J0VmFsdWVzIiwiZXhwb3J0VmFsdWUiLCJkb21FbGVtZW50IiwicXVlcnlTZWxlY3RvciIsImdldEVsZW1lbnRzQnlOYW1lIiwiZ2V0QXR0cmlidXRlIiwibWF5YmVTaG93IiwiZm9yY2VIaWRlIiwiZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCIsImFkZEhpZ2hsaWdodEFyZWEiLCJ0cmlnZ2VycyIsIl9lZGl0T25Eb3VibGVDbGljayIsImlzVG9vbHRpcE9ubHkiLCJsaW5rIiwiaXNCb3VuZCIsImFkZExpbmtBdHRyaWJ1dGVzIiwibmV3V2luZG93IiwiX2JpbmROYW1lZEFjdGlvbiIsImF0dGFjaG1lbnQiLCJfYmluZEF0dGFjaG1lbnQiLCJzZXRPQ0dTdGF0ZSIsImJpbmRTZXRPQ0dTdGF0ZSIsIl9iaW5kTGluayIsIkFjdGlvbiIsIl9iaW5kSlNBY3Rpb24iLCJyZXNldEZvcm0iLCJfYmluZFJlc2V0Rm9ybUFjdGlvbiIsInNldEludGVybmFsTGluayIsImRlc3RpbmF0aW9uIiwiZ2V0RGVzdGluYXRpb25IYXNoIiwib25jbGljayIsImdvVG9EZXN0aW5hdGlvbiIsImdldEFuY2hvclVybCIsImV4ZWN1dGVOYW1lZEFjdGlvbiIsIm9wZW5PckRvd25sb2FkRGF0YSIsImV4ZWN1dGVTZXRPQ0dTdGF0ZSIsIm90aGVyQ2xpY2tBY3Rpb24iLCJyZXNldEZvcm1GaWVsZHMiLCJyZWZzIiwicmVzZXRGb3JtUmVmcyIsImluY2x1ZGUiLCJhbGxGaWVsZHMiLCJmaWVsZElkcyIsImZpZWxkTmFtZSIsImZpZWxkIiwiYWxsSWRzIiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50IiwiYWx0IiwibDEwbklkIiwibDEwbkFyZ3MiLCJhbHRlcm5hdGl2ZVRleHQiLCJzaG93RWxlbWVudEFuZEhpZGVDYW52YXMiLCJwcmV2aW91c1NpYmxpbmciLCJub2RlTmFtZSIsIl9nZXRLZXlNb2RpZmllciIsIl9zZXRFdmVudExpc3RlbmVyIiwiZWxlbWVudERhdGEiLCJiYXNlTmFtZSIsImV2ZW50TmFtZSIsInZhbHVlR2V0dGVyIiwibW9kaWZpZXIiLCJmb2N1c2VkIiwiX3NldEV2ZW50TGlzdGVuZXJzIiwiZ2V0dGVyIiwiQmx1ciIsIkZvY3VzIiwiX3NldEJhY2tncm91bmRDb2xvciIsIl9zZXRUZXh0U3R5bGUiLCJURVhUX0FMSUdOTUVOVCIsImNvbXB1dGVkRm9udFNpemUiLCJyb3VuZFRvT25lRGVjaW1hbCIsIm11bHRpTGluZSIsIm51bWJlck9mTGluZXMiLCJsaW5lSGVpZ2h0IiwidGV4dEFsaWdubWVudCIsInRleHRBbGlnbiIsImlzUmVxdWlyZWQiLCJoYXNBcHBlYXJhbmNlIiwiZmllbGRWYWx1ZSIsInNldFByb3BlcnR5T25TaWJsaW5ncyIsImtleUluU3RvcmFnZSIsIm1heExlbiIsImNoYXJMaW1pdCIsImZpZWxkRm9ybWF0dGVkVmFsdWVzIiwiZm9ybWF0dGVkVmFsdWUiLCJjb21iIiwidXNlclZhbHVlIiwibGFzdENvbW1pdHRlZFZhbHVlIiwiY29tbWl0S2V5IiwiZG9Ob3RTY3JvbGwiLCJvdmVyZmxvd1kiLCJvdmVyZmxvd1giLCJyZWFkT25seSIsIm1heExlbmd0aCIsImRlZmF1bHRGaWVsZFZhbHVlIiwiYmx1ckxpc3RlbmVyIiwic2Nyb2xsTGVmdCIsInNlbFJhbmdlIiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJ3aWxsQ29tbWl0Iiwic2VsU3RhcnQiLCJzZWxlY3Rpb25TdGFydCIsInNlbEVuZCIsInNlbGVjdGlvbkVuZCIsIl9ibHVyTGlzdGVuZXIiLCJLZXlzdHJva2UiLCJpbnB1dFR5cGUiLCJjaGFuZ2UiLCJmaWVsZFdpZHRoIiwiY29tYldpZHRoIiwibGV0dGVyU3BhY2luZyIsInZlcnRpY2FsQWxpZ24iLCJjaGVja2VkIiwiY2hlY2tib3giLCJjdXJDaGVja2VkIiwiYnV0dG9uVmFsdWUiLCJyYWRpbyIsInBkZkJ1dHRvblZhbHVlIiwibGlua0VsZW1lbnQiLCJsYXN0Q2hpbGQiLCJzZWxlY3RFbGVtZW50IiwiYWRkQW5FbXB0eUVudHJ5IiwiY29tYm8iLCJtdWx0aVNlbGVjdCIsIm11bHRpcGxlIiwib3B0aW9uIiwic2VsZWN0ZWQiLCJvcHRpb25FbGVtZW50IiwiZGlzcGxheVZhbHVlIiwicmVtb3ZlRW1wdHlFbnRyeSIsIm5vbmVPcHRpb25FbGVtZW50IiwiaXNFeHBvcnQiLCJzZWxlY3RlZEluZGV4Iiwic2VsZWN0ZWRWYWx1ZXMiLCJnZXRJdGVtcyIsIm11bHRpcGxlU2VsZWN0aW9uIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJzZWxlY3RDaGlsZCIsImJlZm9yZSIsImluZGljZXMiLCJjaGFuZ2VFeCIsImtleURvd24iLCJQb3B1cEVsZW1lbnQiLCJlbGVtZW50SWRzIiwiZGF0ZVRpbWVQcm9taXNlIiwiYm91bmRLZXlEb3duIiwiYm91bmRIaWRlIiwiYm91bmRTaG93IiwiYm91bmRUb2dnbGUiLCJwaW5uZWQiLCJ3YXNWaXNpYmxlIiwiZGF0ZU9iamVjdCIsInRvTG9jYWxlRGF0ZVN0cmluZyIsInRvTG9jYWxlVGltZVN0cmluZyIsInRyaWdnZXIiLCJmbGF0TWFwIiwiYmFzZUNvbG9yIiwib3V0bGluZUNvbG9yIiwiQkFDS0dST1VORF9FTkxJR0hUIiwiaGVhZGVyIiwibG9jYWxpemVkIiwiWGZhTGF5ZXIiLCJ4ZmFIdG1sIiwiaHRtbCIsImNvbnRlbnRzIiwiX2Zvcm1hdENvbnRlbnRzIiwidXNlUGFyZW50UmVjdCIsIm5vcm1hbGl6ZWRSZWN0IiwiSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OIiwicG9wdXBMZWZ0IiwicG9wdXBUb3AiLCJsaW5lcyIsImxpbmVTcGFuIiwibGluZUNvb3JkaW5hdGVzIiwic3F1YXJlIiwiY2lyY2xlIiwicG9seWxpbmUiLCJjb250YWluZXJDbGFzc05hbWUiLCJzdmdFbGVtZW50TmFtZSIsImNvb3JkaW5hdGUiLCJ2ZXJ0aWNlcyIsInBvbHlsaW5lcyIsImlua0xpc3QiLCJpbmtMaXN0cyIsImRvd25sb2FkIiwiZWRpdGFibGVBbm5vdGF0aW9ucyIsIk51bGxMMTBuIiwiYXBwZW5kRWxlbWVudCIsImNvbnRlbnRFbGVtZW50IiwiZmlyc3RDaGlsZCIsImFubm90YXRpb25zIiwicG9wdXBUb0VsZW1lbnRzIiwiZWxlbWVudFBhcmFtcyIsIm5vSFRNTCIsImlzUG9wdXBBbm5vdGF0aW9uIiwicmVuZGVyZWQiLCJzZXRBbm5vdGF0aW9uQ2FudmFzTWFwIiwicmVwbGFjZVdpdGgiLCJtYWtlQ29sb3JDb21wIiwic2NhbGVBbmRDbGFtcCIsIkNNWUtfRyIsIkdfQ01ZSyIsIkdfUkdCIiwiR19yZ2IiLCJHX0hUTUwiLCJHIiwiUkdCX0ciLCJSR0JfcmdiIiwiUkdCX0hUTUwiLCJUX0hUTUwiLCJUX3JnYiIsIkNNWUtfUkdCIiwiQ01ZS19yZ2IiLCJDTVlLX0hUTUwiLCJjb21wb25lbnRzIiwiUkdCX0NNWUsiLCJnZXRMMTBuRmFsbGJhY2siLCJERUZBVUxUX0wxME5fU1RSSU5HUyIsIm9mX3BhZ2VzIiwicGFnZV9vZl9wYWdlcyIsImRvY3VtZW50X3Byb3BlcnRpZXNfa2IiLCJkb2N1bWVudF9wcm9wZXJ0aWVzX21iIiwiZG9jdW1lbnRfcHJvcGVydGllc19kYXRlX3N0cmluZyIsImRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX3VuaXRfaW5jaGVzIiwiZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfdW5pdF9taWxsaW1ldGVycyIsImRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX29yaWVudGF0aW9uX3BvcnRyYWl0IiwiZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfb3JpZW50YXRpb25fbGFuZHNjYXBlIiwiZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfbmFtZV9hMyIsImRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX25hbWVfYTQiLCJkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9uYW1lX2xldHRlciIsImRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX25hbWVfbGVnYWwiLCJkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9kaW1lbnNpb25fc3RyaW5nIiwiZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfZGltZW5zaW9uX25hbWVfc3RyaW5nIiwiZG9jdW1lbnRfcHJvcGVydGllc19saW5lYXJpemVkX3llcyIsImRvY3VtZW50X3Byb3BlcnRpZXNfbGluZWFyaXplZF9ubyIsImFkZGl0aW9uYWxfbGF5ZXJzIiwicGFnZV9sYW5kbWFyayIsInRodW1iX3BhZ2VfdGl0bGUiLCJ0aHVtYl9wYWdlX2NhbnZhcyIsImZpbmRfcmVhY2hlZF90b3AiLCJmaW5kX3JlYWNoZWRfYm90dG9tIiwiZmluZF9ub3RfZm91bmQiLCJwYWdlX3NjYWxlX3dpZHRoIiwicGFnZV9zY2FsZV9maXQiLCJwYWdlX3NjYWxlX2F1dG8iLCJwYWdlX3NjYWxlX2FjdHVhbCIsInBhZ2Vfc2NhbGVfcGVyY2VudCIsImxvYWRpbmdfZXJyb3IiLCJpbnZhbGlkX2ZpbGVfZXJyb3IiLCJtaXNzaW5nX2ZpbGVfZXJyb3IiLCJ1bmV4cGVjdGVkX3Jlc3BvbnNlX2Vycm9yIiwicmVuZGVyaW5nX2Vycm9yIiwiYW5ub3RhdGlvbl9kYXRlX3N0cmluZyIsInByaW50aW5nX25vdF9zdXBwb3J0ZWQiLCJwcmludGluZ19ub3RfcmVhZHkiLCJ3ZWJfZm9udHNfZGlzYWJsZWQiLCJmcmVlX3RleHQyX2RlZmF1bHRfY29udGVudCIsImVkaXRvcl9mcmVlX3RleHQyX2FyaWFfbGFiZWwiLCJlZGl0b3JfaW5rMl9hcmlhX2xhYmVsIiwiZWRpdG9yX2lua19jYW52YXNfYXJpYV9sYWJlbCIsImVkaXRvcl9hbHRfdGV4dF9idXR0b25fbGFiZWwiLCJlZGl0b3JfYWx0X3RleHRfZWRpdF9idXR0b25fbGFiZWwiLCJlZGl0b3JfYWx0X3RleHRfZGVjb3JhdGl2ZV90b29sdGlwIiwicHJpbnRfcHJvZ3Jlc3NfcGVyY2VudCIsImZvcm1hdEwxMG5WYWx1ZSIsImdldExhbmd1YWdlIiwiZ2V0RGlyZWN0aW9uIiwic2V0dXBTdG9yYWdlIiwieGZhT24iLCJ4ZmFPZmYiLCJzZXRBdHRyaWJ1dGVzIiwiaXNIVE1MQW5jaG9yRWxlbWVudCIsIkhUTUxBbmNob3JFbGVtZW50IiwiZGF0YUlkIiwicm9vdEh0bWwiLCJzdGFjayIsInJvb3REaXYiLCJjaGlsZEh0bWwiLCJ4bWxucyIsImVsIiwicXVlcnlTZWxlY3RvckFsbCIsImJhc2VIZWlnaHQiLCJiYXNlV2lkdGgiLCJib3VuZENhbnZhc1BvaW50ZXJtb3ZlIiwiYm91bmRDYW52YXNQb2ludGVybGVhdmUiLCJib3VuZENhbnZhc1BvaW50ZXJ1cCIsImJvdW5kQ2FudmFzUG9pbnRlcmRvd24iLCJjdXJyZW50UGF0aDJEIiwiaGFzU29tZXRoaW5nVG9EcmF3IiwiaXNDYW52YXNJbml0aWFsaXplZCIsIm9ic2VydmVyIiwicmVhbFdpZHRoIiwicmVhbEhlaWdodCIsInJlcXVlc3RGcmFtZUNhbGxiYWNrIiwiX2RlZmF1bHRPcGFjaXR5IiwiX2RlZmF1bHRUaGlja25lc3MiLCJjYW52YXNQb2ludGVybW92ZSIsImNhbnZhc1BvaW50ZXJsZWF2ZSIsImNhbnZhc1BvaW50ZXJ1cCIsImNhbnZhc1BvaW50ZXJkb3duIiwidGhpY2tuZXNzIiwiYmV6aWVyUGF0aDJEIiwiYWxsUmF3UGF0aHMiLCJjdXJyZW50UGF0aCIsInRyYW5zbGF0aW9uWCIsInRyYW5zbGF0aW9uWSIsInVwZGF0ZVRoaWNrbmVzcyIsInVwZGF0ZU9wYWNpdHkiLCJzYXZlZFRoaWNrbmVzcyIsImZpdFRvQ29udGVudCIsInJlZHJhdyIsInNhdmVkT3BhY2l0eSIsImNyZWF0ZU9ic2VydmVyIiwic2V0Q2FudmFzRGltcyIsImRpc2Nvbm5lY3QiLCJzZXREaW1lbnNpb25zIiwiZ2V0SW5pdGlhbEJCb3giLCJzZXRTdHJva2UiLCJzdGFydERyYXdpbmciLCJkcmF3UG9pbnRzIiwiZHJhdyIsImxhc3RYIiwibGFzdFkiLCJwYXRoMkQiLCJtYWtlQmV6aWVyQ3VydmUiLCJsYXN0UG9pbnQiLCJzdG9wRHJhd2luZyIsImJlemllciIsImdlbmVyYXRlQmV6aWVyUG9pbnRzIiwieHkiLCJsYXN0UG9pbnRzIiwieE1pbiIsInhNYXgiLCJ5TWluIiwieU1heCIsInByZXZYIiwicHJldlkiLCJiZXppZXJQb2ludHMiLCJjb250cm9sMSIsImNvbnRyb2wyIiwidXBkYXRlVHJhbnNmb3JtIiwiUmVzaXplT2JzZXJ2ZXIiLCJjb250ZW50UmVjdCIsIm9ic2VydmUiLCJyb3VuZGVkV2lkdGgiLCJyb3VuZGVkSGVpZ2h0Iiwic2V0U2NhbGVGYWN0b3IiLCJnZXRQYWRkaW5nIiwic2NhbGVGYWN0b3JXIiwic2NhbGVGYWN0b3JIIiwiYnVpbGRQYXRoMkQiLCJ0b1BERkNvb3JkaW5hdGVzIiwiZnJvbVBERkNvb3JkaW5hdGVzIiwic2VyaWFsaXplUGF0aHMiLCJwMTAiLCJwMTEiLCJwMjAiLCJwMjEiLCJwMzAiLCJwMzEiLCJwNDAiLCJwNDEiLCJnZXRCYm94IiwiZmlyc3RUaW1lIiwicHJldlRyYW5zbGF0aW9uWCIsInByZXZUcmFuc2xhdGlvblkiLCJ1bnNjYWxlZFBhZGRpbmciLCJiaXRtYXBJZCIsImJpdG1hcFByb21pc2UiLCJiaXRtYXBVcmwiLCJiaXRtYXBGaWxlIiwicmVzaXplVGltZW91dElkIiwiaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2siLCJzdXBwb3J0ZWRUeXBlcyIsInN1cHBvcnRlZFR5cGVzU3RyIiwiZ2V0QXNGaWxlIiwiZ2V0Qml0bWFwRmV0Y2hlZCIsImZyb21JZCIsImdldEJpdG1hcERvbmUiLCJnZXRCaXRtYXAiLCJhY2NlcHQiLCJmaWxlcyIsImNsaWNrIiwiTUFYX1JBVElPIiwiZmFjdG9yIiwiZHJhd0JpdG1hcCIsInNjYWxlQml0bWFwIiwiYml0bWFwV2lkdGgiLCJiaXRtYXBIZWlnaHQiLCJwcmV2V2lkdGgiLCJwcmV2SGVpZ2h0Iiwib2Zmc2NyZWVuIiwidHJhbnNmZXJUb0ltYWdlQml0bWFwIiwic2VyaWFsaXplQml0bWFwIiwidG9VcmwiLCJ0b0RhdGFVUkwiLCJhY2Nlc3NpYmlsaXR5RGF0YSIsInN0YW1wcyIsImFyZWEiLCJwcmV2RGF0YSIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIm1vZHVsZUlkIiwiY2FjaGVkTW9kdWxlIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsIl9hbm5vdGF0aW9uX2VkaXRvcl9sYXllciIsIl9hcGkiLCJfdGV4dF9sYXllciIsInBkZmpzVmVyc2lvbiIsInBkZmpzQnVpbGQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pdfjs-dist/build/pdf.js\n");

/***/ })

};
;