"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/langsmith";
exports.ids = ["vendor-chunks/langsmith"];
exports.modules = {

/***/ "(rsc)/./node_modules/langsmith/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/langsmith/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* binding */ Client)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/async_caller.js */ \"(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\");\n/* harmony import */ var _utils_messages_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/messages.js */ \"(rsc)/./node_modules/langsmith/dist/utils/messages.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n\n\n\n\n\nasync function mergeRuntimeEnvIntoRunCreates(runs) {\n    const runtimeEnv = await (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironment)();\n    const envVars = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangChainEnvVarsMetadata)();\n    return runs.map((run)=>{\n        const extra = run.extra ?? {};\n        const metadata = extra.metadata;\n        run.extra = {\n            ...extra,\n            runtime: {\n                ...runtimeEnv,\n                ...extra?.runtime\n            },\n            metadata: {\n                ...envVars,\n                ...envVars.revision_id || run.revision_id ? {\n                    revision_id: run.revision_id ?? envVars.revision_id\n                } : {},\n                ...metadata\n            }\n        };\n        return run;\n    });\n}\nconst getTracingSamplingRate = ()=>{\n    const samplingRateStr = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url)=>{\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\";\n};\nconst raiseForStatus = async (response, operation)=>{\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    const body = await response.text();\n    if (!response.ok) {\n        throw new Error(`Failed to ${operation}: ${response.status} ${response.statusText} ${body}`);\n    }\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable){\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str.trim().replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\");\n}\nfunction assertUuid(str) {\n    if (!uuid__WEBPACK_IMPORTED_MODULE_4__[\"default\"](str)) {\n        throw new Error(`Invalid UUID: ${str}`);\n    }\n}\nclass Client {\n    constructor(config = {}){\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sampledPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"pendingAutoBatchedRuns\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"pendingAutoBatchedRunLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 100\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 50\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate();\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        this.validateApiKeyIfHosted();\n        this.timeout_ms = config.timeout_ms ?? 12000;\n        this.caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller(config.callerOptions ?? {});\n        this.hideInputs = config.hideInputs ?? defaultConfig.hideInputs;\n        this.hideOutputs = config.hideOutputs ?? defaultConfig.hideOutputs;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.pendingAutoBatchedRunLimit = config.pendingAutoBatchedRunLimit ?? this.pendingAutoBatchedRunLimit;\n    }\n    static getDefaultClientConfig() {\n        const apiKey = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\");\n        const apiUrl = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") ?? \"https://api.smith.langchain.com\";\n        const hideInputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_HIDE_INPUTS\") === \"true\";\n        const hideOutputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs\n        };\n    }\n    validateApiKeyIfHosted() {\n        const isLocal = isLocalhost(this.apiUrl);\n        if (!isLocal && !this.apiKey) {\n            throw new Error(\"API key must be provided when using hosted LangSmith API\");\n        }\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        } else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost\";\n            return \"http://localhost\";\n        } else if (this.apiUrl.includes(\"/api\") && !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        } else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return \"https://dev.smith.langchain.com\";\n        } else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return \"https://smith.langchain.com\";\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${_index_js__WEBPACK_IMPORTED_MODULE_3__.__version__}`\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        return headers;\n    }\n    processInputs(inputs) {\n        if (this.hideInputs) {\n            return {};\n        }\n        return inputs;\n    }\n    processOutputs(outputs) {\n        if (this.hideOutputs) {\n            return {};\n        }\n        return outputs;\n    }\n    prepareRunCreateOrUpdateInputs(run) {\n        const runParams = {\n            ...run\n        };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call(fetch, url, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n        }\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams()) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while(true){\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call(fetch, url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms)\n            });\n            if (!response.ok) {\n                throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n            }\n            const items = await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? {\n            ...body\n        } : {};\n        while(true){\n            const response = await this.caller.call(fetch, `${this.apiUrl}${path}`, {\n                method: requestMethod,\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                body: JSON.stringify(bodyParams)\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs){\n                if (this.sampledPostUuids.has(run.id)) {\n                    sampled.push(run);\n                    this.sampledPostUuids.delete(run.id);\n                }\n            }\n            return sampled;\n        } else {\n            const sampled = [];\n            for (const run of runs){\n                if (Math.random() < this.tracingSampleRate) {\n                    sampled.push(run);\n                    this.sampledPostUuids.add(run.id);\n                }\n            }\n            return sampled;\n        }\n    }\n    async triggerAutoBatchSend(runs) {\n        let batch = runs;\n        if (batch === undefined) {\n            batch = this.pendingAutoBatchedRuns.slice(0, this.pendingAutoBatchedRunLimit);\n            this.pendingAutoBatchedRuns = this.pendingAutoBatchedRuns.slice(this.pendingAutoBatchedRunLimit);\n        }\n        await this.batchIngestRuns({\n            runCreates: batch.filter((item)=>item.action === \"create\").map((item)=>item.item),\n            runUpdates: batch.filter((item)=>item.action === \"update\").map((item)=>item.item)\n        });\n    }\n    appendRunCreateToAutoBatchQueue(item) {\n        const oldTimeout = this.autoBatchTimeout;\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        this.pendingAutoBatchedRuns.push(item);\n        while(this.pendingAutoBatchedRuns.length >= this.pendingAutoBatchedRunLimit){\n            const batch = this.pendingAutoBatchedRuns.slice(0, this.pendingAutoBatchedRunLimit);\n            this.pendingAutoBatchedRuns = this.pendingAutoBatchedRuns.slice(this.pendingAutoBatchedRunLimit);\n            void this.triggerAutoBatchSend(batch);\n        }\n        if (this.pendingAutoBatchedRuns.length > 0) {\n            if (!oldTimeout) {\n                this.autoBatchTimeout = setTimeout(()=>{\n                    this.autoBatchTimeout = undefined;\n                    void this.triggerAutoBatchSend();\n                }, this.autoBatchInitialDelayMs);\n            } else {\n                this.autoBatchTimeout = setTimeout(()=>{\n                    this.autoBatchTimeout = undefined;\n                    void this.triggerAutoBatchSend();\n                }, this.autoBatchAggregationDelayMs);\n            }\n        }\n    }\n    async createRun(run) {\n        if (!this._filterForSampling([\n            run\n        ]).length) {\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\"\n        };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now()\n        });\n        if (this.autoBatchTracing && runCreate.trace_id !== undefined && runCreate.dotted_order !== undefined) {\n            this.appendRunCreateToAutoBatchQueue({\n                action: \"create\",\n                item: runCreate\n            });\n            return;\n        }\n        const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([\n            runCreate\n        ]);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(mergedRunCreateParams[0]),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"create run\");\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */ async batchIngestRuns({ runCreates, runUpdates }) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = runCreates?.map((create)=>this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n        let preparedUpdateParams = runUpdates?.map((update)=>this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run)=>{\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams){\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam\n                    };\n                } else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const body = {\n            post: this._filterForSampling(preparedCreateParams),\n            patch: this._filterForSampling(preparedUpdateParams, true)\n        };\n        if (!body.post.length && !body.patch.length) {\n            return;\n        }\n        preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\"\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/batch`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"batch create run\");\n    }\n    async updateRun(runId, run) {\n        assertUuid(runId);\n        if (run.inputs) {\n            run.inputs = this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = {\n            ...run,\n            id: runId\n        };\n        if (!this._filterForSampling([\n            data\n        ], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing && data.trace_id !== undefined && data.dotted_order !== undefined) {\n            this.appendRunCreateToAutoBatchQueue({\n                action: \"update\",\n                item: data\n            });\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\"\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}`, {\n            method: \"PATCH\",\n            headers,\n            body: JSON.stringify(run),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"update run\");\n    }\n    async readRun(runId, { loadChildRuns } = {\n        loadChildRuns: false\n    }) {\n        assertUuid(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns && run.child_run_ids) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            } else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({\n                    projectName: projectOpts?.projectName\n                })).id;\n            } else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            } else {\n                const project = await this.readProject({\n                    projectName: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_PROJECT\") || \"default\"\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        } else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        } else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({\n            id: run.child_run_ids\n        }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b)=>(a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns){\n            if (childRun.parent_run_id === null || childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (!(childRun.parent_run_id in treemap)) {\n                treemap[childRun.parent_run_id] = [];\n            }\n            treemap[childRun.parent_run_id].push(childRun);\n            runs[childRun.id] = childRun;\n        }\n        run.child_runs = treemap[run.id] || [];\n        for(const runId in treemap){\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    async *listRuns({ projectId, projectName, parentRunId, referenceExampleId, startTime, executionOrder, runType, error, id, query, filter, limit }) {\n        let projectId_ = projectId;\n        if (projectName) {\n            if (projectId) {\n                throw new Error(\"Only one of projectId or projectName may be given\");\n            }\n            projectId_ = (await this.readProject({\n                projectName\n            })).id;\n        }\n        const body = {\n            session: projectId_ ? [\n                projectId_\n            ] : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            execution_order: executionOrder,\n            parent_run: parentRunId ? [\n                parentRunId\n            ] : null,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit\n        };\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)){\n            yield* runs;\n        }\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid__WEBPACK_IMPORTED_MODULE_5__[\"default\"]()\n        };\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"unshare run\");\n    }\n    async readRunSharedLink(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds){\n                queryParams.append(\"id\", runId);\n            }\n        }\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId = dataset.id;\n        }\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId\n        };\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"unshare dataset\");\n    }\n    async readSharedDataset(shareToken) {\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/datasets`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to create session ${projectName}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = {\n                ...extra || {},\n                metadata\n            };\n        }\n        const body = {\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null\n        };\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to update project ${projectId}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async readProject({ projectId, projectName, includeStats }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        } else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        } else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        } else {\n            result = response;\n        }\n        return result;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({\n            limit: \"1\"\n        });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)){\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds){\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        } else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)){\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        } else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId === undefined) {\n            projectId_ = (await this.readProject({\n                projectName\n            })).id;\n        } else {\n            projectId_ = projectId;\n        }\n        assertUuid(projectId_);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/sessions/${projectId_}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, `delete session ${projectId_} (${projectName})`);\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key)=>{\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key)=>{\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${fileName} already exists`);\n            }\n            throw new Error(`Failed to upload CSV: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType } = {}) {\n        const body = {\n            name,\n            description\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${name} already exists`);\n            }\n            throw new Error(`Failed to create dataset ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({\n            limit: \"1\"\n        });\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId !== undefined) {\n            assertUuid(datasetId);\n            path += `/${datasetId}`;\n        } else if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        } else {\n            result = response;\n        }\n        return result;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n        // do nothing\n        } else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({\n                datasetName\n            })).id;\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText.trim().split(\"\\n\").map((line)=>JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString()\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds){\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        for await (const datasets of this._getPaginated(path, params)){\n            yield* datasets;\n        }\n    }\n    async deleteDataset({ datasetId, datasetName }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            assertUuid(datasetId_);\n            path += `/${datasetId_}`;\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async createExample(inputs, outputs, { datasetId, datasetName, createdAt, exampleId }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = createdAt || new Date();\n        const data = {\n            dataset_id: datasetId_,\n            inputs,\n            outputs,\n            created_at: createdAt_?.toISOString(),\n            id: exampleId\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create example: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createExamples(props) {\n        const { inputs, outputs, sourceRunIds, exampleIds, datasetId, datasetName } = props;\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx)=>{\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs ? outputs[idx] : undefined,\n                id: exampleIds ? exampleIds[idx] : undefined,\n                source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined\n            };\n        });\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/bulk`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(formattedExamples),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create examples: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({\n            input\n        }, {\n            output: generation\n        }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message)=>{\n            if ((0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.isLangChainMessage)(message)) {\n                return (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.convertLangChainMessageToExample)(message);\n            }\n            return message;\n        });\n        const finalOutput = (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.isLangChainMessage)(generations) ? (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.convertLangChainMessageToExample)(generations) : generations;\n        return this.createExample({\n            input: finalInput\n        }, {\n            output: finalOutput\n        }, options);\n    }\n    async readExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        return await this._get(path);\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        } else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        } else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({\n            dataset: datasetId_\n        });\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds){\n                params.append(\"id\", id_);\n            }\n        }\n        for await (const examples of this._getPaginated(\"/examples\", params)){\n            yield* examples;\n        }\n    }\n    async deleteExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async updateExample(exampleId, update) {\n        assertUuid(exampleId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/${exampleId}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to update example ${exampleId}: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample } = {\n        loadChildRuns: false\n    }) {\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, {\n                loadChildRuns\n            });\n        } else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        } else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        if (run_.reference_example_id !== null && run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        let sourceInfo_ = sourceInfo ?? {};\n        if (feedbackResult.evaluatorInfo) {\n            sourceInfo_ = {\n                ...sourceInfo_,\n                ...feedbackResult.evaluatorInfo\n            };\n        }\n        const runId = feedbackResult.targetRunId ?? run_.id;\n        return await this.createFeedback(runId, feedbackResult.key, {\n            score: feedbackResult?.score,\n            value: feedbackResult?.value,\n            comment: feedbackResult?.comment,\n            correction: feedbackResult?.correction,\n            sourceInfo: sourceInfo_,\n            feedbackSourceType: \"model\",\n            sourceRunId: feedbackResult?.sourceRunId\n        });\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, eager = false }) {\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {}\n        };\n        if (sourceRunId !== undefined && feedback_source?.metadata !== undefined && !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = {\n                run_id: sourceRunId\n            };\n        }\n        if (feedback_source?.metadata !== undefined && feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            assertUuid(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid__WEBPACK_IMPORTED_MODULE_5__[\"default\"](),\n            run_id: runId,\n            key,\n            score,\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source\n        };\n        const url = `${this.apiUrl}/feedback` + (eager ? \"/eager\" : \"\");\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(feedback),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"create feedback\");\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = score;\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        assertUuid(feedbackId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/${feedbackId}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(feedbackUpdate),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"update feedback\");\n    }\n    async readFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys){\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes){\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)){\n            yield* feedbacks;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNkI7QUFDeUI7QUFDc0M7QUFDaUI7QUFDcEU7QUFDekMsZUFBZVEsOEJBQThCQyxJQUFJO0lBQzdDLE1BQU1DLGFBQWEsTUFBTUosb0VBQXFCQTtJQUM5QyxNQUFNSyxVQUFVTiwwRUFBMkJBO0lBQzNDLE9BQU9JLEtBQUtHLEdBQUcsQ0FBQyxDQUFDQztRQUNiLE1BQU1DLFFBQVFELElBQUlDLEtBQUssSUFBSSxDQUFDO1FBQzVCLE1BQU1DLFdBQVdELE1BQU1DLFFBQVE7UUFDL0JGLElBQUlDLEtBQUssR0FBRztZQUNSLEdBQUdBLEtBQUs7WUFDUkUsU0FBUztnQkFDTCxHQUFHTixVQUFVO2dCQUNiLEdBQUdJLE9BQU9FLE9BQU87WUFDckI7WUFDQUQsVUFBVTtnQkFDTixHQUFHSixPQUFPO2dCQUNWLEdBQUlBLFFBQVFNLFdBQVcsSUFBSUosSUFBSUksV0FBVyxHQUNwQztvQkFBRUEsYUFBYUosSUFBSUksV0FBVyxJQUFJTixRQUFRTSxXQUFXO2dCQUFDLElBQ3RELENBQUMsQ0FBQztnQkFDUixHQUFHRixRQUFRO1lBQ2Y7UUFDSjtRQUNBLE9BQU9GO0lBQ1g7QUFDSjtBQUNBLE1BQU1LLHlCQUF5QjtJQUMzQixNQUFNQyxrQkFBa0JmLHFFQUFzQkEsQ0FBQztJQUMvQyxJQUFJZSxvQkFBb0JDLFdBQVc7UUFDL0IsT0FBT0E7SUFDWDtJQUNBLE1BQU1DLGVBQWVDLFdBQVdIO0lBQ2hDLElBQUlFLGVBQWUsS0FBS0EsZUFBZSxHQUFHO1FBQ3RDLE1BQU0sSUFBSUUsTUFBTSxDQUFDLHFFQUFxRSxFQUFFRixhQUFhLENBQUM7SUFDMUc7SUFDQSxPQUFPQTtBQUNYO0FBQ0Esb0JBQW9CO0FBQ3BCLE1BQU1HLGNBQWMsQ0FBQ0M7SUFDakIsTUFBTUMsY0FBY0QsSUFBSUUsT0FBTyxDQUFDLFdBQVcsSUFBSUEsT0FBTyxDQUFDLFlBQVk7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RSxFQUFFO1lBQ2QsTUFBTSxJQUFJWixNQUFNLENBQUMsaUJBQWlCLEVBQUU2RCxLQUFLLEVBQUUsRUFBRXJELFNBQVNLLE1BQU0sQ0FBQyxDQUFDLEVBQUVMLFNBQVNNLFVBQVUsQ0FBQyxDQUFDO1FBQ3pGO1FBQ0EsTUFBTU4sU0FBU2dFLElBQUk7SUFDdkI7SUFDQSxPQUFPd08sYUFBYSxFQUFFOUcsTUFBTSxFQUFFK0csWUFBWSxFQUFFQyxtQkFBbUIsRUFBRyxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQ3JFLE1BQU1wUCxjQUFjLElBQUlZO1FBQ3hCLElBQUl3SCxRQUFRO1lBQ1JwSSxZQUFZcUksTUFBTSxDQUFDLE9BQU9ELE9BQU9pSCxJQUFJLENBQUM7UUFDMUM7UUFDQSxJQUFJRixjQUFjO1lBQ2QsS0FBSyxNQUFNbkUsT0FBT21FLGFBQWM7Z0JBQzVCblAsWUFBWXFJLE1BQU0sQ0FBQyxPQUFPMkM7WUFDOUI7UUFDSjtRQUNBLElBQUlvRSxxQkFBcUI7WUFDckIsS0FBSyxNQUFNUixRQUFRUSxvQkFBcUI7Z0JBQ3BDcFAsWUFBWXFJLE1BQU0sQ0FBQyxVQUFVdUc7WUFDakM7UUFDSjtRQUNBLFdBQVcsTUFBTVUsYUFBYSxJQUFJLENBQUMzTyxhQUFhLENBQUMsYUFBYVgsYUFBYztZQUN4RSxPQUFPc1A7UUFDWDtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zeW5jY2hhdC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9jbGllbnQuanM/ZWQxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dWlkIGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBBc3luY0NhbGxlciB9IGZyb20gXCIuL3V0aWxzL2FzeW5jX2NhbGxlci5qc1wiO1xuaW1wb3J0IHsgY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUsIGlzTGFuZ0NoYWluTWVzc2FnZSwgfSBmcm9tIFwiLi91dGlscy9tZXNzYWdlcy5qc1wiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSwgZ2V0TGFuZ0NoYWluRW52VmFyc01ldGFkYXRhLCBnZXRSdW50aW1lRW52aXJvbm1lbnQsIH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyBfX3ZlcnNpb25fXyB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5hc3luYyBmdW5jdGlvbiBtZXJnZVJ1bnRpbWVFbnZJbnRvUnVuQ3JlYXRlcyhydW5zKSB7XG4gICAgY29uc3QgcnVudGltZUVudiA9IGF3YWl0IGdldFJ1bnRpbWVFbnZpcm9ubWVudCgpO1xuICAgIGNvbnN0IGVudlZhcnMgPSBnZXRMYW5nQ2hhaW5FbnZWYXJzTWV0YWRhdGEoKTtcbiAgICByZXR1cm4gcnVucy5tYXAoKHJ1bikgPT4ge1xuICAgICAgICBjb25zdCBleHRyYSA9IHJ1bi5leHRyYSA/PyB7fTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBleHRyYS5tZXRhZGF0YTtcbiAgICAgICAgcnVuLmV4dHJhID0ge1xuICAgICAgICAgICAgLi4uZXh0cmEsXG4gICAgICAgICAgICBydW50aW1lOiB7XG4gICAgICAgICAgICAgICAgLi4ucnVudGltZUVudixcbiAgICAgICAgICAgICAgICAuLi5leHRyYT8ucnVudGltZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIC4uLmVudlZhcnMsXG4gICAgICAgICAgICAgICAgLi4uKGVudlZhcnMucmV2aXNpb25faWQgfHwgcnVuLnJldmlzaW9uX2lkXG4gICAgICAgICAgICAgICAgICAgID8geyByZXZpc2lvbl9pZDogcnVuLnJldmlzaW9uX2lkID8/IGVudlZhcnMucmV2aXNpb25faWQgfVxuICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfSk7XG59XG5jb25zdCBnZXRUcmFjaW5nU2FtcGxpbmdSYXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHNhbXBsaW5nUmF0ZVN0ciA9IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fVFJBQ0lOR19TQU1QTElOR19SQVRFXCIpO1xuICAgIGlmIChzYW1wbGluZ1JhdGVTdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBzYW1wbGluZ1JhdGUgPSBwYXJzZUZsb2F0KHNhbXBsaW5nUmF0ZVN0cik7XG4gICAgaWYgKHNhbXBsaW5nUmF0ZSA8IDAgfHwgc2FtcGxpbmdSYXRlID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExBTkdDSEFJTl9UUkFDSU5HX1NBTVBMSU5HX1JBVEUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEgaWYgc2V0LiBHb3Q6ICR7c2FtcGxpbmdSYXRlfWApO1xuICAgIH1cbiAgICByZXR1cm4gc2FtcGxpbmdSYXRlO1xufTtcbi8vIHV0aWxpdHkgZnVuY3Rpb25zXG5jb25zdCBpc0xvY2FsaG9zdCA9ICh1cmwpID0+IHtcbiAgICBjb25zdCBzdHJpcHBlZFVybCA9IHVybC5yZXBsYWNlKFwiaHR0cDovL1wiLCBcIlwiKS5yZXBsYWNlKFwiaHR0cHM6Ly9cIiwgXCJcIik7XG4gICAgY29uc3QgaG9zdG5hbWUgPSBzdHJpcHBlZFVybC5zcGxpdChcIi9cIilbMF0uc3BsaXQoXCI6XCIpWzBdO1xuICAgIHJldHVybiAoaG9zdG5hbWUgPT09IFwibG9jYWxob3N0XCIgfHwgaG9zdG5hbWUgPT09IFwiMTI3LjAuMC4xXCIgfHwgaG9zdG5hbWUgPT09IFwiOjoxXCIpO1xufTtcbmNvbnN0IHJhaXNlRm9yU3RhdHVzID0gYXN5bmMgKHJlc3BvbnNlLCBvcGVyYXRpb24pID0+IHtcbiAgICAvLyBjb25zdW1lIHRoZSByZXNwb25zZSBib2R5IHRvIHJlbGVhc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAvLyBodHRwczovL3VuZGljaS5ub2RlanMub3JnLyMvP2lkPWdhcmJhZ2UtY29sbGVjdGlvblxuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byAke29wZXJhdGlvbn06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9ICR7Ym9keX1gKTtcbiAgICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gdG9BcnJheShpdGVyYWJsZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBpdGVyYWJsZSkge1xuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRyaW1RdW90ZXMoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBzdHJcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAucmVwbGFjZSgvXlwiKC4qKVwiJC8sIFwiJDFcIilcbiAgICAgICAgLnJlcGxhY2UoL14nKC4qKSckLywgXCIkMVwiKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFV1aWQoc3RyKSB7XG4gICAgaWYgKCF1dWlkLnZhbGlkYXRlKHN0cikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFVVSUQ6ICR7c3RyfWApO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFwaUtleVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlVcmxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwid2ViVXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aW1lb3V0X21zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90ZW5hbnRJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGlkZUlucHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoaWRlT3V0cHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFjaW5nU2FtcGxlUmF0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzYW1wbGVkUG9zdFV1aWRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaFRyYWNpbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwZW5kaW5nQXV0b0JhdGNoZWRSdW5zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDEwMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoVGltZW91dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQmF0Y2hJbml0aWFsRGVsYXlNc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMjUwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQmF0Y2hBZ2dyZWdhdGlvbkRlbGF5TXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDUwXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0gQ2xpZW50LmdldERlZmF1bHRDbGllbnRDb25maWcoKTtcbiAgICAgICAgdGhpcy50cmFjaW5nU2FtcGxlUmF0ZSA9IGdldFRyYWNpbmdTYW1wbGluZ1JhdGUoKTtcbiAgICAgICAgdGhpcy5hcGlVcmwgPSB0cmltUXVvdGVzKGNvbmZpZy5hcGlVcmwgPz8gZGVmYXVsdENvbmZpZy5hcGlVcmwpID8/IFwiXCI7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gdHJpbVF1b3Rlcyhjb25maWcuYXBpS2V5ID8/IGRlZmF1bHRDb25maWcuYXBpS2V5KTtcbiAgICAgICAgdGhpcy53ZWJVcmwgPSB0cmltUXVvdGVzKGNvbmZpZy53ZWJVcmwgPz8gZGVmYXVsdENvbmZpZy53ZWJVcmwpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlQXBpS2V5SWZIb3N0ZWQoKTtcbiAgICAgICAgdGhpcy50aW1lb3V0X21zID0gY29uZmlnLnRpbWVvdXRfbXMgPz8gMTIwMDA7XG4gICAgICAgIHRoaXMuY2FsbGVyID0gbmV3IEFzeW5jQ2FsbGVyKGNvbmZpZy5jYWxsZXJPcHRpb25zID8/IHt9KTtcbiAgICAgICAgdGhpcy5oaWRlSW5wdXRzID0gY29uZmlnLmhpZGVJbnB1dHMgPz8gZGVmYXVsdENvbmZpZy5oaWRlSW5wdXRzO1xuICAgICAgICB0aGlzLmhpZGVPdXRwdXRzID0gY29uZmlnLmhpZGVPdXRwdXRzID8/IGRlZmF1bHRDb25maWcuaGlkZU91dHB1dHM7XG4gICAgICAgIHRoaXMuYXV0b0JhdGNoVHJhY2luZyA9IGNvbmZpZy5hdXRvQmF0Y2hUcmFjaW5nID8/IHRoaXMuYXV0b0JhdGNoVHJhY2luZztcbiAgICAgICAgdGhpcy5wZW5kaW5nQXV0b0JhdGNoZWRSdW5MaW1pdCA9XG4gICAgICAgICAgICBjb25maWcucGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXQgPz8gdGhpcy5wZW5kaW5nQXV0b0JhdGNoZWRSdW5MaW1pdDtcbiAgICB9XG4gICAgc3RhdGljIGdldERlZmF1bHRDbGllbnRDb25maWcoKSB7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fQVBJX0tFWVwiKTtcbiAgICAgICAgY29uc3QgYXBpVXJsID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9FTkRQT0lOVFwiKSA/P1xuICAgICAgICAgICAgXCJodHRwczovL2FwaS5zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgIGNvbnN0IGhpZGVJbnB1dHMgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0hJREVfSU5QVVRTXCIpID09PSBcInRydWVcIjtcbiAgICAgICAgY29uc3QgaGlkZU91dHB1dHMgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0hJREVfT1VUUFVUU1wiKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcGlVcmw6IGFwaVVybCxcbiAgICAgICAgICAgIGFwaUtleTogYXBpS2V5LFxuICAgICAgICAgICAgd2ViVXJsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBoaWRlSW5wdXRzOiBoaWRlSW5wdXRzLFxuICAgICAgICAgICAgaGlkZU91dHB1dHM6IGhpZGVPdXRwdXRzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YWxpZGF0ZUFwaUtleUlmSG9zdGVkKCkge1xuICAgICAgICBjb25zdCBpc0xvY2FsID0gaXNMb2NhbGhvc3QodGhpcy5hcGlVcmwpO1xuICAgICAgICBpZiAoIWlzTG9jYWwgJiYgIXRoaXMuYXBpS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBUEkga2V5IG11c3QgYmUgcHJvdmlkZWQgd2hlbiB1c2luZyBob3N0ZWQgTGFuZ1NtaXRoIEFQSVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRIb3N0VXJsKCkge1xuICAgICAgICBpZiAodGhpcy53ZWJVcmwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0xvY2FsaG9zdCh0aGlzLmFwaVVybCkpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwOi8vbG9jYWxob3N0XCI7XG4gICAgICAgICAgICByZXR1cm4gXCJodHRwOi8vbG9jYWxob3N0XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcGlVcmwuaW5jbHVkZXMoXCIvYXBpXCIpICYmXG4gICAgICAgICAgICAhdGhpcy5hcGlVcmwuc3BsaXQoXCIuXCIsIDEpWzBdLmVuZHNXaXRoKFwiYXBpXCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IHRoaXMuYXBpVXJsLnJlcGxhY2UoXCIvYXBpXCIsIFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXBpVXJsLnNwbGl0KFwiLlwiLCAxKVswXS5pbmNsdWRlcyhcImRldlwiKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHBzOi8vZGV2LnNtaXRoLmxhbmdjaGFpbi5jb21cIjtcbiAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi8vZGV2LnNtaXRoLmxhbmdjaGFpbi5jb21cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwczovL3NtaXRoLmxhbmdjaGFpbi5jb21cIjtcbiAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi8vc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgXCJVc2VyLUFnZW50XCI6IGBsYW5nc21pdGgtanMvJHtfX3ZlcnNpb25fX31gLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5hcGlLZXkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJ4LWFwaS1rZXlcIl0gPSBgJHt0aGlzLmFwaUtleX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBwcm9jZXNzSW5wdXRzKGlucHV0cykge1xuICAgICAgICBpZiAodGhpcy5oaWRlSW5wdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0cztcbiAgICB9XG4gICAgcHJvY2Vzc091dHB1dHMob3V0cHV0cykge1xuICAgICAgICBpZiAodGhpcy5oaWRlT3V0cHV0cykge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgIH1cbiAgICBwcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHMocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1blBhcmFtcyA9IHsgLi4ucnVuIH07XG4gICAgICAgIGlmIChydW5QYXJhbXMuaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1blBhcmFtcy5pbnB1dHMgPSB0aGlzLnByb2Nlc3NJbnB1dHMocnVuUGFyYW1zLmlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1blBhcmFtcy5vdXRwdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1blBhcmFtcy5vdXRwdXRzID0gdGhpcy5wcm9jZXNzT3V0cHV0cyhydW5QYXJhbXMub3V0cHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1blBhcmFtcztcbiAgICB9XG4gICAgYXN5bmMgX2dldFJlc3BvbnNlKHBhdGgsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtc1N0cmluZyA9IHF1ZXJ5UGFyYW1zPy50b1N0cmluZygpID8/IFwiXCI7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfSR7cGF0aH0/JHtwYXJhbXNTdHJpbmd9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggJHtwYXRofTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIF9nZXQocGF0aCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXRSZXNwb25zZShwYXRoLCBxdWVyeVBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jICpfZ2V0UGFnaW5hdGVkKHBhdGgsIHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSBOdW1iZXIocXVlcnlQYXJhbXMuZ2V0KFwib2Zmc2V0XCIpKSB8fCAwO1xuICAgICAgICBjb25zdCBsaW1pdCA9IE51bWJlcihxdWVyeVBhcmFtcy5nZXQoXCJsaW1pdFwiKSkgfHwgMTAwO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuc2V0KFwib2Zmc2V0XCIsIFN0cmluZyhvZmZzZXQpKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLnNldChcImxpbWl0XCIsIFN0cmluZyhsaW1pdCkpO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9JHtwYXRofT8ke3F1ZXJ5UGFyYW1zfWA7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIHVybCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCAke3BhdGh9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBpdGVtcztcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqX2dldEN1cnNvclBhZ2luYXRlZExpc3QocGF0aCwgYm9keSA9IG51bGwsIHJlcXVlc3RNZXRob2QgPSBcIlBPU1RcIiwgZGF0YUtleSA9IFwicnVuc1wiKSB7XG4gICAgICAgIGNvbnN0IGJvZHlQYXJhbXMgPSBib2R5ID8geyAuLi5ib2R5IH0gOiB7fTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9JHtwYXRofWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3RNZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keVBhcmFtcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VCb2R5KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlQm9keVtkYXRhS2V5XSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgcmVzcG9uc2VCb2R5W2RhdGFLZXldO1xuICAgICAgICAgICAgY29uc3QgY3Vyc29ycyA9IHJlc3BvbnNlQm9keS5jdXJzb3JzO1xuICAgICAgICAgICAgaWYgKCFjdXJzb3JzKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWN1cnNvcnMubmV4dCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keVBhcmFtcy5jdXJzb3IgPSBjdXJzb3JzLm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ZpbHRlckZvclNhbXBsaW5nKHJ1bnMsIHBhdGNoID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2luZ1NhbXBsZVJhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJ1bnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVkID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1biBvZiBydW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2FtcGxlZFBvc3RVdWlkcy5oYXMocnVuLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGVkLnB1c2gocnVuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zYW1wbGVkUG9zdFV1aWRzLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlZCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBydW4gb2YgcnVucykge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgdGhpcy50cmFjaW5nU2FtcGxlUmF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGVkLnB1c2gocnVuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zYW1wbGVkUG9zdFV1aWRzLmFkZChydW4uaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHRyaWdnZXJBdXRvQmF0Y2hTZW5kKHJ1bnMpIHtcbiAgICAgICAgbGV0IGJhdGNoID0gcnVucztcbiAgICAgICAgaWYgKGJhdGNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJhdGNoID0gdGhpcy5wZW5kaW5nQXV0b0JhdGNoZWRSdW5zLnNsaWNlKDAsIHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXQpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQXV0b0JhdGNoZWRSdW5zID0gdGhpcy5wZW5kaW5nQXV0b0JhdGNoZWRSdW5zLnNsaWNlKHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXQpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuYmF0Y2hJbmdlc3RSdW5zKHtcbiAgICAgICAgICAgIHJ1bkNyZWF0ZXM6IGJhdGNoXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5hY3Rpb24gPT09IFwiY3JlYXRlXCIpXG4gICAgICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gaXRlbS5pdGVtKSxcbiAgICAgICAgICAgIHJ1blVwZGF0ZXM6IGJhdGNoXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5hY3Rpb24gPT09IFwidXBkYXRlXCIpXG4gICAgICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gaXRlbS5pdGVtKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFwcGVuZFJ1bkNyZWF0ZVRvQXV0b0JhdGNoUXVldWUoaXRlbSkge1xuICAgICAgICBjb25zdCBvbGRUaW1lb3V0ID0gdGhpcy5hdXRvQmF0Y2hUaW1lb3V0O1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hdXRvQmF0Y2hUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5hdXRvQmF0Y2hUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBlbmRpbmdBdXRvQmF0Y2hlZFJ1bnMucHVzaChpdGVtKTtcbiAgICAgICAgd2hpbGUgKHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVucy5sZW5ndGggPj0gdGhpcy5wZW5kaW5nQXV0b0JhdGNoZWRSdW5MaW1pdCkge1xuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLnBlbmRpbmdBdXRvQmF0Y2hlZFJ1bnMuc2xpY2UoMCwgdGhpcy5wZW5kaW5nQXV0b0JhdGNoZWRSdW5MaW1pdCk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdBdXRvQmF0Y2hlZFJ1bnMgPSB0aGlzLnBlbmRpbmdBdXRvQmF0Y2hlZFJ1bnMuc2xpY2UodGhpcy5wZW5kaW5nQXV0b0JhdGNoZWRSdW5MaW1pdCk7XG4gICAgICAgICAgICB2b2lkIHRoaXMudHJpZ2dlckF1dG9CYXRjaFNlbmQoYmF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdBdXRvQmF0Y2hlZFJ1bnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKCFvbGRUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvQmF0Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0b0JhdGNoVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCB0aGlzLnRyaWdnZXJBdXRvQmF0Y2hTZW5kKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5hdXRvQmF0Y2hJbml0aWFsRGVsYXlNcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9CYXRjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRvQmF0Y2hUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMudHJpZ2dlckF1dG9CYXRjaFNlbmQoKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzLmF1dG9CYXRjaEFnZ3JlZ2F0aW9uRGVsYXlNcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlUnVuKHJ1bikge1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKFtydW5dKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0geyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH07XG4gICAgICAgIGNvbnN0IHNlc3Npb25fbmFtZSA9IHJ1bi5wcm9qZWN0X25hbWU7XG4gICAgICAgIGRlbGV0ZSBydW4ucHJvamVjdF9uYW1lO1xuICAgICAgICBjb25zdCBydW5DcmVhdGUgPSB0aGlzLnByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyh7XG4gICAgICAgICAgICBzZXNzaW9uX25hbWUsXG4gICAgICAgICAgICAuLi5ydW4sXG4gICAgICAgICAgICBzdGFydF90aW1lOiBydW4uc3RhcnRfdGltZSA/PyBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoVHJhY2luZyAmJlxuICAgICAgICAgICAgcnVuQ3JlYXRlLnRyYWNlX2lkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHJ1bkNyZWF0ZS5kb3R0ZWRfb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRSdW5DcmVhdGVUb0F1dG9CYXRjaFF1ZXVlKHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwiY3JlYXRlXCIsXG4gICAgICAgICAgICAgICAgaXRlbTogcnVuQ3JlYXRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVyZ2VkUnVuQ3JlYXRlUGFyYW1zID0gYXdhaXQgbWVyZ2VSdW50aW1lRW52SW50b1J1bkNyZWF0ZXMoW1xuICAgICAgICAgICAgcnVuQ3JlYXRlLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcnVuc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobWVyZ2VkUnVuQ3JlYXRlUGFyYW1zWzBdKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiY3JlYXRlIHJ1blwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmF0Y2ggaW5nZXN0L3Vwc2VydCBtdWx0aXBsZSBydW5zIGluIHRoZSBMYW5nc21pdGggc3lzdGVtLlxuICAgICAqIEBwYXJhbSBydW5zXG4gICAgICovXG4gICAgYXN5bmMgYmF0Y2hJbmdlc3RSdW5zKHsgcnVuQ3JlYXRlcywgcnVuVXBkYXRlcywgfSkge1xuICAgICAgICBpZiAocnVuQ3JlYXRlcyA9PT0gdW5kZWZpbmVkICYmIHJ1blVwZGF0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmVwYXJlZENyZWF0ZVBhcmFtcyA9IHJ1bkNyZWF0ZXM/Lm1hcCgoY3JlYXRlKSA9PiB0aGlzLnByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyhjcmVhdGUpKSA/PyBbXTtcbiAgICAgICAgbGV0IHByZXBhcmVkVXBkYXRlUGFyYW1zID0gcnVuVXBkYXRlcz8ubWFwKCh1cGRhdGUpID0+IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKHVwZGF0ZSkpID8/IFtdO1xuICAgICAgICBpZiAocHJlcGFyZWRDcmVhdGVQYXJhbXMubGVuZ3RoID4gMCAmJiBwcmVwYXJlZFVwZGF0ZVBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVCeUlkID0gcHJlcGFyZWRDcmVhdGVQYXJhbXMucmVkdWNlKChwYXJhbXMsIHJ1bikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcnVuLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtc1tydW4uaWRdID0gcnVuO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICBjb25zdCBzdGFuZGFsb25lVXBkYXRlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCB1cGRhdGVQYXJhbSBvZiBwcmVwYXJlZFVwZGF0ZVBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVQYXJhbS5pZCAhPT0gdW5kZWZpbmVkICYmIGNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi51cGRhdGVQYXJhbSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YW5kYWxvbmVVcGRhdGVzLnB1c2godXBkYXRlUGFyYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gT2JqZWN0LnZhbHVlcyhjcmVhdGVCeUlkKTtcbiAgICAgICAgICAgIHByZXBhcmVkVXBkYXRlUGFyYW1zID0gc3RhbmRhbG9uZVVwZGF0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIHBvc3Q6IHRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKHByZXBhcmVkQ3JlYXRlUGFyYW1zKSxcbiAgICAgICAgICAgIHBhdGNoOiB0aGlzLl9maWx0ZXJGb3JTYW1wbGluZyhwcmVwYXJlZFVwZGF0ZVBhcmFtcywgdHJ1ZSksXG4gICAgICAgIH07XG4gICAgICAgIGlmICghYm9keS5wb3N0Lmxlbmd0aCAmJiAhYm9keS5wYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcmVwYXJlZENyZWF0ZVBhcmFtcyA9IGF3YWl0IG1lcmdlUnVudGltZUVudkludG9SdW5DcmVhdGVzKHByZXBhcmVkQ3JlYXRlUGFyYW1zKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcnVucy9iYXRjaGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImJhdGNoIGNyZWF0ZSBydW5cIik7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVJ1bihydW5JZCwgcnVuKSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBpZiAocnVuLmlucHV0cykge1xuICAgICAgICAgICAgcnVuLmlucHV0cyA9IHRoaXMucHJvY2Vzc0lucHV0cyhydW4uaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuLm91dHB1dHMpIHtcbiAgICAgICAgICAgIHJ1bi5vdXRwdXRzID0gdGhpcy5wcm9jZXNzT3V0cHV0cyhydW4ub3V0cHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogVW50YW5nbGUgdHlwZXNcbiAgICAgICAgY29uc3QgZGF0YSA9IHsgLi4ucnVuLCBpZDogcnVuSWQgfTtcbiAgICAgICAgaWYgKCF0aGlzLl9maWx0ZXJGb3JTYW1wbGluZyhbZGF0YV0sIHRydWUpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dG9CYXRjaFRyYWNpbmcgJiZcbiAgICAgICAgICAgIGRhdGEudHJhY2VfaWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZGF0YS5kb3R0ZWRfb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRSdW5DcmVhdGVUb0F1dG9CYXRjaFF1ZXVlKHsgYWN0aW9uOiBcInVwZGF0ZVwiLCBpdGVtOiBkYXRhIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJ1biksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBydW5cIik7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRSdW4ocnVuSWQsIHsgbG9hZENoaWxkUnVucyB9ID0geyBsb2FkQ2hpbGRSdW5zOiBmYWxzZSB9KSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBsZXQgcnVuID0gYXdhaXQgdGhpcy5fZ2V0KGAvcnVucy8ke3J1bklkfWApO1xuICAgICAgICBpZiAobG9hZENoaWxkUnVucyAmJiBydW4uY2hpbGRfcnVuX2lkcykge1xuICAgICAgICAgICAgcnVuID0gYXdhaXQgdGhpcy5fbG9hZENoaWxkUnVucyhydW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGdldFJ1blVybCh7IHJ1bklkLCBydW4sIHByb2plY3RPcHRzLCB9KSB7XG4gICAgICAgIGlmIChydW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHNlc3Npb25JZDtcbiAgICAgICAgICAgIGlmIChydW4uc2Vzc2lvbl9pZCkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHJ1bi5zZXNzaW9uX2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvamVjdE9wdHM/LnByb2plY3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkID0gKGF3YWl0IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZTogcHJvamVjdE9wdHM/LnByb2plY3ROYW1lIH0pKS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2plY3RPcHRzPy5wcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSBwcm9qZWN0T3B0cz8ucHJvamVjdElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9IGF3YWl0IHRoaXMucmVhZFByb2plY3Qoe1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0TmFtZTogZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9QUk9KRUNUXCIpIHx8IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHByb2plY3QuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZW5hbnRJZCA9IGF3YWl0IHRoaXMuX2dldFRlbmFudElkKCk7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L28vJHt0ZW5hbnRJZH0vcHJvamVjdHMvcC8ke3Nlc3Npb25JZH0vci8ke3J1bi5pZH0/cG9sbD10cnVlYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydW5JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBydW5fID0gYXdhaXQgdGhpcy5yZWFkUnVuKHJ1bklkKTtcbiAgICAgICAgICAgIGlmICghcnVuXy5hcHBfcGF0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUnVuICR7cnVuSWR9IGhhcyBubyBhcHBfcGF0aGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmFzZVVybCA9IHRoaXMuZ2V0SG9zdFVybCgpO1xuICAgICAgICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9JHtydW5fLmFwcF9wYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHJ1bklkIG9yIHJ1blwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfbG9hZENoaWxkUnVucyhydW4pIHtcbiAgICAgICAgY29uc3QgY2hpbGRSdW5zID0gYXdhaXQgdG9BcnJheSh0aGlzLmxpc3RSdW5zKHsgaWQ6IHJ1bi5jaGlsZF9ydW5faWRzIH0pKTtcbiAgICAgICAgY29uc3QgdHJlZW1hcCA9IHt9O1xuICAgICAgICBjb25zdCBydW5zID0ge307XG4gICAgICAgIC8vIFRPRE86IG1ha2UgZG90dGVkIG9yZGVyIHJlcXVpcmVkIHdoZW4gdGhlIG1pZ3JhdGlvbiBmaW5pc2hlc1xuICAgICAgICBjaGlsZFJ1bnMuc29ydCgoYSwgYikgPT4gKGE/LmRvdHRlZF9vcmRlciA/PyBcIlwiKS5sb2NhbGVDb21wYXJlKGI/LmRvdHRlZF9vcmRlciA/PyBcIlwiKSk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGRSdW4gb2YgY2hpbGRSdW5zKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRSdW4ucGFyZW50X3J1bl9pZCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIGNoaWxkUnVuLnBhcmVudF9ydW5faWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hpbGQgcnVuICR7Y2hpbGRSdW4uaWR9IGhhcyBubyBwYXJlbnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKGNoaWxkUnVuLnBhcmVudF9ydW5faWQgaW4gdHJlZW1hcCkpIHtcbiAgICAgICAgICAgICAgICB0cmVlbWFwW2NoaWxkUnVuLnBhcmVudF9ydW5faWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmVlbWFwW2NoaWxkUnVuLnBhcmVudF9ydW5faWRdLnB1c2goY2hpbGRSdW4pO1xuICAgICAgICAgICAgcnVuc1tjaGlsZFJ1bi5pZF0gPSBjaGlsZFJ1bjtcbiAgICAgICAgfVxuICAgICAgICBydW4uY2hpbGRfcnVucyA9IHRyZWVtYXBbcnVuLmlkXSB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCBydW5JZCBpbiB0cmVlbWFwKSB7XG4gICAgICAgICAgICBpZiAocnVuSWQgIT09IHJ1bi5pZCkge1xuICAgICAgICAgICAgICAgIHJ1bnNbcnVuSWRdLmNoaWxkX3J1bnMgPSB0cmVlbWFwW3J1bklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyAqbGlzdFJ1bnMoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCBwYXJlbnRSdW5JZCwgcmVmZXJlbmNlRXhhbXBsZUlkLCBzdGFydFRpbWUsIGV4ZWN1dGlvbk9yZGVyLCBydW5UeXBlLCBlcnJvciwgaWQsIHF1ZXJ5LCBmaWx0ZXIsIGxpbWl0LCB9KSB7XG4gICAgICAgIGxldCBwcm9qZWN0SWRfID0gcHJvamVjdElkO1xuICAgICAgICBpZiAocHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBvZiBwcm9qZWN0SWQgb3IgcHJvamVjdE5hbWUgbWF5IGJlIGdpdmVuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvamVjdElkXyA9IChhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWUgfSkpLmlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBzZXNzaW9uOiBwcm9qZWN0SWRfID8gW3Byb2plY3RJZF9dIDogbnVsbCxcbiAgICAgICAgICAgIHJ1bl90eXBlOiBydW5UeXBlLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGU6IHJlZmVyZW5jZUV4YW1wbGVJZCxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25PcmRlcixcbiAgICAgICAgICAgIHBhcmVudF9ydW46IHBhcmVudFJ1bklkID8gW3BhcmVudFJ1bklkXSA6IG51bGwsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBzdGFydFRpbWUgPyBzdGFydFRpbWUudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgIH07XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcnVucyBvZiB0aGlzLl9nZXRDdXJzb3JQYWdpbmF0ZWRMaXN0KFwiL3J1bnMvcXVlcnlcIiwgYm9keSkpIHtcbiAgICAgICAgICAgIHlpZWxkKiBydW5zO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNoYXJlUnVuKHJ1bklkLCB7IHNoYXJlSWQgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBydW5faWQ6IHJ1bklkLFxuICAgICAgICAgICAgc2hhcmVfdG9rZW46IHNoYXJlSWQgfHwgdXVpZC52NCgpLFxuICAgICAgICB9O1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgIShcInNoYXJlX3Rva2VuXCIgaW4gcmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBmcm9tIHNlcnZlclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3Jlc3VsdFtcInNoYXJlX3Rva2VuXCJdfS9yYDtcbiAgICB9XG4gICAgYXN5bmMgdW5zaGFyZVJ1bihydW5JZCkge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidW5zaGFyZSBydW5cIik7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRSdW5TaGFyZWRMaW5rKHJ1bklkKSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgIShcInNoYXJlX3Rva2VuXCIgaW4gcmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3Jlc3VsdFtcInNoYXJlX3Rva2VuXCJdfS9yYDtcbiAgICB9XG4gICAgYXN5bmMgbGlzdFNoYXJlZFJ1bnMoc2hhcmVUb2tlbiwgeyBydW5JZHMsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgc2hhcmVfdG9rZW46IHNoYXJlVG9rZW4sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocnVuSWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVuSWQgb2YgcnVuSWRzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwiaWRcIiwgcnVuSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoc2hhcmVUb2tlbik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L3B1YmxpYy8ke3NoYXJlVG9rZW59L3J1bnMke3F1ZXJ5UGFyYW1zfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcnVucyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJ1bnM7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0U2hhcmVkU2NoZW1hKGRhdGFzZXRJZCwgZGF0YXNldE5hbWUpIHtcbiAgICAgICAgaWYgKCFkYXRhc2V0SWQgJiYgIWRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFaXRoZXIgZGF0YXNldElkIG9yIGRhdGFzZXROYW1lIG11c3QgYmUgZ2l2ZW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWQgPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaGFyZVNjaGVtYSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgc2hhcmVTY2hlbWEudXJsID0gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3NoYXJlU2NoZW1hLnNoYXJlX3Rva2VufS9kYDtcbiAgICAgICAgcmV0dXJuIHNoYXJlU2NoZW1hO1xuICAgIH1cbiAgICBhc3luYyBzaGFyZURhdGFzZXQoZGF0YXNldElkLCBkYXRhc2V0TmFtZSkge1xuICAgICAgICBpZiAoIWRhdGFzZXRJZCAmJiAhZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVpdGhlciBkYXRhc2V0SWQgb3IgZGF0YXNldE5hbWUgbXVzdCBiZSBnaXZlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXRJZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGRhdGFzZXRfaWQ6IGRhdGFzZXRJZCxcbiAgICAgICAgfTtcbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2hhcmVTY2hlbWEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHNoYXJlU2NoZW1hLnVybCA9IGAke3RoaXMuZ2V0SG9zdFVybCgpfS9wdWJsaWMvJHtzaGFyZVNjaGVtYS5zaGFyZV90b2tlbn0vZGA7XG4gICAgICAgIHJldHVybiBzaGFyZVNjaGVtYTtcbiAgICB9XG4gICAgYXN5bmMgdW5zaGFyZURhdGFzZXQoZGF0YXNldElkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1bnNoYXJlIGRhdGFzZXRcIik7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRTaGFyZWREYXRhc2V0KHNoYXJlVG9rZW4pIHtcbiAgICAgICAgYXNzZXJ0VXVpZChzaGFyZVRva2VuKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcHVibGljLyR7c2hhcmVUb2tlbn0vZGF0YXNldHNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVQcm9qZWN0KHsgcHJvamVjdE5hbWUsIGRlc2NyaXB0aW9uID0gbnVsbCwgbWV0YWRhdGEgPSBudWxsLCB1cHNlcnQgPSBmYWxzZSwgcHJvamVjdEV4dHJhID0gbnVsbCwgcmVmZXJlbmNlRGF0YXNldElkID0gbnVsbCwgfSkge1xuICAgICAgICBjb25zdCB1cHNlcnRfID0gdXBzZXJ0ID8gYD91cHNlcnQ9dHJ1ZWAgOiBcIlwiO1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucyR7dXBzZXJ0X31gO1xuICAgICAgICBjb25zdCBleHRyYSA9IHByb2plY3RFeHRyYSB8fCB7fTtcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICBleHRyYVtcIm1ldGFkYXRhXCJdID0gbWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIG5hbWU6IHByb2plY3ROYW1lLFxuICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlZmVyZW5jZURhdGFzZXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYm9keVtcInJlZmVyZW5jZV9kYXRhc2V0X2lkXCJdID0gcmVmZXJlbmNlRGF0YXNldElkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBzZXNzaW9uICR7cHJvamVjdE5hbWV9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVByb2plY3QocHJvamVjdElkLCB7IG5hbWUgPSBudWxsLCBkZXNjcmlwdGlvbiA9IG51bGwsIG1ldGFkYXRhID0gbnVsbCwgcHJvamVjdEV4dHJhID0gbnVsbCwgZW5kVGltZSA9IG51bGwsIH0pIHtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLmFwaVVybH0vc2Vzc2lvbnMvJHtwcm9qZWN0SWR9YDtcbiAgICAgICAgbGV0IGV4dHJhID0gcHJvamVjdEV4dHJhO1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGV4dHJhID0geyAuLi4oZXh0cmEgfHwge30pLCBtZXRhZGF0YSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGVuZF90aW1lOiBlbmRUaW1lID8gbmV3IERhdGUoZW5kVGltZSkudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgcHJvamVjdCAke3Byb2plY3RJZH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFByb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCBpbmNsdWRlU3RhdHMsIH0pIHtcbiAgICAgICAgbGV0IHBhdGggPSBcIi9zZXNzaW9uc1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQocHJvamVjdElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke3Byb2plY3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIHByb2plY3ROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVTdGF0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaW5jbHVkZV9zdGF0c1wiLCBpbmNsdWRlU3RhdHMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9qZWN0W2lkPSR7cHJvamVjdElkfSwgbmFtZT0ke3Byb2plY3ROYW1lfV0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRUZW5hbnRJZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RlbmFudElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVuYW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgbGltaXQ6IFwiMVwiIH0pO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb2plY3RzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9zZXNzaW9uc1wiLCBxdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbmFudElkID0gcHJvamVjdHNbMF0udGVuYW50X2lkO1xuICAgICAgICAgICAgcmV0dXJuIHByb2plY3RzWzBdLnRlbmFudF9pZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm9qZWN0cyBmb3VuZCB0byByZXNvbHZlIHRlbmFudC5cIik7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0UHJvamVjdHMoeyBwcm9qZWN0SWRzLCBuYW1lLCBuYW1lQ29udGFpbnMsIHJlZmVyZW5jZURhdGFzZXRJZCwgcmVmZXJlbmNlRGF0YXNldE5hbWUsIHJlZmVyZW5jZUZyZWUsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvamVjdElkIG9mIHByb2plY3RJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgcHJvamVjdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZUNvbnRhaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lX2NvbnRhaW5zXCIsIG5hbWVDb250YWlucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZURhdGFzZXRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2RhdGFzZXRcIiwgcmVmZXJlbmNlRGF0YXNldElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWZlcmVuY2VEYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7XG4gICAgICAgICAgICAgICAgZGF0YXNldE5hbWU6IHJlZmVyZW5jZURhdGFzZXROYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2RhdGFzZXRcIiwgZGF0YXNldC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZUZyZWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInJlZmVyZW5jZV9mcmVlXCIsIHJlZmVyZW5jZUZyZWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwcm9qZWN0cyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvc2Vzc2lvbnNcIiwgcGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIHByb2plY3RzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVByb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCB9KSB7XG4gICAgICAgIGxldCBwcm9qZWN0SWRfO1xuICAgICAgICBpZiAocHJvamVjdElkID09PSB1bmRlZmluZWQgJiYgcHJvamVjdE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb2plY3RJZF8gPSAoYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lIH0pKS5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb2plY3RJZF8gPSBwcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChwcm9qZWN0SWRfKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vc2Vzc2lvbnMvJHtwcm9qZWN0SWRffWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBkZWxldGUgc2Vzc2lvbiAke3Byb2plY3RJZF99ICgke3Byb2plY3ROYW1lfSlgKTtcbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkQ3N2KHsgY3N2RmlsZSwgZmlsZU5hbWUsIGlucHV0S2V5cywgb3V0cHV0S2V5cywgZGVzY3JpcHRpb24sIGRhdGFUeXBlLCBuYW1lLCB9KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy91cGxvYWRgO1xuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIGNzdkZpbGUsIGZpbGVOYW1lKTtcbiAgICAgICAgaW5wdXRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiaW5wdXRfa2V5c1wiLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIm91dHB1dF9rZXlzXCIsIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImRlc2NyaXB0aW9uXCIsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImRhdGFfdHlwZVwiLCBkYXRhVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kZXRhaWwgJiYgcmVzdWx0LmRldGFpbC5pbmNsdWRlcyhcImFscmVhZHkgZXhpc3RzXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhc2V0ICR7ZmlsZU5hbWV9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGxvYWQgQ1NWOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRGF0YXNldChuYW1lLCB7IGRlc2NyaXB0aW9uLCBkYXRhVHlwZSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkYXRhVHlwZSkge1xuICAgICAgICAgICAgYm9keS5kYXRhX3R5cGUgPSBkYXRhVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmRldGFpbCAmJiByZXN1bHQuZGV0YWlsLmluY2x1ZGVzKFwiYWxyZWFkeSBleGlzdHNcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFzZXQgJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGRhdGFzZXQgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIC8vIGxpbWl0IHRvIDEgcmVzdWx0XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBsaW1pdDogXCIxXCIgfSk7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke2RhdGFzZXRJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIGRhdGFzZXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhc2V0W2lkPSR7ZGF0YXNldElkfSwgbmFtZT0ke2RhdGFzZXROYW1lfV0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0T3BlbmFpRmluZXR1bmluZyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IChhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSkpLmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldFJlc3BvbnNlKGAke3BhdGh9LyR7ZGF0YXNldElkfS9vcGVuYWlfZnRgKTtcbiAgICAgICAgY29uc3QgZGF0YXNldFRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0VGV4dFxuICAgICAgICAgICAgLnRyaW0oKVxuICAgICAgICAgICAgLnNwbGl0KFwiXFxuXCIpXG4gICAgICAgICAgICAubWFwKChsaW5lKSA9PiBKU09OLnBhcnNlKGxpbmUpKTtcbiAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0RGF0YXNldHMoeyBsaW1pdCA9IDEwMCwgb2Zmc2V0ID0gMCwgZGF0YXNldElkcywgZGF0YXNldE5hbWUsIGRhdGFzZXROYW1lQ29udGFpbnMsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBsaW1pdDogbGltaXQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LnRvU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGF0YXNldElkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkXyBvZiBkYXRhc2V0SWRzKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImlkXCIsIGlkXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIGRhdGFzZXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldE5hbWVDb250YWlucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZV9jb250YWluc1wiLCBkYXRhc2V0TmFtZUNvbnRhaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGRhdGFzZXRzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChwYXRoLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogZGF0YXNldHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgbGV0IHBhdGggPSBcIi9kYXRhc2V0c1wiO1xuICAgICAgICBsZXQgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWRfKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke2RhdGFzZXRJZF99YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCB0aGlzLmFwaVVybCArIHBhdGgsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVsZXRlICR7cGF0aH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVFeGFtcGxlKGlucHV0cywgb3V0cHV0cywgeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBjcmVhdGVkQXQsIGV4YW1wbGVJZCB9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlYXRlZEF0XyA9IGNyZWF0ZWRBdCB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgZGF0YXNldF9pZDogZGF0YXNldElkXyxcbiAgICAgICAgICAgIGlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHMsXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBjcmVhdGVkQXRfPy50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgaWQ6IGV4YW1wbGVJZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vZXhhbXBsZXNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGV4YW1wbGU6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVFeGFtcGxlcyhwcm9wcykge1xuICAgICAgICBjb25zdCB7IGlucHV0cywgb3V0cHV0cywgc291cmNlUnVuSWRzLCBleGFtcGxlSWRzLCBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkRXhhbXBsZXMgPSBpbnB1dHMubWFwKChpbnB1dCwgaWR4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGFzZXRfaWQ6IGRhdGFzZXRJZF8sXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBpbnB1dCxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBvdXRwdXRzID8gb3V0cHV0c1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGlkOiBleGFtcGxlSWRzID8gZXhhbXBsZUlkc1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHNvdXJjZV9ydW5faWQ6IHNvdXJjZVJ1bklkcyA/IHNvdXJjZVJ1bklkc1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2V4YW1wbGVzL2J1bGtgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmb3JtYXR0ZWRFeGFtcGxlcyksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBleGFtcGxlczogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUxMTUV4YW1wbGUoaW5wdXQsIGdlbmVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXhhbXBsZSh7IGlucHV0IH0sIHsgb3V0cHV0OiBnZW5lcmF0aW9uIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVDaGF0RXhhbXBsZShpbnB1dCwgZ2VuZXJhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZmluYWxJbnB1dCA9IGlucHV0Lm1hcCgobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzTGFuZ0NoYWluTWVzc2FnZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmluYWxPdXRwdXQgPSBpc0xhbmdDaGFpbk1lc3NhZ2UoZ2VuZXJhdGlvbnMpXG4gICAgICAgICAgICA/IGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKGdlbmVyYXRpb25zKVxuICAgICAgICAgICAgOiBnZW5lcmF0aW9ucztcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXhhbXBsZSh7IGlucHV0OiBmaW5hbElucHV0IH0sIHsgb3V0cHV0OiBmaW5hbE91dHB1dCB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZEV4YW1wbGUoZXhhbXBsZUlkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZXhhbXBsZUlkKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvZXhhbXBsZXMvJHtleGFtcGxlSWR9YDtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldChwYXRoKTtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3RFeGFtcGxlcyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGV4YW1wbGVJZHMsIH0gPSB7fSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXztcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgYSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGRhdGFzZXQ6IGRhdGFzZXRJZF8gfSk7XG4gICAgICAgIGlmIChleGFtcGxlSWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWRfIG9mIGV4YW1wbGVJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgaWRfKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGV4YW1wbGVzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9leGFtcGxlc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogZXhhbXBsZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRXhhbXBsZShleGFtcGxlSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9leGFtcGxlcy8ke2V4YW1wbGVJZH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIHRoaXMuYXBpVXJsICsgcGF0aCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZWxldGUgJHtwYXRofTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUV4YW1wbGUoZXhhbXBsZUlkLCB1cGRhdGUpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9leGFtcGxlcy8ke2V4YW1wbGVJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXBkYXRlKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdXBkYXRlIGV4YW1wbGUgJHtleGFtcGxlSWR9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZXZhbHVhdGVSdW4ocnVuLCBldmFsdWF0b3IsIHsgc291cmNlSW5mbywgbG9hZENoaWxkUnVucywgcmVmZXJlbmNlRXhhbXBsZSwgfSA9IHsgbG9hZENoaWxkUnVuczogZmFsc2UgfSkge1xuICAgICAgICBsZXQgcnVuXztcbiAgICAgICAgaWYgKHR5cGVvZiBydW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJ1bl8gPSBhd2FpdCB0aGlzLnJlYWRSdW4ocnVuLCB7IGxvYWRDaGlsZFJ1bnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJ1biA9PT0gXCJvYmplY3RcIiAmJiBcImlkXCIgaW4gcnVuKSB7XG4gICAgICAgICAgICBydW5fID0gcnVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJ1biB0eXBlOiAke3R5cGVvZiBydW59YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bl8ucmVmZXJlbmNlX2V4YW1wbGVfaWQgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHJ1bl8ucmVmZXJlbmNlX2V4YW1wbGVfaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlRXhhbXBsZSA9IGF3YWl0IHRoaXMucmVhZEV4YW1wbGUocnVuXy5yZWZlcmVuY2VfZXhhbXBsZV9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmVlZGJhY2tSZXN1bHQgPSBhd2FpdCBldmFsdWF0b3IuZXZhbHVhdGVSdW4ocnVuXywgcmVmZXJlbmNlRXhhbXBsZSk7XG4gICAgICAgIGxldCBzb3VyY2VJbmZvXyA9IHNvdXJjZUluZm8gPz8ge307XG4gICAgICAgIGlmIChmZWVkYmFja1Jlc3VsdC5ldmFsdWF0b3JJbmZvKSB7XG4gICAgICAgICAgICBzb3VyY2VJbmZvXyA9IHsgLi4uc291cmNlSW5mb18sIC4uLmZlZWRiYWNrUmVzdWx0LmV2YWx1YXRvckluZm8gfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5JZCA9IGZlZWRiYWNrUmVzdWx0LnRhcmdldFJ1bklkID8/IHJ1bl8uaWQ7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZUZlZWRiYWNrKHJ1bklkLCBmZWVkYmFja1Jlc3VsdC5rZXksIHtcbiAgICAgICAgICAgIHNjb3JlOiBmZWVkYmFja1Jlc3VsdD8uc2NvcmUsXG4gICAgICAgICAgICB2YWx1ZTogZmVlZGJhY2tSZXN1bHQ/LnZhbHVlLFxuICAgICAgICAgICAgY29tbWVudDogZmVlZGJhY2tSZXN1bHQ/LmNvbW1lbnQsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiBmZWVkYmFja1Jlc3VsdD8uY29ycmVjdGlvbixcbiAgICAgICAgICAgIHNvdXJjZUluZm86IHNvdXJjZUluZm9fLFxuICAgICAgICAgICAgZmVlZGJhY2tTb3VyY2VUeXBlOiBcIm1vZGVsXCIsXG4gICAgICAgICAgICBzb3VyY2VSdW5JZDogZmVlZGJhY2tSZXN1bHQ/LnNvdXJjZVJ1bklkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRmVlZGJhY2socnVuSWQsIGtleSwgeyBzY29yZSwgdmFsdWUsIGNvcnJlY3Rpb24sIGNvbW1lbnQsIHNvdXJjZUluZm8sIGZlZWRiYWNrU291cmNlVHlwZSA9IFwiYXBpXCIsIHNvdXJjZVJ1bklkLCBmZWVkYmFja0lkLCBlYWdlciA9IGZhbHNlLCB9KSB7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrX3NvdXJjZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IGZlZWRiYWNrU291cmNlVHlwZSA/PyBcImFwaVwiLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHNvdXJjZUluZm8gPz8ge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzb3VyY2VSdW5JZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2U/Lm1ldGFkYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXSkge1xuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0gPSB7IHJ1bl9pZDogc291cmNlUnVuSWQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tfc291cmNlPy5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXT8ucnVuX2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0ucnVuX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmZWVkYmFjayA9IHtcbiAgICAgICAgICAgIGlkOiBmZWVkYmFja0lkID8/IHV1aWQudjQoKSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBzY29yZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY29ycmVjdGlvbixcbiAgICAgICAgICAgIGNvbW1lbnQsXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2U6IGZlZWRiYWNrX3NvdXJjZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9L2ZlZWRiYWNrYCArIChlYWdlciA/IFwiL2VhZ2VyXCIgOiBcIlwiKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZlZWRiYWNrKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiY3JlYXRlIGZlZWRiYWNrXCIpO1xuICAgICAgICByZXR1cm4gZmVlZGJhY2s7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUZlZWRiYWNrKGZlZWRiYWNrSWQsIHsgc2NvcmUsIHZhbHVlLCBjb3JyZWN0aW9uLCBjb21tZW50LCB9KSB7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrVXBkYXRlID0ge307XG4gICAgICAgIGlmIChzY29yZSAhPT0gdW5kZWZpbmVkICYmIHNjb3JlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcInNjb3JlXCJdID0gc2NvcmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1widmFsdWVcIl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ycmVjdGlvbiAhPT0gdW5kZWZpbmVkICYmIGNvcnJlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1wiY29ycmVjdGlvblwiXSA9IGNvcnJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCAmJiBjb21tZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcImNvbW1lbnRcIl0gPSBjb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZmVlZGJhY2tVcGRhdGUpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGRhdGUgZmVlZGJhY2tcIik7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRGZWVkYmFjayhmZWVkYmFja0lkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChwYXRoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVGZWVkYmFjayhmZWVkYmFja0lkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIHRoaXMuYXBpVXJsICsgcGF0aCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZWxldGUgJHtwYXRofTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0RmVlZGJhY2soeyBydW5JZHMsIGZlZWRiYWNrS2V5cywgZmVlZGJhY2tTb3VyY2VUeXBlcywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAocnVuSWRzKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJydW5cIiwgcnVuSWRzLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tLZXlzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBmZWVkYmFja0tleXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tTb3VyY2VUeXBlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGZlZWRiYWNrU291cmNlVHlwZXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJzb3VyY2VcIiwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBmZWVkYmFja3Mgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2ZlZWRiYWNrXCIsIHF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIGZlZWRiYWNrcztcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJ1dWlkIiwiQXN5bmNDYWxsZXIiLCJjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZSIsImlzTGFuZ0NoYWluTWVzc2FnZSIsImdldEVudmlyb25tZW50VmFyaWFibGUiLCJnZXRMYW5nQ2hhaW5FbnZWYXJzTWV0YWRhdGEiLCJnZXRSdW50aW1lRW52aXJvbm1lbnQiLCJfX3ZlcnNpb25fXyIsIm1lcmdlUnVudGltZUVudkludG9SdW5DcmVhdGVzIiwicnVucyIsInJ1bnRpbWVFbnYiLCJlbnZWYXJzIiwibWFwIiwicnVuIiwiZXh0cmEiLCJtZXRhZGF0YSIsInJ1bnRpbWUiLCJyZXZpc2lvbl9pZCIsImdldFRyYWNpbmdTYW1wbGluZ1JhdGUiLCJzYW1wbGluZ1JhdGVTdHIiLCJ1bmRlZmluZWQiLCJzYW1wbGluZ1JhdGUiLCJwYXJzZUZsb2F0IiwiRXJyb3IiLCJpc0xvY2FsaG9zdCIsInVybCIsInN0cmlwcGVkVXJsIiwicmVwbGFjZSIsImhvc3RuYW1lIiwic3BsaXQiLCJyYWlzZUZvclN0YXR1cyIsInJlc3BvbnNlIiwib3BlcmF0aW9uIiwiYm9keSIsInRleHQiLCJvayIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJ0b0FycmF5IiwiaXRlcmFibGUiLCJyZXN1bHQiLCJpdGVtIiwicHVzaCIsInRyaW1RdW90ZXMiLCJzdHIiLCJ0cmltIiwiYXNzZXJ0VXVpZCIsInZhbGlkYXRlIiwiQ2xpZW50IiwiY29uc3RydWN0b3IiLCJjb25maWciLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwiU2V0IiwiZGVmYXVsdENvbmZpZyIsImdldERlZmF1bHRDbGllbnRDb25maWciLCJ0cmFjaW5nU2FtcGxlUmF0ZSIsImFwaVVybCIsImFwaUtleSIsIndlYlVybCIsInZhbGlkYXRlQXBpS2V5SWZIb3N0ZWQiLCJ0aW1lb3V0X21zIiwiY2FsbGVyIiwiY2FsbGVyT3B0aW9ucyIsImhpZGVJbnB1dHMiLCJoaWRlT3V0cHV0cyIsImF1dG9CYXRjaFRyYWNpbmciLCJwZW5kaW5nQXV0b0JhdGNoZWRSdW5MaW1pdCIsImlzTG9jYWwiLCJnZXRIb3N0VXJsIiwiaW5jbHVkZXMiLCJlbmRzV2l0aCIsImhlYWRlcnMiLCJwcm9jZXNzSW5wdXRzIiwiaW5wdXRzIiwicHJvY2Vzc091dHB1dHMiLCJvdXRwdXRzIiwicHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzIiwicnVuUGFyYW1zIiwiX2dldFJlc3BvbnNlIiwicGF0aCIsInF1ZXJ5UGFyYW1zIiwicGFyYW1zU3RyaW5nIiwidG9TdHJpbmciLCJjYWxsIiwiZmV0Y2giLCJtZXRob2QiLCJzaWduYWwiLCJBYm9ydFNpZ25hbCIsInRpbWVvdXQiLCJfZ2V0IiwianNvbiIsIl9nZXRQYWdpbmF0ZWQiLCJVUkxTZWFyY2hQYXJhbXMiLCJvZmZzZXQiLCJOdW1iZXIiLCJnZXQiLCJsaW1pdCIsInNldCIsIlN0cmluZyIsIml0ZW1zIiwibGVuZ3RoIiwiX2dldEN1cnNvclBhZ2luYXRlZExpc3QiLCJyZXF1ZXN0TWV0aG9kIiwiZGF0YUtleSIsImJvZHlQYXJhbXMiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzcG9uc2VCb2R5IiwiY3Vyc29ycyIsIm5leHQiLCJjdXJzb3IiLCJfZmlsdGVyRm9yU2FtcGxpbmciLCJwYXRjaCIsInNhbXBsZWQiLCJzYW1wbGVkUG9zdFV1aWRzIiwiaGFzIiwiaWQiLCJkZWxldGUiLCJNYXRoIiwicmFuZG9tIiwiYWRkIiwidHJpZ2dlckF1dG9CYXRjaFNlbmQiLCJiYXRjaCIsInBlbmRpbmdBdXRvQmF0Y2hlZFJ1bnMiLCJzbGljZSIsImJhdGNoSW5nZXN0UnVucyIsInJ1bkNyZWF0ZXMiLCJmaWx0ZXIiLCJhY3Rpb24iLCJydW5VcGRhdGVzIiwiYXBwZW5kUnVuQ3JlYXRlVG9BdXRvQmF0Y2hRdWV1ZSIsIm9sZFRpbWVvdXQiLCJhdXRvQmF0Y2hUaW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImF1dG9CYXRjaEluaXRpYWxEZWxheU1zIiwiYXV0b0JhdGNoQWdncmVnYXRpb25EZWxheU1zIiwiY3JlYXRlUnVuIiwic2Vzc2lvbl9uYW1lIiwicHJvamVjdF9uYW1lIiwicnVuQ3JlYXRlIiwic3RhcnRfdGltZSIsIkRhdGUiLCJub3ciLCJ0cmFjZV9pZCIsImRvdHRlZF9vcmRlciIsIm1lcmdlZFJ1bkNyZWF0ZVBhcmFtcyIsInByZXBhcmVkQ3JlYXRlUGFyYW1zIiwiY3JlYXRlIiwicHJlcGFyZWRVcGRhdGVQYXJhbXMiLCJ1cGRhdGUiLCJjcmVhdGVCeUlkIiwicmVkdWNlIiwicGFyYW1zIiwic3RhbmRhbG9uZVVwZGF0ZXMiLCJ1cGRhdGVQYXJhbSIsInZhbHVlcyIsInBvc3QiLCJBY2NlcHQiLCJ1cGRhdGVSdW4iLCJydW5JZCIsImRhdGEiLCJyZWFkUnVuIiwibG9hZENoaWxkUnVucyIsImNoaWxkX3J1bl9pZHMiLCJfbG9hZENoaWxkUnVucyIsImdldFJ1blVybCIsInByb2plY3RPcHRzIiwic2Vzc2lvbklkIiwic2Vzc2lvbl9pZCIsInByb2plY3ROYW1lIiwicmVhZFByb2plY3QiLCJwcm9qZWN0SWQiLCJwcm9qZWN0IiwidGVuYW50SWQiLCJfZ2V0VGVuYW50SWQiLCJydW5fIiwiYXBwX3BhdGgiLCJiYXNlVXJsIiwiY2hpbGRSdW5zIiwibGlzdFJ1bnMiLCJ0cmVlbWFwIiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsImNoaWxkUnVuIiwicGFyZW50X3J1bl9pZCIsImNoaWxkX3J1bnMiLCJwYXJlbnRSdW5JZCIsInJlZmVyZW5jZUV4YW1wbGVJZCIsInN0YXJ0VGltZSIsImV4ZWN1dGlvbk9yZGVyIiwicnVuVHlwZSIsImVycm9yIiwicXVlcnkiLCJwcm9qZWN0SWRfIiwic2Vzc2lvbiIsInJ1bl90eXBlIiwicmVmZXJlbmNlX2V4YW1wbGUiLCJleGVjdXRpb25fb3JkZXIiLCJwYXJlbnRfcnVuIiwidG9JU09TdHJpbmciLCJzaGFyZVJ1biIsInNoYXJlSWQiLCJydW5faWQiLCJzaGFyZV90b2tlbiIsInY0IiwidW5zaGFyZVJ1biIsInJlYWRSdW5TaGFyZWRMaW5rIiwibGlzdFNoYXJlZFJ1bnMiLCJzaGFyZVRva2VuIiwicnVuSWRzIiwiYXBwZW5kIiwicmVhZERhdGFzZXRTaGFyZWRTY2hlbWEiLCJkYXRhc2V0SWQiLCJkYXRhc2V0TmFtZSIsImRhdGFzZXQiLCJyZWFkRGF0YXNldCIsInNoYXJlU2NoZW1hIiwic2hhcmVEYXRhc2V0IiwiZGF0YXNldF9pZCIsInVuc2hhcmVEYXRhc2V0IiwicmVhZFNoYXJlZERhdGFzZXQiLCJjcmVhdGVQcm9qZWN0IiwiZGVzY3JpcHRpb24iLCJ1cHNlcnQiLCJwcm9qZWN0RXh0cmEiLCJyZWZlcmVuY2VEYXRhc2V0SWQiLCJ1cHNlcnRfIiwiZW5kcG9pbnQiLCJuYW1lIiwidXBkYXRlUHJvamVjdCIsImVuZFRpbWUiLCJlbmRfdGltZSIsImluY2x1ZGVTdGF0cyIsIkFycmF5IiwiaXNBcnJheSIsIl90ZW5hbnRJZCIsInByb2plY3RzIiwidGVuYW50X2lkIiwibGlzdFByb2plY3RzIiwicHJvamVjdElkcyIsIm5hbWVDb250YWlucyIsInJlZmVyZW5jZURhdGFzZXROYW1lIiwicmVmZXJlbmNlRnJlZSIsImRlbGV0ZVByb2plY3QiLCJ1cGxvYWRDc3YiLCJjc3ZGaWxlIiwiZmlsZU5hbWUiLCJpbnB1dEtleXMiLCJvdXRwdXRLZXlzIiwiZGF0YVR5cGUiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiZm9yRWFjaCIsImtleSIsImRldGFpbCIsImNyZWF0ZURhdGFzZXQiLCJkYXRhX3R5cGUiLCJyZWFkRGF0YXNldE9wZW5haUZpbmV0dW5pbmciLCJkYXRhc2V0VGV4dCIsImxpbmUiLCJwYXJzZSIsImxpc3REYXRhc2V0cyIsImRhdGFzZXRJZHMiLCJkYXRhc2V0TmFtZUNvbnRhaW5zIiwiaWRfIiwiZGF0YXNldHMiLCJkZWxldGVEYXRhc2V0IiwiZGF0YXNldElkXyIsImNyZWF0ZUV4YW1wbGUiLCJjcmVhdGVkQXQiLCJleGFtcGxlSWQiLCJjcmVhdGVkQXRfIiwiY3JlYXRlZF9hdCIsImNyZWF0ZUV4YW1wbGVzIiwicHJvcHMiLCJzb3VyY2VSdW5JZHMiLCJleGFtcGxlSWRzIiwiZm9ybWF0dGVkRXhhbXBsZXMiLCJpbnB1dCIsImlkeCIsInNvdXJjZV9ydW5faWQiLCJjcmVhdGVMTE1FeGFtcGxlIiwiZ2VuZXJhdGlvbiIsIm9wdGlvbnMiLCJvdXRwdXQiLCJjcmVhdGVDaGF0RXhhbXBsZSIsImdlbmVyYXRpb25zIiwiZmluYWxJbnB1dCIsIm1lc3NhZ2UiLCJmaW5hbE91dHB1dCIsInJlYWRFeGFtcGxlIiwibGlzdEV4YW1wbGVzIiwiZXhhbXBsZXMiLCJkZWxldGVFeGFtcGxlIiwidXBkYXRlRXhhbXBsZSIsImV2YWx1YXRlUnVuIiwiZXZhbHVhdG9yIiwic291cmNlSW5mbyIsInJlZmVyZW5jZUV4YW1wbGUiLCJyZWZlcmVuY2VfZXhhbXBsZV9pZCIsImZlZWRiYWNrUmVzdWx0Iiwic291cmNlSW5mb18iLCJldmFsdWF0b3JJbmZvIiwidGFyZ2V0UnVuSWQiLCJjcmVhdGVGZWVkYmFjayIsInNjb3JlIiwiY29tbWVudCIsImNvcnJlY3Rpb24iLCJmZWVkYmFja1NvdXJjZVR5cGUiLCJzb3VyY2VSdW5JZCIsImZlZWRiYWNrSWQiLCJlYWdlciIsImZlZWRiYWNrX3NvdXJjZSIsInR5cGUiLCJmZWVkYmFjayIsInVwZGF0ZUZlZWRiYWNrIiwiZmVlZGJhY2tVcGRhdGUiLCJyZWFkRmVlZGJhY2siLCJkZWxldGVGZWVkYmFjayIsImxpc3RGZWVkYmFjayIsImZlZWRiYWNrS2V5cyIsImZlZWRiYWNrU291cmNlVHlwZXMiLCJqb2luIiwiZmVlZGJhY2tzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/langsmith/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _run_trees_js__WEBPACK_IMPORTED_MODULE_1__.RunTree),\n/* harmony export */   __version__: () => (/* binding */ __version__)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _run_trees_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./run_trees.js */ \"(rsc)/./node_modules/langsmith/dist/run_trees.js\");\n\n\n// Update using yarn bump-version\nconst __version__ = \"0.0.68\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUM7QUFDSTtBQUN6QyxpQ0FBaUM7QUFDMUIsTUFBTUUsY0FBYyxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3luY2NoYXQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanM/YWEyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBDbGllbnQgfSBmcm9tIFwiLi9jbGllbnQuanNcIjtcbmV4cG9ydCB7IFJ1blRyZWUgfSBmcm9tIFwiLi9ydW5fdHJlZXMuanNcIjtcbi8vIFVwZGF0ZSB1c2luZyB5YXJuIGJ1bXAtdmVyc2lvblxuZXhwb3J0IGNvbnN0IF9fdmVyc2lvbl9fID0gXCIwLjAuNjhcIjtcbiJdLCJuYW1lcyI6WyJDbGllbnQiLCJSdW5UcmVlIiwiX192ZXJzaW9uX18iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/run_trees.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/run_trees.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunTree: () => (/* binding */ RunTree),\n/* harmony export */   convertToDottedOrderFormat: () => (/* binding */ convertToDottedOrderFormat)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n\n\n\nconst warnedMessages = {};\nfunction warnOnce(message) {\n    if (!warnedMessages[message]) {\n        console.warn(message);\n        warnedMessages[message] = true;\n    }\n}\nfunction stripNonAlphanumeric(input) {\n    return input.replace(/[-:.]/g, \"\");\n}\nfunction convertToDottedOrderFormat(epoch, runId) {\n    return stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}000Z`) + runId;\n}\nclass RunTree {\n    constructor(config){\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"run_type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"project_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parent_run\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"start_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"end_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"extra\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"error\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"serialized\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"reference_example_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"events\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"trace_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"dotted_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const defaultConfig = RunTree.getDefaultConfig();\n        Object.assign(this, {\n            ...defaultConfig,\n            ...config\n        });\n        if (!this.trace_id) {\n            if (this.parent_run) {\n                this.trace_id = this.parent_run.trace_id;\n            } else {\n                this.trace_id = this.id;\n            }\n        }\n        if (!this.dotted_order) {\n            const currentDottedOrder = convertToDottedOrderFormat(this.start_time, this.id);\n            if (this.parent_run) {\n                this.dotted_order = this.parent_run.dotted_order + \".\" + currentDottedOrder;\n            } else {\n                this.dotted_order = currentDottedOrder;\n            }\n        }\n    }\n    static getDefaultConfig() {\n        return {\n            id: uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"](),\n            project_name: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_PROJECT\") ?? (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_SESSION\") ?? // TODO: Deprecate\n            \"default\",\n            child_runs: [],\n            api_url: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") ?? \"http://localhost:1984\",\n            api_key: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\"),\n            caller_options: {},\n            start_time: Date.now(),\n            serialized: {},\n            inputs: {},\n            extra: {},\n            client: new _client_js__WEBPACK_IMPORTED_MODULE_1__.Client({})\n        };\n    }\n    async createChild(config) {\n        const child = new RunTree({\n            ...config,\n            parent_run: this,\n            project_name: this.project_name,\n            client: this.client\n        });\n        this.child_runs.push(child);\n        return child;\n    }\n    async end(outputs, error, endTime = Date.now()) {\n        this.outputs = outputs;\n        this.error = error;\n        this.end_time = endTime;\n    }\n    async _convertToCreate(run, excludeChildRuns = true) {\n        const runExtra = run.extra ?? {};\n        if (!runExtra.runtime) {\n            runExtra.runtime = {};\n        }\n        const runtimeEnv = await (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getRuntimeEnvironment)();\n        for (const [k, v] of Object.entries(runtimeEnv)){\n            if (!runExtra.runtime[k]) {\n                runExtra.runtime[k] = v;\n            }\n        }\n        let child_runs;\n        let parent_run_id;\n        if (!excludeChildRuns) {\n            child_runs = await Promise.all(run.child_runs.map((child_run)=>this._convertToCreate(child_run, excludeChildRuns)));\n            parent_run_id = undefined;\n        } else {\n            parent_run_id = run.parent_run?.id;\n            child_runs = [];\n        }\n        const persistedRun = {\n            id: run.id,\n            name: run.name,\n            start_time: run.start_time,\n            end_time: run.end_time,\n            run_type: run.run_type,\n            reference_example_id: run.reference_example_id,\n            extra: runExtra,\n            serialized: run.serialized,\n            error: run.error,\n            inputs: run.inputs,\n            outputs: run.outputs,\n            session_name: run.project_name,\n            child_runs: child_runs,\n            parent_run_id: parent_run_id\n        };\n        return persistedRun;\n    }\n    async postRun(excludeChildRuns = true) {\n        const runCreate = await this._convertToCreate(this, true);\n        await this.client.createRun(runCreate);\n        if (!excludeChildRuns) {\n            warnOnce(\"Posting with excludeChildRuns=false is deprecated and will be removed in a future version.\");\n            for (const childRun of this.child_runs){\n                await childRun.postRun(false);\n            }\n        }\n    }\n    async patchRun() {\n        const runUpdate = {\n            end_time: this.end_time,\n            error: this.error,\n            outputs: this.outputs,\n            parent_run_id: this.parent_run?.id,\n            reference_example_id: this.reference_example_id,\n            extra: this.extra,\n            events: this.events\n        };\n        await this.client.updateRun(this.id, runUpdate);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvcnVuX3RyZWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZCO0FBQ2tEO0FBQzFDO0FBQ3JDLE1BQU1JLGlCQUFpQixDQUFDO0FBQ3hCLFNBQVNDLFNBQVNDLE9BQU87SUFDckIsSUFBSSxDQUFDRixjQUFjLENBQUNFLFFBQVEsRUFBRTtRQUMxQkMsUUFBUUMsSUFBSSxDQUFDRjtRQUNiRixjQUFjLENBQUNFLFFBQVEsR0FBRztJQUM5QjtBQUNKO0FBQ0EsU0FBU0cscUJBQXFCQyxLQUFLO0lBQy9CLE9BQU9BLE1BQU1DLE9BQU8sQ0FBQyxVQUFVO0FBQ25DO0FBQ08sU0FBU0MsMkJBQTJCQyxLQUFLLEVBQUVDLEtBQUs7SUFDbkQsT0FBUUwscUJBQXFCLENBQUMsRUFBRSxJQUFJTSxLQUFLRixPQUFPRyxXQUFXLEdBQUdDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsSUFDNUVIO0FBQ1I7QUFDTyxNQUFNSTtJQUNUQyxZQUFZQyxNQUFNLENBQUU7UUFDaEJDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsTUFBTTtZQUM5QkMsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsWUFBWTtZQUNwQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCO1lBQ3hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxjQUFjO1lBQ3RDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxjQUFjO1lBQ3RDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxjQUFjO1lBQ3RDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxZQUFZO1lBQ3BDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxTQUFTO1lBQ2pDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxTQUFTO1lBQ2pDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxjQUFjO1lBQ3RDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxVQUFVO1lBQ2xDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxXQUFXO1lBQ25DQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSx3QkFBd0I7WUFDaERDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFVBQVU7WUFDbENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFVBQVU7WUFDbENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFlBQVk7WUFDcENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGdCQUFnQjtZQUN4Q0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0EsTUFBTUMsZ0JBQWdCVCxRQUFRVSxnQkFBZ0I7UUFDOUNQLE9BQU9RLE1BQU0sQ0FBQyxJQUFJLEVBQUU7WUFBRSxHQUFHRixhQUFhO1lBQUUsR0FBR1AsTUFBTTtRQUFDO1FBQ2xELElBQUksQ0FBQyxJQUFJLENBQUNVLFFBQVEsRUFBRTtZQUNoQixJQUFJLElBQUksQ0FBQ0MsVUFBVSxFQUFFO2dCQUNqQixJQUFJLENBQUNELFFBQVEsR0FBRyxJQUFJLENBQUNDLFVBQVUsQ0FBQ0QsUUFBUTtZQUM1QyxPQUNLO2dCQUNELElBQUksQ0FBQ0EsUUFBUSxHQUFHLElBQUksQ0FBQ0UsRUFBRTtZQUMzQjtRQUNKO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ0MsWUFBWSxFQUFFO1lBQ3BCLE1BQU1DLHFCQUFxQnRCLDJCQUEyQixJQUFJLENBQUN1QixVQUFVLEVBQUUsSUFBSSxDQUFDSCxFQUFFO1lBQzlFLElBQUksSUFBSSxDQUFDRCxVQUFVLEVBQUU7Z0JBQ2pCLElBQUksQ0FBQ0UsWUFBWSxHQUNiLElBQUksQ0FBQ0YsVUFBVSxDQUFDRSxZQUFZLEdBQUcsTUFBTUM7WUFDN0MsT0FDSztnQkFDRCxJQUFJLENBQUNELFlBQVksR0FBR0M7WUFDeEI7UUFDSjtJQUNKO0lBQ0EsT0FBT04sbUJBQW1CO1FBQ3RCLE9BQU87WUFDSEksSUFBSWhDLDRDQUFPO1lBQ1hxQyxjQUFjcEMscUVBQXNCQSxDQUFDLHdCQUNqQ0EscUVBQXNCQSxDQUFDLHdCQUF3QixrQkFBa0I7WUFDakU7WUFDSnFDLFlBQVksRUFBRTtZQUNkQyxTQUFTdEMscUVBQXNCQSxDQUFDLHlCQUF5QjtZQUN6RHVDLFNBQVN2QyxxRUFBc0JBLENBQUM7WUFDaEN3QyxnQkFBZ0IsQ0FBQztZQUNqQk4sWUFBWXBCLEtBQUsyQixHQUFHO1lBQ3BCQyxZQUFZLENBQUM7WUFDYkMsUUFBUSxDQUFDO1lBQ1RDLE9BQU8sQ0FBQztZQUNSQyxRQUFRLElBQUkzQyw4Q0FBTUEsQ0FBQyxDQUFDO1FBQ3hCO0lBQ0o7SUFDQSxNQUFNNEMsWUFBWTNCLE1BQU0sRUFBRTtRQUN0QixNQUFNNEIsUUFBUSxJQUFJOUIsUUFBUTtZQUN0QixHQUFHRSxNQUFNO1lBQ1RXLFlBQVksSUFBSTtZQUNoQk0sY0FBYyxJQUFJLENBQUNBLFlBQVk7WUFDL0JTLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1FBQ3ZCO1FBQ0EsSUFBSSxDQUFDUixVQUFVLENBQUNXLElBQUksQ0FBQ0Q7UUFDckIsT0FBT0E7SUFDWDtJQUNBLE1BQU1FLElBQUlDLE9BQU8sRUFBRUMsS0FBSyxFQUFFQyxVQUFVdEMsS0FBSzJCLEdBQUcsRUFBRSxFQUFFO1FBQzVDLElBQUksQ0FBQ1MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0UsUUFBUSxHQUFHRDtJQUNwQjtJQUNBLE1BQU1FLGlCQUFpQkMsR0FBRyxFQUFFQyxtQkFBbUIsSUFBSSxFQUFFO1FBQ2pELE1BQU1DLFdBQVdGLElBQUlYLEtBQUssSUFBSSxDQUFDO1FBQy9CLElBQUksQ0FBQ2EsU0FBU0MsT0FBTyxFQUFFO1lBQ25CRCxTQUFTQyxPQUFPLEdBQUcsQ0FBQztRQUN4QjtRQUNBLE1BQU1DLGFBQWEsTUFBTTFELG9FQUFxQkE7UUFDOUMsS0FBSyxNQUFNLENBQUMyRCxHQUFHQyxFQUFFLElBQUl6QyxPQUFPMEMsT0FBTyxDQUFDSCxZQUFhO1lBQzdDLElBQUksQ0FBQ0YsU0FBU0MsT0FBTyxDQUFDRSxFQUFFLEVBQUU7Z0JBQ3RCSCxTQUFTQyxPQUFPLENBQUNFLEVBQUUsR0FBR0M7WUFDMUI7UUFDSjtRQUNBLElBQUl4QjtRQUNKLElBQUkwQjtRQUNKLElBQUksQ0FBQ1Asa0JBQWtCO1lBQ25CbkIsYUFBYSxNQUFNMkIsUUFBUUMsR0FBRyxDQUFDVixJQUFJbEIsVUFBVSxDQUFDNkIsR0FBRyxDQUFDLENBQUNDLFlBQWMsSUFBSSxDQUFDYixnQkFBZ0IsQ0FBQ2EsV0FBV1g7WUFDbEdPLGdCQUFnQks7UUFDcEIsT0FDSztZQUNETCxnQkFBZ0JSLElBQUl6QixVQUFVLEVBQUVDO1lBQ2hDTSxhQUFhLEVBQUU7UUFDbkI7UUFDQSxNQUFNZ0MsZUFBZTtZQUNqQnRDLElBQUl3QixJQUFJeEIsRUFBRTtZQUNWdUMsTUFBTWYsSUFBSWUsSUFBSTtZQUNkcEMsWUFBWXFCLElBQUlyQixVQUFVO1lBQzFCbUIsVUFBVUUsSUFBSUYsUUFBUTtZQUN0QmtCLFVBQVVoQixJQUFJZ0IsUUFBUTtZQUN0QkMsc0JBQXNCakIsSUFBSWlCLG9CQUFvQjtZQUM5QzVCLE9BQU9hO1lBQ1BmLFlBQVlhLElBQUliLFVBQVU7WUFDMUJTLE9BQU9JLElBQUlKLEtBQUs7WUFDaEJSLFFBQVFZLElBQUlaLE1BQU07WUFDbEJPLFNBQVNLLElBQUlMLE9BQU87WUFDcEJ1QixjQUFjbEIsSUFBSW5CLFlBQVk7WUFDOUJDLFlBQVlBO1lBQ1owQixlQUFlQTtRQUNuQjtRQUNBLE9BQU9NO0lBQ1g7SUFDQSxNQUFNSyxRQUFRbEIsbUJBQW1CLElBQUksRUFBRTtRQUNuQyxNQUFNbUIsWUFBWSxNQUFNLElBQUksQ0FBQ3JCLGdCQUFnQixDQUFDLElBQUksRUFBRTtRQUNwRCxNQUFNLElBQUksQ0FBQ1QsTUFBTSxDQUFDK0IsU0FBUyxDQUFDRDtRQUM1QixJQUFJLENBQUNuQixrQkFBa0I7WUFDbkJwRCxTQUFTO1lBQ1QsS0FBSyxNQUFNeUUsWUFBWSxJQUFJLENBQUN4QyxVQUFVLENBQUU7Z0JBQ3BDLE1BQU13QyxTQUFTSCxPQUFPLENBQUM7WUFDM0I7UUFDSjtJQUNKO0lBQ0EsTUFBTUksV0FBVztRQUNiLE1BQU1DLFlBQVk7WUFDZDFCLFVBQVUsSUFBSSxDQUFDQSxRQUFRO1lBQ3ZCRixPQUFPLElBQUksQ0FBQ0EsS0FBSztZQUNqQkQsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJhLGVBQWUsSUFBSSxDQUFDakMsVUFBVSxFQUFFQztZQUNoQ3lDLHNCQUFzQixJQUFJLENBQUNBLG9CQUFvQjtZQUMvQzVCLE9BQU8sSUFBSSxDQUFDQSxLQUFLO1lBQ2pCb0MsUUFBUSxJQUFJLENBQUNBLE1BQU07UUFDdkI7UUFDQSxNQUFNLElBQUksQ0FBQ25DLE1BQU0sQ0FBQ29DLFNBQVMsQ0FBQyxJQUFJLENBQUNsRCxFQUFFLEVBQUVnRDtJQUN6QztBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3luY2NoYXQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvcnVuX3RyZWVzLmpzPzUxMmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXVpZCBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSwgZ2V0UnVudGltZUVudmlyb25tZW50IH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyBDbGllbnQgfSBmcm9tIFwiLi9jbGllbnQuanNcIjtcbmNvbnN0IHdhcm5lZE1lc3NhZ2VzID0ge307XG5mdW5jdGlvbiB3YXJuT25jZShtZXNzYWdlKSB7XG4gICAgaWYgKCF3YXJuZWRNZXNzYWdlc1ttZXNzYWdlXSkge1xuICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgIHdhcm5lZE1lc3NhZ2VzW21lc3NhZ2VdID0gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpcE5vbkFscGhhbnVtZXJpYyhpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9bLTouXS9nLCBcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdChlcG9jaCwgcnVuSWQpIHtcbiAgICByZXR1cm4gKHN0cmlwTm9uQWxwaGFudW1lcmljKGAke25ldyBEYXRlKGVwb2NoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIC0xKX0wMDBaYCkgK1xuICAgICAgICBydW5JZCk7XG59XG5leHBvcnQgY2xhc3MgUnVuVHJlZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVuX3R5cGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvamVjdF9uYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhcmVudF9ydW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hpbGRfcnVuc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFydF90aW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuZF90aW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4dHJhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVycm9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlcmlhbGl6ZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5wdXRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm91dHB1dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVmZXJlbmNlX2V4YW1wbGVfaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xpZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV2ZW50c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFjZV9pZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb3R0ZWRfb3JkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IFJ1blRyZWUuZ2V0RGVmYXVsdENvbmZpZygpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgLi4uZGVmYXVsdENvbmZpZywgLi4uY29uZmlnIH0pO1xuICAgICAgICBpZiAoIXRoaXMudHJhY2VfaWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudF9ydW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlX2lkID0gdGhpcy5wYXJlbnRfcnVuLnRyYWNlX2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZV9pZCA9IHRoaXMuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmRvdHRlZF9vcmRlcikge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudERvdHRlZE9yZGVyID0gY29udmVydFRvRG90dGVkT3JkZXJGb3JtYXQodGhpcy5zdGFydF90aW1lLCB0aGlzLmlkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudF9ydW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvdHRlZF9vcmRlciA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50X3J1bi5kb3R0ZWRfb3JkZXIgKyBcIi5cIiArIGN1cnJlbnREb3R0ZWRPcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG90dGVkX29yZGVyID0gY3VycmVudERvdHRlZE9yZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0Q29uZmlnKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHV1aWQudjQoKSxcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9QUk9KRUNUXCIpID8/XG4gICAgICAgICAgICAgICAgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9TRVNTSU9OXCIpID8/IC8vIFRPRE86IERlcHJlY2F0ZVxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBhcGlfdXJsOiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0VORFBPSU5UXCIpID8/IFwiaHR0cDovL2xvY2FsaG9zdDoxOTg0XCIsXG4gICAgICAgICAgICBhcGlfa2V5OiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0FQSV9LRVlcIiksXG4gICAgICAgICAgICBjYWxsZXJfb3B0aW9uczoge30sXG4gICAgICAgICAgICBzdGFydF90aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgc2VyaWFsaXplZDoge30sXG4gICAgICAgICAgICBpbnB1dHM6IHt9LFxuICAgICAgICAgICAgZXh0cmE6IHt9LFxuICAgICAgICAgICAgY2xpZW50OiBuZXcgQ2xpZW50KHt9KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlQ2hpbGQoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbmV3IFJ1blRyZWUoe1xuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgcGFyZW50X3J1bjogdGhpcyxcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogdGhpcy5wcm9qZWN0X25hbWUsXG4gICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaGlsZF9ydW5zLnB1c2goY2hpbGQpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIGFzeW5jIGVuZChvdXRwdXRzLCBlcnJvciwgZW5kVGltZSA9IERhdGUubm93KCkpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLmVuZF90aW1lID0gZW5kVGltZTtcbiAgICB9XG4gICAgYXN5bmMgX2NvbnZlcnRUb0NyZWF0ZShydW4sIGV4Y2x1ZGVDaGlsZFJ1bnMgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHJ1bkV4dHJhID0gcnVuLmV4dHJhID8/IHt9O1xuICAgICAgICBpZiAoIXJ1bkV4dHJhLnJ1bnRpbWUpIHtcbiAgICAgICAgICAgIHJ1bkV4dHJhLnJ1bnRpbWUgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW50aW1lRW52ID0gYXdhaXQgZ2V0UnVudGltZUVudmlyb25tZW50KCk7XG4gICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHJ1bnRpbWVFbnYpKSB7XG4gICAgICAgICAgICBpZiAoIXJ1bkV4dHJhLnJ1bnRpbWVba10pIHtcbiAgICAgICAgICAgICAgICBydW5FeHRyYS5ydW50aW1lW2tdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGRfcnVucztcbiAgICAgICAgbGV0IHBhcmVudF9ydW5faWQ7XG4gICAgICAgIGlmICghZXhjbHVkZUNoaWxkUnVucykge1xuICAgICAgICAgICAgY2hpbGRfcnVucyA9IGF3YWl0IFByb21pc2UuYWxsKHJ1bi5jaGlsZF9ydW5zLm1hcCgoY2hpbGRfcnVuKSA9PiB0aGlzLl9jb252ZXJ0VG9DcmVhdGUoY2hpbGRfcnVuLCBleGNsdWRlQ2hpbGRSdW5zKSkpO1xuICAgICAgICAgICAgcGFyZW50X3J1bl9pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQgPSBydW4ucGFyZW50X3J1bj8uaWQ7XG4gICAgICAgICAgICBjaGlsZF9ydW5zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGVyc2lzdGVkUnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIG5hbWU6IHJ1bi5uYW1lLFxuICAgICAgICAgICAgc3RhcnRfdGltZTogcnVuLnN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBlbmRfdGltZTogcnVuLmVuZF90aW1lLFxuICAgICAgICAgICAgcnVuX3R5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlX2lkOiBydW4ucmVmZXJlbmNlX2V4YW1wbGVfaWQsXG4gICAgICAgICAgICBleHRyYTogcnVuRXh0cmEsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiBydW4uc2VyaWFsaXplZCxcbiAgICAgICAgICAgIGVycm9yOiBydW4uZXJyb3IsXG4gICAgICAgICAgICBpbnB1dHM6IHJ1bi5pbnB1dHMsXG4gICAgICAgICAgICBvdXRwdXRzOiBydW4ub3V0cHV0cyxcbiAgICAgICAgICAgIHNlc3Npb25fbmFtZTogcnVuLnByb2plY3RfbmFtZSxcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IGNoaWxkX3J1bnMsXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRfcnVuX2lkLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGVyc2lzdGVkUnVuO1xuICAgIH1cbiAgICBhc3luYyBwb3N0UnVuKGV4Y2x1ZGVDaGlsZFJ1bnMgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHJ1bkNyZWF0ZSA9IGF3YWl0IHRoaXMuX2NvbnZlcnRUb0NyZWF0ZSh0aGlzLCB0cnVlKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQuY3JlYXRlUnVuKHJ1bkNyZWF0ZSk7XG4gICAgICAgIGlmICghZXhjbHVkZUNoaWxkUnVucykge1xuICAgICAgICAgICAgd2Fybk9uY2UoXCJQb3N0aW5nIHdpdGggZXhjbHVkZUNoaWxkUnVucz1mYWxzZSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkUnVuIG9mIHRoaXMuY2hpbGRfcnVucykge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNoaWxkUnVuLnBvc3RSdW4oZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhdGNoUnVuKCkge1xuICAgICAgICBjb25zdCBydW5VcGRhdGUgPSB7XG4gICAgICAgICAgICBlbmRfdGltZTogdGhpcy5lbmRfdGltZSxcbiAgICAgICAgICAgIGVycm9yOiB0aGlzLmVycm9yLFxuICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogdGhpcy5wYXJlbnRfcnVuPy5pZCxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlX2lkOiB0aGlzLnJlZmVyZW5jZV9leGFtcGxlX2lkLFxuICAgICAgICAgICAgZXh0cmE6IHRoaXMuZXh0cmEsXG4gICAgICAgICAgICBldmVudHM6IHRoaXMuZXZlbnRzLFxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC51cGRhdGVSdW4odGhpcy5pZCwgcnVuVXBkYXRlKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsidXVpZCIsImdldEVudmlyb25tZW50VmFyaWFibGUiLCJnZXRSdW50aW1lRW52aXJvbm1lbnQiLCJDbGllbnQiLCJ3YXJuZWRNZXNzYWdlcyIsIndhcm5PbmNlIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwic3RyaXBOb25BbHBoYW51bWVyaWMiLCJpbnB1dCIsInJlcGxhY2UiLCJjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdCIsImVwb2NoIiwicnVuSWQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzbGljZSIsIlJ1blRyZWUiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJkZWZhdWx0Q29uZmlnIiwiZ2V0RGVmYXVsdENvbmZpZyIsImFzc2lnbiIsInRyYWNlX2lkIiwicGFyZW50X3J1biIsImlkIiwiZG90dGVkX29yZGVyIiwiY3VycmVudERvdHRlZE9yZGVyIiwic3RhcnRfdGltZSIsInY0IiwicHJvamVjdF9uYW1lIiwiY2hpbGRfcnVucyIsImFwaV91cmwiLCJhcGlfa2V5IiwiY2FsbGVyX29wdGlvbnMiLCJub3ciLCJzZXJpYWxpemVkIiwiaW5wdXRzIiwiZXh0cmEiLCJjbGllbnQiLCJjcmVhdGVDaGlsZCIsImNoaWxkIiwicHVzaCIsImVuZCIsIm91dHB1dHMiLCJlcnJvciIsImVuZFRpbWUiLCJlbmRfdGltZSIsIl9jb252ZXJ0VG9DcmVhdGUiLCJydW4iLCJleGNsdWRlQ2hpbGRSdW5zIiwicnVuRXh0cmEiLCJydW50aW1lIiwicnVudGltZUVudiIsImsiLCJ2IiwiZW50cmllcyIsInBhcmVudF9ydW5faWQiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiY2hpbGRfcnVuIiwidW5kZWZpbmVkIiwicGVyc2lzdGVkUnVuIiwibmFtZSIsInJ1bl90eXBlIiwicmVmZXJlbmNlX2V4YW1wbGVfaWQiLCJzZXNzaW9uX25hbWUiLCJwb3N0UnVuIiwicnVuQ3JlYXRlIiwiY3JlYXRlUnVuIiwiY2hpbGRSdW4iLCJwYXRjaFJ1biIsInJ1blVwZGF0ZSIsImV2ZW50cyIsInVwZGF0ZVJ1biJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/run_trees.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/async_caller.js":
/*!***********************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/async_caller.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\");\n\n\nconst STATUS_NO_RETRY = [\n    400,\n    401,\n    403,\n    404,\n    405,\n    406,\n    407,\n    408\n];\nconst STATUS_IGNORE = [\n    409\n];\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */ class AsyncCaller {\n    constructor(params){\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        const PQueue =  true ? p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"] : p_queue__WEBPACK_IMPORTED_MODULE_1__;\n        this.queue = new PQueue({\n            concurrency: this.maxConcurrency\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        return this.queue.add(()=>p_retry__WEBPACK_IMPORTED_MODULE_0__(()=>callable(...args).catch((error)=>{\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (error instanceof Error) {\n                        throw error;\n                    } else {\n                        throw new Error(error);\n                    }\n                }), {\n                onFailedAttempt (error) {\n                    if (error.message.startsWith(\"Cancel\") || error.message.startsWith(\"TimeoutError\") || error.message.startsWith(\"AbortError\")) {\n                        throw error;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    if (error?.code === \"ECONNABORTED\") {\n                        throw error;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const status = error?.response?.status;\n                    if (status) {\n                        if (STATUS_NO_RETRY.includes(+status)) {\n                            throw error;\n                        } else if (STATUS_IGNORE.includes(+status)) {\n                            return;\n                        }\n                    }\n                },\n                retries: this.maxRetries,\n                randomize: true\n            }), {\n            throwOnTimeout: true\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject)=>{\n                    options.signal?.addEventListener(\"abort\", ()=>{\n                        reject(new Error(\"AbortError\"));\n                    });\n                })\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        return this.call(()=>fetch(...args).then((res)=>res.ok ? res : Promise.reject(res)));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2QjtBQUNHO0FBQ2hDLE1BQU1FLGtCQUFrQjtJQUNwQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxNQUFNQyxnQkFBZ0I7SUFDbEI7Q0FDSDtBQUNEOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLE1BQU1DO0lBQ1RDLFlBQVlDLE1BQU0sQ0FBRTtRQUNoQkMsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxrQkFBa0I7WUFDMUNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7WUFDdENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFNBQVM7WUFDakNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBLElBQUksQ0FBQ0MsY0FBYyxHQUFHUCxPQUFPTyxjQUFjLElBQUlDO1FBQy9DLElBQUksQ0FBQ0MsVUFBVSxHQUFHVCxPQUFPUyxVQUFVLElBQUk7UUFDdkMsTUFBTUMsU0FBUyxLQUFzQmYsR0FBR0EsK0NBQWlCLEdBQUdBLG9DQUFTQTtRQUNyRSxJQUFJLENBQUNpQixLQUFLLEdBQUcsSUFBSUYsT0FBTztZQUFFRyxhQUFhLElBQUksQ0FBQ04sY0FBYztRQUFDO0lBQy9EO0lBQ0EsOERBQThEO0lBQzlETyxLQUFLQyxRQUFRLEVBQUUsR0FBR0MsSUFBSSxFQUFFO1FBQ3BCLE9BQU8sSUFBSSxDQUFDSixLQUFLLENBQUNLLEdBQUcsQ0FBQyxJQUFNdkIsb0NBQU1BLENBQUMsSUFBTXFCLFlBQVlDLE1BQU1FLEtBQUssQ0FBQyxDQUFDQztvQkFDOUQsdURBQXVEO29CQUN2RCxJQUFJQSxpQkFBaUJDLE9BQU87d0JBQ3hCLE1BQU1EO29CQUNWLE9BQ0s7d0JBQ0QsTUFBTSxJQUFJQyxNQUFNRDtvQkFDcEI7Z0JBQ0osSUFBSTtnQkFDQUUsaUJBQWdCRixLQUFLO29CQUNqQixJQUFJQSxNQUFNRyxPQUFPLENBQUNDLFVBQVUsQ0FBQyxhQUN6QkosTUFBTUcsT0FBTyxDQUFDQyxVQUFVLENBQUMsbUJBQ3pCSixNQUFNRyxPQUFPLENBQUNDLFVBQVUsQ0FBQyxlQUFlO3dCQUN4QyxNQUFNSjtvQkFDVjtvQkFDQSw4REFBOEQ7b0JBQzlELElBQUlBLE9BQU9LLFNBQVMsZ0JBQWdCO3dCQUNoQyxNQUFNTDtvQkFDVjtvQkFDQSw4REFBOEQ7b0JBQzlELE1BQU1NLFNBQVNOLE9BQU9PLFVBQVVEO29CQUNoQyxJQUFJQSxRQUFRO3dCQUNSLElBQUk3QixnQkFBZ0IrQixRQUFRLENBQUMsQ0FBQ0YsU0FBUzs0QkFDbkMsTUFBTU47d0JBQ1YsT0FDSyxJQUFJdEIsY0FBYzhCLFFBQVEsQ0FBQyxDQUFDRixTQUFTOzRCQUN0Qzt3QkFDSjtvQkFDSjtnQkFDSjtnQkFDQUcsU0FBUyxJQUFJLENBQUNuQixVQUFVO2dCQUN4Qm9CLFdBQVc7WUFHZixJQUFJO1lBQUVDLGdCQUFnQjtRQUFLO0lBQy9CO0lBQ0EsOERBQThEO0lBQzlEQyxnQkFBZ0JDLE9BQU8sRUFBRWpCLFFBQVEsRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDeEMsbURBQW1EO1FBQ25ELHdFQUF3RTtRQUN4RSxJQUFJZ0IsUUFBUUMsTUFBTSxFQUFFO1lBQ2hCLE9BQU9DLFFBQVFDLElBQUksQ0FBQztnQkFDaEIsSUFBSSxDQUFDckIsSUFBSSxDQUFDQyxhQUFhQztnQkFDdkIsSUFBSWtCLFFBQVEsQ0FBQ0UsR0FBR0M7b0JBQ1pMLFFBQVFDLE1BQU0sRUFBRUssaUJBQWlCLFNBQVM7d0JBQ3RDRCxPQUFPLElBQUlqQixNQUFNO29CQUNyQjtnQkFDSjthQUNIO1FBQ0w7UUFDQSxPQUFPLElBQUksQ0FBQ04sSUFBSSxDQUFDQyxhQUFhQztJQUNsQztJQUNBdUIsTUFBTSxHQUFHdkIsSUFBSSxFQUFFO1FBQ1gsT0FBTyxJQUFJLENBQUNGLElBQUksQ0FBQyxJQUFNeUIsU0FBU3ZCLE1BQU13QixJQUFJLENBQUMsQ0FBQ0MsTUFBU0EsSUFBSUMsRUFBRSxHQUFHRCxNQUFNUCxRQUFRRyxNQUFNLENBQUNJO0lBQ3ZGO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zeW5jY2hhdC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9hc3luY19jYWxsZXIuanM/YThkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcFJldHJ5IGZyb20gXCJwLXJldHJ5XCI7XG5pbXBvcnQgUFF1ZXVlTW9kIGZyb20gXCJwLXF1ZXVlXCI7XG5jb25zdCBTVEFUVVNfTk9fUkVUUlkgPSBbXG4gICAgNDAwLFxuICAgIDQwMSxcbiAgICA0MDMsXG4gICAgNDA0LFxuICAgIDQwNSxcbiAgICA0MDYsXG4gICAgNDA3LFxuICAgIDQwOCwgLy8gUmVxdWVzdCBUaW1lb3V0XG5dO1xuY29uc3QgU1RBVFVTX0lHTk9SRSA9IFtcbiAgICA0MDksIC8vIENvbmZsaWN0XG5dO1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFrZSBhc3luYyBjYWxscyB3aXRoIGNvbmN1cnJlbmN5IGFuZCByZXRyeSBsb2dpYy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgbWFraW5nIGNhbGxzIHRvIGFueSBraW5kIG9mIFwiZXhwZW5zaXZlXCIgZXh0ZXJuYWwgcmVzb3VyY2UsXG4gKiBiZSBpdCBiZWNhdXNlIGl0J3MgcmF0ZS1saW1pdGVkLCBzdWJqZWN0IHRvIG5ldHdvcmsgaXNzdWVzLCBldGMuXG4gKlxuICogQ29uY3VycmVudCBjYWxscyBhcmUgbGltaXRlZCBieSB0aGUgYG1heENvbmN1cnJlbmN5YCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzXG4gKiB0byBgSW5maW5pdHlgLiBUaGlzIG1lYW5zIHRoYXQgYnkgZGVmYXVsdCwgYWxsIGNhbGxzIHdpbGwgYmUgbWFkZSBpbiBwYXJhbGxlbC5cbiAqXG4gKiBSZXRyaWVzIGFyZSBsaW1pdGVkIGJ5IHRoZSBgbWF4UmV0cmllc2AgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0cyB0byA2LiBUaGlzXG4gKiBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGVhY2ggY2FsbCB3aWxsIGJlIHJldHJpZWQgdXAgdG8gNiB0aW1lcywgd2l0aCBhblxuICogZXhwb25lbnRpYWwgYmFja29mZiBiZXR3ZWVuIGVhY2ggYXR0ZW1wdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEFzeW5jQ2FsbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4Q29uY3VycmVuY3lcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4UmV0cmllc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJxdWV1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heENvbmN1cnJlbmN5ID0gcGFyYW1zLm1heENvbmN1cnJlbmN5ID8/IEluZmluaXR5O1xuICAgICAgICB0aGlzLm1heFJldHJpZXMgPSBwYXJhbXMubWF4UmV0cmllcyA/PyA2O1xuICAgICAgICBjb25zdCBQUXVldWUgPSBcImRlZmF1bHRcIiBpbiBQUXVldWVNb2QgPyBQUXVldWVNb2QuZGVmYXVsdCA6IFBRdWV1ZU1vZDtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQUXVldWUoeyBjb25jdXJyZW5jeTogdGhpcy5tYXhDb25jdXJyZW5jeSB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLmFkZCgoKSA9PiBwUmV0cnkoKCkgPT4gY2FsbGFibGUoLi4uYXJncykuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgIG9uRmFpbGVkQXR0ZW1wdChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJDYW5jZWxcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiVGltZW91dEVycm9yXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkFib3J0RXJyb3JcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yPy5jb2RlID09PSBcIkVDT05OQUJPUlRFRFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGVycm9yPy5yZXNwb25zZT8uc3RhdHVzO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFNUQVRVU19OT19SRVRSWS5pbmNsdWRlcygrc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoU1RBVFVTX0lHTk9SRS5pbmNsdWRlcygrc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHJpZXM6IHRoaXMubWF4UmV0cmllcyxcbiAgICAgICAgICAgIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgICAgICAgICAgIC8vIElmIG5lZWRlZCB3ZSBjYW4gY2hhbmdlIHNvbWUgb2YgdGhlIGRlZmF1bHRzIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgdGhleSdyZSBxdWl0ZSBzZW5zaWJsZS5cbiAgICAgICAgfSksIHsgdGhyb3dPblRpbWVvdXQ6IHRydWUgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbFdpdGhPcHRpb25zKG9wdGlvbnMsIGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIE5vdGUgdGhpcyBkb2Vzbid0IGNhbmNlbCB0aGUgdW5kZXJseWluZyByZXF1ZXN0LFxuICAgICAgICAvLyB3aGVuIGF2YWlsYWJsZSBwcmVmZXIgdG8gdXNlIHRoZSBzaWduYWwgb3B0aW9uIG9mIHRoZSB1bmRlcmx5aW5nIGNhbGxcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpLFxuICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQWJvcnRFcnJvclwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbChjYWxsYWJsZSwgLi4uYXJncyk7XG4gICAgfVxuICAgIGZldGNoKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbCgoKSA9PiBmZXRjaCguLi5hcmdzKS50aGVuKChyZXMpID0+IChyZXMub2sgPyByZXMgOiBQcm9taXNlLnJlamVjdChyZXMpKSkpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJwUmV0cnkiLCJQUXVldWVNb2QiLCJTVEFUVVNfTk9fUkVUUlkiLCJTVEFUVVNfSUdOT1JFIiwiQXN5bmNDYWxsZXIiLCJjb25zdHJ1Y3RvciIsInBhcmFtcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJtYXhDb25jdXJyZW5jeSIsIkluZmluaXR5IiwibWF4UmV0cmllcyIsIlBRdWV1ZSIsImRlZmF1bHQiLCJxdWV1ZSIsImNvbmN1cnJlbmN5IiwiY2FsbCIsImNhbGxhYmxlIiwiYXJncyIsImFkZCIsImNhdGNoIiwiZXJyb3IiLCJFcnJvciIsIm9uRmFpbGVkQXR0ZW1wdCIsIm1lc3NhZ2UiLCJzdGFydHNXaXRoIiwiY29kZSIsInN0YXR1cyIsInJlc3BvbnNlIiwiaW5jbHVkZXMiLCJyZXRyaWVzIiwicmFuZG9taXplIiwidGhyb3dPblRpbWVvdXQiLCJjYWxsV2l0aE9wdGlvbnMiLCJvcHRpb25zIiwic2lnbmFsIiwiUHJvbWlzZSIsInJhY2UiLCJfIiwicmVqZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImZldGNoIiwidGhlbiIsInJlcyIsIm9rIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/env.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/env.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnv: () => (/* binding */ getEnv),\n/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable),\n/* harmony export */   getEnvironmentVariables: () => (/* binding */ getEnvironmentVariables),\n/* harmony export */   getLangChainEnvVars: () => (/* binding */ getLangChainEnvVars),\n/* harmony export */   getLangChainEnvVarsMetadata: () => (/* binding */ getLangChainEnvVarsMetadata),\n/* harmony export */   getRuntimeEnvironment: () => (/* binding */ getRuntimeEnvironment),\n/* harmony export */   getShas: () => (/* binding */ getShas),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isDeno: () => (/* binding */ isDeno),\n/* harmony export */   isJsDom: () => (/* binding */ isJsDom),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   setEnvironmentVariable: () => (/* binding */ setEnvironmentVariable)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n// Inlined from https://github.com/flexdinesh/browser-or-node\n\nlet globalEnv;\nconst isBrowser = ()=> false && 0;\nconst isWebWorker = ()=>typeof globalThis === \"object\" && globalThis.constructor && globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nconst isJsDom = ()=> false || typeof navigator !== \"undefined\" && (navigator.userAgent.includes(\"Node.js\") || navigator.userAgent.includes(\"jsdom\"));\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nconst isDeno = ()=>typeof Deno !== \"undefined\";\n// Mark not-as-node if in Supabase Edge Function\nconst isNode = ()=>typeof process !== \"undefined\" && typeof process.versions !== \"undefined\" && typeof process.versions.node !== \"undefined\" && !isDeno();\nconst getEnv = ()=>{\n    if (globalEnv) {\n        return globalEnv;\n    }\n    if (isBrowser()) {\n        globalEnv = \"browser\";\n    } else if (isNode()) {\n        globalEnv = \"node\";\n    } else if (isWebWorker()) {\n        globalEnv = \"webworker\";\n    } else if (isJsDom()) {\n        globalEnv = \"jsdom\";\n    } else if (isDeno()) {\n        globalEnv = \"deno\";\n    } else {\n        globalEnv = \"other\";\n    }\n    return globalEnv;\n};\nlet runtimeEnvironment;\nasync function getRuntimeEnvironment() {\n    if (runtimeEnvironment === undefined) {\n        const env = getEnv();\n        const releaseEnv = getShas();\n        runtimeEnvironment = {\n            library: \"langsmith\",\n            runtime: env,\n            sdk: \"langsmith-js\",\n            sdk_version: _index_js__WEBPACK_IMPORTED_MODULE_0__.__version__,\n            ...releaseEnv\n        };\n    }\n    return runtimeEnvironment;\n}\n/**\n * Retrieves the LangChain-specific environment variables from the current runtime environment.\n * Sensitive keys (containing the word \"key\", \"token\", or \"secret\") have their values redacted for security.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain-specific environment variables.\n */ function getLangChainEnvVars() {\n    const allEnvVars = getEnvironmentVariables() || {};\n    const envVars = {};\n    for (const [key, value] of Object.entries(allEnvVars)){\n        if (key.startsWith(\"LANGCHAIN_\") && typeof value === \"string\") {\n            envVars[key] = value;\n        }\n    }\n    for(const key in envVars){\n        if ((key.toLowerCase().includes(\"key\") || key.toLowerCase().includes(\"secret\") || key.toLowerCase().includes(\"token\")) && typeof envVars[key] === \"string\") {\n            const value = envVars[key];\n            envVars[key] = value.slice(0, 2) + \"*\".repeat(value.length - 4) + value.slice(-2);\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves the LangChain-specific metadata from the current runtime environment.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain-specific metadata environment variables.\n */ function getLangChainEnvVarsMetadata() {\n    const allEnvVars = getEnvironmentVariables() || {};\n    const envVars = {};\n    const excluded = [\n        \"LANGCHAIN_API_KEY\",\n        \"LANGCHAIN_ENDPOINT\",\n        \"LANGCHAIN_TRACING_V2\",\n        \"LANGCHAIN_PROJECT\",\n        \"LANGCHAIN_SESSION\"\n    ];\n    for (const [key, value] of Object.entries(allEnvVars)){\n        if (key.startsWith(\"LANGCHAIN_\") && typeof value === \"string\" && !excluded.includes(key) && !key.toLowerCase().includes(\"key\") && !key.toLowerCase().includes(\"secret\") && !key.toLowerCase().includes(\"token\")) {\n            if (key === \"LANGCHAIN_REVISION_ID\") {\n                envVars[\"revision_id\"] = value;\n            } else {\n                envVars[key] = value;\n            }\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves the environment variables from the current runtime environment.\n *\n * This function is designed to operate in a variety of JS environments,\n * including Node.js, Deno, browsers, etc.\n *\n * @returns {Record<string, string> | undefined}\n *  - A record of environment variables if available.\n *  - `undefined` if the environment does not support or allows access to environment variables.\n */ function getEnvironmentVariables() {\n    try {\n        // Check for Node.js environment\n        // eslint-disable-next-line no-process-env\n        if (typeof process !== \"undefined\" && process.env) {\n            // eslint-disable-next-line no-process-env\n            return Object.entries(process.env).reduce((acc, [key, value])=>{\n                acc[key] = String(value);\n                return acc;\n            }, {});\n        }\n        // For browsers and other environments, we may not have direct access to env variables\n        // Return undefined or any other fallback as required.\n        return undefined;\n    } catch (e) {\n        // Catch any errors that might occur while trying to access environment variables\n        return undefined;\n    }\n}\nfunction getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/hwchase17/langchainjs/issues/1412\n    try {\n        return typeof process !== \"undefined\" ? process.env?.[name] : undefined;\n    } catch (e) {\n        return undefined;\n    }\n}\nfunction setEnvironmentVariable(name, value) {\n    if (typeof process !== \"undefined\") {\n        // eslint-disable-next-line no-process-env\n        process.env[name] = value;\n    }\n}\nlet cachedCommitSHAs;\n/**\n * Get the Git commit SHA from common environment variables\n * used by different CI/CD platforms.\n * @returns {string | undefined} The Git commit SHA or undefined if not found.\n */ function getShas() {\n    if (cachedCommitSHAs !== undefined) {\n        return cachedCommitSHAs;\n    }\n    const common_release_envs = [\n        \"VERCEL_GIT_COMMIT_SHA\",\n        \"NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA\",\n        \"COMMIT_REF\",\n        \"RENDER_GIT_COMMIT\",\n        \"CI_COMMIT_SHA\",\n        \"CIRCLE_SHA1\",\n        \"CF_PAGES_COMMIT_SHA\",\n        \"REACT_APP_GIT_SHA\",\n        \"SOURCE_VERSION\",\n        \"GITHUB_SHA\",\n        \"TRAVIS_COMMIT\",\n        \"GIT_COMMIT\",\n        \"BUILD_VCS_NUMBER\",\n        \"bamboo_planRepository_revision\",\n        \"Build.SourceVersion\",\n        \"BITBUCKET_COMMIT\",\n        \"DRONE_COMMIT_SHA\",\n        \"SEMAPHORE_GIT_SHA\",\n        \"BUILDKITE_COMMIT\"\n    ];\n    const shas = {};\n    for (const env of common_release_envs){\n        const envVar = getEnvironmentVariable(env);\n        if (envVar !== undefined) {\n            shas[env] = envVar;\n        }\n    }\n    cachedCommitSHAs = shas;\n    return shas;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNkRBQTZEO0FBQ25CO0FBQzFDLElBQUlDO0FBQ0csTUFBTUMsWUFBWSxJQUFNLE1BQTZCLElBQUksQ0FBc0MsQ0FBQztBQUNoRyxNQUFNRyxjQUFjLElBQU0sT0FBT0MsZUFBZSxZQUNuREEsV0FBV0MsV0FBVyxJQUN0QkQsV0FBV0MsV0FBVyxDQUFDQyxJQUFJLEtBQUssNkJBQTZCO0FBQzFELE1BQU1DLFVBQVUsSUFBTSxNQUEwRCxJQUNsRixPQUFPQyxjQUFjLGVBQ2pCQSxDQUFBQSxVQUFVQyxTQUFTLENBQUNDLFFBQVEsQ0FBQyxjQUMxQkYsVUFBVUMsU0FBUyxDQUFDQyxRQUFRLENBQUMsUUFBTyxFQUFJO0FBQ3BELHlEQUF5RDtBQUN6RCw2QkFBNkI7QUFDdEIsTUFBTUMsU0FBUyxJQUFNLE9BQU9DLFNBQVMsWUFBWTtBQUN4RCxnREFBZ0Q7QUFDekMsTUFBTUMsU0FBUyxJQUFNLE9BQU9DLFlBQVksZUFDM0MsT0FBT0EsUUFBUUMsUUFBUSxLQUFLLGVBQzVCLE9BQU9ELFFBQVFDLFFBQVEsQ0FBQ0MsSUFBSSxLQUFLLGVBQ2pDLENBQUNMLFNBQVM7QUFDUCxNQUFNTSxTQUFTO0lBQ2xCLElBQUlsQixXQUFXO1FBQ1gsT0FBT0E7SUFDWDtJQUNBLElBQUlDLGFBQWE7UUFDYkQsWUFBWTtJQUNoQixPQUNLLElBQUljLFVBQVU7UUFDZmQsWUFBWTtJQUNoQixPQUNLLElBQUlJLGVBQWU7UUFDcEJKLFlBQVk7SUFDaEIsT0FDSyxJQUFJUSxXQUFXO1FBQ2hCUixZQUFZO0lBQ2hCLE9BQ0ssSUFBSVksVUFBVTtRQUNmWixZQUFZO0lBQ2hCLE9BQ0s7UUFDREEsWUFBWTtJQUNoQjtJQUNBLE9BQU9BO0FBQ1gsRUFBRTtBQUNGLElBQUltQjtBQUNHLGVBQWVDO0lBQ2xCLElBQUlELHVCQUF1QkUsV0FBVztRQUNsQyxNQUFNQyxNQUFNSjtRQUNaLE1BQU1LLGFBQWFDO1FBQ25CTCxxQkFBcUI7WUFDakJNLFNBQVM7WUFDVEMsU0FBU0o7WUFDVEssS0FBSztZQUNMQyxhQUFhN0Isa0RBQVdBO1lBQ3hCLEdBQUd3QixVQUFVO1FBQ2pCO0lBQ0o7SUFDQSxPQUFPSjtBQUNYO0FBQ0E7Ozs7OztDQU1DLEdBQ00sU0FBU1U7SUFDWixNQUFNQyxhQUFhQyw2QkFBNkIsQ0FBQztJQUNqRCxNQUFNQyxVQUFVLENBQUM7SUFDakIsS0FBSyxNQUFNLENBQUNDLEtBQUtDLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDTixZQUFhO1FBQ25ELElBQUlHLElBQUlJLFVBQVUsQ0FBQyxpQkFBaUIsT0FBT0gsVUFBVSxVQUFVO1lBQzNERixPQUFPLENBQUNDLElBQUksR0FBR0M7UUFDbkI7SUFDSjtJQUNBLElBQUssTUFBTUQsT0FBT0QsUUFBUztRQUN2QixJQUFJLENBQUNDLElBQUlLLFdBQVcsR0FBRzNCLFFBQVEsQ0FBQyxVQUM1QnNCLElBQUlLLFdBQVcsR0FBRzNCLFFBQVEsQ0FBQyxhQUMzQnNCLElBQUlLLFdBQVcsR0FBRzNCLFFBQVEsQ0FBQyxRQUFPLEtBQ2xDLE9BQU9xQixPQUFPLENBQUNDLElBQUksS0FBSyxVQUFVO1lBQ2xDLE1BQU1DLFFBQVFGLE9BQU8sQ0FBQ0MsSUFBSTtZQUMxQkQsT0FBTyxDQUFDQyxJQUFJLEdBQ1JDLE1BQU1LLEtBQUssQ0FBQyxHQUFHLEtBQUssSUFBSUMsTUFBTSxDQUFDTixNQUFNTyxNQUFNLEdBQUcsS0FBS1AsTUFBTUssS0FBSyxDQUFDLENBQUM7UUFDeEU7SUFDSjtJQUNBLE9BQU9QO0FBQ1g7QUFDQTs7Ozs7Q0FLQyxHQUNNLFNBQVNVO0lBQ1osTUFBTVosYUFBYUMsNkJBQTZCLENBQUM7SUFDakQsTUFBTUMsVUFBVSxDQUFDO0lBQ2pCLE1BQU1XLFdBQVc7UUFDYjtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxLQUFLLE1BQU0sQ0FBQ1YsS0FBS0MsTUFBTSxJQUFJQyxPQUFPQyxPQUFPLENBQUNOLFlBQWE7UUFDbkQsSUFBSUcsSUFBSUksVUFBVSxDQUFDLGlCQUNmLE9BQU9ILFVBQVUsWUFDakIsQ0FBQ1MsU0FBU2hDLFFBQVEsQ0FBQ3NCLFFBQ25CLENBQUNBLElBQUlLLFdBQVcsR0FBRzNCLFFBQVEsQ0FBQyxVQUM1QixDQUFDc0IsSUFBSUssV0FBVyxHQUFHM0IsUUFBUSxDQUFDLGFBQzVCLENBQUNzQixJQUFJSyxXQUFXLEdBQUczQixRQUFRLENBQUMsVUFBVTtZQUN0QyxJQUFJc0IsUUFBUSx5QkFBeUI7Z0JBQ2pDRCxPQUFPLENBQUMsY0FBYyxHQUFHRTtZQUM3QixPQUNLO2dCQUNERixPQUFPLENBQUNDLElBQUksR0FBR0M7WUFDbkI7UUFDSjtJQUNKO0lBQ0EsT0FBT0Y7QUFDWDtBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNNLFNBQVNEO0lBQ1osSUFBSTtRQUNBLGdDQUFnQztRQUNoQywwQ0FBMEM7UUFDMUMsSUFBSSxPQUFPaEIsWUFBWSxlQUFlQSxRQUFRTyxHQUFHLEVBQUU7WUFDL0MsMENBQTBDO1lBQzFDLE9BQU9hLE9BQU9DLE9BQU8sQ0FBQ3JCLFFBQVFPLEdBQUcsRUFBRXNCLE1BQU0sQ0FBQyxDQUFDQyxLQUFLLENBQUNaLEtBQUtDLE1BQU07Z0JBQ3hEVyxHQUFHLENBQUNaLElBQUksR0FBR2EsT0FBT1o7Z0JBQ2xCLE9BQU9XO1lBQ1gsR0FBRyxDQUFDO1FBQ1I7UUFDQSxzRkFBc0Y7UUFDdEYsc0RBQXNEO1FBQ3RELE9BQU94QjtJQUNYLEVBQ0EsT0FBTzBCLEdBQUc7UUFDTixpRkFBaUY7UUFDakYsT0FBTzFCO0lBQ1g7QUFDSjtBQUNPLFNBQVMyQix1QkFBdUJ6QyxJQUFJO0lBQ3ZDLHFGQUFxRjtJQUNyRix1REFBdUQ7SUFDdkQsSUFBSTtRQUNBLE9BQU8sT0FBT1EsWUFBWSxjQUVsQkEsUUFBUU8sR0FBRyxFQUFFLENBQUNmLEtBQUssR0FDckJjO0lBQ1YsRUFDQSxPQUFPMEIsR0FBRztRQUNOLE9BQU8xQjtJQUNYO0FBQ0o7QUFDTyxTQUFTNEIsdUJBQXVCMUMsSUFBSSxFQUFFMkIsS0FBSztJQUM5QyxJQUFJLE9BQU9uQixZQUFZLGFBQWE7UUFDaEMsMENBQTBDO1FBQzFDQSxRQUFRTyxHQUFHLENBQUNmLEtBQUssR0FBRzJCO0lBQ3hCO0FBQ0o7QUFDQSxJQUFJZ0I7QUFDSjs7OztDQUlDLEdBQ00sU0FBUzFCO0lBQ1osSUFBSTBCLHFCQUFxQjdCLFdBQVc7UUFDaEMsT0FBTzZCO0lBQ1g7SUFDQSxNQUFNQyxzQkFBc0I7UUFDeEI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU1DLE9BQU8sQ0FBQztJQUNkLEtBQUssTUFBTTlCLE9BQU82QixvQkFBcUI7UUFDbkMsTUFBTUUsU0FBU0wsdUJBQXVCMUI7UUFDdEMsSUFBSStCLFdBQVdoQyxXQUFXO1lBQ3RCK0IsSUFBSSxDQUFDOUIsSUFBSSxHQUFHK0I7UUFDaEI7SUFDSjtJQUNBSCxtQkFBbUJFO0lBQ25CLE9BQU9BO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zeW5jY2hhdC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9lbnYuanM/YTc0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbmxpbmVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZsZXhkaW5lc2gvYnJvd3Nlci1vci1ub2RlXG5pbXBvcnQgeyBfX3ZlcnNpb25fXyB9IGZyb20gXCIuLi9pbmRleC5qc1wiO1xubGV0IGdsb2JhbEVudjtcbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnQgY29uc3QgaXNXZWJXb3JrZXIgPSAoKSA9PiB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIiAmJlxuICAgIGdsb2JhbFRoaXMuY29uc3RydWN0b3IgJiZcbiAgICBnbG9iYWxUaGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVcIjtcbmV4cG9ydCBjb25zdCBpc0pzRG9tID0gKCkgPT4gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm5hbWUgPT09IFwibm9kZWpzXCIpIHx8XG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJOb2RlLmpzXCIpIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwianNkb21cIikpKTtcbi8vIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb24gcHJvdmlkZXMgYSBgRGVub2AgZ2xvYmFsIG9iamVjdFxuLy8gd2l0aG91dCBgdmVyc2lvbmAgcHJvcGVydHlcbmV4cG9ydCBjb25zdCBpc0Rlbm8gPSAoKSA9PiB0eXBlb2YgRGVubyAhPT0gXCJ1bmRlZmluZWRcIjtcbi8vIE1hcmsgbm90LWFzLW5vZGUgaWYgaW4gU3VwYWJhc2UgRWRnZSBGdW5jdGlvblxuZXhwb3J0IGNvbnN0IGlzTm9kZSA9ICgpID0+IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgIWlzRGVubygpO1xuZXhwb3J0IGNvbnN0IGdldEVudiA9ICgpID0+IHtcbiAgICBpZiAoZ2xvYmFsRW52KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxFbnY7XG4gICAgfVxuICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICBnbG9iYWxFbnYgPSBcImJyb3dzZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOb2RlKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJub2RlXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzV2ViV29ya2VyKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJ3ZWJ3b3JrZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNKc0RvbSgpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwianNkb21cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZW5vKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJkZW5vXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWxFbnYgPSBcIm90aGVyXCI7XG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxFbnY7XG59O1xubGV0IHJ1bnRpbWVFbnZpcm9ubWVudDtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSdW50aW1lRW52aXJvbm1lbnQoKSB7XG4gICAgaWYgKHJ1bnRpbWVFbnZpcm9ubWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGVudiA9IGdldEVudigpO1xuICAgICAgICBjb25zdCByZWxlYXNlRW52ID0gZ2V0U2hhcygpO1xuICAgICAgICBydW50aW1lRW52aXJvbm1lbnQgPSB7XG4gICAgICAgICAgICBsaWJyYXJ5OiBcImxhbmdzbWl0aFwiLFxuICAgICAgICAgICAgcnVudGltZTogZW52LFxuICAgICAgICAgICAgc2RrOiBcImxhbmdzbWl0aC1qc1wiLFxuICAgICAgICAgICAgc2RrX3ZlcnNpb246IF9fdmVyc2lvbl9fLFxuICAgICAgICAgICAgLi4ucmVsZWFzZUVudixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bnRpbWVFbnZpcm9ubWVudDtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBMYW5nQ2hhaW4tc3BlY2lmaWMgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZyb20gdGhlIGN1cnJlbnQgcnVudGltZSBlbnZpcm9ubWVudC5cbiAqIFNlbnNpdGl2ZSBrZXlzIChjb250YWluaW5nIHRoZSB3b3JkIFwia2V5XCIsIFwidG9rZW5cIiwgb3IgXCJzZWNyZXRcIikgaGF2ZSB0aGVpciB2YWx1ZXMgcmVkYWN0ZWQgZm9yIHNlY3VyaXR5LlxuICpcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICogIC0gQSByZWNvcmQgb2YgTGFuZ0NoYWluLXNwZWNpZmljIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmdDaGFpbkVudlZhcnMoKSB7XG4gICAgY29uc3QgYWxsRW52VmFycyA9IGdldEVudmlyb25tZW50VmFyaWFibGVzKCkgfHwge307XG4gICAgY29uc3QgZW52VmFycyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFsbEVudlZhcnMpKSB7XG4gICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIkxBTkdDSEFJTl9cIikgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBlbnZWYXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBlbnZWYXJzKSB7XG4gICAgICAgIGlmICgoa2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJrZXlcIikgfHxcbiAgICAgICAgICAgIGtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwic2VjcmV0XCIpIHx8XG4gICAgICAgICAgICBrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInRva2VuXCIpKSAmJlxuICAgICAgICAgICAgdHlwZW9mIGVudlZhcnNba2V5XSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbnZWYXJzW2tleV07XG4gICAgICAgICAgICBlbnZWYXJzW2tleV0gPVxuICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKDAsIDIpICsgXCIqXCIucmVwZWF0KHZhbHVlLmxlbmd0aCAtIDQpICsgdmFsdWUuc2xpY2UoLTIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbnZWYXJzO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIExhbmdDaGFpbi1zcGVjaWZpYyBtZXRhZGF0YSBmcm9tIHRoZSBjdXJyZW50IHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKiAgLSBBIHJlY29yZCBvZiBMYW5nQ2hhaW4tc3BlY2lmaWMgbWV0YWRhdGEgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGFuZ0NoYWluRW52VmFyc01ldGFkYXRhKCkge1xuICAgIGNvbnN0IGFsbEVudlZhcnMgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpIHx8IHt9O1xuICAgIGNvbnN0IGVudlZhcnMgPSB7fTtcbiAgICBjb25zdCBleGNsdWRlZCA9IFtcbiAgICAgICAgXCJMQU5HQ0hBSU5fQVBJX0tFWVwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9FTkRQT0lOVFwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9UUkFDSU5HX1YyXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX1BST0pFQ1RcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fU0VTU0lPTlwiLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYWxsRW52VmFycykpIHtcbiAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKFwiTEFOR0NIQUlOX1wiKSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAhZXhjbHVkZWQuaW5jbHVkZXMoa2V5KSAmJlxuICAgICAgICAgICAgIWtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwia2V5XCIpICYmXG4gICAgICAgICAgICAha2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJzZWNyZXRcIikgJiZcbiAgICAgICAgICAgICFrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInRva2VuXCIpKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcIkxBTkdDSEFJTl9SRVZJU0lPTl9JRFwiKSB7XG4gICAgICAgICAgICAgICAgZW52VmFyc1tcInJldmlzaW9uX2lkXCJdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbnZWYXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW52VmFycztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZnJvbSB0aGUgY3VycmVudCBydW50aW1lIGVudmlyb25tZW50LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gb3BlcmF0ZSBpbiBhIHZhcmlldHkgb2YgSlMgZW52aXJvbm1lbnRzLFxuICogaW5jbHVkaW5nIE5vZGUuanMsIERlbm8sIGJyb3dzZXJzLCBldGMuXG4gKlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz4gfCB1bmRlZmluZWR9XG4gKiAgLSBBIHJlY29yZCBvZiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaWYgYXZhaWxhYmxlLlxuICogIC0gYHVuZGVmaW5lZGAgaWYgdGhlIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgb3IgYWxsb3dzIGFjY2VzcyB0byBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBmb3IgTm9kZS5qcyBlbnZpcm9ubWVudFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52KSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhwcm9jZXNzLmVudikucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBicm93c2VycyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzLCB3ZSBtYXkgbm90IGhhdmUgZGlyZWN0IGFjY2VzcyB0byBlbnYgdmFyaWFibGVzXG4gICAgICAgIC8vIFJldHVybiB1bmRlZmluZWQgb3IgYW55IG90aGVyIGZhbGxiYWNrIGFzIHJlcXVpcmVkLlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBDYXRjaCBhbnkgZXJyb3JzIHRoYXQgbWlnaHQgb2NjdXIgd2hpbGUgdHJ5aW5nIHRvIGFjY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShuYW1lKSB7XG4gICAgLy8gQ2VydGFpbiBEZW5vIHNldHVwcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSB0cnkgdG8gYWNjZXNzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9od2NoYXNlMTcvbGFuZ2NoYWluanMvaXNzdWVzLzE0MTJcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnY/LltuYW1lXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNldEVudmlyb25tZW50VmFyaWFibGUobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgIHByb2Nlc3MuZW52W25hbWVdID0gdmFsdWU7XG4gICAgfVxufVxubGV0IGNhY2hlZENvbW1pdFNIQXM7XG4vKipcbiAqIEdldCB0aGUgR2l0IGNvbW1pdCBTSEEgZnJvbSBjb21tb24gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKiB1c2VkIGJ5IGRpZmZlcmVudCBDSS9DRCBwbGF0Zm9ybXMuXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSBUaGUgR2l0IGNvbW1pdCBTSEEgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYXMoKSB7XG4gICAgaWYgKGNhY2hlZENvbW1pdFNIQXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkQ29tbWl0U0hBcztcbiAgICB9XG4gICAgY29uc3QgY29tbW9uX3JlbGVhc2VfZW52cyA9IFtcbiAgICAgICAgXCJWRVJDRUxfR0lUX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJORVhUX1BVQkxJQ19WRVJDRUxfR0lUX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJDT01NSVRfUkVGXCIsXG4gICAgICAgIFwiUkVOREVSX0dJVF9DT01NSVRcIixcbiAgICAgICAgXCJDSV9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiQ0lSQ0xFX1NIQTFcIixcbiAgICAgICAgXCJDRl9QQUdFU19DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiUkVBQ1RfQVBQX0dJVF9TSEFcIixcbiAgICAgICAgXCJTT1VSQ0VfVkVSU0lPTlwiLFxuICAgICAgICBcIkdJVEhVQl9TSEFcIixcbiAgICAgICAgXCJUUkFWSVNfQ09NTUlUXCIsXG4gICAgICAgIFwiR0lUX0NPTU1JVFwiLFxuICAgICAgICBcIkJVSUxEX1ZDU19OVU1CRVJcIixcbiAgICAgICAgXCJiYW1ib29fcGxhblJlcG9zaXRvcnlfcmV2aXNpb25cIixcbiAgICAgICAgXCJCdWlsZC5Tb3VyY2VWZXJzaW9uXCIsXG4gICAgICAgIFwiQklUQlVDS0VUX0NPTU1JVFwiLFxuICAgICAgICBcIkRST05FX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJTRU1BUEhPUkVfR0lUX1NIQVwiLFxuICAgICAgICBcIkJVSUxES0lURV9DT01NSVRcIixcbiAgICBdO1xuICAgIGNvbnN0IHNoYXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGVudiBvZiBjb21tb25fcmVsZWFzZV9lbnZzKSB7XG4gICAgICAgIGNvbnN0IGVudlZhciA9IGdldEVudmlyb25tZW50VmFyaWFibGUoZW52KTtcbiAgICAgICAgaWYgKGVudlZhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzaGFzW2Vudl0gPSBlbnZWYXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FjaGVkQ29tbWl0U0hBcyA9IHNoYXM7XG4gICAgcmV0dXJuIHNoYXM7XG59XG4iXSwibmFtZXMiOlsiX192ZXJzaW9uX18iLCJnbG9iYWxFbnYiLCJpc0Jyb3dzZXIiLCJ3aW5kb3ciLCJkb2N1bWVudCIsImlzV2ViV29ya2VyIiwiZ2xvYmFsVGhpcyIsImNvbnN0cnVjdG9yIiwibmFtZSIsImlzSnNEb20iLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbmNsdWRlcyIsImlzRGVubyIsIkRlbm8iLCJpc05vZGUiLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJub2RlIiwiZ2V0RW52IiwicnVudGltZUVudmlyb25tZW50IiwiZ2V0UnVudGltZUVudmlyb25tZW50IiwidW5kZWZpbmVkIiwiZW52IiwicmVsZWFzZUVudiIsImdldFNoYXMiLCJsaWJyYXJ5IiwicnVudGltZSIsInNkayIsInNka192ZXJzaW9uIiwiZ2V0TGFuZ0NoYWluRW52VmFycyIsImFsbEVudlZhcnMiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlcyIsImVudlZhcnMiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJzdGFydHNXaXRoIiwidG9Mb3dlckNhc2UiLCJzbGljZSIsInJlcGVhdCIsImxlbmd0aCIsImdldExhbmdDaGFpbkVudlZhcnNNZXRhZGF0YSIsImV4Y2x1ZGVkIiwicmVkdWNlIiwiYWNjIiwiU3RyaW5nIiwiZSIsImdldEVudmlyb25tZW50VmFyaWFibGUiLCJzZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwiY2FjaGVkQ29tbWl0U0hBcyIsImNvbW1vbl9yZWxlYXNlX2VudnMiLCJzaGFzIiwiZW52VmFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/messages.js":
/*!*******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/messages.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertLangChainMessageToExample: () => (/* binding */ convertLangChainMessageToExample),\n/* harmony export */   isLangChainMessage: () => (/* binding */ isLangChainMessage)\n/* harmony export */ });\nfunction isLangChainMessage(message) {\n    return typeof message?._getType === \"function\";\n}\nfunction convertLangChainMessageToExample(message) {\n    const converted = {\n        type: message._getType(),\n        data: {\n            content: message.content\n        }\n    };\n    // Check for presence of keys in additional_kwargs\n    if (message?.additional_kwargs && Object.keys(message.additional_kwargs).length > 0) {\n        converted.data.additional_kwargs = {\n            ...message.additional_kwargs\n        };\n    }\n    return converted;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxTQUFTQSxtQkFBbUJDLE9BQU87SUFDdEMsT0FBTyxPQUFPQSxTQUFTQyxhQUFhO0FBQ3hDO0FBQ08sU0FBU0MsaUNBQWlDRixPQUFPO0lBQ3BELE1BQU1HLFlBQVk7UUFDZEMsTUFBTUosUUFBUUMsUUFBUTtRQUN0QkksTUFBTTtZQUFFQyxTQUFTTixRQUFRTSxPQUFPO1FBQUM7SUFDckM7SUFDQSxrREFBa0Q7SUFDbEQsSUFBSU4sU0FBU08scUJBQ1RDLE9BQU9DLElBQUksQ0FBQ1QsUUFBUU8saUJBQWlCLEVBQUVHLE1BQU0sR0FBRyxHQUFHO1FBQ25EUCxVQUFVRSxJQUFJLENBQUNFLGlCQUFpQixHQUFHO1lBQUUsR0FBR1AsUUFBUU8saUJBQWlCO1FBQUM7SUFDdEU7SUFDQSxPQUFPSjtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3luY2NoYXQvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanM/NDczYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNMYW5nQ2hhaW5NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIG1lc3NhZ2U/Ll9nZXRUeXBlID09PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUobWVzc2FnZSkge1xuICAgIGNvbnN0IGNvbnZlcnRlZCA9IHtcbiAgICAgICAgdHlwZTogbWVzc2FnZS5fZ2V0VHlwZSgpLFxuICAgICAgICBkYXRhOiB7IGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCB9LFxuICAgIH07XG4gICAgLy8gQ2hlY2sgZm9yIHByZXNlbmNlIG9mIGtleXMgaW4gYWRkaXRpb25hbF9rd2FyZ3NcbiAgICBpZiAobWVzc2FnZT8uYWRkaXRpb25hbF9rd2FyZ3MgJiZcbiAgICAgICAgT2JqZWN0LmtleXMobWVzc2FnZS5hZGRpdGlvbmFsX2t3YXJncykubGVuZ3RoID4gMCkge1xuICAgICAgICBjb252ZXJ0ZWQuZGF0YS5hZGRpdGlvbmFsX2t3YXJncyA9IHsgLi4ubWVzc2FnZS5hZGRpdGlvbmFsX2t3YXJncyB9O1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydGVkO1xufVxuIl0sIm5hbWVzIjpbImlzTGFuZ0NoYWluTWVzc2FnZSIsIm1lc3NhZ2UiLCJfZ2V0VHlwZSIsImNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlIiwiY29udmVydGVkIiwidHlwZSIsImRhdGEiLCJjb250ZW50IiwiYWRkaXRpb25hbF9rd2FyZ3MiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/messages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/index.js":
/*!*****************************************!*\
  !*** ./node_modules/langsmith/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),\n/* harmony export */   __version__: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.__version__)\n/* harmony export */ });\n/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zeW5jY2hhdC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvaW5kZXguanM/MTgxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2Rpc3QvaW5kZXguanMnIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/index.js\n");

/***/ })

};
;